diff -Naur openssl-0.9.8j/apps/Makefile TurboSSL-0.9.8j/apps/Makefile
--- openssl-0.9.8j/apps/Makefile	2008-11-19 17:03:48.000000000 +0100
+++ TurboSSL-0.9.8j/apps/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -5,7 +5,17 @@
 DIR=		apps
 TOP=		..
 CC=		cc
-INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES)
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_FIPS)
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+else
+CAVIUM_INCLUDEDIR := .
+endif
+
+INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES) -I$(CAVIUM_INCLUDEDIR)
 CFLAG=		-g -static
 MAKEFILE=	Makefile
 PERL=		perl
diff -Naur openssl-0.9.8j/apps/Makefile.save TurboSSL-0.9.8j/apps/Makefile.save
--- openssl-0.9.8j/apps/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/apps/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,182 @@
+#
+#  apps/Makefile
+#
+
+DIR=		apps
+TOP=		..
+CC=		cc
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_FIPS)
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+else
+CAVIUM_INCLUDEDIR := .
+endif
+
+INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES) -I$(CAVIUM_INCLUDEDIR)
+CFLAG=		-g -static
+MAKEFILE=	Makefile
+PERL=		perl
+RM=		rm -f
+# KRB5 stuff
+KRB5_INCLUDES=
+LIBKRB5=
+
+PEX_LIBS=
+EX_LIBS= 
+EXE_EXT= 
+
+SHLIB_TARGET=
+
+CFLAGS= -DMONOLITH $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile makeapps.com install.com
+
+DLIBCRYPTO=../libcrypto.a
+DLIBSSL=../libssl.a
+LIBCRYPTO=-L.. -lcrypto
+LIBSSL=-L.. -lssl
+
+PROGRAM= openssl
+
+SCRIPTS=CA.sh CA.pl
+
+EXE= $(PROGRAM)$(EXE_EXT)
+
+E_EXE=	verify asn1pars req dgst dh dhparam enc passwd gendh errstr \
+	ca crl rsa rsautl dsa dsaparam ec ecparam \
+	x509 genrsa gendsa s_server s_client speed \
+	s_time version pkcs7 cms crl2pkcs7 sess_id ciphers nseq pkcs12 \
+	pkcs8 spkac smime rand engine ocsp prime
+
+PROGS= $(PROGRAM).c
+
+A_OBJ=apps.o
+A_SRC=apps.c
+S_OBJ=	s_cb.o s_socket.o
+S_SRC=	s_cb.c s_socket.c
+RAND_OBJ=app_rand.o
+RAND_SRC=app_rand.c
+
+E_OBJ=	verify.o asn1pars.o req.o dgst.o dh.o dhparam.o enc.o passwd.o gendh.o errstr.o \
+	ca.o pkcs7.o crl2p7.o crl.o \
+	rsa.o rsautl.o dsa.o dsaparam.o ec.o ecparam.o \
+	x509.o genrsa.o gendsa.o s_server.o s_client.o speed.o \
+	s_time.o $(A_OBJ) $(S_OBJ) $(RAND_OBJ) version.o sess_id.o \
+	ciphers.o nseq.o pkcs12.o pkcs8.o spkac.o smime.o rand.o engine.o \
+	ocsp.o prime.o cms.o
+
+E_SRC=	verify.c asn1pars.c req.c dgst.c dh.c enc.c passwd.c gendh.c errstr.c ca.c \
+	pkcs7.c crl2p7.c crl.c \
+	rsa.c rsautl.c dsa.c dsaparam.c ec.c ecparam.c \
+	x509.c genrsa.c gendsa.c s_server.c s_client.c speed.c \
+	s_time.c $(A_SRC) $(S_SRC) $(RAND_SRC) version.c sess_id.c \
+	ciphers.c nseq.c pkcs12.c pkcs8.c spkac.c smime.c rand.c engine.c \
+	ocsp.c prime.c cms.c
+
+SRC=$(E_SRC)
+
+EXHEADER=
+HEADER=	apps.h progs.h s_apps.h \
+	testdsa.h testrsa.h \
+	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	@(cd ..; $(MAKE) DIRS=$(DIR) all)
+
+all:	exe
+
+exe:	$(EXE)
+
+req: sreq.o $(A_OBJ) $(DLIBCRYPTO)
+	shlib_target=; if [ -n "$(SHARED_LIBS)" ]; then \
+		shlib_target="$(SHLIB_TARGET)"; \
+	fi; \
+	$(MAKE) -f $(TOP)/Makefile.shared -e \
+		APPNAME=req OBJECTS="sreq.o $(A_OBJ) $(RAND_OBJ)" \
+		LIBDEPS="$(PEX_LIBS) $(LIBCRYPTO) $(EX_LIBS)" \
+		link_app.$${shlib_target}
+
+sreq.o: req.c 
+	$(CC) -c $(INCLUDES) $(CFLAG) -o sreq.o req.c
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@set -e; for i in $(EXE); \
+	do  \
+	(echo installing $$i; \
+	 cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
+	 chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
+	 mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i ); \
+	 done;
+	@set -e; for i in $(SCRIPTS); \
+	do  \
+	(echo installing $$i; \
+	 cp $$i $(INSTALL_PREFIX)$(OPENSSLDIR)/misc/$$i.new; \
+	 chmod 755 $(INSTALL_PREFIX)$(OPENSSLDIR)/misc/$$i.new; \
+	 mv -f $(INSTALL_PREFIX)$(OPENSSLDIR)/misc/$$i.new $(INSTALL_PREFIX)$(OPENSSLDIR)/misc/$$i ); \
+	 done
+	@cp openssl.cnf $(INSTALL_PREFIX)$(OPENSSLDIR)/openssl.cnf.new; \
+	chmod 644 $(INSTALL_PREFIX)$(OPENSSLDIR)/openssl.cnf.new; \
+	mv -f  $(INSTALL_PREFIX)$(OPENSSLDIR)/openssl.cnf.new $(INSTALL_PREFIX)$(OPENSSLDIR)/openssl.cnf
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+links:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@if [ -z "$(THIS)" ]; then \
+	    $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; \
+	else \
+	    $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(SRC); \
+	fi
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff $(EXE)
+	rm -f req
+
+$(DLIBSSL):
+	(cd ..; $(MAKE) DIRS=ssl all)
+
+$(DLIBCRYPTO):
+	(cd ..; $(MAKE) DIRS=crypto all)
+
+$(EXE): progs.h $(E_OBJ) $(PROGRAM).o $(DLIBCRYPTO) $(DLIBSSL)
+	$(RM) $(EXE)
+	shlib_target=; if [ -n "$(SHARED_LIBS)" ]; then \
+		shlib_target="$(SHLIB_TARGET)"; \
+	elif [ -n "$(FIPSCANLIB)" ]; then \
+	  FIPSLD_CC=$(CC); CC=$(TOP)/fips/fipsld; export CC FIPSLD_CC; \
+	fi; \
+	LIBRARIES="$(LIBSSL) $(LIBKRB5) $(LIBCRYPTO)" ; \
+	[ "x$(FIPSCANLIB)" = "xlibfips" ] && LIBRARIES="$$LIBRARIES -lfips"; \
+	$(MAKE) -f $(TOP)/Makefile.shared -e \
+		CC=$${CC} APPNAME=$(EXE) OBJECTS="$(PROGRAM).o $(E_OBJ)" \
+		LIBDEPS="$(PEX_LIBS) $$LIBRARIES $(EX_LIBS)" \
+		link_app.$${shlib_target}
+	-(cd ..; \
+	  OPENSSL="`pwd`/util/opensslwrap.sh"; export OPENSSL; \
+	  $(PERL) tools/c_rehash certs)
+
+progs.h: progs.pl
+	$(PERL) progs.pl $(E_EXE) >progs.h
+	$(RM) $(PROGRAM).o
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/apps/md4.c TurboSSL-0.9.8j/apps/md4.c
--- openssl-0.9.8j/apps/md4.c	2003-01-13 16:35:20.000000000 +0100
+++ TurboSSL-0.9.8j/apps/md4.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/* crypto/md4/md4.c */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <openssl/md4.h>
-
-#define BUFSIZE	1024*16
-
-void do_fp(FILE *f);
-void pt(unsigned char *md);
-#if !defined(_OSD_POSIX) && !defined(__DJGPP__)
-int read(int, void *, unsigned int);
-#endif
-
-int main(int argc, char **argv)
-	{
-	int i,err=0;
-	FILE *IN;
-
-	if (argc == 1)
-		{
-		do_fp(stdin);
-		}
-	else
-		{
-		for (i=1; i<argc; i++)
-			{
-			IN=fopen(argv[i],"r");
-			if (IN == NULL)
-				{
-				perror(argv[i]);
-				err++;
-				continue;
-				}
-			printf("MD4(%s)= ",argv[i]);
-			do_fp(IN);
-			fclose(IN);
-			}
-		}
-	exit(err);
-	}
-
-void do_fp(FILE *f)
-	{
-	MD4_CTX c;
-	unsigned char md[MD4_DIGEST_LENGTH];
-	int fd;
-	int i;
-	static unsigned char buf[BUFSIZE];
-
-	fd=fileno(f);
-	MD4_Init(&c);
-	for (;;)
-		{
-		i=read(fd,buf,sizeof buf);
-		if (i <= 0) break;
-		MD4_Update(&c,buf,(unsigned long)i);
-		}
-	MD4_Final(&(md[0]),&c);
-	pt(md);
-	}
-
-void pt(unsigned char *md)
-	{
-	int i;
-
-	for (i=0; i<MD4_DIGEST_LENGTH; i++)
-		printf("%02x",md[i]);
-	printf("\n");
-	}
-
diff -Naur openssl-0.9.8j/apps/openssl.c TurboSSL-0.9.8j/apps/openssl.c
--- openssl-0.9.8j/apps/openssl.c	2008-09-16 00:24:39.000000000 +0200
+++ TurboSSL-0.9.8j/apps/openssl.c	2010-05-31 12:13:09.000000000 +0200
@@ -391,6 +391,7 @@
 		{ ret=0; goto end; }
 	f.name=argv[0];
 	fp=(FUNCTION *)lh_retrieve(prog,&f);
+/*	fprintf ("Str_name: %s\n", fp->name); */
 	if (fp != NULL)
 		{
 		ret=fp->func(argc,argv);
diff -Naur openssl-0.9.8j/apps/s_client.c TurboSSL-0.9.8j/apps/s_client.c
--- openssl-0.9.8j/apps/s_client.c	2008-12-20 18:04:08.000000000 +0100
+++ TurboSSL-0.9.8j/apps/s_client.c	2010-05-31 12:13:09.000000000 +0200
@@ -638,6 +638,7 @@
 	if (key_file)
 
 		{
+#ifndef CAVIUM_FIPS		
 
 		key = load_key(bio_err, key_file, key_format, 0, pass, e,
 			       "client certificate private key file");
@@ -646,7 +647,7 @@
 			ERR_print_errors(bio_err);
 			goto end;
 			}
-
+#endif
 		}
 
 	if (cert_file)
@@ -727,7 +728,11 @@
 #endif
 
 	SSL_CTX_set_verify(ctx,verify,verify_callback);
+#ifdef CAVIUM_FIPS
+    if (!set_cert_stuff(ctx,cert_file,key_file))
+#else
 	if (!set_cert_key_stuff(ctx,cert,key))
+#endif
 		goto end;
 
 	if ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||
diff -Naur openssl-0.9.8j/apps/speed.c TurboSSL-0.9.8j/apps/speed.c
--- openssl-0.9.8j/apps/speed.c	2009-01-07 11:48:22.000000000 +0100
+++ TurboSSL-0.9.8j/apps/speed.c	2011-01-06 09:23:28.000000000 +0100
@@ -114,7 +114,7 @@
 # define TIMES
 #endif
 #if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(OPENSSL_SYS_MPE) && !defined(__NetBSD__) && !defined(OPENSSL_SYS_VXWORKS) /* FIXME */
-# define TIMEB
+//# define TIMEB
 #endif
 
 #if defined(OPENSSL_SYS_NETWARE)
@@ -757,6 +757,11 @@
 	usertime=-1;
 #endif
 
+#ifdef CAVIUM_MULTICARD_API
+                          Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID);
+#else
+                          Csp1Initialize(CAVIUM_DIRECT);
+#endif
 	apps_startup();
 	memset(results, 0, sizeof(results));
 #ifndef OPENSSL_NO_DSA
diff -Naur openssl-0.9.8j/apps/s_server.c TurboSSL-0.9.8j/apps/s_server.c
--- openssl-0.9.8j/apps/s_server.c	2008-12-20 18:04:08.000000000 +0100
+++ TurboSSL-0.9.8j/apps/s_server.c	2010-05-31 12:13:09.000000000 +0200
@@ -1120,6 +1120,7 @@
 
 	if (nocert == 0)
 		{
+#ifndef CAVIUM_FIPS
 		s_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,
 		       "server certificate private key file");
 		if (!s_key)
@@ -1127,7 +1128,7 @@
 			ERR_print_errors(bio_err);
 			goto end;
 			}
-
+#endif
 		s_cert = load_cert(bio_err,s_cert_file,s_cert_format,
 			NULL, e, "server certificate file");
 
@@ -1427,18 +1428,29 @@
 		}
 #endif
 	
+#ifdef CAVIUM_FIPS
+	if (!set_cert_stuff(ctx,(char *)s_cert_file,(char *)s_key_file))
+#else	
 	if (!set_cert_key_stuff(ctx,s_cert,s_key))
+#endif
 		goto end;
 #ifndef OPENSSL_NO_TLSEXT
 	if (ctx2 && !set_cert_key_stuff(ctx2,s_cert2,s_key2))
 		goto end; 
 #endif
+#ifdef CAVIUM_FIPS
+	if (s_dcert_file != NULL)
+		{
+		if (!set_cert_stuff(ctx,(char *)s_dcert_file, (char *)s_dkey_file))
+			goto end;
+		}
+#else
 	if (s_dcert != NULL)
 		{
 		if (!set_cert_key_stuff(ctx,s_dcert,s_dkey))
 			goto end;
 		}
-
+#endif
 #ifndef OPENSSL_NO_RSA
 #if 1
 	if (!no_tmp_rsa)
diff -Naur openssl-0.9.8j/auto.makefile.lib TurboSSL-0.9.8j/auto.makefile.lib
--- openssl-0.9.8j/auto.makefile.lib	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/auto.makefile.lib	2010-11-25 18:23:19.000000000 +0100
@@ -0,0 +1,57 @@
+#make -f star_auto.makefile KERNEL=$(KERNEL) TARGET_ROOTFS_DIR=$(TARGET_ROOTFS_DIR) CROSS_COMPILE=${CROSS_COMPILE}
+#
+# Initial parameters (don't change)
+#
+PWD=$(shell pwd)
+MYPATH=$(shell dirname ${PWD})
+MYNAME=$(shell basename ${PWD})
+
+
+# 
+# Received Parameter (don't change)
+#  
+#
+TARGET_ROOTFS_DIR?=$(shell pwd)/target
+KERNEL?=$(shell pwd)/../../kernels/linux
+CROSS_COMPILE?=arm-linux-
+
+#
+# Application specific application, change as needed
+#
+CC=${CROSS_COMPILE}gcc
+PARAM= INSTALL_PREFIX=${TARGET_ROOTFS_DIR} 
+
+
+#export APIDIR=/home/prj/vega_trunk/cpl/nitrox-driver-cns3xxx-3.0-pre-release/software/api;\
+#export CAVIUM_INCLUDEDIR=/home/prj/vega_trunk/cpl/nitrox-driver-cns3xxx-3.0-pre-release/software/include/;\
+
+#
+# build: configure, then build
+#
+build: info
+	@echo action=$@
+	./Configure compiler:${CROSS_COMPILE}gcc no-asm no-threads cavium
+	make ${PARAM}
+
+clean: info
+	@echo action=$@
+	#make clean ${PARAM}
+	if [ -f Makefile ] ; then make clean ${PARAM}||exit 1; fi
+
+install: info
+	@echo action=$@
+	mkdir ${TARGET_ROOTFS_DIR} -p
+	make install ${PARAM}
+	#cp _install/* ${TARGET_ROOTFS_DIR} -af
+
+info:
+	@echo ==================
+	@echo MYPATH=${MYPATH}
+	@echo MYNAME=${MYNAME}
+	@echo PWD=${PWD}
+	@echo TARGET_ROOTFS_DIR=${TARGET_ROOTFS_DIR}
+	@echo KERNEL=${KERNEL}
+	@echo ==================
+	if [ -f Makefile ] ; then touch Makefile ; fi;
+
+
diff -Naur openssl-0.9.8j/Configure TurboSSL-0.9.8j/Configure
--- openssl-0.9.8j/Configure	2008-12-29 01:18:23.000000000 +0100
+++ TurboSSL-0.9.8j/Configure	2010-05-31 12:13:09.000000000 +0200
@@ -12,7 +12,7 @@
 
 # see INSTALL for instructions.
 
-my $usage="Usage: Configure [no-<cipher> ...] [enable-<cipher> ...] [experimental-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [enable-montasm] [no-asm] [no-dso] [no-krb5] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
+my $usage="Usage: Configure [no-<cipher> ...] [enable-<cipher> ...] [experimental-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [cavium] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [enable-montasm] [no-asm] [no-dso] [no-krb5] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
 
 # Options:
 #
@@ -591,6 +591,7 @@
 my $no_krb5=0;   # but "no-krb5" is implied unless "--with-krb5-..." is used
 my $no_rfc3779=1; # but "no-rfc3779" is default
 my $montasm=1;   # but "no-montasm" is default
+my $cavium="";
 my $no_asm=0;
 my $no_dso=0;
 my $no_gmp=0;
@@ -636,6 +637,7 @@
                  "rfc3779"        => "default",
                  "seed"           => "default",
                  "shared"         => "default",
+				 "tlsext"         => "default",
                  "zlib"           => "default",
                  "zlib-dynamic"   => "default"
                );
@@ -643,7 +645,7 @@
 
 # This is what $depflags will look like with the above defaults
 # (we need this to see if we should advise the user to run "make depend"):
-my $default_depflags = " -DOPENSSL_NO_CAMELLIA -DOPENSSL_NO_CAPIENG -DOPENSSL_NO_CMS -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_MDC2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SEED";
+my $default_depflags = " -DOPENSSL_NO_CAMELLIA -DOPENSSL_NO_CAPIENG -DOPENSSL_NO_CMS -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_MDC2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SEED";
 
 
 # Explicit "no-..." options will be collected in %disabled along with the defaults.
@@ -777,6 +779,19 @@
 			# The check for the option is there so scripts aren't
 			# broken
 			}
+		elsif (/^cavium$/)
+			{
+			#my @cavium_check = `ls ../../bin`;
+			#if (@cavium_check < 3) 
+			#	{
+			#	print "ERROR: Nitrox Driver not build yet\n";
+			#	exit (1);
+			#	}
+			$flags .= "-fPIC ";
+			$flags .= "-DCAVIUM_SSL ";
+			$openssl_other_defines .= "#define CAVIUM_SSL\n";
+			$cavium="cavium";
+			}
 		elsif (/^nofipscanistercheck$/)
 			{
 			$fips = 1;
@@ -1457,6 +1472,7 @@
 	s/^PLATFORM=.*$/PLATFORM=$target/;
 	s/^OPTIONS=.*$/OPTIONS=$options/;
 	s/^CONFIGURE_ARGS=.*$/CONFIGURE_ARGS=$argvstring/;
+	s/^CAVIUM=.*$/CAVIUM=$cavium/;
 	s/^CC=.*$/CC= $cc/;
 	s/^MAKEDEPPROG=.*$/MAKEDEPPROG= $cc/ if $cc eq "gcc";
 	s/^CFLAG=.*$/CFLAG= $cflags/;
diff -Naur openssl-0.9.8j/crypto/aes/aes_cbc.c TurboSSL-0.9.8j/crypto/aes/aes_cbc.c
--- openssl-0.9.8j/crypto/aes/aes_cbc.c	2008-09-16 12:47:23.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/aes/aes_cbc.c	2010-05-31 12:14:31.000000000 +0200
@@ -58,11 +58,110 @@
 
 #include <openssl/aes.h>
 #include "aes_locl.h"
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#include "luna_api.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#endif
+
+#ifdef CAVIUM_SSL
+static int pkp_device_state=1;
+#endif
 
 #if !defined(OPENSSL_FIPS_AES_ASM)
 void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
 		     const unsigned long length, const AES_KEY *key,
-		     unsigned char *ivec, const int enc) {
+		     unsigned char *ivec, const int enc) 
+{
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#ifdef MC2
+	       unsigned long n;
+	       unsigned long len = length;
+	       unsigned char tmp[AES_BLOCK_SIZE];
+#endif	
+#endif	
+		int driver_ready =-1;
+#ifndef MC2
+		Uint64 tmp_ctx;
+#endif
+#ifdef CAVIUM_FIPS
+		Uint64 hWrapper;
+		Uint64 hkey_handle;
+		Uint8 enc_key_out[50];
+		Uint8 local_iv[8]={0x67, 0xC6, 0x69, 0x73, 0x51, 0xFF, 0x4A, 0xEC };
+		int i;
+#endif
+//#if !defined(MC2) || (defined(MC2) && defined(CNLITE)) 
+#if !defined(MC2) || (defined(MC2))  
+		Uint32 req_id;
+		unsigned char *iv;
+		unsigned char aes_key[50];
+		AesType aes_type=0;
+		int bs=16;
+		unsigned char *iiv;
+		unsigned char saved_iv[24];
+		int ret;
+		memcpy(aes_key,(Uint8*)key->key,key->bytes);
+		iv=ivec;
+		if(key->bytes == 16)
+			aes_type = AES_128;
+		if(key->bytes == 24)
+			aes_type = AES_192;
+		if(key->bytes == 32)
+			aes_type = AES_256;
+#endif
+
+
+		if(enc){
+			ret = Csp1EncryptAes( CAVIUM_BLOCKING,
+						0, //(Uint64)NULL,
+						CAVIUM_NO_UPDATE,
+						aes_type,
+						length,
+						(Uint8 *)in,
+						(Uint8 *)out,
+						(Uint8 *)iv,
+						(Uint8 *)aes_key,
+#ifdef CAVIUM_MULTICARD_API
+						&req_id,CAVIUM_DEV_ID
+#else
+						&req_id
+#endif
+                                             );
+			iiv=(Uint8 *) ((Uint8 *)out+length-bs);
+		}else
+		{
+			iiv= (Uint8 *)((Uint8 *)in+length-bs);
+			memcpy(saved_iv,iiv,bs);
+			ret = Csp1DecryptAes( CAVIUM_BLOCKING,
+						0, //(Uint64)NULL,
+						CAVIUM_NO_UPDATE,
+						aes_type,
+						length,
+						(Uint8 *)in,
+						(Uint8 *)out,
+						(Uint8 *)iv,
+						(Uint8 *)aes_key,
+#ifdef CAVIUM_MULTICARD_API
+						&req_id,CAVIUM_DEV_ID
+#else
+						&req_id
+#endif
+                                             );
+			iiv = saved_iv;
+		}
+		iv = ivec;
+		memcpy(iv,iiv,bs);
+
+        return;
+#endif /*CAVIUM_SSL*/
+   {
 
 	unsigned long n;
 	unsigned long len = length;
@@ -129,5 +228,6 @@
 			memcpy(ivec, tmp, AES_BLOCK_SIZE);
 		}
 	}
-}
+   } /*software aes*/
+} /*end function*/
 #endif
diff -Naur openssl-0.9.8j/crypto/aes/aes_core.c TurboSSL-0.9.8j/crypto/aes/aes_core.c
--- openssl-0.9.8j/crypto/aes/aes_core.c	2008-09-16 12:47:23.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/aes/aes_core.c	2010-05-31 12:13:09.000000000 +0200
@@ -638,6 +638,10 @@
 #ifdef OPENSSL_FIPS
 	FIPS_selftest_check();
 #endif
+#ifdef CAVIUM_SSL
+	key->bytes = bits/8;
+	memcpy(key->key,userKey,key->bytes);
+#endif
 
 	if (!userKey || !key)
 		return -1;
@@ -739,6 +743,10 @@
         u32 *rk;
 	int i, j, status;
 	u32 temp;
+#ifdef CAVIUM_SSL
+	key->bytes = bits/8;
+	memcpy(key->key,userKey,key->bytes);
+#endif
 
 	/* first, start with an encryption schedule */
 	status = AES_set_encrypt_key(userKey, bits, key);
diff -Naur openssl-0.9.8j/crypto/aes/aes.h TurboSSL-0.9.8j/crypto/aes/aes.h
--- openssl-0.9.8j/crypto/aes/aes.h	2008-09-16 12:47:23.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/aes/aes.h	2010-05-31 12:13:09.000000000 +0200
@@ -76,6 +76,10 @@
 
 /* This should be a hidden type, but EVP requires that the size be known */
 struct aes_key_st {
+#ifdef CAVIUM_SSL
+	unsigned char key[32+1];
+	int bytes;
+#endif
 #ifdef AES_LONG
     unsigned long rd_key[4 *(AES_MAXNR + 1)];
 #else
diff -Naur openssl-0.9.8j/crypto/aes/Makefile.save TurboSSL-0.9.8j/crypto/aes/Makefile.save
--- openssl-0.9.8j/crypto/aes/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/aes/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,98 @@
+#
+# crypto/aes/Makefile
+#
+
+DIR=	aes
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+AES_ASM_OBJ=aes_core.o aes_cbc.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+#TEST=aestest.c
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=aes_core.c aes_misc.c aes_ecb.c aes_cbc.c aes_cfb.c aes_ofb.c \
+       aes_ctr.c aes_ige.c aes_wrap.c
+LIBOBJ=aes_misc.o aes_ecb.o aes_cfb.o aes_ofb.o aes_ctr.o aes_ige.o aes_wrap.o \
+       $(AES_ASM_OBJ)
+
+SRC= $(LIBSRC)
+
+EXHEADER= aes.h
+HEADER= aes_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+$(LIBOBJ): $(LIBSRC)
+
+aes-ia64.s: asm/aes-ia64.S
+	$(CC) $(CFLAGS) -E asm/aes-ia64.S > $@
+
+ax86-elf.s: asm/aes-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) aes-586.pl elf $(CFLAGS) $(PROCESSOR) > ../$@)
+ax86-cof.s: asm/aes-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) aes-586.pl coff $(CFLAGS) $(PROCESSOR) > ../$@)
+ax86-out.s: asm/aes-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) aes-586.pl a.out $(CFLAGS) $(PROCESSOR) > ../$@)
+
+aes-x86_64.s: asm/aes-x86_64.pl
+	$(PERL) asm/aes-x86_64.pl $@
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/asn1/Makefile.save TurboSSL-0.9.8j/crypto/asn1/Makefile.save
--- openssl-0.9.8j/crypto/asn1/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/asn1/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,106 @@
+#
+# OpenSSL/crypto/asn1/Makefile
+#
+
+DIR=	asn1
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
+	a_print.c a_type.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
+	a_enum.c a_utf8.c a_sign.c a_digest.c a_verify.c a_mbstr.c a_strex.c \
+	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c x_bignum.c \
+	x_long.c x_name.c x_x509.c x_x509a.c x_crl.c x_info.c x_spki.c nsseq.c \
+	d2i_pu.c d2i_pr.c i2d_pu.c i2d_pr.c\
+	t_req.c t_x509.c t_x509a.c t_crl.c t_pkey.c t_spki.c t_bitst.c \
+	tasn_new.c tasn_fre.c tasn_enc.c tasn_dec.c tasn_utl.c tasn_typ.c \
+	f_int.c f_string.c n_pkey.c \
+	f_enum.c a_hdr.c x_pkey.c a_bool.c x_exten.c asn_mime.c \
+	asn1_gen.c asn1_par.c asn1_lib.c asn1_err.c a_meth.c a_bytes.c a_strnid.c \
+	evp_asn1.c asn_pack.c p5_pbe.c p5_pbev2.c p8_pkey.c asn_moid.c
+LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
+	a_print.o a_type.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
+	a_enum.o a_utf8.o a_sign.o a_digest.o a_verify.o a_mbstr.o a_strex.o \
+	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o x_bignum.o \
+	x_long.o x_name.o x_x509.o x_x509a.o x_crl.o x_info.o x_spki.o nsseq.o \
+	d2i_pu.o d2i_pr.o i2d_pu.o i2d_pr.o \
+	t_req.o t_x509.o t_x509a.o t_crl.o t_pkey.o t_spki.o t_bitst.o \
+	tasn_new.o tasn_fre.o tasn_enc.o tasn_dec.o tasn_utl.o tasn_typ.o \
+	f_int.o f_string.o n_pkey.o \
+	f_enum.o a_hdr.o x_pkey.o a_bool.o x_exten.o asn_mime.o \
+	asn1_gen.o asn1_par.o asn1_lib.o asn1_err.o a_meth.o a_bytes.o a_strnid.o \
+	evp_asn1.o asn_pack.o p5_pbe.o p5_pbev2.o p8_pkey.o asn_moid.o
+
+SRC= $(LIBSRC)
+
+EXHEADER=  asn1.h asn1_mac.h asn1t.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+test:	test.c
+	cc -g -I../../include -c test.c
+	cc -g -I../../include -o test test.o -L../.. -lcrypto
+
+pk:	pk.c
+	cc -g -I../../include -c pk.c
+	cc -g -I../../include -o pk pk.o -L../.. -lcrypto
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by top Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/bf/Makefile TurboSSL-0.9.8j/crypto/bf/Makefile
--- openssl-0.9.8j/crypto/bf/Makefile	2008-09-17 19:10:56.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/bf/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -93,19 +93,3 @@
 	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-bf_cfb64.o: ../../include/openssl/blowfish.h ../../include/openssl/e_os2.h
-bf_cfb64.o: ../../include/openssl/opensslconf.h bf_cfb64.c bf_locl.h
-bf_ecb.o: ../../include/openssl/blowfish.h ../../include/openssl/e_os2.h
-bf_ecb.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-bf_ecb.o: bf_ecb.c bf_locl.h
-bf_enc.o: ../../include/openssl/blowfish.h ../../include/openssl/e_os2.h
-bf_enc.o: ../../include/openssl/opensslconf.h bf_enc.c bf_locl.h
-bf_ofb64.o: ../../include/openssl/blowfish.h ../../include/openssl/e_os2.h
-bf_ofb64.o: ../../include/openssl/opensslconf.h bf_locl.h bf_ofb64.c
-bf_skey.o: ../../include/openssl/blowfish.h ../../include/openssl/crypto.h
-bf_skey.o: ../../include/openssl/e_os2.h ../../include/openssl/fips.h
-bf_skey.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-bf_skey.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-bf_skey.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-bf_skey.o: bf_locl.h bf_pi.h bf_skey.c
diff -Naur openssl-0.9.8j/crypto/bf/Makefile.save TurboSSL-0.9.8j/crypto/bf/Makefile.save
--- openssl-0.9.8j/crypto/bf/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/bf/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,95 @@
+#
+# OpenSSL/crypto/blowfish/Makefile
+#
+
+DIR=	bf
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+BF_ENC=		bf_enc.o
+# or use
+#DES_ENC=	bx86-elf.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=bftest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=bf_skey.c bf_ecb.c bf_enc.c bf_cfb64.c bf_ofb64.c 
+LIBOBJ=bf_skey.o bf_ecb.o $(BF_ENC) bf_cfb64.o bf_ofb64.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= blowfish.h
+HEADER=	bf_pi.h bf_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+bx86-elf.s: asm/bf-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) bf-586.pl elf $(CFLAGS) $(PROCESSOR) > ../$@)
+# COFF
+bx86-cof.s: asm/bf-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) bf-586.pl coff $(CFLAGS) $(PROCESSOR) > ../$@)
+# a.out
+bx86-out.s: asm/bf-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) bf-586.pl a.out $(CFLAGS) $(PROCESSOR) > ../$@)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+# We need to use force because 'install' matches 'INSTALL' on case
+# insensitive systems
+FRC.install:
+install: FRC.install
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/bio/Makefile.save TurboSSL-0.9.8j/crypto/bio/Makefile.save
--- openssl-0.9.8j/crypto/bio/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/bio/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,87 @@
+#
+# OpenSSL/crypto/bio/Makefile
+#
+
+DIR=	bio
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= bio_lib.c bio_cb.c bio_err.c \
+	bss_mem.c bss_null.c bss_fd.c \
+	bss_file.c bss_sock.c bss_conn.c \
+	bf_null.c bf_buff.c b_print.c b_dump.c \
+	b_sock.c bss_acpt.c bf_nbio.c bss_log.c bss_bio.c \
+	bss_dgram.c
+#	bf_lbuf.c
+LIBOBJ= bio_lib.o bio_cb.o bio_err.o \
+	bss_mem.o bss_null.o bss_fd.o \
+	bss_file.o bss_sock.o bss_conn.o \
+	bf_null.o bf_buff.o b_print.o b_dump.o \
+	b_sock.o bss_acpt.o bf_nbio.o bss_log.o bss_bio.o \
+	bss_dgram.o
+#	bf_lbuf.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= bio.h
+HEADER=	bio_lcl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/bn/bn_exp.c TurboSSL-0.9.8j/crypto/bn/bn_exp.c
--- openssl-0.9.8j/crypto/bn/bn_exp.c	2007-03-28 02:14:18.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/bn/bn_exp.c	2010-05-31 12:13:09.000000000 +0200
@@ -112,6 +112,14 @@
 
 #include "cryptlib.h"
 #include "bn_lcl.h"
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#include <openssl/cav_crypto_engine.h>
+#endif
 
 /* maximum precomputation table size for *variable* sliding windows */
 #define TABLE_SIZE	32
@@ -169,6 +177,10 @@
 	bn_check_top(p);
 	bn_check_top(m);
 
+#if defined (CAVIUM_SSL) && !defined(CAVIUM_FIPS)
+	if(cav_mod_exp(r,(BIGNUM *)a,(BIGNUM *)p,(BIGNUM *)m))
+		return 1;
+#endif
 	/* For even modulus  m = 2^k*m_odd,  it might make sense to compute
 	 * a^p mod m_odd  and  a^p mod 2^k  separately (with Montgomery
 	 * exponentiation for the odd part), using appropriate exponent
@@ -378,15 +390,19 @@
 	/* Table of variables obtained from 'ctx' */
 	BIGNUM *val[TABLE_SIZE];
 	BN_MONT_CTX *mont=NULL;
-
+#ifndef CAVIUM_SSL
 	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
 		{
 		return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);
 		}
-
+#endif
 	bn_check_top(a);
 	bn_check_top(p);
 	bn_check_top(m);
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	if(cav_mod_exp(rr,(BIGNUM *)a,(BIGNUM *)p,(BIGNUM *)m))
+		return 1;
+#endif
 
 	if (!BN_is_odd(m))
 		{
@@ -781,6 +797,14 @@
 	r = BN_CTX_get(ctx);
 	t = BN_CTX_get(ctx);
 	if (d == NULL || r == NULL || t == NULL) goto err;
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	BN_set_word(t, a);
+	if(cav_mod_exp(rr,t,(BIGNUM *)p,(BIGNUM *)m))
+	{
+		BN_CTX_end(ctx);
+		return 1;
+	}
+#endif
 
 	if (in_mont != NULL)
 		mont=in_mont;
diff -Naur openssl-0.9.8j/crypto/bn/bntest.c TurboSSL-0.9.8j/crypto/bn/bntest.c
--- openssl-0.9.8j/crypto/bn/bntest.c	2007-07-04 14:56:31.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/bn/bntest.c	2010-05-31 12:13:09.000000000 +0200
@@ -1755,12 +1755,22 @@
 
 	for (i = 0; i < 16; i++)
 		{
+#ifdef CAVIUM_SSL
+		if (i < 16)
+			{
+			unsigned primes[16] = { 2, 3, 5, 7, 11, 13, 17, 19,
+                                           23, 29, 31, 37, 41, 43, 47, 53 };
+
+			if (!BN_set_word(p, primes[i])) goto err;
+			}
+#else
 		if (i < 8)
 			{
 			unsigned primes[8] = { 2, 3, 5, 7, 11, 13, 17, 19 };
 			
 			if (!BN_set_word(p, primes[i])) goto err;
 			}
+#endif			
 		else
 			{
 			if (!BN_set_word(a, 32)) goto err;
diff -Naur openssl-0.9.8j/crypto/bn/Makefile.save TurboSSL-0.9.8j/crypto/bn/Makefile.save
--- openssl-0.9.8j/crypto/bn/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/bn/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,164 @@
+#
+# OpenSSL/crypto/bn/Makefile
+#
+
+DIR=	bn
+TOP=	../..
+CC=	cc
+CPP=    $(CC) -E
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+BN_ASM=		bn_asm.o
+# or use
+#BN_ASM=	bn86-elf.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=bntest.c exptest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	bn_add.c bn_div.c bn_exp.c bn_lib.c bn_ctx.c bn_mul.c bn_mod.c \
+	bn_print.c bn_rand.c bn_shift.c bn_word.c bn_blind.c \
+	bn_kron.c bn_sqrt.c bn_gcd.c bn_prime.c bn_err.c bn_sqr.c bn_asm.c \
+	bn_recp.c bn_mont.c bn_mpi.c bn_exp2.c bn_gf2m.c bn_nist.c \
+	bn_depr.c bn_x931p.c bn_const.c bn_opt.c
+
+LIBOBJ=	bn_add.o bn_div.o bn_exp.o bn_lib.o bn_ctx.o bn_mul.o bn_mod.o \
+	bn_print.o bn_rand.o bn_shift.o bn_word.o bn_blind.o \
+	bn_kron.o bn_sqrt.o bn_gcd.o bn_prime.o bn_err.o bn_sqr.o $(BN_ASM) \
+	bn_recp.o bn_mont.o bn_mpi.o bn_exp2.o bn_gf2m.o bn_nist.o \
+	bn_depr.o bn_x931p.o bn_const.o bn_opt.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= bn.h
+HEADER=	bn_lcl.h bn_prime.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+bn_prime.h: bn_prime.pl
+	$(PERL) bn_prime.pl >bn_prime.h
+
+divtest: divtest.c ../../libcrypto.a
+	cc -I../../include divtest.c -o divtest ../../libcrypto.a
+
+bnbug: bnbug.c ../../libcrypto.a top
+	cc -g -I../../include bnbug.c -o bnbug ../../libcrypto.a
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+bn86-elf.s:	asm/bn-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) bn-586.pl elf $(CFLAGS) > ../$@)
+co86-elf.s:	asm/co-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) co-586.pl elf $(CFLAGS) > ../$@)
+mo86-elf.s:	asm/mo-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) mo-586.pl elf $(CFLAGS) > ../$@)
+# COFF
+bn86-cof.s: asm/bn-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) bn-586.pl coff $(CFLAGS) > ../$@)
+co86-cof.s: asm/co-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) co-586.pl coff $(CFLAGS) > ../$@)
+mo86-cof.s: asm/mo-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) mo-586.pl coff $(CFLAGS) > ../$@)
+# a.out
+bn86-out.s: asm/bn-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) bn-586.pl a.out $(CFLAGS) > ../$@)
+co86-out.s: asm/co-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) co-586.pl a.out $(CFLAGS) > ../$@)
+mo86-out.s: asm/mo-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) mo-586.pl a.out $(CFLAGS) > ../$@)
+
+sparcv8.o:	asm/sparcv8.S
+	$(CC) $(CFLAGS) -c asm/sparcv8.S
+sparcv8plus.o:	asm/sparcv8plus.S
+	$(CC) $(CFLAGS) -c asm/sparcv8plus.S
+
+bn-mips3.o:	asm/mips3.s
+	@if [ "$(CC)" = "gcc" ]; then \
+		ABI=`expr "$(CFLAGS)" : ".*-mabi=\([n3264]*\)"` && \
+		as -$$ABI -O -o $@ asm/mips3.s; \
+	else	$(CC) -c $(CFLAGS) -o $@ asm/mips3.s; fi
+
+x86_64-gcc.o:	asm/x86_64-gcc.c
+	$(CC) $(CFLAGS) -c -o $@ asm/x86_64-gcc.c
+x86_64-mont.s:	asm/x86_64-mont.pl
+	$(PERL) asm/x86_64-mont.pl $@
+
+bn-ia64.s:	asm/ia64.S
+	$(CC) $(CFLAGS) -E asm/ia64.S > $@
+
+# GNU assembler fails to compile PA-RISC2 modules, insist on calling
+# vendor assembler...
+pa-risc2W.o: asm/pa-risc2W.s
+	/usr/ccs/bin/as -o pa-risc2W.o asm/pa-risc2W.s
+pa-risc2.o: asm/pa-risc2.s
+	/usr/ccs/bin/as -o pa-risc2.o asm/pa-risc2.s
+
+# ppc - AIX, Linux, MacOS X...
+linux_ppc32.s: asm/ppc.pl;	$(PERL) $< $@
+linux_ppc64.s: asm/ppc.pl;	$(PERL) $< $@
+aix_ppc32.s: asm/ppc.pl;	$(PERL) asm/ppc.pl $@
+aix_ppc64.s: asm/ppc.pl;	$(PERL) asm/ppc.pl $@
+osx_ppc32.s: asm/ppc.pl;	$(PERL) $< $@
+osx_ppc64.s: asm/ppc.pl;	$(PERL) $< $@
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+exptest:
+	rm -f exptest
+	gcc -I../../include -g2 -ggdb -o exptest exptest.c ../../libcrypto.a
+
+div:
+	rm -f a.out
+	gcc -I.. -g div.c ../../libcrypto.a
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/buffer/Makefile.save TurboSSL-0.9.8j/crypto/buffer/Makefile.save
--- openssl-0.9.8j/crypto/buffer/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/buffer/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/buffer/Makefile
+#
+
+DIR=	buffer
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= buffer.c buf_str.c buf_err.c
+LIBOBJ= buffer.o buf_str.o buf_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= buffer.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/cast/Makefile TurboSSL-0.9.8j/crypto/cast/Makefile
--- openssl-0.9.8j/crypto/cast/Makefile	2008-09-17 19:10:57.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/cast/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -88,22 +88,3 @@
 	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-c_cfb64.o: ../../e_os.h ../../include/openssl/cast.h
-c_cfb64.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
-c_cfb64.o: c_cfb64.c cast_lcl.h
-c_ecb.o: ../../e_os.h ../../include/openssl/cast.h
-c_ecb.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
-c_ecb.o: ../../include/openssl/opensslv.h c_ecb.c cast_lcl.h
-c_enc.o: ../../e_os.h ../../include/openssl/cast.h
-c_enc.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
-c_enc.o: c_enc.c cast_lcl.h
-c_ofb64.o: ../../e_os.h ../../include/openssl/cast.h
-c_ofb64.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
-c_ofb64.o: c_ofb64.c cast_lcl.h
-c_skey.o: ../../e_os.h ../../include/openssl/cast.h
-c_skey.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-c_skey.o: ../../include/openssl/fips.h ../../include/openssl/opensslconf.h
-c_skey.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-c_skey.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-c_skey.o: ../../include/openssl/symhacks.h c_skey.c cast_lcl.h cast_s.h
diff -Naur openssl-0.9.8j/crypto/cast/Makefile.save TurboSSL-0.9.8j/crypto/cast/Makefile.save
--- openssl-0.9.8j/crypto/cast/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/cast/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,90 @@
+#
+# OpenSSL/crypto/cast/Makefile
+#
+
+DIR=	cast
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CAST_ENC=c_enc.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=casttest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=c_skey.c c_ecb.c c_enc.c c_cfb64.c c_ofb64.c 
+LIBOBJ=c_skey.o c_ecb.o $(CAST_ENC) c_cfb64.o c_ofb64.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= cast.h
+HEADER=	cast_s.h cast_lcl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+cx86-elf.s: asm/cast-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) cast-586.pl elf $(CLAGS) $(PROCESSOR) > ../$@)
+# COFF
+cx86-cof.s: asm/cast-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) cast-586.pl coff $(CLAGS) $(PROCESSOR) > ../$@)
+# a.out
+cx86-out.s: asm/cast-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) cast-586.pl a.out $(CLAGS) $(PROCESSOR) > ../$@)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/cavium/cav_crypto_engine.c TurboSSL-0.9.8j/crypto/cavium/cav_crypto_engine.c
--- openssl-0.9.8j/crypto/cavium/cav_crypto_engine.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/cavium/cav_crypto_engine.c	2010-05-31 12:14:16.000000000 +0200
@@ -0,0 +1,2834 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation and/or 
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived 
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws, 
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply 
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility 
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS 
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY 
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, 
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, 
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE 
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+#if defined(linux)
+   #include <alloca.h>
+   #include <malloc.h>
+#elif defined(__FreeBSD__)
+   #include <stdlib.h>
+#endif
+
+#include <netinet/in.h>
+#include <string.h>
+#include <openssl/md5.h>
+#include <openssl/sha.h>
+#include <openssl/ssl.h>
+#include <openssl/bn.h>
+
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#include "luna_api.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#include <openssl/cav_debug.h>
+#endif /* CAVIUM_FIPS */
+
+void pkp_leftfill(unsigned char input[], int length, unsigned char output[], int finallength )
+{
+  int i;
+  int j;
+  memset(output,0,finallength);
+  j = finallength-1;
+  for (i=length-1; i>=0; i--) 
+  {
+    output[j] = input[i];
+    j = j-1;
+  }
+}
+
+#ifndef MC2
+
+static void swap_word_openssl(unsigned char *d, unsigned char *s, int len)
+{
+  int i,j;
+  Uint64 *ps;
+  Uint64 *pd;
+
+  j=0;
+
+  ps = (Uint64 *)s;
+  pd = (Uint64 *)d;
+
+  for(i=(len>>3)-1; i>=0; i--)
+   {
+     pd[j] = ps[i];
+     j++;      
+   }
+
+}
+#endif
+
+
+#ifdef CAVIUM_FIPS
+
+/*
+ * Appends pkcs5 padding to a buffer (for 3DES in this case)
+ */
+int add_pkcs5_padding(unsigned char* key, unsigned long *size)
+{
+  int pad_len = 0x0;
+  int i=0;
+
+  if ((*size % 8) == 0x0) 
+  {
+      pad_len = 0x8;
+  }
+  else
+  {
+      pad_len = (((*size/8)+1)*8) - *size;
+  }
+
+  for (i=0; i<pad_len; i++) key[*size+i] = pad_len;
+
+  *size += pad_len;
+
+  return (0);
+}
+
+
+
+/*
+ * imports private key
+ *
+ * returns 0 on success, else failure
+ *
+ * returned error codes:
+ *
+ *   1 - not enough memory
+ *   2 - rsa to pkey conversion failed
+ *   3 - pkey to pkcs8 inf conversion failed
+ *   4 - pkcs8 inf to pkcs8 conversion failed
+ *   5 - invalid pkcs8 converted blob size
+ *   6 - generate symmetric key failed
+ *   7 - alloc context failed
+ *   8 - init 3DES failed
+ *   9 - encrypt 3DES failed
+ *  10 - import private key failed
+ */
+int fips_import_private_key(RSA* rsa, unsigned long long *key_handle)
+{
+   int ret = 0;
+   EVP_PKEY *pkey = NULL;
+   PKCS8_PRIV_KEY_INFO *p8inf=NULL;
+   int p8_broken = PKCS8_OK;
+   BIO *pkcs8_bio = NULL;
+   char* ptr = NULL;
+   char* lcl_key = NULL;
+   char* lcl_key_enc = NULL;
+   unsigned long pkcs8_size = 0;
+   Uint64 h3DesKey = 0;
+   Uint64 context_handle = 0;
+   Uint8 iv[8] = "12345678";
+
+
+   /* do all the initializations */
+   pkey = EVP_PKEY_new();
+   if (pkey == NULL)
+   {
+       ret = 1;
+       goto end_import_prv_key;
+   }
+
+   pkcs8_bio = BIO_new(BIO_s_mem());
+   if (pkcs8_bio == NULL)
+   {
+       ret = 1;
+       goto end_import_prv_key;
+   }
+
+
+   /* step 1 : convert rsa key to PKEY */
+   ret = EVP_PKEY_set1_RSA(pkey, rsa);
+   if (!ret)
+   {
+       ret = 2;
+       goto end_import_prv_key;
+   }
+
+   /* step 2 : convert pkey to pkcs8 inf format */
+   if (!(p8inf = EVP_PKEY2PKCS8_broken(pkey, p8_broken))) 
+   {
+       ret = 3;
+       goto end_import_prv_key;
+   }
+
+   /* step 3 : convert the pkcs8 inf to pkcs8 format */
+   ret = i2d_PKCS8_PRIV_KEY_INFO_bio(pkcs8_bio, p8inf);
+   if (!ret)
+   {
+       ret = 4;
+       goto end_import_prv_key;
+   }
+
+   /* step 4 : get the size and ptr of the converted key */
+   pkcs8_size = BIO_get_mem_data(pkcs8_bio, &ptr);
+   if (pkcs8_size == 0)
+   {
+       ret = 5;
+       goto end_import_prv_key;
+   }
+
+   /* step 5 : copy the key to a local buffer, and add pkcs5 padding */
+   lcl_key = (char*)malloc(pkcs8_size+32);
+   lcl_key_enc = (char*)malloc(pkcs8_size+32);
+   if ((lcl_key == NULL) || (lcl_key_enc == NULL))
+   {
+       ret = 1;
+       goto end_import_prv_key;
+   }
+
+   memcpy(lcl_key, ptr, pkcs8_size);
+   add_pkcs5_padding((unsigned char *)lcl_key, &pkcs8_size);
+
+
+  /* step 6 : generate a symmetric key (3DES) and init the 3DES engine */
+  ret = Cfm1GenerateSymmetricKey(LUNA_KEY_DES3, 24, (Uint8 *)"3DES", 4, &h3DesKey);
+  if(ret)
+  {
+      ret = 6;
+      goto end_import_prv_key;
+  }
+
+  ret = Cfm1AllocContext(OP_BLOCKING, &context_handle, NULL);
+  if(ret)
+  {
+      ret = 7;
+      goto end_import_prv_key;
+  }
+
+  ret = Cfm1Initialize3DES(OP_BLOCKING, context_handle, iv, &h3DesKey, NULL);
+  if(ret)
+  {
+      ret = 8;
+      goto end_import_prv_key;
+  }
+
+  /* step 7 : encrypt the pkcs8 encoded key */
+  memset(lcl_key_enc, 0x0, sizeof(lcl_key_enc));
+
+  ret = Cfm1Encrypt3Des(OP_BLOCKING, context_handle, NO_UPDATE, pkcs8_size, (Uint8 *)lcl_key, (Uint8 *)lcl_key_enc, NULL);
+  if (ret)
+  {
+      ret = 9;
+      goto end_import_prv_key;
+  }
+
+
+  /* step 8 : import the encrypted key */
+  ret = Cfm1ImportRSAPrivateKey(h3DesKey, (Uint8 *)lcl_key_enc, pkcs8_size,(Uint8 *) "PRV_KEY_IMPORT", 14, iv, key_handle);
+  if (ret)
+  {
+      ret = 10;
+      goto end_import_prv_key;
+  }
+
+  ret = 0;
+
+end_import_prv_key:
+
+   if (pkey)            EVP_PKEY_free(pkey);
+   if (pkcs8_bio)       BIO_free_all(pkcs8_bio);
+   if (p8inf)	        PKCS8_PRIV_KEY_INFO_free (p8inf);
+   if (lcl_key)         free(lcl_key);
+   if (lcl_key_enc)     free(lcl_key_enc);
+   if (context_handle)  Cfm1FreeContext(OP_BLOCKING, context_handle, NULL);
+   if (h3DesKey)        Cfm1DeleteKey(h3DesKey);
+
+   return (ret);
+}
+
+
+/*
+ * imports public key
+ *
+ * returns 0 on success, 1 on failure
+ */
+int fips_import_public_key(RSA* rsa, unsigned long long *key_handle)
+{
+   Uint8 *modulus = NULL, *exponent = NULL;
+   Uint32 modulus_size = 0, exp_size = 0;
+   Uint32 pub_exponent = 0;
+   int ret = 1, size = 0;
+   Uint8* ptr = (Uint8*)&pub_exponent;
+
+   modulus_size = BN_num_bytes(rsa->n);
+   exp_size = BN_num_bytes(rsa->e);
+
+   if((modulus_size&0x7)!=0)
+   {
+       goto end_import_pub_key;
+   }
+
+   if (exp_size > (sizeof(Uint32)))
+   {
+       goto end_import_pub_key;
+   }
+
+   modulus = (Uint8*)malloc(modulus_size);
+   exponent = (Uint8*)malloc(sizeof(Uint32));
+   if (modulus == NULL)
+   {
+       goto end_import_pub_key;
+   }
+
+   memset(modulus, 0, modulus_size);
+   memset(exponent, 0, sizeof(Uint32));
+
+   BN_bn2bin(rsa->n, modulus);
+   size = BN_bn2bin(rsa->e, exponent);
+   memmove(ptr + ((sizeof(Uint32)) - size), exponent, size);
+
+   pub_exponent = htobe32(pub_exponent);
+
+   ret = Cfm1CreateRSAPublicKey(modulus, modulus_size, pub_exponent, (Uint8 *)"PUB_KEY_IMPORT", 14, key_handle);
+   if (ret)
+   {
+       goto end_import_pub_key;
+   }
+
+   ret = 0;
+
+end_import_pub_key:
+
+   if (modulus)   free(modulus);
+   if (exponent)  free(exponent);
+
+   return (ret);
+}
+
+
+
+
+
+
+
+#ifdef CAVIUM_MODEX_DEBUG
+#include <stdio.h>
+#endif
+
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m)
+{
+
+  /* for fips mode, the control should never get here */
+  printf("cav_mod_exp : mod exp can only be done using a key handle imported earlier\n");
+  return (1);
+
+}
+
+
+/*
+ * is_key_handle flag is set only in FIPS mode calls when the key handle is passed
+ *
+ * note : when the is_key_handle flag is set in fips mode, the RSA* is actually an
+ *        SSL* which includes the key handle and its size, so type casting is
+ *        is required to access the SSL* data structure
+ */
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle)
+{
+
+	int i,ret=0;
+        Uint64 dummy_context_pointer = 0;
+	int modulus_size;
+	Uint32 req_id;
+        unsigned char *from_b=NULL, *temp=NULL;
+	Uint64 out_length=0;
+
+        Uint64 key_handle = 0;
+
+	if (is_key_handle)
+	{
+            SSL *s = (SSL*)rsa;
+            modulus_size = s->ctx->pkey_info.size;
+            key_handle = s->key_handle;
+	}
+	else
+	{
+            ret = fips_import_public_key(rsa, &key_handle);
+	    if (ret) return(0);
+
+	    modulus_size  = BN_num_bytes(rsa->n);
+	}
+
+    //    if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+	    return(0);
+	}
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL) 
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+            return(0);
+	}
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+            return(0);
+	}
+
+        swap_word_openssl(temp, from, modulus_size);
+        memcpy(from_b, temp, modulus_size);
+
+
+        i = Cfm1Pkcs1v15Dec(OP_BLOCKING, 
+                            RESULT_PTR,
+                            dummy_context_pointer, 
+                            &key_handle, 
+                            BT1,
+		            (unsigned short)modulus_size,
+                            from_b,
+		            to,
+                            &out_length,
+		            &req_id);
+
+	if(i) ret=0;
+	else  ret = (Uint32)out_length;
+
+        if (!is_key_handle) Cfm1DeleteKey(key_handle);
+
+	return (ret);
+
+}
+
+
+
+/*
+ * is_key_handle flag is set only in FIPS mode calls when the key handle is passed
+ *
+ * note : when the is_key_handle flag is set in fips mode, the RSA* is actually an
+ *        SSL* which includes the key handle and its size, so type casting is
+ *        is required to access the SSL* data structure
+ */
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle)
+{
+
+	int i,ret=0;
+        Uint64 dummy_context_pointer = 0;
+	int modulus_size;
+	Uint32 req_id;
+        unsigned char *from_b=NULL, *temp=NULL;
+	Uint64 out_length=0;
+
+        Uint64 key_handle = 0;
+
+	if (is_key_handle)
+	{
+            SSL *s = (SSL*)rsa;
+            modulus_size = s->ctx->pkey_info.size;
+            key_handle = s->key_handle;
+	}
+	else
+	{
+            ret = fips_import_private_key(rsa, &key_handle);
+	    if (ret) return(0);
+
+	    modulus_size  = BN_num_bytes(rsa->n);
+	}
+
+    //    if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+	    return(0);
+	}
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL) 
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+            return(0);
+	}
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+            return(0);
+	}
+
+        swap_word_openssl(temp, from, modulus_size);
+        memcpy(from_b, temp, modulus_size);
+
+
+        i = Cfm1Pkcs1v15Dec(OP_BLOCKING, 
+                            RESULT_PTR,
+                            dummy_context_pointer, 
+                            &key_handle, 
+                            BT2,
+		            (unsigned short)modulus_size,
+                            from_b,
+		            to,
+                            &out_length,
+		            &req_id);
+
+	if(i) ret=0;
+	else  ret = (Uint32)out_length;
+
+        if (!is_key_handle) Cfm1DeleteKey(key_handle);
+
+	return (ret);
+
+}
+
+
+
+
+/*
+ * is_key_handle flag is set only in FIPS mode calls when the key handle is passed
+ *
+ * note : when the is_key_handle flag is set in fips mode, the RSA* is actually an
+ *        SSL* which includes the key handle and its size, so type casting is
+ *        is required to access the SSL* data structure
+ */
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle)
+{
+
+	int i,ret=0;
+        Uint64 dummy_context_pointer = 0;
+	int modulus_size;
+	Uint32 req_id;
+
+        Uint64 key_handle = 0;
+
+	if (is_key_handle)
+	{
+            SSL *s = (SSL*)rsa;
+            modulus_size = s->ctx->pkey_info.size;
+            key_handle = s->key_handle;
+	}
+	else
+	{
+            ret = fips_import_public_key(rsa, &key_handle);
+	    if (ret) return(0);
+
+	    modulus_size  = BN_num_bytes(rsa->n);
+	}
+
+    //    if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+	    return(0);
+	}
+
+
+        i = Cfm1Pkcs1v15Enc(OP_BLOCKING, 
+                            RESULT_PTR,
+                            dummy_context_pointer, 
+                            &key_handle, 
+                            BT2,
+		            modulus_size,
+                            flen, 
+                            from,
+		            to,
+		            &req_id);
+
+        if(i) ret=0;
+	else ret = modulus_size;
+
+        if (!is_key_handle) Cfm1DeleteKey(key_handle);
+
+	return (ret);
+
+}
+
+
+/*
+ * is_key_handle flag is set only in FIPS mode calls when the key handle is passed
+ *
+ * note : when the is_key_handle flag is set in fips mode, the RSA* is actually an
+ *        SSL* which includes the key handle and its size, so type casting is
+ *        is required to access the SSL* data structure
+ */
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle)
+{
+
+	int i,ret=0;
+        Uint64 dummy_context_pointer = 0;
+	int modulus_size;
+	Uint32 req_id;
+        Uint64 key_handle = 0;
+
+	if (is_key_handle)
+	{
+            SSL *s = (SSL*)rsa;
+            modulus_size = s->ctx->pkey_info.size;
+            key_handle = s->key_handle;
+	}
+	else
+	{
+            ret = fips_import_private_key(rsa, &key_handle);
+	    if (ret) return(0);
+
+	    modulus_size  = BN_num_bytes(rsa->n);
+	}
+
+    //    if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+	{
+	    if (!is_key_handle) Cfm1DeleteKey(key_handle);
+	    return(0);
+	}
+
+
+        i = Cfm1Pkcs1v15Enc(OP_BLOCKING, 
+                            RESULT_PTR,
+                            dummy_context_pointer, 
+                            &key_handle, 
+                            BT1,
+		            modulus_size,
+                            flen, 
+                            from,
+		            to,
+		            &req_id);
+
+        if(i) ret=0;
+	else ret = modulus_size;
+
+        if (!is_key_handle) Cfm1DeleteKey(key_handle);
+
+	return (ret);
+
+}
+#else 
+
+
+int check_crypto_completion (SSL *s,
+#ifdef MC2
+				 Uint16 *ret
+#else
+				 Uint64 *ret
+#endif
+				 ) ;
+
+
+#ifdef CAVIUM_MODEX_DEBUG
+#include <stdio.h>
+#endif
+
+#ifdef MC2
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m)
+{
+  unsigned char *ab, *pb, *mb, *rb;
+  int sizep,sizem,sizea;
+  int driver_ready=-1;
+  int ret = 0;
+  Uint32 req_id;
+
+
+  sizem = BN_num_bytes(m);
+  if( (sizem < 24) || (sizem>256) ) return 0;
+
+#ifdef CAVIUM_MULTICARD_API
+  driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+  driver_ready = Csp1GetDriverState();
+#endif
+  if(driver_ready == -1)
+  {
+
+#ifdef CAVIUM_MULTICARD_API
+	  if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+  }
+
+  sizea = BN_num_bytes(a);
+  sizep = BN_num_bytes(p);
+
+  mb = alloca(sizem);
+  if(mb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(mb,0,sizem);
+
+  ab = alloca(sizea);
+  if(ab==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(ab,0,sizea);
+
+  pb = alloca(sizep);
+  if(pb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(pb,0,sizep);   
+
+  rb = alloca(sizem); 
+  if(rb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(rb,0,sizem);
+
+  BN_bn2bin(a,ab); 
+
+  BN_bn2bin(p,pb); 
+
+  BN_bn2bin(m,mb); 
+
+#ifdef CAVIUM_MULTICARD_API
+  if (Csp1Me(CAVIUM_BLOCKING,sizem, sizep, sizea, mb, pb,ab, rb, &req_id,CAVIUM_DEV_ID))
+#else
+  if (Csp1Me(CAVIUM_BLOCKING,sizem, sizep, sizea, mb, pb,ab, rb, &req_id))
+#endif
+   {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+   }
+  
+
+  BN_bin2bn(rb,sizem,r); 
+  ret = 1;
+
+mod_exp_cleanup:
+  if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+	  Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+	  Csp1Shutdown();
+#endif
+  return ret;
+
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_public_decrypt_cav(void *s1,int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+	int driver_ready = -1;
+	int rc;
+
+	SSL *s = (SSL *)s1;
+	
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+
+		if (rc == 1) {
+			memcpy (to, s->pre_master_result,flen);
+			return out_length;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc;
+		else{
+			return 0;
+		}
+	}
+	
+#ifdef CAVIUM_MULTICARD_API
+	driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+	driver_ready = Csp1GetDriverState();
+#endif
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+
+	memcpy(from_b,from,modulus_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+	s->cryp_flen = flen;
+
+	i = Csp1Pkcs1v15Dec(s->cav_nb_mode,
+					BT1,
+				(Uint16)modulus_size, 
+				(Uint16)exponent_size,
+	   			 modulus_b, 
+			   	 exponent_b, 
+				 from_b,
+				&(s->pre_master_len),
+				 s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+				 &(s->cav_req_id),s->dev_id
+#else
+				 &(s->cav_req_id)
+#endif
+                             );
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_public_decrypt(): %s\n",
+                                        "Csp1Pkcs1v15De() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+
+		if (s->state == SSL3_ST_CR_KEY_EXCH_B)
+			s->state = SSL3_ST_CR_KEY_EXCH_B ;
+		else
+                	s->state = CAV_ST_IN_PRE_MASTER_KEY;
+
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+        if(i) {
+		ret = 0;
+		return ret;
+	}
+	else {
+	 	ret = (Uint32)ntohs(s->pre_master_len); 
+		memcpy (to, s->pre_master_result,flen);
+	}
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}/*pkp_rsa_public_decrypt*/
+#endif
+
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+	Uint32 req_id;
+	int driver_ready = -1;
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+
+	memcpy(from_b,from,modulus_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+	
+	i = Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+		BT1,
+		(Uint16)modulus_size, 
+		(Uint16)exponent_size,
+	   	 modulus_b, 
+	   	 exponent_b, 
+		 from_b,
+		&out_length,
+		to,
+#ifdef CAVIUM_MULTICARD_API
+                &req_id,CAVIUM_DEV_ID
+#else
+                &req_id
+#endif
+                );
+
+
+	if(i) ret=0;
+	else ret = (Uint32)ntohs(out_length);
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}/*pkp_rsa_public_decrypt*/
+
+
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_priv_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+   	i = Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+				BT2,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				&out_length,
+				to,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+	if(i) ret=0;
+	else ret = (Uint32)ntohs(out_length);
+
+rsa_priv_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_public_encrypt_cav(void *s1 , int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint16 out_length=0;
+	int rc ;
+
+	SSL *s = (SSL *)s1;
+
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+		if (rc == 1) {
+	                modulus_size  = BN_num_bytes(rsa->n);
+			memcpy (to, s->pre_master_result,modulus_size);
+			return s->cryp_flen;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc;
+		else
+			return 0;
+	}
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+	s->cryp_flen = modulus_size;
+
+	i = Csp1Pkcs1v15Enc(s->cav_nb_mode,
+				BT2,
+				(Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+	   			 modulus_b, 
+			   	 exponent_b, 
+				 from_b,
+				 s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+                                 &(s->cav_req_id),s->dev_id
+#else
+                                 &(s->cav_req_id)
+#endif
+                             );
+
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_public_encrypt(): %s\n",
+                                        "Csp1Pkcs1v15Enc() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+		s->state = SSL3_ST_CW_KEY_EXCH_A;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+
+	if(i) {
+		ret=0;
+		return ret;
+	}
+	
+	else {
+		ret = modulus_size;
+		memcpy(to,s->pre_master_result,ret);
+	}
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif
+
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+   i = Csp1Pkcs1v15Enc(CAVIUM_BLOCKING,
+			    BT2,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				to,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_private_encrypt_cav(void *s1,int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint16 out_length=0;
+	int rc ;
+
+
+	SSL *s = (SSL *)s1;
+	
+
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+
+		if (rc == 1) {
+	                modulus_size  = BN_num_bytes(rsa->n);
+			memcpy (to, s->pre_master_result,modulus_size);
+			return s->cryp_flen;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc ;
+		else
+			return 0;
+	}
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if((modulus_size<17)||(modulus_size>256))
+	if((modulus_size<17)||(modulus_size>512))
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+	s->cryp_flen = modulus_size;
+
+
+	i = Csp1Pkcs1v15Enc(s->cav_nb_mode,
+				BT1,
+				(Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+	   			 modulus_b, 
+			   	 exponent_b, 
+				 from_b,
+				 s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+                                 &(s->cav_req_id),s->dev_id
+#else
+                                 &(s->cav_req_id)
+#endif
+                             );
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_private_encrypt(): %s\n",
+                                        "Csp1Pkcs1v15Enc() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+	//	if (s->state == SSL3_ST_CW_CERT_VRFY_A )
+                        s->state = CAV_ST_IN_PRE_MASTER_KEY;
+          //      else
+            //            s->state = SSL3_ST_CW_KEY_EXCH_A;
+
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+	if(i) {
+		ret=0;
+		return ret;
+	}	
+	else {
+		ret = modulus_size;
+		memcpy(to,s->pre_master_result,ret);
+	}		
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif
+
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	if((modulus_size<17)||(modulus_size>512))
+	//if((modulus_size<17)||(modulus_size>256))
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+	i = Csp1Pkcs1v15Enc(CAVIUM_BLOCKING,
+			    BT1,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				to,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+
+	return ret;
+}
+
+#else
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m)
+{
+  unsigned char *ab, *pb, *mb, *rb, *temp;
+  int sizep,sizem,sizea,osizem;
+  int driver_ready=-1;
+  int ret = 0;
+  Uint32 req_id;
+
+#ifdef CAVIUM_MODEX_DEBUG
+  int i; 
+  FILE *fptr;
+#endif
+
+  osizem = BN_num_bytes(m);
+  if( (osizem < 24) || (osizem>256) ) return 0;
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+  if(driver_ready == -1)
+  {
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+  }
+
+  sizem = ((osizem+7)/8)*8;
+  sizea = BN_num_bytes(a);
+  sizep = BN_num_bytes(p);
+
+  mb = alloca(sizem);
+  if(mb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(mb,0,sizem);
+
+  ab = alloca(sizem);
+  if(ab==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(ab,0,sizem);
+
+  pb = alloca(sizem);
+  if(pb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(pb,0,sizem);   
+
+  temp = alloca(sizem); 
+  if(temp==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(temp,0,sizem);
+
+  rb = alloca(sizem); 
+  if(rb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(rb,0,sizem);
+
+  BN_bn2bin(a,ab); 
+
+  BN_bn2bin(p,pb); 
+
+  if(sizep < sizem)
+   {
+    pkp_leftfill(pb,sizep,temp,sizem);
+    memcpy(pb,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+   if(sizea < sizem)
+   {
+    pkp_leftfill(ab,sizea,temp,sizem);
+    memcpy(ab,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+  BN_bn2bin(m,mb); 
+  if(sizem > osizem)
+   {
+    pkp_leftfill(mb,osizem,temp,sizem);
+    memcpy(mb,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+#ifdef CAVIUM_MODEX_DEBUG
+   fptr = fopen("me.tst", "a");
+   fprintf(fptr, "\ndata:\n");
+   for (i=0;i<sizem; i++)
+     fprintf(fptr, "%02x ", ab[i]);
+   fprintf(fptr, "\nexponent\n");
+   for(i=0;i<sizem;i++)
+    fprintf(fptr,"%02x ", pb[i]);
+   fprintf(fptr,"\nmodulus:\n");
+   for(i=0;i<sizem;i++)
+     fprintf(fptr, "%02x ",mb[i]);
+#endif
+  
+  swap_word_openssl(temp, ab, sizem);
+  memcpy(ab,temp,sizem);
+  memset(temp,0,sizem);
+
+  swap_word_openssl(temp, pb, sizem);
+  memcpy(pb,temp,sizem);
+  memset(temp,0,sizem);
+
+  swap_word_openssl(temp, mb, sizem);
+  memcpy(mb,temp,sizem);
+  memset(temp,0,sizem);
+
+#ifdef CAVIUM_MODEX_DEBUG
+  fprintf(fptr, "\ndata after swap :\n");
+   for (i=0;i<sizem; i++)
+     fprintf(fptr, "%02x ", ab[i]);
+   fprintf(fptr, "\nexponent after swap\n");
+   for(i=0;i<sizem;i++)
+    fprintf(fptr,"%02x ", pb[i]);
+   fprintf(fptr,"\nmodulus after swap:\n");
+   for(i=0;i<sizem;i++)
+     fprintf(fptr, "%02x ",mb[i]); 
+#endif
+
+#ifdef CAVIUM_MULTICARD_API
+   if (Csp1Me(CAVIUM_BLOCKING,RESULT_PTR, (Uint64)NULL, sizem, ab, mb, pb, rb, &req_id,CAVIUM_DEV_ID))
+#else
+   if (Csp1Me(CAVIUM_BLOCKING,RESULT_PTR, (Uint64)NULL, sizem, ab, mb, pb, rb, &req_id))
+#endif
+
+   {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+   }
+
+
+#ifdef CAVIUM_MODEX_DEBUG
+   fprintf(fptr, "\nresult:\n");
+   for(i=0;i<sizem;i++)
+   {
+    fprintf(fptr, "%02x ",rb[i]);
+   }
+  fclose(fptr);
+#endif
+
+  
+  BN_bin2bn(rb,sizem,r); 
+  ret = 1;
+
+mod_exp_cleanup:
+  if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  return ret;
+
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_public_decrypt_cav(void *s1,int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+	Uint64 out_length=0;
+	int rc ;
+
+	SSL *s = (SSL *)s1;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_ctx_ptr = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+		if (rc == 1) {
+			memcpy (to, s->pre_master_result,s->cryp_flen);
+			return (Uint32)out_length;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc;
+		else
+			return 0;
+	}
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+//	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, from_b, modulus_size);
+   memcpy(from_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+    s->cryp_flen = flen;
+	
+	i  =	Csp1Pkcs1v15Dec(s->cav_nb_mode,
+						RESULT_PTR, /* got it ?? */
+						dummy_ctx_ptr, 
+						INPUT_DATA,
+						dummy_key_handle, 
+						BT1,
+						(unsigned short)modulus_size, 
+					    modulus_b, 
+					    exponent_b, 
+					    from_b,
+						s->pre_master_result,
+						&s->pre_master_len,
+#ifdef CAVIUM_MULTICARD_API
+                                 &(s->cav_req_id),s->dev_id
+#else
+                                 &(s->cav_req_id)
+#endif
+                             );
+
+
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_public_decrypt(): %s\n",
+                                        "Csp1Pkcs1v15De() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+
+		if (s->state == SSL3_ST_CR_KEY_EXCH_B)
+			s->state = SSL3_ST_CR_KEY_EXCH_B ;
+		else	
+                	s->state = CAV_ST_IN_PRE_MASTER_KEY;
+
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+        if(i) {
+
+		ret = 0;
+		return ret;
+	}
+	else {
+	 ret = (Uint32)(s->pre_master_len); 
+	 memcpy (to, s->pre_master_result,s->cryp_flen);
+	}
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif
+
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+	Uint64 out_length=0;
+	Uint32 req_id;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_ctx_ptr = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, from_b, modulus_size);
+   memcpy(from_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+	i=	Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+						RESULT_PTR, /* got it ?? */
+						dummy_ctx_ptr, 
+						INPUT_DATA,
+						dummy_key_handle, 
+						BT1,
+						(unsigned short)modulus_size, 
+					    modulus_b, 
+					    exponent_b, 
+					    from_b,
+						to,
+						&out_length,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+
+	if(i) ret=0;
+	else ret = (Uint32)out_length;
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+	Uint64 out_length=0;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_ctx_ptr = 0;
+	Uint64 dummy_key_handle = 0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_priv_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, from_b, modulus_size);
+   memcpy(from_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+	i=	Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+	   					RESULT_PTR, /* got it ?? */
+						dummy_ctx_ptr, 
+						INPUT_DATA,
+						dummy_key_handle, 
+						BT2,
+						(unsigned short)modulus_size, 
+					    modulus_b, 
+					    exponent_b, 
+					    from_b,
+						to,
+						&out_length,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+
+	if(i) ret=0;
+	else ret = (Uint32)out_length;
+
+rsa_priv_dec_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_public_encrypt_cav(void *s1,int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+   	Uint64 dummy_key_handle = 0;
+	int driver_ready = -1;
+	Uint64 out_length=0;
+	int rc ;
+
+
+	SSL *s = (SSL *)s1;
+
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+		if (rc == 1) {
+	                modulus_size  = BN_num_bytes(rsa->n);
+			memcpy (to,s->pre_master_result,modulus_size);
+			return s->cryp_flen;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc;
+		else
+			return 0;
+	}
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+	
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+	
+   s->cryp_flen = modulus_size;		
+
+   i = Csp1Pkcs1v15Enc( s->cav_nb_mode,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT2,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						(unsigned short)flen, 
+						from_b,
+						s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+                                 &(s->cav_req_id),s->dev_id
+#else
+                                 &(s->cav_req_id)
+#endif
+                             );
+
+
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_public_encrypt(): %s\n",
+                                        "Csp1Pkcs1v15Enc() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+		s->state = SSL3_ST_CW_KEY_EXCH_A;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+
+	if(i) {
+		ret=0;
+		return ret;
+	}
+	
+	else {
+		ret = modulus_size;
+		memcpy(to,s->pre_master_result,ret);
+	}
+
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif
+
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+    Uint64 dummy_key_handle = 0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+	
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   i = Csp1Pkcs1v15Enc( CAVIUM_BLOCKING,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT2,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						(unsigned short)flen, 
+						from_b,
+						to,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+
+#ifdef CAVIUM_SSL
+int pkp_rsa_private_encrypt_cav(void *s1,int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+	Uint64 out_length=0;
+	int rc ;
+
+
+
+	SSL *s = (SSL *)s1;
+
+	if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY){
+		
+		rc = check_crypto_completion (s,
+						  &out_length	
+						  );	
+
+		if (rc == 1) {
+	                modulus_size  = BN_num_bytes(rsa->n);
+			memcpy (to,s->pre_master_result ,modulus_size);
+			return s->cryp_flen;
+		}
+		else if(rc == -EAGAIN) 
+		  	return rc;
+		else
+			return 0;
+	}
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   s->cryp_flen = modulus_size;	
+	
+   i = Csp1Pkcs1v15Enc( s->cav_nb_mode,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT1,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						flen, 
+						from_b,
+						s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+                                 &(s->cav_req_id),s->dev_id
+#else
+                                 &(s->cav_req_id)
+#endif
+                             );
+
+
+
+
+	if ( i == EAGAIN)
+	{
+		cav_fprintf(cav_nb_fp,"rsa_private_encrypt(): %s\n",
+                                        "Csp1Pkcs1v15Enc() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+                s->cav_saved_state = s->state;
+	//	if (s->state == SSL3_ST_CW_CERT_VRFY_A )
+			s->state = CAV_ST_IN_PRE_MASTER_KEY;
+	//	else
+	//		s->state = SSL3_ST_CW_KEY_EXCH_A;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+		return -EAGAIN;
+	}
+
+	if(i) {
+		ret=0;
+		return ret;
+	}
+	
+	else {
+		ret = modulus_size;
+		memcpy(to,s->pre_master_result,ret);
+	}
+
+
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif
+
+
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+
+	if(driver_ready == -1)
+	{
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	//if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+
+   i = Csp1Pkcs1v15Enc( CAVIUM_BLOCKING,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT1,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						flen, 
+						from_b,
+						to,
+#ifdef CAVIUM_MULTICARD_API
+                                 &req_id,CAVIUM_DEV_ID
+#else
+                                 &req_id
+#endif
+                             );
+
+
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+#ifdef CAVIUM_MULTICARD_API
+          Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+          Csp1Shutdown();
+#endif
+
+  
+	return ret;
+}
+#endif /* MC2 else */
+
+int check_crypto_completion (SSL *s,
+#ifdef MC2
+				  Uint16 *out_length	
+#else
+				  Uint64 *out_length	
+#endif
+				  ) {
+
+
+	int rc ;
+
+	s->state = s->cav_saved_state;
+        if ( s->cav_req_id_check_done ) {
+                cav_fprintf(cav_nb_fp,"check_crypto_completion(): %s\n",
+                        "already checked, probably directly by app\n");
+                rc = 0;
+        }
+        else {
+#ifdef CAVIUM_MULTICARD_API
+                rc = Csp1CheckForCompletion(s->cav_req_id,s->dev_id);
+#else
+                rc = Csp1CheckForCompletion(s->cav_req_id);
+#endif
+        }
+        cav_fprintf(cav_nb_fp,
+                "check_crypto_completion():Csp1CheckForCompletion() rc=%d\n",
+                rc);
+
+        switch(rc) {
+                                                                                                                             
+        case EAGAIN:
+                cav_fprintf(cav_nb_fp,"check_crypto_completion(): %s\n",
+                                "Csp1CheckForCompletion() EAGAIN");
+                s->cav_saved_state = s->state;
+                cav_fprintf(cav_nb_fp,"check_crypto_completion() s->state: %d\n",
+                                s->state);
+
+
+		if (s->state == SSL3_ST_CW_KEY_EXCH_A)
+			s->state = SSL3_ST_CW_KEY_EXCH_A ;
+		else if (s->state == SSL3_ST_CR_KEY_EXCH_B )
+			s->state = SSL3_ST_CR_KEY_EXCH_B;
+                else
+	                s->state = CAV_ST_IN_PRE_MASTER_KEY;
+		//else if (s->state == SSL3_ST_CW_CERT_VRFY_A )
+                  //      s->state = CAV_ST_IN_PRE_MASTER_KEY;
+		
+                return(-EAGAIN);
+        case 0:
+                cav_fprintf(cav_nb_fp,"===>check_crypto_completion(): %s\n",
+                                "Csp1CheckForCompletion() completed");
+                                                                                                                             
+                s->cav_crypto_state = 0;
+                s->cav_req_id_check_done = 1;
+                s->rwstate = SSL_NOTHING;
+		#ifdef MC2
+	 		*out_length = (Uint32)ntohs(s->pre_master_len); 
+		#else
+			*out_length = (Uint32)(s->pre_master_len); 
+		#endif
+		break;
+         default:
+                cav_fprintf(cav_nb_fp,"check_crypto_completion(): %s\n",
+                                "Csp1CheckForCompletion() default case");
+                /*
+                 * should we reset the cav_crypto_state to 0 here
+                 * to prevent an infinite loop
+                 */
+                s->cav_crypto_state = 0;
+                s->cav_req_id_check_done = 1;
+                s->rwstate = SSL_NOTHING;
+                return(-1);
+        } // end switch
+        return(1);
+}
+#endif /* CAVIUM_FIPS */ 
diff -Naur openssl-0.9.8j/crypto/cavium/Makefile TurboSSL-0.9.8j/crypto/cavium/Makefile
--- openssl-0.9.8j/crypto/cavium/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/cavium/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,101 @@
+#
+# SSLeay/crypto/cast/Makefile
+#
+
+DIR=	cavium
+APIDIR ?= ../../../../api
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES= -I$(APIDIR)
+CFLAG=-g
+INSTALL_PREFIX=
+OPENSSLDIR=     /usr/local/ssl
+INSTALLTOP=/usr/local/ssl
+MAKE=		make -f Makefile.ssl
+MAKEDEPEND=	$(TOP)/util/domd $(TOP)
+MAKEFILE=	Makefile.ssl
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+APPS=
+
+
+LIB=$(TOP)/libcrypto.a
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS) 
+LIBSRC=luna_ssl.c luna_common.c cav_crypto_engine.c luna_private.c luna_api.c  
+LIBOBJ=luna_ssl.o luna_common.o cav_crypto_engine.o luna_private.o luna_api.o $(CAVEO_ENC)
+else
+LIBSRC=cavium_ssl.c cavium_common.c cav_crypto_engine.c 
+LIBOBJ=cavium_ssl.o cavium_common.o cav_crypto_engine.o $(CAVEO_ENC)
+endif
+
+SRC= $(LIBSRC)
+
+EXHEADER= 
+
+HEADER= $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB)
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile.ssl >> $(TOP)/MINFO
+
+links:
+	#@$(TOP)/util/point.sh Makefile.ssl Makefile
+	@if test -f $(APIDIR)/luna_common.c; then \
+	ln -fs  $(APIDIR)/luna_common.c luna_common.c ; \
+	ln -fs  $(APIDIR)/luna_api.c luna_api.c ;\
+	ln -fs  $(APIDIR)/luna_private.c luna_private.c; \
+	ln -fs  $(APIDIR)/luna_ssl.c luna_ssl.c; \
+	fi
+	@if test -f $(APIDIR)/cavium_common.c; then \
+	ln -fs  $(APIDIR)/cavium_common.c cavium_common.c ; \
+	ln -fs  $(APIDIR)/cavium_ssl.c cavium_ssl.c;\
+	fi
+	@if test -f $(APIDIR)/cavium_ecc.c; then \
+        ln -fs  $(APIDIR)/cavium_ecc.c cavium_ecc.c ; \
+	fi
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@for i in $(EXHEADER) ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	$(MAKEDEPEND) $(INCLUDES) $(DEPFLAG) $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f asm/cx86unix.cpp *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/cavium/Makefile.save TurboSSL-0.9.8j/crypto/cavium/Makefile.save
--- openssl-0.9.8j/crypto/cavium/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/cavium/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,102 @@
+#
+# SSLeay/crypto/cast/Makefile
+#
+
+DIR=	cavium
+APIDIR = ../../../../api
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES= -I$(APIDIR)
+CFLAG=-g
+INSTALL_PREFIX=
+OPENSSLDIR=     /usr/local/ssl
+INSTALLTOP=/usr/local/ssl
+MAKE=		make -f Makefile.ssl
+MAKEDEPEND=	$(TOP)/util/domd $(TOP)
+MAKEFILE=	Makefile.ssl
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+APPS=
+
+
+LIB=$(TOP)/libcrypto.a
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS) 
+LIBSRC=luna_ssl.c luna_common.c cav_crypto_engine.c luna_private.c luna_api.c  
+LIBOBJ=luna_ssl.o luna_common.o cav_crypto_engine.o luna_private.o luna_api.o $(CAVEO_ENC)
+else
+LIBSRC=cavium_ssl.c cavium_common.c cav_crypto_engine.c 
+LIBOBJ=cavium_ssl.o cavium_common.o cav_crypto_engine.o $(CAVEO_ENC)
+endif
+
+SRC= $(LIBSRC)
+
+EXHEADER= 
+
+HEADER= $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB)
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile.ssl >> $(TOP)/MINFO
+
+links:
+	#@$(TOP)/util/point.sh Makefile.ssl Makefile
+	@if test -f $(APIDIR)/luna_common.c; then \
+	ln -fs  $(APIDIR)/luna_common.c luna_common.c ; \
+	ln -fs  $(APIDIR)/luna_api.c luna_api.c ;\
+	ln -fs  $(APIDIR)/luna_private.c luna_private.c; \
+	ln -fs  $(APIDIR)/luna_ssl.c luna_ssl.c; \
+	fi
+	@if test -f $(APIDIR)/cavium_common.c; then \
+	ln -fs  $(APIDIR)/cavium_common.c cavium_common.c ; \
+	ln -fs  $(APIDIR)/cavium_ssl.c cavium_ssl.c;\
+	fi
+	@if test -f $(APIDIR)/cavium_ecc.c; then \
+        ln -fs  $(APIDIR)/cavium_ecc.c cavium_ecc.c ; \
+	fi
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@for i in $(EXHEADER) ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	$(MAKEDEPEND) $(INCLUDES) $(DEPFLAG) $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f asm/cx86unix.cpp *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
diff -Naur openssl-0.9.8j/crypto/comp/Makefile TurboSSL-0.9.8j/crypto/comp/Makefile
--- openssl-0.9.8j/crypto/comp/Makefile	2008-09-16 23:44:43.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/comp/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -76,33 +76,3 @@
 	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-c_rle.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-c_rle.o: ../../include/openssl/comp.h ../../include/openssl/crypto.h
-c_rle.o: ../../include/openssl/e_os2.h ../../include/openssl/obj_mac.h
-c_rle.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-c_rle.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-c_rle.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-c_rle.o: ../../include/openssl/symhacks.h c_rle.c
-c_zlib.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-c_zlib.o: ../../include/openssl/comp.h ../../include/openssl/crypto.h
-c_zlib.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-c_zlib.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
-c_zlib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-c_zlib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-c_zlib.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-c_zlib.o: ../../include/openssl/symhacks.h c_zlib.c
-comp_err.o: ../../include/openssl/bio.h ../../include/openssl/comp.h
-comp_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-comp_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
-comp_err.o: ../../include/openssl/opensslconf.h
-comp_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-comp_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-comp_err.o: ../../include/openssl/symhacks.h comp_err.c
-comp_lib.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-comp_lib.o: ../../include/openssl/comp.h ../../include/openssl/crypto.h
-comp_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/obj_mac.h
-comp_lib.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-comp_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-comp_lib.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-comp_lib.o: ../../include/openssl/symhacks.h comp_lib.c
diff -Naur openssl-0.9.8j/crypto/comp/Makefile.save TurboSSL-0.9.8j/crypto/comp/Makefile.save
--- openssl-0.9.8j/crypto/comp/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/comp/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,78 @@
+#
+# OpenSSL/crypto/comp/Makefile
+#
+
+DIR=	comp
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= comp_lib.c comp_err.c \
+	c_rle.c c_zlib.c
+
+LIBOBJ=	comp_lib.o comp_err.o \
+	c_rle.o c_zlib.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= comp.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/conf/Makefile TurboSSL-0.9.8j/crypto/conf/Makefile
--- openssl-0.9.8j/crypto/conf/Makefile	2008-09-17 19:10:57.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/conf/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -76,78 +76,3 @@
 	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-conf_api.o: ../../e_os.h ../../include/openssl/bio.h
-conf_api.o: ../../include/openssl/conf.h ../../include/openssl/conf_api.h
-conf_api.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-conf_api.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-conf_api.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_api.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-conf_api.o: ../../include/openssl/symhacks.h conf_api.c
-conf_def.o: ../../e_os.h ../../include/openssl/bio.h
-conf_def.o: ../../include/openssl/buffer.h ../../include/openssl/conf.h
-conf_def.o: ../../include/openssl/conf_api.h ../../include/openssl/crypto.h
-conf_def.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-conf_def.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-conf_def.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_def.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-conf_def.o: ../../include/openssl/symhacks.h ../cryptlib.h conf_def.c
-conf_def.o: conf_def.h
-conf_err.o: ../../include/openssl/bio.h ../../include/openssl/conf.h
-conf_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-conf_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
-conf_err.o: ../../include/openssl/opensslconf.h
-conf_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-conf_err.o: ../../include/openssl/symhacks.h conf_err.c
-conf_lib.o: ../../include/openssl/bio.h ../../include/openssl/conf.h
-conf_lib.o: ../../include/openssl/conf_api.h ../../include/openssl/crypto.h
-conf_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-conf_lib.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-conf_lib.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_lib.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-conf_lib.o: ../../include/openssl/symhacks.h conf_lib.c
-conf_mall.o: ../../e_os.h ../../include/openssl/asn1.h
-conf_mall.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
-conf_mall.o: ../../include/openssl/conf.h ../../include/openssl/crypto.h
-conf_mall.o: ../../include/openssl/dso.h ../../include/openssl/e_os2.h
-conf_mall.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
-conf_mall.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
-conf_mall.o: ../../include/openssl/err.h ../../include/openssl/evp.h
-conf_mall.o: ../../include/openssl/fips.h ../../include/openssl/lhash.h
-conf_mall.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
-conf_mall.o: ../../include/openssl/opensslconf.h
-conf_mall.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_mall.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
-conf_mall.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
-conf_mall.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
-conf_mall.o: ../../include/openssl/x509_vfy.h ../cryptlib.h conf_mall.c
-conf_mod.o: ../../e_os.h ../../include/openssl/asn1.h
-conf_mod.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
-conf_mod.o: ../../include/openssl/conf.h ../../include/openssl/crypto.h
-conf_mod.o: ../../include/openssl/dso.h ../../include/openssl/e_os2.h
-conf_mod.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
-conf_mod.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
-conf_mod.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-conf_mod.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
-conf_mod.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-conf_mod.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_mod.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
-conf_mod.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
-conf_mod.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
-conf_mod.o: ../../include/openssl/x509_vfy.h ../cryptlib.h conf_mod.c
-conf_sap.o: ../../e_os.h ../../include/openssl/asn1.h
-conf_sap.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
-conf_sap.o: ../../include/openssl/conf.h ../../include/openssl/crypto.h
-conf_sap.o: ../../include/openssl/dso.h ../../include/openssl/e_os2.h
-conf_sap.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
-conf_sap.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
-conf_sap.o: ../../include/openssl/err.h ../../include/openssl/evp.h
-conf_sap.o: ../../include/openssl/fips.h ../../include/openssl/lhash.h
-conf_sap.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
-conf_sap.o: ../../include/openssl/opensslconf.h
-conf_sap.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-conf_sap.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
-conf_sap.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
-conf_sap.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
-conf_sap.o: ../../include/openssl/x509_vfy.h ../cryptlib.h conf_sap.c
diff -Naur openssl-0.9.8j/crypto/conf/Makefile.save TurboSSL-0.9.8j/crypto/conf/Makefile.save
--- openssl-0.9.8j/crypto/conf/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/conf/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,78 @@
+#
+# OpenSSL/crypto/conf/Makefile
+#
+
+DIR=	conf
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= conf_err.c conf_lib.c conf_api.c conf_def.c conf_mod.c \
+	 conf_mall.c conf_sap.c
+
+LIBOBJ=	conf_err.o conf_lib.o conf_api.o conf_def.o conf_mod.o \
+	conf_mall.o conf_sap.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= conf.h conf_api.h
+HEADER=	conf_def.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/des/des_enc.c TurboSSL-0.9.8j/crypto/des/des_enc.c
--- openssl-0.9.8j/crypto/des/des_enc.c	2008-09-16 13:17:48.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/des/des_enc.c	2011-01-06 09:23:28.000000000 +0100
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -57,235 +57,237 @@
  */
 
 #include "des_locl.h"
-
+#if defined(CAVIUM_SSL) && !defined(CAVIUM_FIPS)
+static int pkp_device_state=1;
+#endif
 void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc)
-	{
-	register DES_LONG l,r,t,u;
+        {
+        register DES_LONG l,r,t,u;
 #ifdef DES_PTR
-	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+        register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
 #endif
 #ifndef DES_UNROLL
-	register int i;
+        register int i;
 #endif
-	register DES_LONG *s;
+        register DES_LONG *s;
 
-	r=data[0];
-	l=data[1];
+        r=data[0];
+        l=data[1];
 
-	IP(r,l);
-	/* Things have been modified so that the initial rotate is
-	 * done outside the loop.  This required the
-	 * DES_SPtrans values in sp.h to be rotated 1 bit to the right.
-	 * One perl script later and things have a 5% speed up on a sparc2.
-	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
-	 * for pointing this out. */
-	/* clear the top bits on machines with 8byte longs */
-	/* shift left by 2 */
-	r=ROTATE(r,29)&0xffffffffL;
-	l=ROTATE(l,29)&0xffffffffL;
-
-	s=ks->ks->deslong;
-	/* I don't know if it is worth the effort of loop unrolling the
-	 * inner loop */
-	if (enc)
-		{
+        IP(r,l);
+        /* Things have been modified so that the initial rotate is
+         * done outside the loop.  This required the
+         * DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+         * One perl script later and things have a 5% speed up on a sparc2.
+         * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+         * for pointing this out. */
+        /* clear the top bits on machines with 8byte longs */
+        /* shift left by 2 */
+        r=ROTATE(r,29)&0xffffffffL;
+        l=ROTATE(l,29)&0xffffffffL;
+
+        s=ks->ks->deslong;
+        /* I don't know if it is worth the effort of loop unrolling the
+         * inner loop */
+        if (enc)
+                {
 #ifdef DES_UNROLL
-		D_ENCRYPT(l,r, 0); /*  1 */
-		D_ENCRYPT(r,l, 2); /*  2 */
-		D_ENCRYPT(l,r, 4); /*  3 */
-		D_ENCRYPT(r,l, 6); /*  4 */
-		D_ENCRYPT(l,r, 8); /*  5 */
-		D_ENCRYPT(r,l,10); /*  6 */
-		D_ENCRYPT(l,r,12); /*  7 */
-		D_ENCRYPT(r,l,14); /*  8 */
-		D_ENCRYPT(l,r,16); /*  9 */
-		D_ENCRYPT(r,l,18); /*  10 */
-		D_ENCRYPT(l,r,20); /*  11 */
-		D_ENCRYPT(r,l,22); /*  12 */
-		D_ENCRYPT(l,r,24); /*  13 */
-		D_ENCRYPT(r,l,26); /*  14 */
-		D_ENCRYPT(l,r,28); /*  15 */
-		D_ENCRYPT(r,l,30); /*  16 */
+                D_ENCRYPT(l,r, 0); /*  1 */
+                D_ENCRYPT(r,l, 2); /*  2 */
+                D_ENCRYPT(l,r, 4); /*  3 */
+                D_ENCRYPT(r,l, 6); /*  4 */
+                D_ENCRYPT(l,r, 8); /*  5 */
+                D_ENCRYPT(r,l,10); /*  6 */
+                D_ENCRYPT(l,r,12); /*  7 */
+                D_ENCRYPT(r,l,14); /*  8 */
+                D_ENCRYPT(l,r,16); /*  9 */
+                D_ENCRYPT(r,l,18); /*  10 */
+                D_ENCRYPT(l,r,20); /*  11 */
+                D_ENCRYPT(r,l,22); /*  12 */
+                D_ENCRYPT(l,r,24); /*  13 */
+                D_ENCRYPT(r,l,26); /*  14 */
+                D_ENCRYPT(l,r,28); /*  15 */
+                D_ENCRYPT(r,l,30); /*  16 */
 #else
-		for (i=0; i<32; i+=8)
-			{
-			D_ENCRYPT(l,r,i+0); /*  1 */
-			D_ENCRYPT(r,l,i+2); /*  2 */
-			D_ENCRYPT(l,r,i+4); /*  3 */
-			D_ENCRYPT(r,l,i+6); /*  4 */
-			}
-#endif
-		}
-	else
-		{
+                for (i=0; i<32; i+=8)
+                        {
+                        D_ENCRYPT(l,r,i+0); /*  1 */
+                        D_ENCRYPT(r,l,i+2); /*  2 */
+                        D_ENCRYPT(l,r,i+4); /*  3 */
+                        D_ENCRYPT(r,l,i+6); /*  4 */
+                        }
+#endif
+                }
+        else
+                {
 #ifdef DES_UNROLL
-		D_ENCRYPT(l,r,30); /* 16 */
-		D_ENCRYPT(r,l,28); /* 15 */
-		D_ENCRYPT(l,r,26); /* 14 */
-		D_ENCRYPT(r,l,24); /* 13 */
-		D_ENCRYPT(l,r,22); /* 12 */
-		D_ENCRYPT(r,l,20); /* 11 */
-		D_ENCRYPT(l,r,18); /* 10 */
-		D_ENCRYPT(r,l,16); /*  9 */
-		D_ENCRYPT(l,r,14); /*  8 */
-		D_ENCRYPT(r,l,12); /*  7 */
-		D_ENCRYPT(l,r,10); /*  6 */
-		D_ENCRYPT(r,l, 8); /*  5 */
-		D_ENCRYPT(l,r, 6); /*  4 */
-		D_ENCRYPT(r,l, 4); /*  3 */
-		D_ENCRYPT(l,r, 2); /*  2 */
-		D_ENCRYPT(r,l, 0); /*  1 */
+                D_ENCRYPT(l,r,30); /* 16 */
+                D_ENCRYPT(r,l,28); /* 15 */
+                D_ENCRYPT(l,r,26); /* 14 */
+                D_ENCRYPT(r,l,24); /* 13 */
+                D_ENCRYPT(l,r,22); /* 12 */
+                D_ENCRYPT(r,l,20); /* 11 */
+                D_ENCRYPT(l,r,18); /* 10 */
+                D_ENCRYPT(r,l,16); /*  9 */
+                D_ENCRYPT(l,r,14); /*  8 */
+                D_ENCRYPT(r,l,12); /*  7 */
+                D_ENCRYPT(l,r,10); /*  6 */
+                D_ENCRYPT(r,l, 8); /*  5 */
+                D_ENCRYPT(l,r, 6); /*  4 */
+                D_ENCRYPT(r,l, 4); /*  3 */
+                D_ENCRYPT(l,r, 2); /*  2 */
+                D_ENCRYPT(r,l, 0); /*  1 */
 #else
-		for (i=30; i>0; i-=8)
-			{
-			D_ENCRYPT(l,r,i-0); /* 16 */
-			D_ENCRYPT(r,l,i-2); /* 15 */
-			D_ENCRYPT(l,r,i-4); /* 14 */
-			D_ENCRYPT(r,l,i-6); /* 13 */
-			}
-#endif
-		}
-
-	/* rotate and clear the top bits on machines with 8byte longs */
-	l=ROTATE(l,3)&0xffffffffL;
-	r=ROTATE(r,3)&0xffffffffL;
-
-	FP(r,l);
-	data[0]=l;
-	data[1]=r;
-	l=r=t=u=0;
-	}
+                for (i=30; i>0; i-=8)
+                        {
+                        D_ENCRYPT(l,r,i-0); /* 16 */
+                        D_ENCRYPT(r,l,i-2); /* 15 */
+                        D_ENCRYPT(l,r,i-4); /* 14 */
+                        D_ENCRYPT(r,l,i-6); /* 13 */
+                        }
+#endif
+                }
+
+        /* rotate and clear the top bits on machines with 8byte longs */
+        l=ROTATE(l,3)&0xffffffffL;
+        r=ROTATE(r,3)&0xffffffffL;
+
+        FP(r,l);
+        data[0]=l;
+        data[1]=r;
+        l=r=t=u=0;
+        }
 
 void DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc)
-	{
-	register DES_LONG l,r,t,u;
+        {
+        register DES_LONG l,r,t,u;
 #ifdef DES_PTR
-	register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
+        register const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;
 #endif
 #ifndef DES_UNROLL
-	register int i;
+        register int i;
 #endif
-	register DES_LONG *s;
+        register DES_LONG *s;
 
-	r=data[0];
-	l=data[1];
+        r=data[0];
+        l=data[1];
 
-	/* Things have been modified so that the initial rotate is
-	 * done outside the loop.  This required the
-	 * DES_SPtrans values in sp.h to be rotated 1 bit to the right.
-	 * One perl script later and things have a 5% speed up on a sparc2.
-	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
-	 * for pointing this out. */
-	/* clear the top bits on machines with 8byte longs */
-	r=ROTATE(r,29)&0xffffffffL;
-	l=ROTATE(l,29)&0xffffffffL;
-
-	s=ks->ks->deslong;
-	/* I don't know if it is worth the effort of loop unrolling the
-	 * inner loop */
-	if (enc)
-		{
+        /* Things have been modified so that the initial rotate is
+         * done outside the loop.  This required the
+         * DES_SPtrans values in sp.h to be rotated 1 bit to the right.
+         * One perl script later and things have a 5% speed up on a sparc2.
+         * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
+         * for pointing this out. */
+        /* clear the top bits on machines with 8byte longs */
+        r=ROTATE(r,29)&0xffffffffL;
+        l=ROTATE(l,29)&0xffffffffL;
+
+        s=ks->ks->deslong;
+        /* I don't know if it is worth the effort of loop unrolling the
+         * inner loop */
+        if (enc)
+                {
 #ifdef DES_UNROLL
-		D_ENCRYPT(l,r, 0); /*  1 */
-		D_ENCRYPT(r,l, 2); /*  2 */
-		D_ENCRYPT(l,r, 4); /*  3 */
-		D_ENCRYPT(r,l, 6); /*  4 */
-		D_ENCRYPT(l,r, 8); /*  5 */
-		D_ENCRYPT(r,l,10); /*  6 */
-		D_ENCRYPT(l,r,12); /*  7 */
-		D_ENCRYPT(r,l,14); /*  8 */
-		D_ENCRYPT(l,r,16); /*  9 */
-		D_ENCRYPT(r,l,18); /*  10 */
-		D_ENCRYPT(l,r,20); /*  11 */
-		D_ENCRYPT(r,l,22); /*  12 */
-		D_ENCRYPT(l,r,24); /*  13 */
-		D_ENCRYPT(r,l,26); /*  14 */
-		D_ENCRYPT(l,r,28); /*  15 */
-		D_ENCRYPT(r,l,30); /*  16 */
+                D_ENCRYPT(l,r, 0); /*  1 */
+                D_ENCRYPT(r,l, 2); /*  2 */
+                D_ENCRYPT(l,r, 4); /*  3 */
+                D_ENCRYPT(r,l, 6); /*  4 */
+                D_ENCRYPT(l,r, 8); /*  5 */
+                D_ENCRYPT(r,l,10); /*  6 */
+                D_ENCRYPT(l,r,12); /*  7 */
+                D_ENCRYPT(r,l,14); /*  8 */
+                D_ENCRYPT(l,r,16); /*  9 */
+                D_ENCRYPT(r,l,18); /*  10 */
+                D_ENCRYPT(l,r,20); /*  11 */
+                D_ENCRYPT(r,l,22); /*  12 */
+                D_ENCRYPT(l,r,24); /*  13 */
+                D_ENCRYPT(r,l,26); /*  14 */
+                D_ENCRYPT(l,r,28); /*  15 */
+                D_ENCRYPT(r,l,30); /*  16 */
 #else
-		for (i=0; i<32; i+=8)
-			{
-			D_ENCRYPT(l,r,i+0); /*  1 */
-			D_ENCRYPT(r,l,i+2); /*  2 */
-			D_ENCRYPT(l,r,i+4); /*  3 */
-			D_ENCRYPT(r,l,i+6); /*  4 */
-			}
-#endif
-		}
-	else
-		{
+                for (i=0; i<32; i+=8)
+                        {
+                        D_ENCRYPT(l,r,i+0); /*  1 */
+                        D_ENCRYPT(r,l,i+2); /*  2 */
+                        D_ENCRYPT(l,r,i+4); /*  3 */
+                        D_ENCRYPT(r,l,i+6); /*  4 */
+                        }
+#endif
+                }
+        else
+                {
 #ifdef DES_UNROLL
-		D_ENCRYPT(l,r,30); /* 16 */
-		D_ENCRYPT(r,l,28); /* 15 */
-		D_ENCRYPT(l,r,26); /* 14 */
-		D_ENCRYPT(r,l,24); /* 13 */
-		D_ENCRYPT(l,r,22); /* 12 */
-		D_ENCRYPT(r,l,20); /* 11 */
-		D_ENCRYPT(l,r,18); /* 10 */
-		D_ENCRYPT(r,l,16); /*  9 */
-		D_ENCRYPT(l,r,14); /*  8 */
-		D_ENCRYPT(r,l,12); /*  7 */
-		D_ENCRYPT(l,r,10); /*  6 */
-		D_ENCRYPT(r,l, 8); /*  5 */
-		D_ENCRYPT(l,r, 6); /*  4 */
-		D_ENCRYPT(r,l, 4); /*  3 */
-		D_ENCRYPT(l,r, 2); /*  2 */
-		D_ENCRYPT(r,l, 0); /*  1 */
+                D_ENCRYPT(l,r,30); /* 16 */
+                D_ENCRYPT(r,l,28); /* 15 */
+                D_ENCRYPT(l,r,26); /* 14 */
+                D_ENCRYPT(r,l,24); /* 13 */
+                D_ENCRYPT(l,r,22); /* 12 */
+                D_ENCRYPT(r,l,20); /* 11 */
+                D_ENCRYPT(l,r,18); /* 10 */
+                D_ENCRYPT(r,l,16); /*  9 */
+                D_ENCRYPT(l,r,14); /*  8 */
+                D_ENCRYPT(r,l,12); /*  7 */
+                D_ENCRYPT(l,r,10); /*  6 */
+                D_ENCRYPT(r,l, 8); /*  5 */
+                D_ENCRYPT(l,r, 6); /*  4 */
+                D_ENCRYPT(r,l, 4); /*  3 */
+                D_ENCRYPT(l,r, 2); /*  2 */
+                D_ENCRYPT(r,l, 0); /*  1 */
 #else
-		for (i=30; i>0; i-=8)
-			{
-			D_ENCRYPT(l,r,i-0); /* 16 */
-			D_ENCRYPT(r,l,i-2); /* 15 */
-			D_ENCRYPT(l,r,i-4); /* 14 */
-			D_ENCRYPT(r,l,i-6); /* 13 */
-			}
-#endif
-		}
-	/* rotate and clear the top bits on machines with 8byte longs */
-	data[0]=ROTATE(l,3)&0xffffffffL;
-	data[1]=ROTATE(r,3)&0xffffffffL;
-	l=r=t=u=0;
-	}
+                for (i=30; i>0; i-=8)
+                        {
+                        D_ENCRYPT(l,r,i-0); /* 16 */
+                        D_ENCRYPT(r,l,i-2); /* 15 */
+                        D_ENCRYPT(l,r,i-4); /* 14 */
+                        D_ENCRYPT(r,l,i-6); /* 13 */
+                        }
+#endif
+                }
+        /* rotate and clear the top bits on machines with 8byte longs */
+        data[0]=ROTATE(l,3)&0xffffffffL;
+        data[1]=ROTATE(r,3)&0xffffffffL;
+        l=r=t=u=0;
+        }
 
 void DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
-		  DES_key_schedule *ks2, DES_key_schedule *ks3)
-	{
-	register DES_LONG l,r;
-
-	l=data[0];
-	r=data[1];
-	IP(l,r);
-	data[0]=l;
-	data[1]=r;
-	DES_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);
-	DES_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);
-	DES_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);
-	l=data[0];
-	r=data[1];
-	FP(r,l);
-	data[0]=l;
-	data[1]=r;
-	}
+                  DES_key_schedule *ks2, DES_key_schedule *ks3)
+        {
+        register DES_LONG l,r;
+
+        l=data[0];
+        r=data[1];
+        IP(l,r);
+        data[0]=l;
+        data[1]=r;
+        DES_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);
+        DES_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);
+        DES_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);
+        l=data[0];
+        r=data[1];
+        FP(r,l);
+        data[0]=l;
+        data[1]=r;
+        }
 
 void DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
-		  DES_key_schedule *ks2, DES_key_schedule *ks3)
-	{
-	register DES_LONG l,r;
-
-	l=data[0];
-	r=data[1];
-	IP(l,r);
-	data[0]=l;
-	data[1]=r;
-	DES_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);
-	DES_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);
-	DES_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);
-	l=data[0];
-	r=data[1];
-	FP(r,l);
-	data[0]=l;
-	data[1]=r;
-	}
+                  DES_key_schedule *ks2, DES_key_schedule *ks3)
+        {
+        register DES_LONG l,r;
+
+        l=data[0];
+        r=data[1];
+        IP(l,r);
+        data[0]=l;
+        data[1]=r;
+        DES_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);
+        DES_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);
+        DES_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);
+        l=data[0];
+        r=data[1];
+        FP(r,l);
+        data[0]=l;
+        data[1]=r;
+        }
 
 #ifndef DES_DEFAULT_OPTIONS
 
@@ -295,117 +297,185 @@
 #include "ncbc_enc.c" /* DES_ncbc_encrypt */
 
 void DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,
-			  long length, DES_key_schedule *ks1,
-			  DES_key_schedule *ks2, DES_key_schedule *ks3,
-			  DES_cblock *ivec, int enc)
-	{
-	register DES_LONG tin0,tin1;
-	register DES_LONG tout0,tout1,xor0,xor1;
-	register const unsigned char *in;
-	unsigned char *out;
-	register long l=length;
-	DES_LONG tin[2];
-	unsigned char *iv;
-
-	in=input;
-	out=output;
-	iv = &(*ivec)[0];
-
-	if (enc)
-		{
-		c2l(iv,tout0);
-		c2l(iv,tout1);
-		for (l-=8; l>=0; l-=8)
-			{
-			c2l(in,tin0);
-			c2l(in,tin1);
-			tin0^=tout0;
-			tin1^=tout1;
-
-			tin[0]=tin0;
-			tin[1]=tin1;
-			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
-			tout0=tin[0];
-			tout1=tin[1];
-
-			l2c(tout0,out);
-			l2c(tout1,out);
-			}
-		if (l != -8)
-			{
-			c2ln(in,tin0,tin1,l+8);
-			tin0^=tout0;
-			tin1^=tout1;
-
-			tin[0]=tin0;
-			tin[1]=tin1;
-			DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
-			tout0=tin[0];
-			tout1=tin[1];
-
-			l2c(tout0,out);
-			l2c(tout1,out);
-			}
-		iv = &(*ivec)[0];
-		l2c(tout0,iv);
-		l2c(tout1,iv);
-		}
-	else
-		{
-		register DES_LONG t0,t1;
-
-		c2l(iv,xor0);
-		c2l(iv,xor1);
-		for (l-=8; l>=0; l-=8)
-			{
-			c2l(in,tin0);
-			c2l(in,tin1);
-
-			t0=tin0;
-			t1=tin1;
-
-			tin[0]=tin0;
-			tin[1]=tin1;
-			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
-			tout0=tin[0];
-			tout1=tin[1];
-
-			tout0^=xor0;
-			tout1^=xor1;
-			l2c(tout0,out);
-			l2c(tout1,out);
-			xor0=t0;
-			xor1=t1;
-			}
-		if (l != -8)
-			{
-			c2l(in,tin0);
-			c2l(in,tin1);
-			
-			t0=tin0;
-			t1=tin1;
-
-			tin[0]=tin0;
-			tin[1]=tin1;
-			DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
-			tout0=tin[0];
-			tout1=tin[1];
-		
-			tout0^=xor0;
-			tout1^=xor1;
-			l2cn(tout0,tout1,out,l+8);
-			xor0=t0;
-			xor1=t1;
-			}
-
-		iv = &(*ivec)[0];
-		l2c(xor0,iv);
-		l2c(xor1,iv);
-		}
-	tin0=tin1=tout0=tout1=xor0=xor1=0;
-	tin[0]=tin[1]=0;
-	}
-
+                          long length, DES_key_schedule *ks1,
+                          DES_key_schedule *ks2, DES_key_schedule *ks3,
+                          DES_cblock *ivec, int enc)
+{
+#ifdef CAVIUM_SSL
+        Uint32 req_id;
+        unsigned char *iv;
+        unsigned char key[40];
+        Uint64 tmp_ctx = 0;
+        unsigned char *iiv;
+        int ret;
+        int driver_ready = -1;
+        unsigned char saved_iv[24];
+#ifdef CAVIUM_FIPS
+        Uint64 hWrapper = 0;
+        Uint64 hkey_handle = 0;
+        Uint8 enc_key_out[50];
+        Uint8 local_iv[8]={0x67, 0xC6, 0x69, 0x73, 0x51, 0xFF, 0x4A, 0xEC };
+        int i;
+#endif
+        DES_set_odd_parity((DES_cblock *)ks1->key);
+        DES_set_odd_parity((DES_cblock *)ks2->key);
+        DES_set_odd_parity((DES_cblock *)ks3->key);
+        memcpy(&key[0],ks1->key,8);
+        memcpy(&key[8],ks2->key,8);
+        memcpy(&key[16],ks3->key,8);
+        iv=&(*ivec[0]);
+
+                if(enc){
+                        ret = Csp1Encrypt3Des( CAVIUM_BLOCKING,
+//                                                tmp_ctx,
+												 NULL,                    
+                                                CAVIUM_NO_UPDATE,
+                                                length,
+                                                (Uint8 *)input,
+                                                (Uint8 *)output,
+                                                (Uint8 *)iv,
+                                                (Uint8 *)key,
+#ifdef CAVIUM_MULTICARD_API
+                                                &req_id,CAVIUM_DEV_ID
+#else
+                                                &req_id
+#endif
+                                               );
+                        iiv=(Uint8 *) ((Uint8 *)output+length-8);
+                }else
+                {
+                        iiv= (Uint8 *)((Uint8 *)input+length-8);
+                        memcpy(saved_iv,iiv,8);
+                        length=(length+7)&~(0x7);
+                        ret = Csp1Decrypt3Des( CAVIUM_BLOCKING,
+                                                tmp_ctx,
+                                                CAVIUM_NO_UPDATE,
+                                                length,
+                                                (Uint8 *)input,
+                                                (Uint8 *)output,
+                                                (Uint8 *)iv,
+                                                (Uint8 *)key,
+#ifdef CAVIUM_MULTICARD_API
+                                                &req_id,CAVIUM_DEV_ID
+#else
+                                                &req_id
+#endif
+                                               );
+                        iiv=saved_iv;
+                }
+                iv = &(*ivec)[0];
+                memcpy(iv,iiv,8);
+
+                return;
+#endif /*CAVIUM_SSL*/
+{
+        register DES_LONG tin0,tin1;
+        register DES_LONG tout0,tout1,xor0,xor1;
+        register const unsigned char *in;
+        unsigned char *out;
+        register long l=length;
+        DES_LONG tin[2];
+        unsigned char *iv;
+
+        in=input;
+        out=output;
+        iv = &(*ivec)[0];
+
+        if (enc)
+                {
+                c2l(iv,tout0);
+                c2l(iv,tout1);
+                for (l-=8; l>=0; l-=8)
+                        {
+                        c2l(in,tin0);
+                        c2l(in,tin1);
+                        tin0^=tout0;
+                        tin1^=tout1;
+
+                        tin[0]=tin0;
+                        tin[1]=tin1;
+                        DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+                        tout0=tin[0];
+                        tout1=tin[1];
+
+                        l2c(tout0,out);
+                        l2c(tout1,out);
+                        }
+                if (l != -8)
+                        {
+                        c2ln(in,tin0,tin1,l+8);
+                        tin0^=tout0;
+                        tin1^=tout1;
+
+                        tin[0]=tin0;
+                        tin[1]=tin1;
+                        DES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+                        tout0=tin[0];
+                        tout1=tin[1];
+
+                        l2c(tout0,out);
+                        l2c(tout1,out);
+                        }
+                iv = &(*ivec)[0];
+                l2c(tout0,iv);
+                l2c(tout1,iv);
+                }
+        else
+                {
+                register DES_LONG t0,t1;
+
+                c2l(iv,xor0);
+                c2l(iv,xor1);
+                for (l-=8; l>=0; l-=8)
+                        {
+                        c2l(in,tin0);
+                        c2l(in,tin1);
+
+                        t0=tin0;
+                        t1=tin1;
+
+                        tin[0]=tin0;
+                        tin[1]=tin1;
+                        DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+                        tout0=tin[0];
+                        tout1=tin[1];
+
+                        tout0^=xor0;
+                        tout1^=xor1;
+                        l2c(tout0,out);
+                        l2c(tout1,out);
+                        xor0=t0;
+                        xor1=t1;
+                        }
+                if (l != -8)
+                        {
+                        c2l(in,tin0);
+                        c2l(in,tin1);
+
+                        t0=tin0;
+                        t1=tin1;
+
+                        tin[0]=tin0;
+                        tin[1]=tin1;
+                        DES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);
+                        tout0=tin[0];
+                        tout1=tin[1];
+
+                        tout0^=xor0;
+                        tout1^=xor1;
+                        l2cn(tout0,tout1,out,l+8);
+                        xor0=t0;
+                        xor1=t1;
+                        }
+
+                iv = &(*ivec)[0];
+                l2c(xor0,iv);
+                l2c(xor1,iv);
+                }
+        tin0=tin1=tout0=tout1=xor0=xor1=0;
+        tin[0]=tin[1]=0;
+}
+}
 #endif
 
 #endif /* DES_DEFAULT_OPTIONS */
diff -Naur openssl-0.9.8j/crypto/des/des.h TurboSSL-0.9.8j/crypto/des/des.h
--- openssl-0.9.8j/crypto/des/des.h	2008-05-20 13:50:12.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/des/des.h	2010-05-31 12:13:09.000000000 +0200
@@ -89,6 +89,9 @@
 	 * 8 byte longs */
 	DES_LONG deslong[2];
 	} ks[16];
+#ifdef CAVIUM_SSL
+	unsigned char key[8];
+#endif
     } DES_key_schedule;
 
 #ifndef OPENSSL_DISABLE_OLD_DES_SUPPORT
diff -Naur openssl-0.9.8j/crypto/des/destest.c TurboSSL-0.9.8j/crypto/des/destest.c
--- openssl-0.9.8j/crypto/des/destest.c	2005-06-23 23:53:52.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/des/destest.c	2010-05-31 12:13:09.000000000 +0200
@@ -60,6 +60,14 @@
 #include <stdlib.h>
 
 #include <openssl/e_os2.h>
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
+
 #if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16) || defined(OPENSSL_SYS_WINDOWS)
 #ifndef OPENSSL_SYS_MSDOS
 #define OPENSSL_SYS_MSDOS
@@ -351,6 +359,32 @@
 #endif
 	int num;
 	char *str;
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+	int driver_open = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+	if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+	{
+		Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID);
+		driver_open = 1;
+	}
+#else
+	if(CSP1_driver_handle == -1)
+	{
+		Csp1Initialize(CAVIUM_DIRECT);
+		driver_open = 1;
+	}
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+	if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+	if(Cfm1Initialize(500,DIRECT))
+#endif
+		;/*return 0;*/
+#endif
+#endif
 
 #ifndef OPENSSL_NO_DESCBCM
 	printf("Doing cbcm\n");
@@ -821,6 +855,20 @@
 		printf("fast crypt error, %s should be yA1Rp/1hZXIJk\n",str);
 		err=1;
 		}
+#ifdef CAVIUM_SSL
+
+#ifndef CAVIUM_FIPS
+	if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+		Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+	Csp1Shutdown();
+#endif
+#else
+	Cfm1Shutdown();
+#endif
+#endif
+
 #ifdef OPENSSL_SYS_NETWARE
     if (err) printf("ERROR: %d\n", err);
 #endif
diff -Naur openssl-0.9.8j/crypto/des/Makefile.save TurboSSL-0.9.8j/crypto/des/Makefile.save
--- openssl-0.9.8j/crypto/des/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/des/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,121 @@
+#
+# OpenSSL/crypto/des/Makefile
+#
+
+DIR=	des
+TOP=	../..
+CC=	cc
+CPP=	$(CC) -E
+INCLUDES=-I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+RANLIB=		ranlib
+DES_ENC=	des_enc.o fcrypt_b.o
+# or use
+#DES_ENC=	dx86-elf.o yx86-elf.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=destest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	des_lib.c cbc_cksm.c cbc_enc.c  cfb64enc.c cfb_enc.c  \
+	ecb3_enc.c ecb_enc.c  enc_read.c enc_writ.c \
+	fcrypt.c ofb64enc.c ofb_enc.c  pcbc_enc.c \
+	qud_cksm.c rand_key.c rpc_enc.c  set_key.c  \
+	des_enc.c fcrypt_b.c \
+	xcbc_enc.c \
+	str2key.c  cfb64ede.c ofb64ede.c ede_cbcm_enc.c des_old.c des_old2.c \
+	read2pwd.c
+
+LIBOBJ= des_lib.o set_key.o  ecb_enc.o  cbc_enc.o \
+	ecb3_enc.o cfb64enc.o cfb64ede.o cfb_enc.o  ofb64ede.o \
+	enc_read.o enc_writ.o ofb64enc.o \
+	ofb_enc.o  str2key.o  pcbc_enc.o qud_cksm.o rand_key.o \
+	${DES_ENC} \
+	fcrypt.o xcbc_enc.o rpc_enc.o  cbc_cksm.o \
+	ede_cbcm_enc.o des_old.o des_old2.o read2pwd.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= des.h des_old.h
+HEADER=	des_locl.h rpc_des.h spr.h des_ver.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+des: des.o cbc3_enc.o lib
+	$(CC) $(CFLAGS) -o des des.o cbc3_enc.o $(LIB)
+
+des_enc-sparc.S:	asm/des_enc.m4
+	m4 -B 8192 asm/des_enc.m4 > des_enc-sparc.S
+
+# ELF
+dx86-elf.s:	asm/des-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) des-586.pl elf $(CFLAGS) > ../$@)
+yx86-elf.s:	asm/crypt586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) crypt586.pl elf $(CFLAGS) > ../$@)
+# COFF
+dx86-cof.s: asm/des-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) des-586.pl coff $(CFLAGS) > ../$@)
+yx86-cof.s: asm/crypt586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) crypt586.pl coff $(CFLAGS) > ../$@)
+# a.out
+dx86-out.s: asm/des-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) des-586.pl a.out $(CFLAGS) > ../$@)
+yx86-out.s: asm/crypt586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
+	(cd asm; $(PERL) crypt586.pl a.out $(CFLAGS) > ../$@)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+# We need to use force because 'install' matches 'INSTALL' on case
+# insensitive systems
+FRC.install:
+install: FRC.install
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj des lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/des/ncbc_enc.c TurboSSL-0.9.8j/crypto/des/ncbc_enc.c
--- openssl-0.9.8j/crypto/des/ncbc_enc.c	2001-10-24 23:20:27.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/des/ncbc_enc.c	2010-05-31 12:14:39.000000000 +0200
@@ -10,21 +10,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -39,10 +39,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -54,7 +54,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -63,86 +63,165 @@
 
 #include "des_locl.h"
 
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#include "luna_api.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#endif
+
+#if defined(CAVIUM_SSL) && !defined(CAVIUM_FIPS)
+static int pkp_device_present=1;
+#endif
+
 #ifdef CBC_ENC_C__DONT_UPDATE_IV
 void DES_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,
-		     DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+                     DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
 #else
 void DES_ncbc_encrypt(const unsigned char *in, unsigned char *out, long length,
-		     DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+                     DES_key_schedule *_schedule, DES_cblock *ivec, int enc)
+#endif
+        {
+#ifdef CAVIUM_SSL
+                Uint32 req_id;
+                unsigned char *iv;
+                unsigned char key[50];
+                unsigned char *iiv;
+                unsigned char saved_iv[24];
+                int ret;
+                int driver_ready=-1;
+#ifndef MC2
+                Uint64 tmp_ctx = 0;
+#endif
+                int driver_open = 0;
+                DES_set_odd_parity((DES_cblock *)_schedule->key);
+                memcpy(&key[0],_schedule->key,8);
+                memcpy(&key[8],_schedule->key,8);
+                memcpy(&key[16],_schedule->key,8);
+                iv = &(*ivec)[0];
+
+                if(enc){
+                        ret = Csp1Encrypt3Des( CAVIUM_BLOCKING,
+                                                0, //(Uint64)NULL,
+                                                CAVIUM_NO_UPDATE,
+                                                length,
+                                                (Uint8 *)in,
+                                                (Uint8 *)out,
+                                                (Uint8 *)iv,
+                                                (Uint8 *)key,
+#ifdef CAVIUM_MULTICARD_API
+                                                &req_id,CAVIUM_DEV_ID
+#else
+                                                &req_id
 #endif
-	{
-	register DES_LONG tin0,tin1;
-	register DES_LONG tout0,tout1,xor0,xor1;
-	register long l=length;
-	DES_LONG tin[2];
-	unsigned char *iv;
-
-	iv = &(*ivec)[0];
-
-	if (enc)
-		{
-		c2l(iv,tout0);
-		c2l(iv,tout1);
-		for (l-=8; l>=0; l-=8)
-			{
-			c2l(in,tin0);
-			c2l(in,tin1);
-			tin0^=tout0; tin[0]=tin0;
-			tin1^=tout1; tin[1]=tin1;
-			DES_encrypt1((DES_LONG *)tin,_schedule,DES_ENCRYPT);
-			tout0=tin[0]; l2c(tout0,out);
-			tout1=tin[1]; l2c(tout1,out);
-			}
-		if (l != -8)
-			{
-			c2ln(in,tin0,tin1,l+8);
-			tin0^=tout0; tin[0]=tin0;
-			tin1^=tout1; tin[1]=tin1;
-			DES_encrypt1((DES_LONG *)tin,_schedule,DES_ENCRYPT);
-			tout0=tin[0]; l2c(tout0,out);
-			tout1=tin[1]; l2c(tout1,out);
-			}
+                                              );
+                iiv=(Uint8 *) ((Uint8 *)out+length-8);
+                }else
+                {
+
+                        iiv= (Uint8 *)((Uint8 *)in+length-8);
+                        memcpy(saved_iv,iiv,8);
+                        length=(length+7)&~(0x7);
+                        ret = Csp1Decrypt3Des( CAVIUM_BLOCKING,
+                                                0, //(Uint64)NULL,
+                                                CAVIUM_NO_UPDATE,
+                                                length,
+                                                (Uint8 *)in,
+                                                (Uint8 *)out,
+                                                (Uint8 *)iv,
+                                                (Uint8 *)key,
+#ifdef CAVIUM_MULTICARD_API
+                                                &req_id,CAVIUM_DEV_ID
+#else
+                                                &req_id
+#endif
+                                              );
+                        iiv=saved_iv;
+                }
+                iv = &(*ivec)[0];
+               memcpy(iv,iiv,8);
+        return ;
+
+#endif /*CAVIUM_SSL*/
+
+{
+        register DES_LONG tin0,tin1;
+        register DES_LONG tout0,tout1,xor0,xor1;
+        register long l=length;
+        DES_LONG tin[2];
+        unsigned char *iv;
+
+        iv = &(*ivec)[0];
+
+        if (enc)
+                {
+                c2l(iv,tout0);
+                c2l(iv,tout1);
+                for (l-=8; l>=0; l-=8)
+                        {
+                        c2l(in,tin0);
+                        c2l(in,tin1);
+                        tin0^=tout0; tin[0]=tin0;
+                        tin1^=tout1; tin[1]=tin1;
+                        DES_encrypt1((DES_LONG *)tin,_schedule,DES_ENCRYPT);
+                        tout0=tin[0]; l2c(tout0,out);
+                        tout1=tin[1]; l2c(tout1,out);
+                        }
+                if (l != -8)
+                        {
+                        c2ln(in,tin0,tin1,l+8);
+                        tin0^=tout0; tin[0]=tin0;
+                        tin1^=tout1; tin[1]=tin1;
+                        DES_encrypt1((DES_LONG *)tin,_schedule,DES_ENCRYPT);
+                        tout0=tin[0]; l2c(tout0,out);
+                        tout1=tin[1]; l2c(tout1,out);
+                        }
 #ifndef CBC_ENC_C__DONT_UPDATE_IV
-		iv = &(*ivec)[0];
-		l2c(tout0,iv);
-		l2c(tout1,iv);
-#endif
-		}
-	else
-		{
-		c2l(iv,xor0);
-		c2l(iv,xor1);
-		for (l-=8; l>=0; l-=8)
-			{
-			c2l(in,tin0); tin[0]=tin0;
-			c2l(in,tin1); tin[1]=tin1;
-			DES_encrypt1((DES_LONG *)tin,_schedule,DES_DECRYPT);
-			tout0=tin[0]^xor0;
-			tout1=tin[1]^xor1;
-			l2c(tout0,out);
-			l2c(tout1,out);
-			xor0=tin0;
-			xor1=tin1;
-			}
-		if (l != -8)
-			{
-			c2l(in,tin0); tin[0]=tin0;
-			c2l(in,tin1); tin[1]=tin1;
-			DES_encrypt1((DES_LONG *)tin,_schedule,DES_DECRYPT);
-			tout0=tin[0]^xor0;
-			tout1=tin[1]^xor1;
-			l2cn(tout0,tout1,out,l+8);
+                iv = &(*ivec)[0];
+                l2c(tout0,iv);
+                l2c(tout1,iv);
+#endif
+                }
+        else
+                {
+                c2l(iv,xor0);
+                c2l(iv,xor1);
+                for (l-=8; l>=0; l-=8)
+                        {
+                        c2l(in,tin0); tin[0]=tin0;
+                        c2l(in,tin1); tin[1]=tin1;
+                        DES_encrypt1((DES_LONG *)tin,_schedule,DES_DECRYPT);
+                        tout0=tin[0]^xor0;
+                        tout1=tin[1]^xor1;
+                        l2c(tout0,out);
+                        l2c(tout1,out);
+                        xor0=tin0;
+                        xor1=tin1;
+                        }
+                if (l != -8)
+                        {
+                        c2l(in,tin0); tin[0]=tin0;
+                        c2l(in,tin1); tin[1]=tin1;
+                        DES_encrypt1((DES_LONG *)tin,_schedule,DES_DECRYPT);
+                        tout0=tin[0]^xor0;
+                        tout1=tin[1]^xor1;
+                        l2cn(tout0,tout1,out,l+8);
+#ifndef CBC_ENC_C__DONT_UPDATE_IV
+                        xor0=tin0;
+                        xor1=tin1;
+#endif
+                        }
 #ifndef CBC_ENC_C__DONT_UPDATE_IV
-			xor0=tin0;
-			xor1=tin1;
+                iv = &(*ivec)[0];
+                l2c(xor0,iv);
+                l2c(xor1,iv);
 #endif
-			}
-#ifndef CBC_ENC_C__DONT_UPDATE_IV 
-		iv = &(*ivec)[0];
-		l2c(xor0,iv);
-		l2c(xor1,iv);
-#endif
-		}
-	tin0=tin1=tout0=tout1=xor0=xor1=0;
-	tin[0]=tin[1]=0;
-	}
+                }
+        tin0=tin1=tout0=tout1=xor0=xor1=0;
+        tin[0]=tin[1]=0;
+} /*software DES*/
+}
diff -Naur openssl-0.9.8j/crypto/des/set_key.c TurboSSL-0.9.8j/crypto/des/set_key.c
--- openssl-0.9.8j/crypto/des/set_key.c	2008-09-21 13:40:33.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/des/set_key.c	2010-05-31 12:13:09.000000000 +0200
@@ -345,6 +345,11 @@
 	register const unsigned char *in;
 	register DES_LONG *k;
 	register int i;
+#ifdef CAVIUM_SSL
+	unsigned char *skey;
+	skey=(unsigned char *)key;
+	memcpy(schedule->key,skey,8);
+#endif
 
 #ifdef OPENBSD_DEV_CRYPTO
 	memcpy(schedule->key,key,sizeof schedule->key);
diff -Naur openssl-0.9.8j/crypto/dh/Makefile.save TurboSSL-0.9.8j/crypto/dh/Makefile.save
--- openssl-0.9.8j/crypto/dh/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/dh/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/dh/Makefile
+#
+
+DIR=	dh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= dhtest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= dh_asn1.c dh_gen.c dh_key.c dh_lib.c dh_check.c dh_err.c dh_depr.c
+LIBOBJ= dh_asn1.o dh_gen.o dh_key.o dh_lib.o dh_check.o dh_err.o dh_depr.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= dh.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/dsa/dsatest.c TurboSSL-0.9.8j/crypto/dsa/dsatest.c
--- openssl-0.9.8j/crypto/dsa/dsatest.c	2005-07-16 13:13:04.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/dsa/dsatest.c	2010-05-31 12:13:09.000000000 +0200
@@ -75,6 +75,13 @@
 #include <openssl/bio.h>
 #include <openssl/err.h>
 #include <openssl/bn.h>
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 
 #ifdef OPENSSL_NO_DSA
 int main(int argc, char *argv[])
@@ -143,6 +150,32 @@
 	unsigned long h;
 	unsigned char sig[256];
 	unsigned int siglen;
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+        int driver_open = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+        if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        { 
+         if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+	          driver_open=1;
+        }
+#else
+        if(CSP1_driver_handle == -1)
+        { 
+         if(!Csp1Initialize(CAVIUM_DIRECT))
+	          driver_open=1;
+        }
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+         if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+         if(Cfm1Initialize(500,DIRECT))
+#endif
+		;/*return 0; */
+#endif
+#endif
 
 	if (bio_err == NULL)
 		bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
@@ -231,6 +264,19 @@
 		BIO_free(bio_err);
 		bio_err = NULL;
 		}
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+      if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+        Csp1Shutdown();
+#endif
+#else
+        Cfm1Shutdown();
+#endif
+#endif
+
 #ifdef OPENSSL_SYS_NETWARE
     if (!ret) printf("ERROR\n");
 #endif
diff -Naur openssl-0.9.8j/crypto/dsa/Makefile.save TurboSSL-0.9.8j/crypto/dsa/Makefile.save
--- openssl-0.9.8j/crypto/dsa/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/dsa/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,77 @@
+#
+# OpenSSL/crypto/dsa/Makefile
+#
+
+DIR=	dsa
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=dsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= dsa_gen.c dsa_key.c dsa_lib.c dsa_asn1.c dsa_vrf.c dsa_sign.c \
+	dsa_err.c dsa_ossl.c dsa_depr.c dsa_utl.c
+LIBOBJ= dsa_gen.o dsa_key.o dsa_lib.o dsa_asn1.o dsa_vrf.o dsa_sign.o \
+	dsa_err.o dsa_ossl.o dsa_depr.o dsa_utl.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= dsa.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/dso/Makefile.save TurboSSL-0.9.8j/crypto/dso/Makefile.save
--- openssl-0.9.8j/crypto/dso/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/dso/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,77 @@
+#
+# OpenSSL/crypto/dso/Makefile
+#
+
+DIR=	dso
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= dso_dl.c dso_dlfcn.c dso_err.c dso_lib.c dso_null.c \
+	dso_openssl.c dso_win32.c dso_vms.c
+LIBOBJ= dso_dl.o dso_dlfcn.o dso_err.o dso_lib.o dso_null.o \
+	dso_openssl.o dso_win32.o dso_vms.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= dso.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/ec/ec_lcl.h TurboSSL-0.9.8j/crypto/ec/ec_lcl.h
--- openssl-0.9.8j/crypto/ec/ec_lcl.h	2005-05-16 12:10:59.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/ec/ec_lcl.h	2010-05-31 12:13:09.000000000 +0200
@@ -75,6 +75,10 @@
 #include <openssl/obj_mac.h>
 #include <openssl/ec.h>
 #include <openssl/bn.h>
+#if defined(CAVIUM_SSL) && !defined(CAVIUM_FIPS) 
+#include <openssl/cavium_common.h>
+#include <openssl/cavium_ssl.h>
+#endif
 
 #if defined(__SUNPRO_C)
 # if __SUNPRO_C >= 0x520
@@ -194,6 +198,10 @@
 	unsigned char *seed; /* optional seed for parameters (appears in ASN1) */
 	size_t seed_len;
 
+#if defined(CAVIUM_SSL) && defined(MC2)
+	Uint64 cav_ctx;
+#endif
+
 	EC_EXTRA_DATA *extra_data; /* linked list */
 
 	/* The following members are handled by the method functions,
diff -Naur openssl-0.9.8j/crypto/ec/ec_lib.c TurboSSL-0.9.8j/crypto/ec/ec_lib.c
--- openssl-0.9.8j/crypto/ec/ec_lib.c	2006-02-08 20:16:13.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ec/ec_lib.c	2010-05-31 12:13:09.000000000 +0200
@@ -65,9 +65,18 @@
 
 #include <openssl/err.h>
 #include <openssl/opensslv.h>
+#if defined(CAVIUM_SSL) && !defined(CAVIUM_FIPS) 
+#include <openssl/cavium_common.h>
+#include <openssl/cavium_ssl.h>
+#include <openssl/cav_ecc_mul.h>	
+#endif
 
 #include "ec_lcl.h"
 
+#if defined(CAVIUM_SSL) && defined(MC2)
+Uint32 device=0;
+#endif
+
 static const char EC_version[] = "EC" OPENSSL_VERSION_PTEXT;
 
 
@@ -109,7 +118,9 @@
 
 	ret->seed = NULL;
 	ret->seed_len = 0;
-
+#if defined(CAVIUM_SSL) && defined(MC2)
+	ret->cav_ctx=0;
+#endif
 	if (!meth->group_init(ret))
 		{
 		OPENSSL_free(ret);
@@ -124,6 +135,35 @@
 	{
 	if (!group) return;
 
+#if defined(CAVIUM_SSL) && defined(MC2) && defined(PX_ECC)
+    int ret=0;   
+if(device==NPX_DEVICE){
+	Uint64 cid;
+	int driver_ready=-1;
+	cid=Get_Curve_Id(group);
+
+	if(((cid==P256)||(cid==P384)))
+	{
+#ifdef CAVIUM_MULTICARD_API
+	   driver_ready=Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+	   driver_ready=Csp1GetDriverState();
+#endif
+	  if(driver_ready==0)
+	  {
+             ret=         
+#ifdef CAVIUM_MULTICARD_API
+             PX_ECC_FreeContext(&group->cav_ctx,cid,CAVIUM_DEV_ID);
+#else
+             PX_ECC_FreeContext(&group->cav_ctx,cid);
+#endif
+             if(ret)    
+		 printf("\n Context memory freeing is falied");
+			
+	  } 
+	} 
+	}
+#endif
 	if (group->meth->group_finish != 0)
 		group->meth->group_finish(group);
 
@@ -171,6 +211,7 @@
 int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
 	{
 	EC_EXTRA_DATA *d;
+	int ret=0;
 
 	if (dest->meth->group_copy == 0)
 		{
@@ -243,7 +284,38 @@
 		}
 	
 
-	return dest->meth->group_copy(dest, src);
+	ret = dest->meth->group_copy(dest, src);
+
+#if defined(CAVIUM_SSL) && defined(MC2) && defined (PX_ECC)
+if(device==NPX_DEVICE){
+    Uint64 cid;
+    int driver_ready=-1;
+    cid=Get_Curve_Id(dest);
+    dest->cav_ctx=0;
+    if((cid==P256)||(cid==P384))
+    {
+#ifdef CAVIUM_MULTICARD_API
+         driver_ready=Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+         driver_ready=Csp1GetDriverState();
+#endif
+        if(driver_ready==-1)
+        {
+
+#ifdef CAVIUM_MULTICARD_API
+         if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+         if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+             return ret;
+        }  
+
+         if(!Ecc_Alloc_Context(dest,cid))
+		           printf("context allocation is falied");
+	}
+}
+#endif
+    return ret;
 	}
 
 
@@ -337,6 +409,37 @@
 void EC_GROUP_set_curve_name(EC_GROUP *group, int nid)
 	{
 	group->curve_name = nid;
+
+#if defined(CAVIUM_SSL) && defined(MC2) && defined(PX_ECC)
+	Uint64 cid=0;
+	cid=Get_Curve_Id(group);
+	int driver_ready=-1;
+	if(cid==P256||cid==P384)
+	{
+
+#ifdef CAVIUM_MULTICARD_API
+                driver_ready=Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+                driver_ready=Csp1GetDriverState();
+#endif
+             if(driver_ready==-1)
+	     {
+#ifdef CAVIUM_MULTICARD_API
+                  if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+                  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+                          return;
+	 }
+		if(Csp1GetDevType(&device))
+			return ;			
+	
+	if(device==NPX_DEVICE)
+	     if(!Ecc_Alloc_Context(group,cid))	
+			printf("context allocation is falied");
+		 
+	}
+#endif 
 	}
 
 
@@ -1118,6 +1221,27 @@
 int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 	size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)
 	{
+#if defined(CAVIUM_SSL) && defined(MC2) && defined(PX_ECC)
+if(device==NPX_DEVICE){
+	Uint64 cid;
+	int driver_ready=-1;
+	cid=Get_Curve_Id(group);	
+	if((cid==P256)||(cid==P384))
+	{
+#ifdef CAVIUM_MULTICARD_API
+                driver_ready=Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+                driver_ready=Csp1GetDriverState();
+#endif
+		if(driver_ready==0)	
+		{
+			if(num<=1)
+				if(Cav_Ecc_Mul(group,cid,r,scalar,points[0],scalars[0],ctx))				return 1;
+		}
+		printf("driver is not ready continueing in software mode \n");
+	}
+	}	
+#endif	
 	if (group->meth->mul == 0)
 		/* use default */
 		return ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
diff -Naur openssl-0.9.8j/crypto/ec/Makefile.save TurboSSL-0.9.8j/crypto/ec/Makefile.save
--- openssl-0.9.8j/crypto/ec/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ec/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,80 @@
+#
+# crypto/ec/Makefile
+#
+
+DIR=	ec
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=ectest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	ec_lib.c ecp_smpl.c ecp_mont.c ecp_nist.c ec_cvt.c ec_mult.c\
+	ec_err.c ec_curve.c ec_check.c ec_print.c ec_asn1.c ec_key.c\
+	ec2_smpl.c ec2_smpt.c ec2_mult.c
+
+LIBOBJ=	ec_lib.o ecp_smpl.o ecp_mont.o ecp_nist.o ec_cvt.o ec_mult.o\
+	ec_err.o ec_curve.o ec_check.o ec_print.o ec_asn1.o ec_key.o\
+	ec2_smpl.o ec2_mult.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= ec.h
+HEADER=	ec_lcl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/ecdh/Makefile.save TurboSSL-0.9.8j/crypto/ecdh/Makefile.save
--- openssl-0.9.8j/crypto/ecdh/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ecdh/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,76 @@
+#
+# crypto/ecdh/Makefile
+#
+
+DIR=	ecdh
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g -Wall
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=ecdhtest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	ech_lib.c ech_ossl.c ech_key.c ech_err.c
+
+LIBOBJ=	ech_lib.o ech_ossl.o ech_key.o ech_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= ecdh.h
+HEADER=	ech_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/ecdsa/Makefile.save TurboSSL-0.9.8j/crypto/ecdsa/Makefile.save
--- openssl-0.9.8j/crypto/ecdsa/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ecdsa/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,76 @@
+#
+# crypto/ecdsa/Makefile
+#
+
+DIR=	ecdsa
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g -Wall
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=ecdsatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	ecs_lib.c ecs_asn1.c ecs_ossl.c ecs_sign.c ecs_vrf.c ecs_err.c
+
+LIBOBJ=	ecs_lib.o ecs_asn1.o ecs_ossl.o ecs_sign.o ecs_vrf.o ecs_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= ecdsa.h
+HEADER=	ecs_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/engine/Makefile.save TurboSSL-0.9.8j/crypto/engine/Makefile.save
--- openssl-0.9.8j/crypto/engine/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/engine/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,83 @@
+#
+# OpenSSL/crypto/engine/Makefile
+#
+
+DIR=	engine
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= enginetest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= eng_err.c eng_lib.c eng_list.c eng_init.c eng_ctrl.c \
+	eng_table.c eng_pkey.c eng_fat.c eng_all.c \
+	tb_rsa.c tb_dsa.c tb_ecdsa.c tb_dh.c tb_ecdh.c tb_rand.c tb_store.c \
+	tb_cipher.c tb_digest.c \
+	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c eng_padlock.c
+LIBOBJ= eng_err.o eng_lib.o eng_list.o eng_init.o eng_ctrl.o \
+	eng_table.o eng_pkey.o eng_fat.o eng_all.o \
+	tb_rsa.o tb_dsa.o tb_ecdsa.o tb_dh.o tb_ecdh.o tb_rand.o tb_store.o \
+	tb_cipher.o tb_digest.o \
+	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o eng_padlock.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= engine.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/err/Makefile.save TurboSSL-0.9.8j/crypto/err/Makefile.save
--- openssl-0.9.8j/crypto/err/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/err/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/err/Makefile
+#
+
+DIR=	err
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=err.c err_def.c err_all.c err_prn.c err_str.c err_bio.c
+LIBOBJ=err.o err_def.o err_all.o err_prn.o err_str.o err_bio.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= err.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/evp/digest.c TurboSSL-0.9.8j/crypto/evp/digest.c
--- openssl-0.9.8j/crypto/evp/digest.c	2008-09-16 00:21:40.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/evp/digest.c	2010-05-31 12:14:39.000000000 +0200
@@ -117,6 +117,13 @@
 #include <openssl/engine.h>
 #endif
 #include "evp_locl.h"
+#ifndef CAVIUM_SSL
+#include <openssl/md5.h>
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#endif
 
 void EVP_MD_CTX_init(EVP_MD_CTX *ctx)
 	{
@@ -307,6 +314,93 @@
 	return ctx->digest->init(ctx);
 	}
 
+
+#ifndef CAVIUM_SSL
+void EVP_Copy_Pad(EVP_MD_CTX *ctx,unsigned char *pad) 
+{
+    if(EVP_MD_CTX_type(ctx) == NID_sha1) 
+    {
+        SHA_CTX *c = (SHA_CTX *)ctx->md_data;
+        ltoc(&(pad[0]),c->h0,1);
+        ltoc(&(pad[4]),c->h1,1);
+        ltoc(&(pad[8]),c->h2,1);
+        ltoc(&(pad[12]),c->h3,1);
+        ltoc(&(pad[16]),c->h4,1);
+    }
+    else if(EVP_MD_CTX_type(ctx) == NID_md5) 
+    {
+        MD5_CTX *c = (MD5_CTX *)ctx->md_data;
+        ltoc(&(pad[0]),c->A,0);
+        ltoc(&(pad[4]),c->B,0);
+        ltoc(&(pad[8]),c->C,0);
+        ltoc(&(pad[12]),c->D,0);
+    }
+}
+
+
+void EVP_Digest_new_init(EVP_MD_CTX *ctx,unsigned char *pad) 
+{
+    if(EVP_MD_CTX_type(ctx) == NID_sha1) 
+	{
+        SHA_CTX *c =(SHA_CTX *)ctx->md_data;
+
+        c->h0 = (SHA_LONG) ctol(&(pad[0]),1);
+        c->h1 = (SHA_LONG) ctol(&(pad[4]),1);
+        c->h2 = (SHA_LONG) ctol(&(pad[8]),1);
+        c->h3 = (SHA_LONG) ctol(&(pad[12]),1);
+        c->h4 = (SHA_LONG) ctol(&(pad[16]),1);
+        c->Nl = (SHA_LONG)512;
+        c->Nh = (SHA_LONG) 0;
+    }
+    else if(EVP_MD_CTX_type(ctx) == NID_md5) 
+	{
+        MD5_CTX *c =(MD5_CTX *)ctx->md_data;
+
+        c->A = (MD5_LONG) ctol(&(pad[0]),0);
+        c->B = (MD5_LONG) ctol(&(pad[4]),0);
+        c->C = (MD5_LONG) ctol(&(pad[8]),0);
+        c->D = (MD5_LONG) ctol(&(pad[12]),0);
+        c->Nl = (MD5_LONG)512;
+        c->Nh = (MD5_LONG) 0;
+    }
+}
+
+
+unsigned long ctol(unsigned char *c,int is_sha)
+{
+    unsigned long l;
+
+    if(is_sha)
+        l =  ((((unsigned long)(c[0])) << 24) |
+              (((unsigned long)(c[1])) << 16) |
+              (((unsigned long)(c[2])) <<  8) |
+              (((unsigned long)(c[3])) <<  0));
+    else
+        l = ((((unsigned long)(c[0])) << 0) |
+             (((unsigned long)(c[1])) << 8) |
+             (((unsigned long)(c[2])) << 16) |
+             (((unsigned long)(c[3])) << 24));
+    return l;
+ }
+
+void ltoc(unsigned char *s,unsigned long l,int is_sha) 
+{
+    if(is_sha) {
+        s[0] = (unsigned char)((l >> 24) & 0xff);
+        s[1] = (unsigned char)((l >> 16) & 0xff);
+        s[2] = (unsigned char)((l >>  8) & 0xff);
+        s[3] = (unsigned char)((l >>  0) & 0xff);
+    }
+    else {
+        s[0] = (unsigned char)((l >> 0) & 0xff);
+        s[1] = (unsigned char)((l >> 8 ) & 0xff);
+        s[2] = (unsigned char)((l >> 16) & 0xff);
+        s[3] = (unsigned char)((l >> 24) & 0xff);
+    }
+}
+
+#endif
+
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data,
 	     size_t count)
 	{
@@ -390,12 +484,188 @@
 	
 	return 1;
 	}
-
+#if 0 //jjose
+#if defined(CAVIUM_SSL) && !defined(CAVIUM_FIPS)
+static int evp_pkp_device_state=1;
+#endif
+#endif //jjose
 int EVP_Digest(const void *data, size_t count,
 		unsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
 	{
 	EVP_MD_CTX ctx;
 	int ret;
+#ifndef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+        Uint32 req_id;
+        int driver_open = 0;
+#ifdef CAVIUM_MULTICARD_API
+        int driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        int driver_ready = Csp1GetDriverState();
+#endif
+
+        if(driver_ready == -1)
+        {
+
+#ifdef CAVIUM_MULTICARD_API
+                if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+                if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+
+                   evp_pkp_device_state=0;     /*return 0;*/
+                else
+                   driver_open = 1;
+        }
+if(evp_pkp_device_state)
+{
+#ifdef MC2
+        switch(type->type)
+        {
+                case NID_sha1   :
+                                ret = Csp1Hash( CAVIUM_BLOCKING,
+                                                  SHA1_TYPE,
+                                                  (Uint16)count,
+                                                  (Uint8 *)data,
+                                                  (Uint8 *)md,
+#ifdef CAVIUM_MULTICARD_API
+                                                  &req_id,CAVIUM_DEV_ID
+#else
+                                                  &req_id
+#endif
+                                                );
+                                if(ret)
+                                        ret = 0;
+                                else{
+                                        if(size)
+                                                *size =20;
+                                        ret = 1;
+                                }
+                                break;
+                case NID_md5    :
+                                ret = Csp1Hash( CAVIUM_BLOCKING,
+                                                  MD5_TYPE,
+                                                  (Uint16)count,
+                                                  (Uint8 *)data,
+                                                  (Uint8 *)md,
+#ifdef CAVIUM_MULTICARD_API
+                                                  &req_id,CAVIUM_DEV_ID
+#else
+                                                  &req_id
+#endif
+                                                );
+                                if(ret)
+                                        ret =0;
+                                else{
+                                        if(size)
+                                                *size =16;
+                                        ret=1;
+                                }
+                                break;
+                default         :
+                                EVP_MD_CTX_init(&ctx);
+                                EVP_MD_CTX_set_flags(&ctx,EVP_MD_CTX_FLAG_ONESHOT);
+                                ret=EVP_DigestInit_ex(&ctx, type, impl)
+                                         && EVP_DigestUpdate(&ctx, data, count)
+                                         && EVP_DigestFinal_ex(&ctx, md, size);
+                                EVP_MD_CTX_cleanup(&ctx);
+                                break;
+        }
+
+#else
+{
+        Uint64 temp_ctx;
+        unsigned char md5[16],sha[20];
+        if(type->type == NID_sha1 || type->type==NID_md5)
+        {
+#ifdef CAVIUM_MULTICARD_API
+                if(Csp1AllocContext(CONTEXT_SSL,&temp_ctx,CAVIUM_DEV_ID))
+#else
+                if(Csp1AllocContext(CONTEXT_SSL,&temp_ctx))
+#endif
+                        return 0;
+                ret = Csp1HandshakeStart( CAVIUM_BLOCKING,
+                                          temp_ctx,
+                                          0,
+                                          NULL,
+#ifdef CAVIUM_MULTICARD_API
+                                                  &req_id,CAVIUM_DEV_ID
+#else
+                                                  &req_id
+#endif
+                                                );
+                if(ret)
+                        return 0;
+                ret = Csp1HandshakeUpdate(CAVIUM_BLOCKING,
+                                          temp_ctx,
+                                          (Uint16)count,
+                                          (Uint8 *)data,
+#ifdef CAVIUM_MULTICARD_API
+                                                  &req_id,CAVIUM_DEV_ID
+#else
+                                                  &req_id
+#endif
+                                                );
+                if(ret)
+                        return 0;
+                ret = Csp1HandshakeFinish( CAVIUM_BLOCKING,
+                                           temp_ctx,
+                                           0,
+                                           NULL,
+                                           md5,
+                                           sha,
+#ifdef CAVIUM_MULTICARD_API
+                                                  &req_id,CAVIUM_DEV_ID
+#else
+                                                  &req_id
+#endif
+                                                );
+#ifdef CAVIUM_MULTICARD_API
+                Csp1FreeContext(CONTEXT_SSL,temp_ctx,CAVIUM_DEV_ID);
+#else
+                Csp1FreeContext(CONTEXT_SSL,temp_ctx);
+#endif
+                if(!ret){
+                        if(type->type == NID_sha1){
+                                memcpy(md,sha,20);
+                                if(size)
+                                        *size=20;
+                        }
+                        else{
+                                memcpy(md,md5,16);
+                                if(size)
+                                        *size=16;
+                        }
+                }
+                return ret;
+        }else{
+                EVP_MD_CTX_init(&ctx);
+                EVP_MD_CTX_set_flags(&ctx,EVP_MD_CTX_FLAG_ONESHOT);
+                ret=EVP_DigestInit_ex(&ctx, type, impl)
+                        && EVP_DigestUpdate(&ctx, data, count)
+                        && EVP_DigestFinal_ex(&ctx, md, size);
+                EVP_MD_CTX_cleanup(&ctx);
+        }
+}
+#endif
+        if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+	   Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+	   Csp1Shutdown();
+#endif
+	return ret;
+}
+#else
+        EVP_MD_CTX_init(&ctx);
+        EVP_MD_CTX_set_flags(&ctx,EVP_MD_CTX_FLAG_ONESHOT);
+        ret=EVP_DigestInit_ex(&ctx, type, impl)
+          && EVP_DigestUpdate(&ctx, data, count)
+          && EVP_DigestFinal_ex(&ctx, md, size);
+        EVP_MD_CTX_cleanup(&ctx);
+	return ret;
+#endif 
+#endif
 
 	EVP_MD_CTX_init(&ctx);
 	M_EVP_MD_CTX_set_flags(&ctx,EVP_MD_CTX_FLAG_ONESHOT);
diff -Naur openssl-0.9.8j/crypto/evp/e_aes.c TurboSSL-0.9.8j/crypto/evp/e_aes.c
--- openssl-0.9.8j/crypto/evp/e_aes.c	2008-09-16 00:21:40.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/evp/e_aes.c	2010-05-31 12:13:09.000000000 +0200
@@ -115,3 +115,13 @@
 	}
 
 #endif
+
+#if defined(CAVIUM_SSL) 
+void aes_get_key(unsigned char *key, EVP_CIPHER_CTX *ctx)
+    {
+    AES_KEY *aes_key = (AES_KEY *)ctx->cipher_data;
+    memcpy(key,&(aes_key->key[0]),EVP_CIPHER_CTX_key_length(ctx));
+    return;
+    }
+#endif
+
diff -Naur openssl-0.9.8j/crypto/evp/e_des3.c TurboSSL-0.9.8j/crypto/evp/e_des3.c
--- openssl-0.9.8j/crypto/evp/e_des3.c	2008-11-10 19:55:07.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/evp/e_des3.c	2010-05-31 12:13:09.000000000 +0200
@@ -268,3 +268,15 @@
 	return &des_ede3_ecb;
 }
 #endif
+
+#if defined(CAVIUM_SSL)
+void des3_get_key(unsigned char *key,EVP_CIPHER_CTX *ctx)
+ {
+        DES_EDE_KEY *des_key = data(ctx);
+        memcpy(&(key[0]),&(des_key->ks1.key[0]),8);
+        memcpy(&(key[8]),&(des_key->ks2.key[0]),8);
+        memcpy(&(key[16]),&(des_key->ks3.key[0]),8);
+        return;
+ }
+#endif
+
diff -Naur openssl-0.9.8j/crypto/evp/e_des.c TurboSSL-0.9.8j/crypto/evp/e_des.c
--- openssl-0.9.8j/crypto/evp/e_des.c	2008-09-16 00:21:41.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/evp/e_des.c	2010-05-31 12:13:09.000000000 +0200
@@ -177,3 +177,13 @@
 	}
 
 #endif
+
+#if defined(CAVIUM_SSL) 
+void des_get_key(unsigned char *key,EVP_CIPHER_CTX *ctx)
+    {
+    DES_key_schedule *des_key = (DES_key_schedule *)ctx->cipher_data;
+    memcpy(key,&(des_key->key[0]),EVP_CIPHER_CTX_key_length(ctx));
+    return;
+    }
+#endif
+
diff -Naur openssl-0.9.8j/crypto/evp/e_rc4.c TurboSSL-0.9.8j/crypto/evp/e_rc4.c
--- openssl-0.9.8j/crypto/evp/e_rc4.c	2008-09-16 00:21:41.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/evp/e_rc4.c	2010-05-31 12:13:09.000000000 +0200
@@ -65,6 +65,14 @@
 #include <openssl/objects.h>
 #include <openssl/rc4.h>
 #include "evp_locl.h"
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+extern int rc4_pkp_dev_state;
+#endif
 
 /* FIXME: surely this is available elsewhere? */
 #define EVP_RC4_KEY_SIZE		16
@@ -80,6 +88,9 @@
 			const unsigned char *iv,int enc);
 static int rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 		      const unsigned char *in, unsigned int inl);
+#if defined(CAVIUM_SSL) && !defined(MC2)
+static int rc4_cleanup(EVP_CIPHER_CTX *rc4_ctx);
+#endif
 static const EVP_CIPHER r4_cipher=
 	{
 	NID_rc4,
@@ -87,7 +98,11 @@
 	EVP_CIPH_VARIABLE_LENGTH,
 	rc4_init_key,
 	rc4_cipher,
-	NULL,
+#if defined(CAVIUM_SSL) && !defined(MC2)
+        rc4_cleanup,
+#else
+        NULL,
+#endif
 	sizeof(EVP_RC4_KEY),
 	NULL,
 	NULL,
@@ -102,7 +117,11 @@
 	EVP_CIPH_VARIABLE_LENGTH,
 	rc4_init_key,
 	rc4_cipher,
-	NULL,
+#if defined(CAVIUM_SSL) && !defined(MC2)
+        rc4_cleanup,
+#else
+        NULL,
+#endif
 	sizeof(EVP_RC4_KEY),
 	NULL, 
 	NULL,
@@ -134,4 +153,109 @@
 	RC4(&data(ctx)->ks,inl,in,out);
 	return 1;
 	}
+#if defined(CAVIUM_SSL) && !defined(MC2)
+static int rc4_cleanup(EVP_CIPHER_CTX *rc4_ctx){
+        Uint64 tmp_ctx;
+        RC4_KEY *ks;
+    if(rc4_pkp_dev_state)
+    {
+#ifdef CAVIUM_FIPS
+        Uint32 req_id;
+#endif
+        ks=(RC4_KEY *)(&data(rc4_ctx)->ks);
+        if(ks){
+        tmp_ctx=(Uint64)(ks->ctx);
+#ifndef CAVIUM_FIPS
+        if(tmp_ctx)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1FreeContext(CONTEXT_SSL,tmp_ctx,CAVIUM_DEV_ID);
+#else
+        Csp1FreeContext(CONTEXT_SSL,tmp_ctx);
+#endif
+#else
+        if(tmp_ctx)
+        Cfm1FreeContext(OP_BLOCKING,tmp_ctx,&req_id);
 #endif
+        }
+     }
+        return 1;
+}
+#endif
+
+#endif
+
+#if defined(CAVIUM_SSL) 
+
+int rc4_init_cipher_ctx(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *c,const unsigned char *state,int enc)
+{
+    RC4_KEY *rc4_key;
+    int i;
+    ctx->encrypt = enc;
+    ctx->cipher=c;
+    if (ctx->cipher->ctx_size)
+    {
+        ctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);
+        if (!ctx->cipher_data)
+         {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
+            return 0;
+         }
+    }
+    else
+    {
+        ctx->cipher_data = NULL;
+    }
+    ctx->key_len = c->key_len;
+    ctx->flags = 0;
+    if(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)
+    {
+        if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))
+        {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            return 0;
+        }
+    }
+    OPENSSL_assert(ctx->cipher->block_size == 1
+                    || ctx->cipher->block_size == 8
+                    || ctx->cipher->block_size == 16);
+
+    if(state)  {
+        rc4_key = &(data(ctx)->ks);
+        for(i=0;i<256;i++)
+            rc4_key->data[i] = (RC4_INT)state[i];
+        rc4_key->x = (RC4_INT)state[256];
+        rc4_key->y = (RC4_INT)state[257];
+    }
+    else
+         return 0;
+    ctx->buf_len=0;
+    ctx->final_used=0;
+    ctx->block_mask=ctx->cipher->block_size-1;
+    return 1;
+}
+
+void rc4_get_cipher_state(unsigned char *state,EVP_CIPHER_CTX *ctx) 
+{
+    RC4_KEY *rc4_key;
+    int i;
+
+    rc4_key = &(data(ctx)->ks);
+    for(i=0;i<256;i++)
+        state[i] = (unsigned char)rc4_key->data[i];
+    state[256] = (unsigned char)rc4_key->x;
+    state[257] = (unsigned char)rc4_key->y;
+}
+
+void rc4_set_state(EVP_CIPHER_CTX *ctx,unsigned char *state) 
+{
+    RC4_KEY *rc4_key;
+    int i;
+
+    rc4_key = &(data(ctx)->ks);
+    for(i=0;i<256;i++)
+        rc4_key->data[i] = (RC4_INT)state[i];
+    rc4_key->x = (RC4_INT)state[256];
+    rc4_key->y = (RC4_INT)state[257];
+}
+#endif
+
diff -Naur openssl-0.9.8j/crypto/evp/evp.h TurboSSL-0.9.8j/crypto/evp/evp.h
--- openssl-0.9.8j/crypto/evp/evp.h	2008-09-17 19:11:00.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/evp/evp.h	2010-05-31 12:13:09.000000000 +0200
@@ -640,6 +640,22 @@
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);
 
+#ifdef CAVIUM_SSL
+
+void  EVP_Digest_new_init(EVP_MD_CTX *ctx,unsigned char *pad);
+unsigned long ctol(unsigned char *c,int);
+void ltoc(unsigned char *c,unsigned long,int);
+int rc4_init_cipher_ctx(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *c,const unsigned char *key,int enc);
+void rc4_get_cipher_state(unsigned char *state,EVP_CIPHER_CTX *ctx);
+void rc4_set_state(EVP_CIPHER_CTX *ctx,unsigned char *state);
+void aes_get_key(unsigned char *key,EVP_CIPHER_CTX *ctx);
+void des_get_key(unsigned char *key,EVP_CIPHER_CTX *ctx);
+void des3_get_key(unsigned char *key,EVP_CIPHER_CTX *ctx);
+void EVP_Copy_Pad(EVP_MD_CTX *,unsigned char *);
+
+#endif
+
+
 #ifndef OPENSSL_NO_BIO
 BIO_METHOD *BIO_f_md(void);
 BIO_METHOD *BIO_f_base64(void);
diff -Naur openssl-0.9.8j/crypto/evp/Makefile.save TurboSSL-0.9.8j/crypto/evp/Makefile.save
--- openssl-0.9.8j/crypto/evp/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/evp/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,98 @@
+#
+# OpenSSL/crypto/evp/Makefile
+#
+
+DIR=	evp
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=evp_test.c
+TESTDATA=evptests.txt
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= encode.c digest.c dig_eng.c evp_enc.c evp_key.c evp_acnf.c evp_cnf.c \
+	e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
+	e_rc4.c e_aes.c names.c e_seed.c \
+	e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c enc_min.c \
+	m_null.c m_md2.c m_md4.c m_md5.c m_sha.c m_sha1.c \
+	m_dss.c m_dss1.c m_mdc2.c m_ripemd.c m_ecdsa.c\
+	p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
+	bio_md.c bio_b64.c bio_enc.c evp_err.c e_null.c \
+	c_all.c c_allc.c c_alld.c evp_lib.c bio_ok.c \
+	evp_pkey.c evp_pbe.c p5_crpt.c p5_crpt2.c \
+	e_old.c
+
+LIBOBJ=	encode.o digest.o dig_eng.o evp_enc.o evp_key.o evp_acnf.o evp_cnf.o \
+	e_des.o e_bf.o e_idea.o e_des3.o e_camellia.o\
+	e_rc4.o e_aes.o names.o e_seed.o \
+	e_xcbc_d.o e_rc2.o e_cast.o e_rc5.o enc_min.o \
+	m_null.o m_md2.o m_md4.o m_md5.o m_sha.o m_sha1.o \
+	m_dss.o m_dss1.o m_mdc2.o m_ripemd.o m_ecdsa.o\
+	p_open.o p_seal.o p_sign.o p_verify.o p_lib.o p_enc.o p_dec.o \
+	bio_md.o bio_b64.o bio_enc.o evp_err.o e_null.o \
+	c_all.o c_allc.o c_alld.o evp_lib.o bio_ok.o \
+	evp_pkey.o evp_pbe.o p5_crpt.o p5_crpt2.o \
+	e_old.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= evp.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	cp $(TESTDATA) ../../test
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/hmac/hmac.c TurboSSL-0.9.8j/crypto/hmac/hmac.c
--- openssl-0.9.8j/crypto/hmac/hmac.c	2008-09-16 13:37:03.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/hmac/hmac.c	2010-05-31 12:14:39.000000000 +0200
@@ -61,6 +61,29 @@
 #include "cryptlib.h"
 #include <openssl/hmac.h>
 
+#ifndef CAVIUM_SSL
+void HMAC_New_Init_ex(HMAC_CTX *ctx,unsigned char *ipad,unsigned char *opad,const EVP_MD *md)
+{
+    int reset=0;
+    if(md!=NULL)
+    {
+        reset = 1;
+        ctx->md = md;
+    }
+    else
+        md = ctx->md;
+
+    if(reset) {
+        EVP_DigestInit_ex(&ctx->i_ctx,md, NULL);
+        EVP_Digest_new_init(&ctx->i_ctx,ipad);
+        EVP_DigestInit_ex(&ctx->o_ctx,md, NULL);
+        EVP_Digest_new_init(&ctx->o_ctx,opad);
+    }
+    EVP_MD_CTX_copy_ex(&ctx->md_ctx,&ctx->i_ctx);
+
+}
+#endif
+
 #ifndef OPENSSL_FIPS
 
 void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
diff -Naur openssl-0.9.8j/crypto/hmac/hmac.h TurboSSL-0.9.8j/crypto/hmac/hmac.h
--- openssl-0.9.8j/crypto/hmac/hmac.h	2008-06-16 18:56:40.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/hmac/hmac.h	2010-05-31 12:13:09.000000000 +0200
@@ -94,6 +94,7 @@
 	       const EVP_MD *md); /* deprecated */
 void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
 		  const EVP_MD *md, ENGINE *impl);
+void HMAC_New_Init_ex(HMAC_CTX *ctx, unsigned char *ipad,unsigned char *opad,const EVP_MD *md);
 void HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len);
 void HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);
 unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
diff -Naur openssl-0.9.8j/crypto/hmac/Makefile TurboSSL-0.9.8j/crypto/hmac/Makefile
--- openssl-0.9.8j/crypto/hmac/Makefile	2008-09-17 19:11:01.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/hmac/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -73,14 +73,3 @@
 	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-hmac.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
-hmac.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
-hmac.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-hmac.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-hmac.o: ../../include/openssl/hmac.h ../../include/openssl/lhash.h
-hmac.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
-hmac.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-hmac.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-hmac.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-hmac.o: ../cryptlib.h hmac.c
diff -Naur openssl-0.9.8j/crypto/hmac/Makefile.save TurboSSL-0.9.8j/crypto/hmac/Makefile.save
--- openssl-0.9.8j/crypto/hmac/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/hmac/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/md/Makefile
+#
+
+DIR=	hmac
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=hmactest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=hmac.c
+LIBOBJ=hmac.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= hmac.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.

diff -Naur openssl-0.9.8j/crypto/idea/Makefile.save TurboSSL-0.9.8j/crypto/idea/Makefile.save
--- openssl-0.9.8j/crypto/idea/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/idea/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/idea/Makefile
+#
+
+DIR=	idea
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=ideatest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=i_cbc.c i_cfb64.c i_ofb64.c i_ecb.c i_skey.c
+LIBOBJ=i_cbc.o i_cfb64.o i_ofb64.o i_ecb.o i_skey.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= idea.h
+HEADER=	idea_lcl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/krb5/Makefile.save TurboSSL-0.9.8j/crypto/krb5/Makefile.save
--- openssl-0.9.8j/crypto/krb5/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/krb5/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,76 @@
+#
+# OpenSSL/krb5/Makefile
+#
+
+DIR=	krb5
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= krb5_asn.c
+
+LIBOBJ= krb5_asn.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= krb5_asn.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/lhash/Makefile.save TurboSSL-0.9.8j/crypto/lhash/Makefile.save
--- openssl-0.9.8j/crypto/lhash/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/lhash/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/lhash/Makefile
+#
+
+DIR=	lhash
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=lhash.c lh_stats.c
+LIBOBJ=lhash.o lh_stats.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= lhash.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/Makefile TurboSSL-0.9.8j/crypto/Makefile
--- openssl-0.9.8j/crypto/Makefile	2008-09-17 19:10:55.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -5,9 +5,14 @@
 DIR=		crypto
 TOP=		..
 CC=		cc
-INCLUDE=	-I. -I$(TOP) -I../include
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+INCLUDE=	-I. -I$(TOP) -I../include -I$(CAVIUM_INCLUDEDIR)
 # INCLUDES targets sudbirs!
-INCLUDES=	-I.. -I../.. -I../../include
+INCLUDES=	-I.. -I../.. -I../../include -I$(CAVIUM_INCLUDEDIR) -I../../include/openssl
 CFLAG=		-g
 MAKEDEPPROG=	makedepend
 MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
diff -Naur openssl-0.9.8j/crypto/Makefile.save TurboSSL-0.9.8j/crypto/Makefile.save
--- openssl-0.9.8j/crypto/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,145 @@
+#
+# OpenSSL/crypto/Makefile
+#
+
+DIR=		crypto
+TOP=		..
+CC=		cc
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+INCLUDE=	-I. -I$(TOP) -I../include -I$(CAVIUM_INCLUDEDIR)
+# INCLUDES targets sudbirs!
+INCLUDES=	-I.. -I../.. -I../../include -I$(CAVIUM_INCLUDEDIR) -I../../include/openssl
+CFLAG=		-g
+MAKEDEPPROG=	makedepend
+MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
+MAKEFILE=       Makefile
+RM=             rm -f
+AR=		ar r
+
+RECURSIVE_MAKE=	[ -n "$(SDIRS)" ] && for i in $(SDIRS) ; do \
+		    (cd $$i && echo "making $$target in $(DIR)/$$i..." && \
+		    $(MAKE) -e TOP=../.. DIR=$$i INCLUDES='${INCLUDES}' $$target ) || exit 1; \
+		done;
+
+PEX_LIBS=
+EX_LIBS=
+ 
+CFLAGS= $(INCLUDE) $(CFLAG)
+ASFLAGS= $(INCLUDE) $(ASFLAG)
+AFLAGS=$(ASFLAGS)
+
+LIBS=
+
+GENERAL=Makefile README crypto-lib.com install.com
+
+LIB= $(TOP)/libcrypto.a
+SHARED_LIB= libcrypto$(SHLIB_EXT)
+LIBSRC=	cryptlib.c dyn_lck.c mem.c mem_clr.c mem_dbg.c cversion.c ex_data.c tmdiff.c cpt_err.c ebcdic.c uid.c o_time.c o_str.c o_dir.c o_init.c fips_err.c
+LIBOBJ= cryptlib.o dyn_lck.o mem.o mem_clr.o mem_dbg.o cversion.o ex_data.o tmdiff.o cpt_err.o ebcdic.o uid.o o_time.o o_str.o o_dir.o o_init.o fips_err.o $(CPUID_OBJ)
+
+SRC= $(LIBSRC)
+
+EXHEADER= crypto.h tmdiff.h opensslv.h opensslconf.h ebcdic.h symhacks.h \
+	ossl_typ.h
+HEADER=	cryptlib.h buildinf.h md32_common.h o_time.h o_str.h o_dir.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	@(cd ..; $(MAKE) DIRS=$(DIR) all)
+
+all: lib
+
+buildinf.h: ../Makefile
+	( echo "#ifndef MK1MF_BUILD"; \
+	echo '  /* auto-generated by crypto/Makefile for crypto/cversion.c */'; \
+	echo '  #define CFLAGS "$(CC) $(CFLAG)"'; \
+	echo '  #define PLATFORM "$(PLATFORM)"'; \
+	echo "  #define DATE \"`LC_ALL=C LC_TIME=C date`\""; \
+	echo '#endif' ) >buildinf.h
+
+x86cpuid-elf.s:	x86cpuid.pl perlasm/x86asm.pl
+	$(PERL) x86cpuid.pl elf $(CFLAGS) $(PROCESSOR) > $@
+x86cpuid-cof.s: x86cpuid.pl perlasm/x86asm.pl
+	$(PERL) x86cpuid.pl coff $(CFLAGS) $(PROCESSOR) > $@
+x86cpuid-out.s: x86cpuid.pl perlasm/x86asm.pl
+	$(PERL) x86cpuid.pl a.out $(CFLAGS) $(PROCESSOR) > $@
+
+uplink.o:	../ms/uplink.c
+	$(CC) $(CFLAGS) -c -o $@ ../ms/uplink.c
+
+uplink-cof.s:	../ms/uplink.pl
+	$(PERL) ../ms/uplink.pl coff > $@
+
+x86_64cpuid.s: x86_64cpuid.pl
+	$(PERL) x86_64cpuid.pl $@
+ia64cpuid.s: ia64cpuid.S
+	$(CC) $(CFLAGS) -E ia64cpuid.S > $@
+
+testapps:
+	[ -z "$(THIS)" ] || (	if echo ${SDIRS} | fgrep ' des '; \
+				then cd des && $(MAKE) -e des; fi )
+	[ -z "$(THIS)" ] || ( cd pkcs7 && $(MAKE) -e testapps );
+	@if [ -z "$(THIS)" ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
+
+subdirs:
+	@target=all; $(RECURSIVE_MAKE)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+	@target=files; $(RECURSIVE_MAKE)
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../apps $(APPS)
+	@target=links; $(RECURSIVE_MAKE)
+
+# lib: and $(LIB): are splitted to avoid end-less loop
+lib:	buildinf.h $(LIB) subdirs
+	@touch lib
+$(LIB):	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+
+shared: buildinf.h lib subdirs
+	if [ -n "$(SHARED_LIBS)" ]; then \
+		(cd ..; $(MAKE) $(SHARED_LIB)); \
+	fi
+
+libs:
+	@target=lib; $(RECURSIVE_MAKE)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ;\
+	do \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+	@target=install; $(RECURSIVE_MAKE)
+
+lint:
+	@target=lint; $(RECURSIVE_MAKE)
+
+depend:
+	@[ -z "$(THIS)" -o -f buildinf.h ] || touch buildinf.h # fake buildinf.h if it does not exist
+	@[ -z "$(THIS)" ] || $(MAKEDEPEND) -- $(CFLAG) $(INCLUDE) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+	@[ -z "$(THIS)" -o -s buildinf.h ] || rm buildinf.h
+	@[ -z "$(THIS)" ] || (set -e; target=depend; $(RECURSIVE_MAKE) )
+	@if [ -z "$(THIS)" ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
+
+clean:
+	rm -f buildinf.h *.s *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+	@target=clean; $(RECURSIVE_MAKE)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+	@target=dclean; $(RECURSIVE_MAKE)
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.

diff -Naur openssl-0.9.8j/crypto/md2/Makefile.save TurboSSL-0.9.8j/crypto/md2/Makefile.save
--- openssl-0.9.8j/crypto/md2/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/md2/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/md/Makefile
+#
+
+DIR=	md2
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=md2test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=md2_dgst.c md2_one.c
+LIBOBJ=md2_dgst.o md2_one.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= md2.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.

diff -Naur openssl-0.9.8j/crypto/md4/Makefile.save TurboSSL-0.9.8j/crypto/md4/Makefile.save
--- openssl-0.9.8j/crypto/md4/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/md4/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,76 @@
+#
+# OpenSSL/crypto/md4/Makefile
+#
+
+DIR=    md4
+TOP=    ../..
+CC=     cc
+CPP=    $(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=       Makefile
+AR=             ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=md4test.c
+APPS=md4.c
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=md4_dgst.c md4_one.c
+LIBOBJ=md4_dgst.o md4_one.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= md4.h
+HEADER= md4_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:    lib
+
+lib:    $(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f asm/mx86unix.cpp *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/md5/Makefile.save TurboSSL-0.9.8j/crypto/md5/Makefile.save
--- openssl-0.9.8j/crypto/md5/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/md5/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,92 @@
+#
+# OpenSSL/crypto/md5/Makefile
+#
+
+DIR=    md5
+TOP=    ../..
+CC=     cc
+CPP=    $(CC) -E
+INCLUDES=-I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=       Makefile
+AR=             ar r
+
+MD5_ASM_OBJ=
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=md5test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=md5_dgst.c md5_one.c
+LIBOBJ=md5_dgst.o md5_one.o $(MD5_ASM_OBJ)
+
+SRC= $(LIBSRC)
+
+EXHEADER= md5.h
+HEADER= md5_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:    lib
+
+lib:    $(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+mx86-elf.s: asm/md5-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) md5-586.pl elf $(CFLAGS) > ../$@)
+# COFF
+mx86-cof.s: asm/md5-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) md5-586.pl coff $(CFLAGS) > ../$@)
+# a.out
+mx86-out.s: asm/md5-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) md5-586.pl a.out $(CFLAGS) > ../$@)
+
+md5-x86_64.s:	asm/md5-x86_64.pl;	$(PERL) asm/md5-x86_64.pl $@
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/md5/md5test.c TurboSSL-0.9.8j/crypto/md5/md5test.c
--- openssl-0.9.8j/crypto/md5/md5test.c	2007-06-07 18:13:55.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/md5/md5test.c	2010-05-31 12:13:09.000000000 +0200
@@ -59,6 +59,13 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 
 #include "../e_os.h"
 
@@ -72,7 +79,7 @@
 #include <openssl/evp.h>
 #include <openssl/md5.h>
 
-static char *test[]={
+char *test[]={
 	"",
 	"a",
 	"abc",
@@ -83,7 +90,7 @@
 	NULL,
 	};
 
-static char *ret[]={
+char *ret[]={
 	"d41d8cd98f00b204e9800998ecf8427e",
 	"0cc175b9c0f1b6a831c399e269772661",
 	"900150983cd24fb0d6963f7d28e17f72",
@@ -100,6 +107,32 @@
 	char **P,**R;
 	char *p;
 	unsigned char md[MD5_DIGEST_LENGTH];
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+        int driver_open = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+        if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+	           driver_open = 1;
+        }
+#else
+        if(CSP1_driver_handle == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT))
+	           driver_open = 1;
+        }
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+         if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+         if(Cfm1Initialize(500,DIRECT))
+#endif
+		;	/*return 0; */
+#endif
+#endif
 
 	P=test;
 	R=ret;
@@ -120,6 +153,19 @@
 		R++;
 		P++;
 		}
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+      if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+        Csp1Shutdown();
+#endif
+
+#else
+        Cfm1Shutdown();
+#endif
+#endif
 
 #ifdef OPENSSL_SYS_NETWARE
     if (err) printf("ERROR: %d\n", err);
diff -Naur openssl-0.9.8j/crypto/objects/Makefile.save TurboSSL-0.9.8j/crypto/objects/Makefile.save
--- openssl-0.9.8j/crypto/objects/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/objects/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,84 @@
+#
+# OpenSSL/crypto/objects/Makefile
+#
+
+DIR=	objects
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+PERL=		perl
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	o_names.c obj_dat.c obj_lib.c obj_err.c
+LIBOBJ= o_names.o obj_dat.o obj_lib.o obj_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= objects.h obj_mac.h
+HEADER=	$(EXHEADER) obj_dat.h
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	obj_dat.h lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+obj_dat.h: obj_dat.pl obj_mac.h
+	$(PERL) obj_dat.pl obj_mac.h obj_dat.h
+
+# objects.pl both reads and writes obj_mac.num
+obj_mac.h: objects.pl objects.txt obj_mac.num
+	$(PERL) objects.pl objects.txt obj_mac.num obj_mac.h
+	@sleep 1; touch obj_mac.h; sleep 1
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/ocsp/Makefile.save TurboSSL-0.9.8j/crypto/ocsp/Makefile.save
--- openssl-0.9.8j/crypto/ocsp/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ocsp/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,78 @@
+#
+# OpenSSL/ocsp/Makefile
+#
+
+DIR=	ocsp
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= ocsp_asn.c ocsp_ext.c ocsp_ht.c ocsp_lib.c ocsp_cl.c \
+	ocsp_srv.c ocsp_prn.c ocsp_vfy.c ocsp_err.c
+
+LIBOBJ= ocsp_asn.o ocsp_ext.o ocsp_ht.o ocsp_lib.o ocsp_cl.o \
+	ocsp_srv.o ocsp_prn.o ocsp_vfy.o ocsp_err.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= ocsp.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/opensslconf.h TurboSSL-0.9.8j/crypto/opensslconf.h
--- openssl-0.9.8j/crypto/opensslconf.h	2009-01-07 12:57:01.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/opensslconf.h	2010-05-31 12:14:16.000000000 +0200
@@ -35,9 +35,18 @@
 #ifndef OPENSSL_NO_SEED
 # define OPENSSL_NO_SEED
 #endif
+#ifndef OPENSSL_NO_TLSEXT
+# define OPENSSL_NO_TLSEXT
+#endif
 
 #endif /* OPENSSL_DOING_MAKEDEPEND */
 
+#ifndef CAVIUM_SSL
+# define CAVIUM_SSL
+#endif
+#ifndef OPENSSL_NO_ASM
+# define OPENSSL_NO_ASM
+#endif
 #ifndef OPENSSL_NO_DYNAMIC_ENGINE
 # define OPENSSL_NO_DYNAMIC_ENGINE
 #endif
@@ -77,6 +86,9 @@
 # if defined(OPENSSL_NO_SEED) && !defined(NO_SEED)
 #  define NO_SEED
 # endif
+# if defined(OPENSSL_NO_TLSEXT) && !defined(NO_TLSEXT)
+#  define NO_TLSEXT
+# endif
 #endif
 
 /* crypto/opensslconf.h.in */
diff -Naur openssl-0.9.8j/crypto/pem/Makefile.save TurboSSL-0.9.8j/crypto/pem/Makefile.save
--- openssl-0.9.8j/crypto/pem/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/pem/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,78 @@
+#
+# OpenSSL/crypto/pem/Makefile
+#
+
+DIR=	pem
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= pem_sign.c pem_seal.c pem_info.c pem_lib.c pem_all.c pem_err.c \
+	pem_x509.c pem_xaux.c pem_oth.c pem_pk8.c pem_pkey.c
+
+LIBOBJ=	pem_sign.o pem_seal.o pem_info.o pem_lib.o pem_all.o pem_err.o \
+	pem_x509.o pem_xaux.o pem_oth.o pem_pk8.o pem_pkey.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= pem.h pem2.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links: $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/pem/pem.h TurboSSL-0.9.8j/crypto/pem/pem.h
--- openssl-0.9.8j/crypto/pem/pem.h	2008-11-11 13:42:32.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/pem/pem.h	2010-05-31 12:13:09.000000000 +0200
@@ -737,6 +737,8 @@
 #define PEM_F_PEM_ASN1_WRITE				 104
 #define PEM_F_PEM_ASN1_WRITE_BIO			 105
 #define PEM_F_PEM_DEF_CALLBACK				 100
+/*To support apache application*/
+#define PEM_F_DEF_CALLBACK                           100
 #define PEM_F_PEM_DO_HEADER				 106
 #define PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY		 118
 #define PEM_F_PEM_GET_EVP_CIPHER_INFO			 107
diff -Naur openssl-0.9.8j/crypto/pkcs12/Makefile.save TurboSSL-0.9.8j/crypto/pkcs12/Makefile.save
--- openssl-0.9.8j/crypto/pkcs12/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/pkcs12/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,81 @@
+#
+# OpenSSL/crypto/pkcs12/Makefile
+#
+
+DIR=	pkcs12
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= p12_add.c p12_asn.c p12_attr.c p12_crpt.c p12_crt.c p12_decr.c \
+	p12_init.c p12_key.c p12_kiss.c p12_mutl.c\
+	p12_utl.c p12_npas.c pk12err.c p12_p8d.c p12_p8e.c
+LIBOBJ= p12_add.o p12_asn.o p12_attr.o p12_crpt.o p12_crt.o p12_decr.o \
+	p12_init.o p12_key.o p12_kiss.o p12_mutl.o\
+	p12_utl.o p12_npas.o pk12err.o p12_p8d.o p12_p8e.o
+
+SRC= $(LIBSRC)
+
+EXHEADER=  pkcs12.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+test:
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/pkcs7/Makefile.save TurboSSL-0.9.8j/crypto/pkcs7/Makefile.save
--- openssl-0.9.8j/crypto/pkcs7/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/pkcs7/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,96 @@
+#
+# OpenSSL/crypto/pkcs7/Makefile
+#
+
+DIR=	pkcs7
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+PEX_LIBS=
+EX_LIBS=
+ 
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	pk7_asn1.c pk7_lib.c pkcs7err.c pk7_doit.c pk7_smime.c pk7_attr.c \
+	pk7_mime.c
+LIBOBJ= pk7_asn1.o pk7_lib.o pkcs7err.o pk7_doit.o pk7_smime.o pk7_attr.o \
+	pk7_mime.o
+
+SRC= $(LIBSRC)
+
+EXHEADER=  pkcs7.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+test:
+
+all:	lib
+
+testapps: enc dec sign verify
+
+enc: enc.o lib
+	$(CC) $(CFLAGS) -o enc enc.o $(PEX_LIBS) $(LIB) $(EX_LIBS)
+
+dec: dec.o lib
+	$(CC) $(CFLAGS) -o dec dec.o $(PEX_LIBS) $(LIB) $(EX_LIBS)
+
+sign: sign.o lib
+	$(CC) $(CFLAGS) -o sign sign.o $(PEX_LIBS) $(LIB) $(EX_LIBS)
+
+verify: verify.o example.o lib
+	$(CC) $(CFLAGS) -o verify verify.o $(PEX_LIBS) example.o $(LIB) $(EX_LIBS)
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff enc dec sign verify
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rand/Makefile.save TurboSSL-0.9.8j/crypto/rand/Makefile.save
--- openssl-0.9.8j/crypto/rand/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rand/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,77 @@
+#
+# OpenSSL/crypto/rand/Makefile
+#
+
+DIR=	rand
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= randtest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=md_rand.c randfile.c rand_lib.c rand_eng.c rand_err.c rand_egd.c \
+	rand_win.c rand_unix.c rand_os2.c rand_nw.c
+LIBOBJ=md_rand.o randfile.o rand_lib.o rand_eng.o rand_err.o rand_egd.o \
+	rand_win.o rand_unix.o rand_os2.o rand_nw.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rand.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rc2/Makefile.save TurboSSL-0.9.8j/crypto/rc2/Makefile.save
--- openssl-0.9.8j/crypto/rc2/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rc2/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/rc2/Makefile
+#
+
+DIR=	rc2
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=rc2test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=rc2_ecb.c rc2_skey.c rc2_cbc.c rc2cfb64.c rc2ofb64.c
+LIBOBJ=rc2_ecb.o rc2_skey.o rc2_cbc.o rc2cfb64.o rc2ofb64.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rc2.h
+HEADER=	rc2_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rc4/Makefile.save TurboSSL-0.9.8j/crypto/rc4/Makefile.save
--- openssl-0.9.8j/crypto/rc4/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rc4/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,98 @@
+#
+# OpenSSL/crypto/rc4/Makefile
+#
+
+DIR=	rc4
+TOP=	../..
+CC=	cc
+CPP=    $(CC) -E
+INCLUDES=
+CFLAG=-g
+AR=		ar r
+
+RC4_ENC=rc4_enc.o rc4_skey.o
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=rc4test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=rc4_skey.c rc4_enc.c rc4_fblk.c
+LIBOBJ=$(RC4_ENC) rc4_fblk.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rc4.h
+HEADER=	$(EXHEADER) rc4_locl.h
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+rx86-elf.s: asm/rc4-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rc4-586.pl elf $(CFLAGS) > ../$@)
+# COFF
+rx86-cof.s: asm/rc4-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rc4-586.pl coff $(CFLAGS) > ../$@)
+# a.out
+rx86-out.s: asm/rc4-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rc4-586.pl a.out $(CFLAGS) > ../$@)
+
+rc4-x86_64.s: asm/rc4-x86_64.pl;	$(PERL) asm/rc4-x86_64.pl $@
+
+rc4-ia64.s: asm/rc4-ia64.S
+	@case `awk '/^#define RC4_INT/{print$$NF}' $(TOP)/include/openssl/opensslconf.h` in \
+	int)	set -x; $(CC) $(CFLAGS) -DSZ=4 -E asm/rc4-ia64.S > $@ ;; \
+	char)	set -x; $(CC) $(CFLAGS) -DSZ=1 -E asm/rc4-ia64.S > $@ ;; \
+	*)	exit 1 ;; \
+	esac
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rc4/rc4_enc.c TurboSSL-0.9.8j/crypto/rc4/rc4_enc.c
--- openssl-0.9.8j/crypto/rc4/rc4_enc.c	2005-07-05 01:30:31.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rc4/rc4_enc.c	2010-05-31 12:13:09.000000000 +0200
@@ -58,6 +58,13 @@
 
 #include <openssl/rc4.h>
 #include "rc4_locl.h"
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 
 /* RC4 as implemented from a posting from
  * Newsgroups: sci.crypt
@@ -67,9 +74,49 @@
  * Date: Wed, 14 Sep 1994 06:35:31 GMT
  */
 
+#if defined(CAVIUM_SSL) && !defined(MC2)
+extern int rc4_pkp_dev_state;
+#endif
 void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,
 	     unsigned char *outdata)
 	{
+#if defined(CAVIUM_SSL) && !defined(MC2)
+        int ret;
+        Uint64 tmp_ctx;
+        Uint32 req_id;
+        tmp_ctx=(Uint64)key->ctx;
+if(rc4_pkp_dev_state)
+{
+#ifndef CAVIUM_FIPS
+        ret = Csp1EncryptRc4(
+                                CAVIUM_BLOCKING,
+                                (Uint64)tmp_ctx,
+                                CAVIUM_UPDATE,
+                                (Uint16)len,
+                                (Uint8 *)indata,
+                                (Uint8 *)outdata,
+#ifdef CAVIUM_MULTICARD_API
+                                &req_id,CAVIUM_DEV_ID
+#else
+                                &req_id
+#endif
+                            );
+        if(ret) return;
+#else
+        ret = Cfm1EncryptRc4(   OP_BLOCKING,
+                        tmp_ctx,
+                        UPDATE,
+                        len,
+                        (Uint8 *)indata,
+                        (Uint8 *)outdata,
+                        &req_id);
+        if(ret) return;
+#endif
+return;
+} /*rc4_pkp_dev_state*/
+#endif
+{
+
         register RC4_INT *d;
         register RC4_INT x,y,tx,ty;
 	int i;
@@ -313,3 +360,4 @@
 	key->x=x;     
 	key->y=y;
 	}
+}	
diff -Naur openssl-0.9.8j/crypto/rc4/rc4.h TurboSSL-0.9.8j/crypto/rc4/rc4.h
--- openssl-0.9.8j/crypto/rc4/rc4.h	2008-09-16 12:47:26.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rc4/rc4.h	2010-05-31 12:13:09.000000000 +0200
@@ -58,6 +58,13 @@
 
 #ifndef HEADER_RC4_H
 #define HEADER_RC4_H
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 
 #include <openssl/opensslconf.h> /* OPENSSL_NO_RC4, RC4_INT */
 #ifdef OPENSSL_NO_RC4
@@ -70,6 +77,9 @@
 
 typedef struct rc4_key_st
 	{
+#if defined(CAVIUM_SSL) && !defined(MC2)
+        Uint64 ctx;
+#endif
 	RC4_INT x,y;
 	RC4_INT data[256];
 	} RC4_KEY;
diff -Naur openssl-0.9.8j/crypto/rc4/rc4_skey.c TurboSSL-0.9.8j/crypto/rc4/rc4_skey.c
--- openssl-0.9.8j/crypto/rc4/rc4_skey.c	2008-09-16 12:47:26.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rc4/rc4_skey.c	2010-05-31 12:13:09.000000000 +0200
@@ -63,7 +63,18 @@
 #ifdef OPENSSL_FIPS
 #include <openssl/fips.h>
 #endif
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#else
+#include "luna_common.h"
+#include "luna_ssl.h"
+#include "luna_api.h"
+#endif
 
+int rc4_pkp_dev_state=1;
+#endif
 
 const char RC4_version[]="RC4" OPENSSL_VERSION_PTEXT;
 
@@ -96,6 +107,105 @@
 void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)
 #endif
 	{
+#if defined(CAVIUM_SSL) && !defined(MC2)
+        unsigned char *skey;
+        int ret;
+        Uint64 tmp_ctx;
+        Uint32 req_id;
+        int driver_ready = -1;
+#ifdef CAVIUM_FIPS
+        Uint64 hWrapper;
+        Uint64 hkey_handle;
+        Uint8 enc_key_out[200];
+        Uint8 local_iv[8]={0x67, 0xC6, 0x69, 0x73, 0x51, 0xFF, 0x4A, 0xEC };
+        int i;
+        Uint8 pad_patern=0x08;
+#endif
+        if(len == 0)
+                return;
+        skey=(unsigned char *)data;
+        if(skey == NULL)
+                return;
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_MULTICARD_API
+        driver_ready = Csp1GetDriverState(CAVIUM_DEV_ID);
+#else
+        driver_ready = Csp1GetDriverState();
+#endif
+#else
+        driver_ready = Cfm1GetDriverState();
+#endif
+        if(driver_ready == -1)
+        {
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_MULTICARD_API
+          if(Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+#else
+          if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+          if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+          if(Cfm1Initialize(500,DIRECT))
+#endif
+#endif
+               rc4_pkp_dev_state=0;  /*  return;*/
+  }
+if(rc4_pkp_dev_state)
+{
+#ifndef CAVIUM_FIPS
+
+#ifdef CAVIUM_MULTICARD_API
+        if(Csp1AllocContext(CONTEXT_SSL,&tmp_ctx,CAVIUM_DEV_ID))
+                return;
+        ret = Csp1InitializeRc4( CAVIUM_BLOCKING,
+                           tmp_ctx,
+                           len,
+                           (Uint8 *)skey,
+                           &req_id,CAVIUM_DEV_ID );
+#else
+        if(Csp1AllocContext(CONTEXT_SSL,&tmp_ctx))
+                return;
+        ret = Csp1InitializeRc4( CAVIUM_BLOCKING,
+                           tmp_ctx,
+                           len,
+                           (Uint8 *)skey,
+                           &req_id );
+#endif
+        if(ret) return;
+         key->ctx = tmp_ctx;
+#else
+        if(Cfm1AllocContext(OP_BLOCKING,&tmp_ctx,&req_id))
+                return;
+        if(Cfm1GenerateSymmetricKey(8,24,(Uint8 *)"3DES",4,&hWrapper))
+                return;
+        Cfm1Initialize3DES(OP_BLOCKING,tmp_ctx,local_iv,&hWrapper,&req_id);
+        if(len%8)
+        {
+                i=(len+7)&~(0x7);
+                pad_patern=(8-(len%8))+8;
+                while(len < i)
+                skey[len++]=pad_patern;;
+        }
+        for(i=len;i<(len+8);i++)
+                skey[i]=pad_patern;
+        len=len+8;
+        Cfm1Encrypt3Des(OP_BLOCKING,tmp_ctx,NO_UPDATE,len,(Uint8 *)skey,enc_key_out,&req_id);
+        Cfm1ImportSymmetricKey(hWrapper,5,enc_key_out,len,(Uint8 *)"key_",strlen("key_"),local_iv,8,&hkey_handle);
+        ret = Cfm1InitializeRc4( OP_BLOCKING,
+                           tmp_ctx,
+                           (Uint64 *)&hkey_handle,
+                           &req_id );
+        if(ret) return;
+         key->ctx = tmp_ctx;
+        Cfm1DeleteKey(hWrapper);
+	Cfm1DeleteKey(hkey_handle);
+#endif
+	return;	
+} /*rc4_pkp_dev_state*/
+#endif
+{
         register RC4_INT tmp;
         register int id1,id2;
         register RC4_INT *d;
@@ -162,4 +272,4 @@
 		SK_LOOP(d,i+3);
 		}
 	}
-    
+}    
diff -Naur openssl-0.9.8j/crypto/rc4/rc4test.c TurboSSL-0.9.8j/crypto/rc4/rc4test.c
--- openssl-0.9.8j/crypto/rc4/rc4test.c	2005-08-29 01:20:49.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rc4/rc4test.c	2010-05-31 12:13:09.000000000 +0200
@@ -60,6 +60,13 @@
 #include <stdlib.h>
 #include <string.h>
 
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 #include "../e_os.h"
 
 #ifdef OPENSSL_NO_RC4
@@ -119,6 +126,32 @@
 	unsigned char *p;
 	RC4_KEY key;
 	unsigned char obuf[512];
+#if defined(CAVIUM_SSL) && !defined(MC2) && !defined(CAVIUM_FIPS)
+        int driver_open = 0;
+#ifndef CAVIUM_FIPS
+
+#ifdef CAVIUM_MULTICARD_API
+        if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+              driver_open = 1;
+        }
+#else
+        if(CSP1_driver_handle == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT))
+              driver_open = 1;
+        }
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+         if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+         if(Cfm1Initialize(500,DIRECT))
+#endif
+		;/*return 0;*/
+#endif
+#endif
 
 	for (i=0; i<6; i++)
 		{
@@ -227,6 +260,19 @@
 		}
 		else	printf("ok\n");
 	}
+#if defined(CAVIUM_SSL) && !defined(MC2)
+#ifndef CAVIUM_FIPS
+        if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+           Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+           Csp1Shutdown();
+#endif
+#else
+        Cfm1Shutdown();
+#endif
+#endif
+
 #ifdef OPENSSL_SYS_NETWARE
     if (err) printf("ERROR: %d\n", err);
 #endif

diff -Naur openssl-0.9.8j/crypto/ripemd/Makefile.save TurboSSL-0.9.8j/crypto/ripemd/Makefile.save
--- openssl-0.9.8j/crypto/ripemd/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/ripemd/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,90 @@
+#
+# OpenSSL/crypto/ripemd/Makefile
+#
+
+DIR=    ripemd
+TOP=    ../..
+CC=     cc
+CPP=    $(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=       Makefile
+AR=             ar r
+
+RIP_ASM_OBJ=
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=rmdtest.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=rmd_dgst.c rmd_one.c
+LIBOBJ=rmd_dgst.o rmd_one.o $(RMD160_ASM_OBJ)
+
+SRC= $(LIBSRC)
+
+EXHEADER= ripemd.h
+HEADER= rmd_locl.h rmdconst.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:    lib
+
+lib:    $(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+rm86-elf.s: asm/rmd-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rmd-586.pl elf $(CFLAGS) > ../$@)
+# COFF
+rm86-cof.s: asm/rmd-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rmd-586.pl coff $(CFLAGS) > ../$@)
+# a.out
+rm86-out.s: asm/rmd-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) rmd-586.pl a.out $(CFLAGS) > ../$@)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rsa/Makefile.save TurboSSL-0.9.8j/crypto/rsa/Makefile.save
--- openssl-0.9.8j/crypto/rsa/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,79 @@
+#
+# OpenSSL/crypto/rsa/Makefile
+#
+
+DIR=	rsa
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=rsa_test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= rsa_eay.c rsa_gen.c rsa_lib.c rsa_sign.c rsa_saos.c rsa_err.c \
+	rsa_pk1.c rsa_ssl.c rsa_none.c rsa_oaep.c rsa_chk.c rsa_null.c \
+	rsa_pss.c rsa_x931.c rsa_x931g.c rsa_asn1.c rsa_depr.c rsa_eng.c
+LIBOBJ= rsa_eay.o rsa_gen.o rsa_lib.o rsa_sign.o rsa_saos.o rsa_err.o \
+	rsa_pk1.o rsa_ssl.o rsa_none.o rsa_oaep.o rsa_chk.o rsa_null.o \
+	rsa_pss.o rsa_x931.o rsa_x931g.o rsa_asn1.o rsa_depr.o rsa_eng.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rsa.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/rsa/rsa.h TurboSSL-0.9.8j/crypto/rsa/rsa.h
--- openssl-0.9.8j/crypto/rsa/rsa.h	2008-09-16 16:55:26.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rsa/rsa.h	2010-05-31 12:13:09.000000000 +0200
@@ -277,6 +277,18 @@
 		unsigned char *to, RSA *rsa,int padding);
 int	RSA_private_decrypt(int flen, const unsigned char *from, 
 		unsigned char *to, RSA *rsa,int padding);
+#ifdef CAVIUM_SSL
+int RSA_public_encrypt_cav(void *s,int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa,int padding);
+int RSA_private_encrypt_cav(void *s,int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa,int padding);
+int RSA_public_decrypt_cav(void *s,int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa,int padding);
+//int RSA_private_decrypt_cav(void *s,int flen, const unsigned char *from,
+//      unsigned char *to, RSA *rsa,int padding);
+
+#endif
+
 void	RSA_free (RSA *r);
 /* "up" the RSA object's reference count */
 int	RSA_up_ref(RSA *r);
@@ -332,6 +344,13 @@
  * inside PKCS#1 padded RSA encryption */
 int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
 	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
+#ifdef CAVIUM_SSL
+int RSA_verify_cav(void *s, int type, const unsigned char *m, 
+	unsigned int m_length,unsigned char *sigbuf,unsigned int siglen, RSA *rsa);
+int RSA_sign_cav(void *s, int type, const unsigned char *m, 
+	unsigned int m_length,unsigned char *sigret,unsigned int *siglen, RSA *rsa);
+#endif
+
 int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
 	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
 
diff -Naur openssl-0.9.8j/crypto/rsa/rsa_lib.c TurboSSL-0.9.8j/crypto/rsa/rsa_lib.c
--- openssl-0.9.8j/crypto/rsa/rsa_lib.c	2008-09-16 16:55:26.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rsa/rsa_lib.c	2010-05-31 12:13:09.000000000 +0200
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -66,169 +66,270 @@
 #ifndef OPENSSL_NO_ENGINE
 #include <openssl/engine.h>
 #endif
+#ifdef CAVIUM_SSL
+#include <openssl/cav_crypto_engine.h>
+#endif
 
 int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
-	return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
-	}
+         RSA *rsa, int padding)
+    {
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+#if defined(CAVIUM_FIPS)
+        ret = pkp_rsa_public_encrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+        ret = pkp_rsa_public_encrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+        if(ret)
+            return ret;
+        }
+#endif
+    return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
+    }
+
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+int RSA_private_encrypt_cav(void *s, int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa, int padding)
+    {
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+        ret = pkp_rsa_private_encrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+        if (ret)
+            return ret;
+        }
+    return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
+    }
+#endif
 
 int RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+         RSA *rsa, int padding)
+    {
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+#if defined(CAVIUM_FIPS)
+        ret = pkp_rsa_private_encrypt(flen, (unsigned char *)from, to, rsa , 1 );
+#else
+        ret = pkp_rsa_private_encrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+        if(ret)
+            return ret;
+        }
+#endif
 #ifdef OPENSSL_FIPS
-	if(FIPS_mode() && !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
-		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
-		return 0;
-		}
+    if(FIPS_mode() && !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
+        {
+        RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
+        return 0;
+        }
 #endif
-	return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
-	}
+    return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
+    }
 
 int RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
-	return(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));
-	}
+         RSA *rsa, int padding)
+    {
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+#ifdef CAVIUM_FIPS
+        ret = pkp_rsa_private_decrypt(flen, (unsigned char *)from, to, rsa , 1 );
+#else
+        ret = pkp_rsa_private_decrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+        if(ret)
+            return ret;
+        }
+#endif
+    return(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));
+    }
+
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+int RSA_public_decrypt_cav(void *s ,int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa, int padding)
+    {
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+        ret = pkp_rsa_public_decrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+        if (ret)
+            return ret;
+        }
+    return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
+    }
+#endif
 
 int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+         RSA *rsa, int padding)
+    {
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+#ifdef CAVIUM_FIPS
+        ret = pkp_rsa_public_decrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+        ret = pkp_rsa_public_decrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+        if(ret)
+            return ret;
+        }
+#endif
 #ifdef OPENSSL_FIPS
-	if(FIPS_mode() && !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
-		RSAerr(RSA_F_RSA_PUBLIC_DECRYPT, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
-		return 0;
-		}
+    if(FIPS_mode() && !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
+        {
+        RSAerr(RSA_F_RSA_PUBLIC_DECRYPT, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
+        return 0;
+        }
 #endif
-	return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
-	}
+    return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
+    }
 
 int RSA_size(const RSA *r)
-	{
-	return(BN_num_bytes(r->n));
-	}
+    {
+    return(BN_num_bytes(r->n));
+    }
+
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+int RSA_public_encrypt_cav(void *s,int flen, const unsigned char *from,
+        unsigned char *to, RSA *rsa, int padding)
+    {
+    if(padding == RSA_PKCS1_PADDING)
+        {
+        int ret;
+        ret = pkp_rsa_public_encrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+        if (ret)
+            return ret;
+        }
+    return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
+    }
+#endif
+
 
 void RSA_blinding_off(RSA *rsa)
-	{
-	if (rsa->blinding != NULL)
-		{
-		BN_BLINDING_free(rsa->blinding);
-		rsa->blinding=NULL;
-		}
-	rsa->flags &= ~RSA_FLAG_BLINDING;
-	rsa->flags |= RSA_FLAG_NO_BLINDING;
-	}
+    {
+    if (rsa->blinding != NULL)
+        {
+        BN_BLINDING_free(rsa->blinding);
+        rsa->blinding=NULL;
+        }
+    rsa->flags &= ~RSA_FLAG_BLINDING;
+    rsa->flags |= RSA_FLAG_NO_BLINDING;
+    }
 
 int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
-	{
-	int ret=0;
+    {
+    int ret=0;
 
-	if (rsa->blinding != NULL)
-		RSA_blinding_off(rsa);
+    if (rsa->blinding != NULL)
+        RSA_blinding_off(rsa);
 
-	rsa->blinding = RSA_setup_blinding(rsa, ctx);
-	if (rsa->blinding == NULL)
-		goto err;
-
-	rsa->flags |= RSA_FLAG_BLINDING;
-	rsa->flags &= ~RSA_FLAG_NO_BLINDING;
-	ret=1;
+    rsa->blinding = RSA_setup_blinding(rsa, ctx);
+    if (rsa->blinding == NULL)
+        goto err;
+
+    rsa->flags |= RSA_FLAG_BLINDING;
+    rsa->flags &= ~RSA_FLAG_NO_BLINDING;
+    ret=1;
 err:
-	return(ret);
-	}
+    return(ret);
+    }
 
 static BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,
-	const BIGNUM *q, BN_CTX *ctx)
+    const BIGNUM *q, BN_CTX *ctx)
 {
-	BIGNUM *ret = NULL, *r0, *r1, *r2;
+    BIGNUM *ret = NULL, *r0, *r1, *r2;
 
-	if (d == NULL || p == NULL || q == NULL)
-		return NULL;
+    if (d == NULL || p == NULL || q == NULL)
+        return NULL;
 
-	BN_CTX_start(ctx);
-	r0 = BN_CTX_get(ctx);
-	r1 = BN_CTX_get(ctx);
-	r2 = BN_CTX_get(ctx);
-	if (r2 == NULL)
-		goto err;
-
-	if (!BN_sub(r1, p, BN_value_one())) goto err;
-	if (!BN_sub(r2, q, BN_value_one())) goto err;
-	if (!BN_mul(r0, r1, r2, ctx)) goto err;
+    BN_CTX_start(ctx);
+    r0 = BN_CTX_get(ctx);
+    r1 = BN_CTX_get(ctx);
+    r2 = BN_CTX_get(ctx);
+    if (r2 == NULL)
+        goto err;
+
+    if (!BN_sub(r1, p, BN_value_one())) goto err;
+    if (!BN_sub(r2, q, BN_value_one())) goto err;
+    if (!BN_mul(r0, r1, r2, ctx)) goto err;
 
-	ret = BN_mod_inverse(NULL, d, r0, ctx);
+    ret = BN_mod_inverse(NULL, d, r0, ctx);
 err:
-	BN_CTX_end(ctx);
-	return ret;
+    BN_CTX_end(ctx);
+    return ret;
 }
 
 BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
 {
-	BIGNUM local_n;
-	BIGNUM *e,*n;
-	BN_CTX *ctx;
-	BN_BLINDING *ret = NULL;
-
-	if (in_ctx == NULL)
-		{
-		if ((ctx = BN_CTX_new()) == NULL) return 0;
-		}
-	else
-		ctx = in_ctx;
-
-	BN_CTX_start(ctx);
-	e  = BN_CTX_get(ctx);
-	if (e == NULL)
-		{
-		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-
-	if (rsa->e == NULL)
-		{
-		e = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);
-		if (e == NULL)
-			{
-			RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
-			goto err;
-			}
-		}
-	else
-		e = rsa->e;
-
-	
-	if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
-		{
-		/* if PRNG is not properly seeded, resort to secret
-		 * exponent as unpredictable seed */
-		RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);
-		}
-
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		/* Set BN_FLG_CONSTTIME flag */
-		n = &local_n;
-		BN_with_flags(n, rsa->n, BN_FLG_CONSTTIME);
-		}
-	else
-		n = rsa->n;
-
-	ret = BN_BLINDING_create_param(NULL, e, n, ctx,
-			rsa->meth->bn_mod_exp, rsa->_method_mod_n);
-	if (ret == NULL)
-		{
-		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);
-		goto err;
-		}
-	BN_BLINDING_set_thread_id(ret, CRYPTO_thread_id());
+    BIGNUM local_n;
+    BIGNUM *e,*n;
+    BN_CTX *ctx;
+    BN_BLINDING *ret = NULL;
+
+    if (in_ctx == NULL)
+        {
+        if ((ctx = BN_CTX_new()) == NULL) return 0;
+        }
+    else
+        ctx = in_ctx;
+
+    BN_CTX_start(ctx);
+    e  = BN_CTX_get(ctx);
+    if (e == NULL)
+        {
+        RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
+        goto err;
+        }
+
+    if (rsa->e == NULL)
+        {
+        e = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);
+        if (e == NULL)
+            {
+            RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
+            goto err;
+            }
+        }
+    else
+        e = rsa->e;
+
+
+    if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
+        {
+        /* if PRNG is not properly seeded, resort to secret
+         * exponent as unpredictable seed */
+        RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);
+        }
+
+    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
+        {
+        /* Set BN_FLG_CONSTTIME flag */
+        n = &local_n;
+        BN_with_flags(n, rsa->n, BN_FLG_CONSTTIME);
+        }
+    else
+        n = rsa->n;
+
+    ret = BN_BLINDING_create_param(NULL, e, n, ctx,
+            rsa->meth->bn_mod_exp, rsa->_method_mod_n);
+    if (ret == NULL)
+        {
+        RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);
+        goto err;
+        }
+    BN_BLINDING_set_thread_id(ret, CRYPTO_thread_id());
 err:
-	BN_CTX_end(ctx);
-	if (in_ctx == NULL)
-		BN_CTX_free(ctx);
-	if(rsa->e == NULL)
-		BN_free(e);
+    BN_CTX_end(ctx);
+    if (in_ctx == NULL)
+        BN_CTX_free(ctx);
+    if(rsa->e == NULL)
+        BN_free(e);
 
-	return ret;
+    return ret;
 }
diff -Naur openssl-0.9.8j/crypto/rsa/rsa_sign.c TurboSSL-0.9.8j/crypto/rsa/rsa_sign.c
--- openssl-0.9.8j/crypto/rsa/rsa_sign.c	2008-09-16 16:55:26.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rsa/rsa_sign.c	2010-05-31 12:14:39.000000000 +0200
@@ -66,9 +66,29 @@
 /* Size of an SSL signature: MD5+SHA1 */
 #define SSL_SIG_LENGTH	36
 
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+static int RSA_sign_cav2(int cav_mode,void *ssl,int type,const unsigned char *m,
+        unsigned int m_len,unsigned char *sigret,unsigned int *siglen,RSA *rsa);
+
+int RSA_sign_cav(void *ssl,int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+	{
+	return(RSA_sign_cav2(1,ssl,type,m,m_len,sigret,siglen,rsa));
+	}
+
 int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
 	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
 	{
+	return(RSA_sign_cav2(0,NULL,type,m,m_len,sigret,siglen,rsa));
+	}
+
+static int RSA_sign_cav2(int cav_mode,void *ssl,int type,const unsigned char *m,
+        unsigned int m_len,unsigned char *sigret,unsigned int *siglen,RSA *rsa)
+#else
+int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+#endif		 
+	{
 	X509_SIG sig;
 	ASN1_TYPE parameter;
 	int i,j,ret=1;
@@ -137,6 +157,12 @@
 		i2d_X509_SIG(&sig,&p);
 		s=tmps;
 	}
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	if (cav_mode) {
+		i=RSA_private_encrypt_cav(ssl,i,s,sigret,rsa,RSA_PKCS1_PADDING);
+		if ( i == -EAGAIN ) ret = i;
+	} else
+#endif
 	i=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);
 	if (i <= 0)
 		ret=0;meth->rsa_priv_enc(i,s,sigret,rsa,RSA_PKCS1_PADDING);
 #else
@@ -150,8 +176,30 @@
 	return(ret);
 	}
 
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+int RSA_verify_cav2(int cav_mode, void *ssl,int dtype, 
+        const unsigned char *m, unsigned int m_len, 
+        unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+
+int RSA_verify_cav(void *ssl,int dtype, const unsigned char *m, 
+    unsigned int m_len, unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+{
+	return (RSA_verify_cav2(1,ssl,dtype,m,m_len,sigbuf,siglen,rsa));
+}
+
+int RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+{
+	return (RSA_verify_cav2(0,NULL,dtype,m,m_len,sigbuf,siglen,rsa));
+}
+
+int RSA_verify_cav2(int cav_mode, void *ssl,int dtype, 
+    const unsigned char *m, unsigned int m_len,
+    unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+#else
 int RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
 	     unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+#endif
 	{
 	int i,ret=0,sigtype;
 	unsigned char *s;
@@ -191,6 +239,16 @@
 		return 0;
 		}
 #endif
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	if (cav_mode) {
+		i=RSA_public_decrypt_cav(ssl,(int)siglen,sigbuf,s,
+						rsa,RSA_PKCS1_PADDING);
+		if (i == -EAGAIN) {
+			ret = i;
+			goto err ;
+		}
+	} else
+#endif
 	i=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);
 
 	if (i <= 0) goto err;
diff -Naur openssl-0.9.8j/crypto/rsa/rsa_test.c TurboSSL-0.9.8j/crypto/rsa/rsa_test.c
--- openssl-0.9.8j/crypto/rsa/rsa_test.c	2007-04-04 14:50:12.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/rsa/rsa_test.c	2010-05-31 12:14:39.000000000 +0200
@@ -4,6 +4,13 @@
 #include <string.h>
 
 #include "e_os.h"
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
 
 #include <openssl/crypto.h>
 #include <openssl/err.h>
@@ -220,6 +227,35 @@
     int clen = 0;
     int num;
     int n;
+#ifdef CAVIUM_SSL
+#if 0 //jjose
+#ifndef CAVIUM_FIPS
+    int driver_open = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+       if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))	
+	           driver_open = 1;
+        }
+#else   
+        if(CSP1_driver_handle == -1)
+        {
+
+          if(!Csp1Initialize(CAVIUM_DIRECT))
+	           driver_open = 1;
+        }
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+         if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+         if(Cfm1Initialize(500,DIRECT))
+#endif
+		; /*return 0; */
+#endif
+#endif
+#endif
 
     CRYPTO_malloc_debug_init();
     CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
@@ -331,6 +367,20 @@
     ERR_remove_state(0);
 
     CRYPTO_mem_leaks_fp(stderr);
+#ifdef CAVIUM_SSL
+#if 0 //jjose
+#ifndef CAVIUM_FIPS
+     if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+        Csp1Shutdown();
+#endif
+#else
+        Cfm1Shutdown();
+#endif
+#endif
+#endif
 
 #ifdef OPENSSL_SYS_NETWARE
     if (err) printf("ERROR: %d\n", err);
diff -Naur openssl-0.9.8j/crypto/rsa_d/Makefile TurboSSL-0.9.8j/crypto/rsa_d/Makefile
--- openssl-0.9.8j/crypto/rsa_d/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,239 @@
+#
+# OpenSSL/crypto/rsa/Makefile
+#
+
+DIR=	rsa
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=rsa_test.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC= rsa_eay.c rsa_gen.c rsa_lib.c rsa_sign.c rsa_saos.c rsa_err.c \
+	rsa_pk1.c rsa_ssl.c rsa_none.c rsa_oaep.c rsa_chk.c rsa_null.c \
+	rsa_pss.c rsa_x931.c rsa_asn1.c rsa_depr.c
+LIBOBJ= rsa_eay.o rsa_gen.o rsa_lib.o rsa_sign.o rsa_saos.o rsa_err.o \
+	rsa_pk1.o rsa_ssl.o rsa_none.o rsa_oaep.o rsa_chk.o rsa_null.o \
+	rsa_pss.o rsa_x931.o rsa_asn1.o rsa_depr.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= rsa.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+rsa_asn1.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_asn1.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+rsa_asn1.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+rsa_asn1.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+rsa_asn1.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+rsa_asn1.o: ../../include/openssl/opensslconf.h
+rsa_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_asn1.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_asn1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_asn1.o: ../cryptlib.h rsa_asn1.c
+rsa_chk.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+rsa_chk.o: ../../include/openssl/bn.h ../../include/openssl/crypto.h
+rsa_chk.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_chk.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_chk.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_chk.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_chk.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_chk.o: rsa_chk.c
+rsa_depr.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_depr.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_depr.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_depr.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_depr.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_depr.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_depr.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_depr.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_depr.o: ../cryptlib.h rsa_depr.c
+rsa_eay.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_eay.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_eay.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_eay.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_eay.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_eay.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_eay.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_eay.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_eay.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_eay.c
+rsa_err.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+rsa_err.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+rsa_err.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+rsa_err.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+rsa_err.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rsa.h
+rsa_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_err.o: ../../include/openssl/symhacks.h rsa_err.c
+rsa_gen.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_gen.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_gen.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_gen.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_gen.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_gen.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_gen.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_gen.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_gen.o: ../cryptlib.h rsa_gen.c
+rsa_lib.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_lib.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_lib.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_lib.o: ../../include/openssl/e_os2.h ../../include/openssl/engine.h
+rsa_lib.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+rsa_lib.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+rsa_lib.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
+rsa_lib.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_lib.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_lib.o: ../cryptlib.h rsa_lib.c
+rsa_none.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_none.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_none.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_none.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_none.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_none.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_none.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_none.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_none.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_none.c
+rsa_null.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_null.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_null.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_null.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_null.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_null.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_null.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_null.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_null.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_null.c
+rsa_oaep.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_oaep.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_oaep.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_oaep.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_oaep.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+rsa_oaep.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+rsa_oaep.o: ../../include/openssl/opensslconf.h
+rsa_oaep.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_oaep.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_oaep.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+rsa_oaep.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_oaep.o: ../cryptlib.h rsa_oaep.c
+rsa_pk1.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_pk1.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_pk1.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_pk1.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_pk1.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_pk1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_pk1.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_pk1.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_pk1.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_pk1.c
+rsa_pss.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_pss.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_pss.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_pss.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_pss.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+rsa_pss.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+rsa_pss.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+rsa_pss.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
+rsa_pss.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+rsa_pss.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+rsa_pss.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_pss.c
+rsa_saos.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_saos.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_saos.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_saos.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+rsa_saos.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+rsa_saos.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+rsa_saos.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+rsa_saos.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+rsa_saos.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_saos.o: ../../include/openssl/pkcs7.h ../../include/openssl/rsa.h
+rsa_saos.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+rsa_saos.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_saos.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+rsa_saos.o: ../cryptlib.h rsa_saos.c
+rsa_sign.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_sign.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_sign.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_sign.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+rsa_sign.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+rsa_sign.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+rsa_sign.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+rsa_sign.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+rsa_sign.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_sign.o: ../../include/openssl/pkcs7.h ../../include/openssl/rsa.h
+rsa_sign.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+rsa_sign.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+rsa_sign.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+rsa_sign.o: ../cryptlib.h rsa_sign.c
+rsa_ssl.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_ssl.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_ssl.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_ssl.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_ssl.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+rsa_ssl.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_ssl.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_ssl.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_ssl.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_ssl.c
+rsa_x931.o: ../../e_os.h ../../include/openssl/asn1.h
+rsa_x931.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+rsa_x931.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+rsa_x931.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+rsa_x931.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+rsa_x931.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
+rsa_x931.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+rsa_x931.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+rsa_x931.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+rsa_x931.o: ../../include/openssl/symhacks.h ../cryptlib.h rsa_x931.c
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_asn1.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_asn1.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_asn1.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_asn1.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,121 @@
+/* rsa_asn1.c */
+/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL
+ * project 2000.
+ */
+/* ====================================================================
+ * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/asn1t.h>
+
+static ASN1_METHOD method={
+        (I2D_OF(void))     i2d_RSAPrivateKey,
+        (D2I_OF(void))     d2i_RSAPrivateKey,
+        (void *(*)(void))  RSA_new,
+        (void (*)(void *)) RSA_free};
+
+ASN1_METHOD *RSAPrivateKey_asn1_meth(void)
+	{
+	return(&method);
+	}
+
+/* Override the default free and new methods */
+static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
+{
+	if(operation == ASN1_OP_NEW_PRE) {
+		*pval = (ASN1_VALUE *)RSA_new();
+		if(*pval) return 2;
+		return 0;
+	} else if(operation == ASN1_OP_FREE_PRE) {
+		RSA_free((RSA *)*pval);
+		*pval = NULL;
+		return 2;
+	}
+	return 1;
+}
+
+ASN1_SEQUENCE_cb(RSAPrivateKey, rsa_cb) = {
+	ASN1_SIMPLE(RSA, version, LONG),
+	ASN1_SIMPLE(RSA, n, BIGNUM),
+	ASN1_SIMPLE(RSA, e, BIGNUM),
+	ASN1_SIMPLE(RSA, d, BIGNUM),
+	ASN1_SIMPLE(RSA, p, BIGNUM),
+	ASN1_SIMPLE(RSA, q, BIGNUM),
+	ASN1_SIMPLE(RSA, dmp1, BIGNUM),
+	ASN1_SIMPLE(RSA, dmq1, BIGNUM),
+	ASN1_SIMPLE(RSA, iqmp, BIGNUM)
+} ASN1_SEQUENCE_END_cb(RSA, RSAPrivateKey)
+
+
+ASN1_SEQUENCE_cb(RSAPublicKey, rsa_cb) = {
+	ASN1_SIMPLE(RSA, n, BIGNUM),
+	ASN1_SIMPLE(RSA, e, BIGNUM),
+} ASN1_SEQUENCE_END_cb(RSA, RSAPublicKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(RSA, RSAPrivateKey, RSAPrivateKey)
+
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(RSA, RSAPublicKey, RSAPublicKey)
+
+RSA *RSAPublicKey_dup(RSA *rsa)
+	{
+	return ASN1_item_dup(ASN1_ITEM_rptr(RSAPublicKey), rsa);
+	}
+
+RSA *RSAPrivateKey_dup(RSA *rsa)
+	{
+	return ASN1_item_dup(ASN1_ITEM_rptr(RSAPrivateKey), rsa);
+	}
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_chk.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_chk.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_chk.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_chk.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,184 @@
+/* crypto/rsa/rsa_chk.c  -*- Mode: C; c-file-style: "eay" -*- */
+/* ====================================================================
+ * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#include <openssl/bn.h>
+#include <openssl/err.h>
+#include <openssl/rsa.h>
+
+
+int RSA_check_key(const RSA *key)
+	{
+	BIGNUM *i, *j, *k, *l, *m;
+	BN_CTX *ctx;
+	int r;
+	int ret=1;
+	
+	i = BN_new();
+	j = BN_new();
+	k = BN_new();
+	l = BN_new();
+	m = BN_new();
+	ctx = BN_CTX_new();
+	if (i == NULL || j == NULL || k == NULL || l == NULL ||
+		m == NULL || ctx == NULL)
+		{
+		ret = -1;
+		RSAerr(RSA_F_RSA_CHECK_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	
+	/* p prime? */
+	r = BN_is_prime_ex(key->p, BN_prime_checks, NULL, NULL);
+	if (r != 1)
+		{
+		ret = r;
+		if (r != 0)
+			goto err;
+		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_P_NOT_PRIME);
+		}
+	
+	/* q prime? */
+	r = BN_is_prime_ex(key->q, BN_prime_checks, NULL, NULL);
+	if (r != 1)
+		{
+		ret = r;
+		if (r != 0)
+			goto err;
+		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_Q_NOT_PRIME);
+		}
+	
+	/* n = p*q? */
+	r = BN_mul(i, key->p, key->q, ctx);
+	if (!r) { ret = -1; goto err; }
+	
+	if (BN_cmp(i, key->n) != 0)
+		{
+		ret = 0;
+		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_N_DOES_NOT_EQUAL_P_Q);
+		}
+	
+	/* d*e = 1  mod lcm(p-1,q-1)? */
+
+	r = BN_sub(i, key->p, BN_value_one());
+	if (!r) { ret = -1; goto err; }
+	r = BN_sub(j, key->q, BN_value_one());
+	if (!r) { ret = -1; goto err; }
+
+	/* now compute k = lcm(i,j) */
+	r = BN_mul(l, i, j, ctx);
+	if (!r) { ret = -1; goto err; }
+	r = BN_gcd(m, i, j, ctx);
+	if (!r) { ret = -1; goto err; }
+	r = BN_div(k, NULL, l, m, ctx); /* remainder is 0 */
+	if (!r) { ret = -1; goto err; }
+
+	r = BN_mod_mul(i, key->d, key->e, k, ctx);
+	if (!r) { ret = -1; goto err; }
+
+	if (!BN_is_one(i))
+		{
+		ret = 0;
+		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_D_E_NOT_CONGRUENT_TO_1);
+		}
+	
+	if (key->dmp1 != NULL && key->dmq1 != NULL && key->iqmp != NULL)
+		{
+		/* dmp1 = d mod (p-1)? */
+		r = BN_sub(i, key->p, BN_value_one());
+		if (!r) { ret = -1; goto err; }
+
+		r = BN_mod(j, key->d, i, ctx);
+		if (!r) { ret = -1; goto err; }
+
+		if (BN_cmp(j, key->dmp1) != 0)
+			{
+			ret = 0;
+			RSAerr(RSA_F_RSA_CHECK_KEY,
+				RSA_R_DMP1_NOT_CONGRUENT_TO_D);
+			}
+	
+		/* dmq1 = d mod (q-1)? */    
+		r = BN_sub(i, key->q, BN_value_one());
+		if (!r) { ret = -1; goto err; }
+	
+		r = BN_mod(j, key->d, i, ctx);
+		if (!r) { ret = -1; goto err; }
+
+		if (BN_cmp(j, key->dmq1) != 0)
+			{
+			ret = 0;
+			RSAerr(RSA_F_RSA_CHECK_KEY,
+				RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
+			}
+	
+		/* iqmp = q^-1 mod p? */
+		if(!BN_mod_inverse(i, key->q, key->p, ctx))
+			{
+			ret = -1;
+			goto err;
+			}
+
+		if (BN_cmp(i, key->iqmp) != 0)
+			{
+			ret = 0;
+			RSAerr(RSA_F_RSA_CHECK_KEY,
+				RSA_R_IQMP_NOT_INVERSE_OF_Q);
+			}
+		}
+
+ err:
+	if (i != NULL) BN_free(i);
+	if (j != NULL) BN_free(j);
+	if (k != NULL) BN_free(k);
+	if (l != NULL) BN_free(l);
+	if (m != NULL) BN_free(m);
+	if (ctx != NULL) BN_CTX_free(ctx);
+	return (ret);
+	}
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_depr.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_depr.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_depr.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_depr.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,101 @@
+/* crypto/rsa/rsa_depr.c */
+/* ====================================================================
+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NB: This file contains deprecated functions (compatibility wrappers to the
+ * "new" versions). */
+
+#include <stdio.h>
+#include <time.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+
+#ifdef OPENSSL_NO_DEPRECATED
+
+static void *dummy=&dummy;
+
+#else
+
+RSA *RSA_generate_key(int bits, unsigned long e_value,
+	     void (*callback)(int,int,void *), void *cb_arg)
+	{
+	BN_GENCB cb;
+	int i;
+	RSA *rsa = RSA_new();
+	BIGNUM *e = BN_new();
+
+	if(!rsa || !e) goto err;
+
+	/* The problem is when building with 8, 16, or 32 BN_ULONG,
+	 * unsigned long can be larger */
+	for (i=0; i<(int)sizeof(unsigned long)*8; i++)
+		{
+		if (e_value & (1UL<<i))
+			if (BN_set_bit(e,i) == 0)
+				goto err;
+		}
+
+	BN_GENCB_set_old(&cb, callback, cb_arg);
+
+	if(RSA_generate_key_ex(rsa, bits, e, &cb)) {
+		BN_free(e);
+		return rsa;
+	}
+err:
+	if(e) BN_free(e);
+	if(rsa) RSA_free(rsa);
+	return 0;
+	}
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_eay.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_eay.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_eay.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_eay.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,827 @@
+/* crypto/rsa/rsa_eay.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+#ifndef RSA_NULL
+
+static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);
+static int RSA_eay_init(RSA *rsa);
+static int RSA_eay_finish(RSA *rsa);
+static RSA_METHOD rsa_pkcs1_eay_meth={
+	"Eric Young's PKCS#1 RSA",
+	RSA_eay_public_encrypt,
+	RSA_eay_public_decrypt, /* signature verification */
+	RSA_eay_private_encrypt, /* signing */
+	RSA_eay_private_decrypt,
+	RSA_eay_mod_exp,
+	BN_mod_exp_mont, /* XXX probably we should not use Montgomery if  e == 3 */
+	RSA_eay_init,
+	RSA_eay_finish,
+	0, /* flags */
+	NULL,
+	0, /* rsa_sign */
+	0, /* rsa_verify */
+	NULL /* rsa_keygen */
+	};
+
+const RSA_METHOD *RSA_PKCS1_SSLeay(void)
+	{
+	return(&rsa_pkcs1_eay_meth);
+	}
+
+/* Usage example;
+ *    MONT_HELPER(rsa, bn_ctx, p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
+ */
+#define MONT_HELPER(rsa, ctx, m, pre_cond, err_instr) \
+	if((pre_cond) && ((rsa)->_method_mod_##m == NULL) && \
+			!BN_MONT_CTX_set_locked(&((rsa)->_method_mod_##m), \
+				CRYPTO_LOCK_RSA, \
+				(rsa)->m, (ctx))) \
+		err_instr
+
+static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM *f,*ret;
+	int i,j,k,num=0,r= -1;
+	unsigned char *buf=NULL;
+	BN_CTX *ctx=NULL;
+
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
+	if (BN_ucmp(rsa->n, rsa->e) <= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+		}
+
+	/* for large moduli, enforce exponent limit */
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
+		{
+		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
+			{
+			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+			return -1;
+			}
+		}
+	
+	if ((ctx=BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+	f = BN_CTX_get(ctx);
+	ret = BN_CTX_get(ctx);
+	num=BN_num_bytes(rsa->n);
+	buf = OPENSSL_malloc(num);
+	if (!f || !ret || !buf)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);
+		break;
+#ifndef OPENSSL_NO_SHA
+	case RSA_PKCS1_OAEP_PADDING:
+	        i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);
+		break;
+#endif
+	case RSA_SSLV23_PADDING:
+		i=RSA_padding_add_SSLv23(buf,num,from,flen);
+		break;
+	case RSA_NO_PADDING:
+		i=RSA_padding_add_none(buf,num,from,flen);
+		break;
+	default:
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (i <= 0) goto err;
+
+	if (BN_bin2bn(buf,num,f) == NULL) goto err;
+	
+	if (BN_ucmp(f, rsa->n) >= 0)
+		{	
+		/* usually the padding functions would catch this */
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	MONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
+
+	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
+		rsa->_method_mod_n)) goto err;
+
+	/* put in leading 0 bytes if the number is less than the
+	 * length of the modulus */
+	j=BN_num_bytes(ret);
+	i=BN_bn2bin(ret,&(to[num-j]));
+	for (k=0; k<(num-i); k++)
+		to[k]=0;
+
+	r=num;
+err:
+	if (ctx != NULL)
+		{
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+		}
+	if (buf != NULL) 
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
+{
+	BN_BLINDING *ret;
+	int got_write_lock = 0;
+
+	CRYPTO_r_lock(CRYPTO_LOCK_RSA);
+
+	if (rsa->blinding == NULL)
+		{
+		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
+		CRYPTO_w_lock(CRYPTO_LOCK_RSA);
+		got_write_lock = 1;
+
+		if (rsa->blinding == NULL)
+			rsa->blinding = RSA_setup_blinding(rsa, ctx);
+		}
+
+	ret = rsa->blinding;
+	if (ret == NULL)
+		goto err;
+
+	if (BN_BLINDING_get_thread_id(ret) == CRYPTO_thread_id())
+		{
+		/* rsa->blinding is ours! */
+
+		*local = 1;
+		}
+	else
+		{
+		/* resort to rsa->mt_blinding instead */
+
+		*local = 0; /* instructs rsa_blinding_convert(), rsa_blinding_invert()
+		             * that the BN_BLINDING is shared, meaning that accesses
+		             * require locks, and that the blinding factor must be
+		             * stored outside the BN_BLINDING
+		             */
+
+		if (rsa->mt_blinding == NULL)
+			{
+			if (!got_write_lock)
+				{
+				CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
+				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
+				got_write_lock = 1;
+				}
+			
+			if (rsa->mt_blinding == NULL)
+				rsa->mt_blinding = RSA_setup_blinding(rsa, ctx);
+			}
+		ret = rsa->mt_blinding;
+		}
+
+ err:
+	if (got_write_lock)
+		CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
+	else
+		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
+	return ret;
+}
+
+static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,
+	BIGNUM *r, BN_CTX *ctx)
+{
+	if (local)
+		return BN_BLINDING_convert_ex(f, NULL, b, ctx);
+	else
+		{
+		int ret;
+		CRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);
+		ret = BN_BLINDING_convert_ex(f, r, b, ctx);
+		CRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);
+		return ret;
+		}
+}
+
+static int rsa_blinding_invert(BN_BLINDING *b, int local, BIGNUM *f,
+	BIGNUM *r, BN_CTX *ctx)
+{
+	if (local)
+		return BN_BLINDING_invert_ex(f, NULL, b, ctx);
+	else
+		{
+		int ret;
+		CRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);
+		ret = BN_BLINDING_invert_ex(f, r, b, ctx);
+		CRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);
+		return ret;
+		}
+}
+
+/* signing */
+static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM *f, *ret, *br, *res;
+	int i,j,k,num=0,r= -1;
+	unsigned char *buf=NULL;
+	BN_CTX *ctx=NULL;
+	int local_blinding = 0;
+	BN_BLINDING *blinding = NULL;
+
+	if ((ctx=BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+	f   = BN_CTX_get(ctx);
+	br  = BN_CTX_get(ctx);
+	ret = BN_CTX_get(ctx);
+	num = BN_num_bytes(rsa->n);
+	buf = OPENSSL_malloc(num);
+	if(!f || !ret || !buf)
+		{
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		i=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);
+		break;
+	case RSA_X931_PADDING:
+		i=RSA_padding_add_X931(buf,num,from,flen);
+		break;
+	case RSA_NO_PADDING:
+		i=RSA_padding_add_none(buf,num,from,flen);
+		break;
+	case RSA_SSLV23_PADDING:
+	default:
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (i <= 0) goto err;
+
+	if (BN_bin2bn(buf,num,f) == NULL) goto err;
+	
+	if (BN_ucmp(f, rsa->n) >= 0)
+		{	
+		/* usually the padding functions would catch this */
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
+		{
+		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
+		if (blinding == NULL)
+			{
+			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);
+			goto err;
+			}
+		}
+	
+	if (blinding != NULL)
+		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
+			goto err;
+
+	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
+		((rsa->p != NULL) &&
+		(rsa->q != NULL) &&
+		(rsa->dmp1 != NULL) &&
+		(rsa->dmq1 != NULL) &&
+		(rsa->iqmp != NULL)) )
+		{ 
+		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
+		}
+	else
+		{
+		BIGNUM local_d;
+		BIGNUM *d = NULL;
+		
+		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
+			{
+			BN_init(&local_d);
+			d = &local_d;
+			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
+			}
+		else
+			d = rsa->d;
+
+		MONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
+
+		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
+				rsa->_method_mod_n)) goto err;
+		}
+
+	if (blinding)
+		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
+			goto err;
+
+	if (padding == RSA_X931_PADDING)
+		{
+		BN_sub(f, rsa->n, ret);
+		if (BN_cmp(ret, f))
+			res = f;
+		else
+			res = ret;
+		}
+	else
+		res = ret;
+
+	/* put in leading 0 bytes if the number is less than the
+	 * length of the modulus */
+	j=BN_num_bytes(res);
+	i=BN_bn2bin(res,&(to[num-j]));
+	for (k=0; k<(num-i); k++)
+		to[k]=0;
+
+	r=num;
+err:
+	if (ctx != NULL)
+		{
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+		}
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM *f, *ret, *br;
+	int j,num=0,r= -1;
+	unsigned char *p;
+	unsigned char *buf=NULL;
+	BN_CTX *ctx=NULL;
+	int local_blinding = 0;
+	BN_BLINDING *blinding = NULL;
+
+	if((ctx = BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+	f   = BN_CTX_get(ctx);
+	br  = BN_CTX_get(ctx);
+	ret = BN_CTX_get(ctx);
+	num = BN_num_bytes(rsa->n);
+	buf = OPENSSL_malloc(num);
+	if(!f || !ret || !buf)
+		{
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	/* This check was for equality but PGP does evil things
+	 * and chops off the top '0' bytes */
+	if (flen > num)
+		{
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
+		goto err;
+		}
+
+	/* make data into a big number */
+	if (BN_bin2bn(from,(int)flen,f) == NULL) goto err;
+
+	if (BN_ucmp(f, rsa->n) >= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
+		{
+		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
+		if (blinding == NULL)
+			{
+			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);
+			goto err;
+			}
+		}
+	
+	if (blinding != NULL)
+		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
+			goto err;
+
+	/* do the decrypt */
+	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
+		((rsa->p != NULL) &&
+		(rsa->q != NULL) &&
+		(rsa->dmp1 != NULL) &&
+		(rsa->dmq1 != NULL) &&
+		(rsa->iqmp != NULL)) )
+		{
+		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
+		}
+	else
+		{
+		BIGNUM local_d;
+		BIGNUM *d = NULL;
+		
+		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
+			{
+			d = &local_d;
+			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
+			}
+		else
+			d = rsa->d;
+
+		MONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
+		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
+				rsa->_method_mod_n))
+		  goto err;
+		}
+
+	if (blinding)
+		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
+			goto err;
+
+	p=buf;
+	j=BN_bn2bin(ret,p); /* j is only used with no-padding mode */
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		r=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);
+		break;
+#ifndef OPENSSL_NO_SHA
+        case RSA_PKCS1_OAEP_PADDING:
+	        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);
+                break;
+#endif
+ 	case RSA_SSLV23_PADDING:
+		r=RSA_padding_check_SSLv23(to,num,buf,j,num);
+		break;
+	case RSA_NO_PADDING:
+		r=RSA_padding_check_none(to,num,buf,j,num);
+		break;
+	default:
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (r < 0)
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
+
+err:
+	if (ctx != NULL)
+		{
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+		}
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+/* signature verification */
+static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM *f,*ret;
+	int i,num=0,r= -1;
+	unsigned char *p;
+	unsigned char *buf=NULL;
+	BN_CTX *ctx=NULL;
+
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
+		return -1;
+		}
+
+	if (BN_ucmp(rsa->n, rsa->e) <= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+		}
+
+	/* for large moduli, enforce exponent limit */
+	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
+		{
+		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
+			{
+			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+			return -1;
+			}
+		}
+	
+	if((ctx = BN_CTX_new()) == NULL) goto err;
+	BN_CTX_start(ctx);
+	f = BN_CTX_get(ctx);
+	ret = BN_CTX_get(ctx);
+	num=BN_num_bytes(rsa->n);
+	buf = OPENSSL_malloc(num);
+	if(!f || !ret || !buf)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	/* This check was for equality but PGP does evil things
+	 * and chops off the top '0' bytes */
+	if (flen > num)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
+		goto err;
+		}
+
+	if (BN_bin2bn(from,flen,f) == NULL) goto err;
+
+	if (BN_ucmp(f, rsa->n) >= 0)
+		{
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	MONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
+
+	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
+		rsa->_method_mod_n)) goto err;
+
+	if ((padding == RSA_X931_PADDING) && ((ret->d[0] & 0xf) != 12))
+		BN_sub(ret, rsa->n, ret);
+
+	p=buf;
+	i=BN_bn2bin(ret,p);
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		r=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);
+		break;
+	case RSA_X931_PADDING:
+		r=RSA_padding_check_X931(to,num,buf,i,num);
+		break;
+	case RSA_NO_PADDING:
+		r=RSA_padding_check_none(to,num,buf,i,num);
+		break;
+	default:
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (r < 0)
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
+
+err:
+	if (ctx != NULL)
+		{
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+		}
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
+	{
+	BIGNUM *r1,*m1,*vrfy;
+	BIGNUM local_dmp1, local_dmq1;
+	BIGNUM *dmp1, *dmq1;
+	int ret=0;
+
+	BN_CTX_start(ctx);
+	r1 = BN_CTX_get(ctx);
+	m1 = BN_CTX_get(ctx);
+	vrfy = BN_CTX_get(ctx);
+
+	MONT_HELPER(rsa, ctx, p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
+	MONT_HELPER(rsa, ctx, q, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
+	MONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
+
+	if (!BN_mod(r1,I,rsa->q,ctx)) goto err;
+	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
+		{
+		dmq1 = &local_dmq1;
+		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_EXP_CONSTTIME);
+		}
+	else
+		dmq1 = rsa->dmq1;
+	if (!rsa->meth->bn_mod_exp(m1,r1,dmq1,rsa->q,ctx,
+		rsa->_method_mod_q)) goto err;
+
+	if (!BN_mod(r1,I,rsa->p,ctx)) goto err;
+	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
+		{
+		dmp1 = &local_dmp1;
+		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_EXP_CONSTTIME);
+		}
+	else
+		dmp1 = rsa->dmp1;
+	if (!rsa->meth->bn_mod_exp(r0,r1,dmp1,rsa->p,ctx,
+		rsa->_method_mod_p)) goto err;
+
+	if (!BN_sub(r0,r0,m1)) goto err;
+	/* This will help stop the size of r0 increasing, which does
+	 * affect the multiply if it optimised for a power of 2 size */
+	if (BN_is_negative(r0))
+		if (!BN_add(r0,r0,rsa->p)) goto err;
+
+	if (!BN_mul(r1,r0,rsa->iqmp,ctx)) goto err;
+	if (!BN_mod(r0,r1,rsa->p,ctx)) goto err;
+	/* If p < q it is occasionally possible for the correction of
+         * adding 'p' if r0 is negative above to leave the result still
+	 * negative. This can break the private key operations: the following
+	 * second correction should *always* correct this rare occurrence.
+	 * This will *never* happen with OpenSSL generated keys because
+         * they ensure p > q [steve]
+         */
+	if (BN_is_negative(r0))
+		if (!BN_add(r0,r0,rsa->p)) goto err;
+	if (!BN_mul(r1,r0,rsa->q,ctx)) goto err;
+	if (!BN_add(r0,r1,m1)) goto err;
+
+	if (rsa->e && rsa->n)
+		{
+		if (!rsa->meth->bn_mod_exp(vrfy,r0,rsa->e,rsa->n,ctx,rsa->_method_mod_n)) goto err;
+		/* If 'I' was greater than (or equal to) rsa->n, the operation
+		 * will be equivalent to using 'I mod n'. However, the result of
+		 * the verify will *always* be less than 'n' so we don't check
+		 * for absolute equality, just congruency. */
+		if (!BN_sub(vrfy, vrfy, I)) goto err;
+		if (!BN_mod(vrfy, vrfy, rsa->n, ctx)) goto err;
+		if (BN_is_negative(vrfy))
+			if (!BN_add(vrfy, vrfy, rsa->n)) goto err;
+		if (!BN_is_zero(vrfy))
+			{
+			/* 'I' and 'vrfy' aren't congruent mod n. Don't leak
+			 * miscalculated CRT output, just do a raw (slower)
+			 * mod_exp and return that instead. */
+
+			BIGNUM local_d;
+			BIGNUM *d = NULL;
+		
+			if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
+				{
+				d = &local_d;
+				BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
+				}
+			else
+				d = rsa->d;
+			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,
+						   rsa->_method_mod_n)) goto err;
+			}
+		}
+	ret=1;
+err:
+	BN_CTX_end(ctx);
+	return(ret);
+	}
+
+static int RSA_eay_init(RSA *rsa)
+	{
+	rsa->flags|=RSA_FLAG_CACHE_PUBLIC|RSA_FLAG_CACHE_PRIVATE;
+	return(1);
+	}
+
+static int RSA_eay_finish(RSA *rsa)
+	{
+	if (rsa->_method_mod_n != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_n);
+	if (rsa->_method_mod_p != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_p);
+	if (rsa->_method_mod_q != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_q);
+	return(1);
+	}
+
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_err.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_err.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_err.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_err.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,174 @@
+/* crypto/rsa/rsa_err.c */
+/* ====================================================================
+ * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+/* NOTE: this file was auto generated by the mkerr.pl script: any changes
+ * made to it will be overwritten when the script next updates this file,
+ * only reason strings will be preserved.
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include <openssl/rsa.h>
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+
+#define ERR_FUNC(func) ERR_PACK(ERR_LIB_RSA,func,0)
+#define ERR_REASON(reason) ERR_PACK(ERR_LIB_RSA,0,reason)
+
+static ERR_STRING_DATA RSA_str_functs[]=
+	{
+{ERR_FUNC(RSA_F_MEMORY_LOCK),	"MEMORY_LOCK"},
+{ERR_FUNC(RSA_F_RSA_BUILTIN_KEYGEN),	"RSA_BUILTIN_KEYGEN"},
+{ERR_FUNC(RSA_F_RSA_CHECK_KEY),	"RSA_check_key"},
+{ERR_FUNC(RSA_F_RSA_EAY_PRIVATE_DECRYPT),	"RSA_EAY_PRIVATE_DECRYPT"},
+{ERR_FUNC(RSA_F_RSA_EAY_PRIVATE_ENCRYPT),	"RSA_EAY_PRIVATE_ENCRYPT"},
+{ERR_FUNC(RSA_F_RSA_EAY_PUBLIC_DECRYPT),	"RSA_EAY_PUBLIC_DECRYPT"},
+{ERR_FUNC(RSA_F_RSA_EAY_PUBLIC_ENCRYPT),	"RSA_EAY_PUBLIC_ENCRYPT"},
+{ERR_FUNC(RSA_F_RSA_GENERATE_KEY),	"RSA_generate_key"},
+{ERR_FUNC(RSA_F_RSA_MEMORY_LOCK),	"RSA_memory_lock"},
+{ERR_FUNC(RSA_F_RSA_NEW_METHOD),	"RSA_new_method"},
+{ERR_FUNC(RSA_F_RSA_NULL),	"RSA_NULL"},
+{ERR_FUNC(RSA_F_RSA_NULL_MOD_EXP),	"RSA_NULL_MOD_EXP"},
+{ERR_FUNC(RSA_F_RSA_NULL_PRIVATE_DECRYPT),	"RSA_NULL_PRIVATE_DECRYPT"},
+{ERR_FUNC(RSA_F_RSA_NULL_PRIVATE_ENCRYPT),	"RSA_NULL_PRIVATE_ENCRYPT"},
+{ERR_FUNC(RSA_F_RSA_NULL_PUBLIC_DECRYPT),	"RSA_NULL_PUBLIC_DECRYPT"},
+{ERR_FUNC(RSA_F_RSA_NULL_PUBLIC_ENCRYPT),	"RSA_NULL_PUBLIC_ENCRYPT"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_NONE),	"RSA_padding_add_none"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP),	"RSA_padding_add_PKCS1_OAEP"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_PKCS1_PSS),	"RSA_padding_add_PKCS1_PSS"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1),	"RSA_padding_add_PKCS1_type_1"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2),	"RSA_padding_add_PKCS1_type_2"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_SSLV23),	"RSA_padding_add_SSLv23"},
+{ERR_FUNC(RSA_F_RSA_PADDING_ADD_X931),	"RSA_padding_add_X931"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_NONE),	"RSA_padding_check_none"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP),	"RSA_padding_check_PKCS1_OAEP"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1),	"RSA_padding_check_PKCS1_type_1"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2),	"RSA_padding_check_PKCS1_type_2"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_SSLV23),	"RSA_padding_check_SSLv23"},
+{ERR_FUNC(RSA_F_RSA_PADDING_CHECK_X931),	"RSA_padding_check_X931"},
+{ERR_FUNC(RSA_F_RSA_PRINT),	"RSA_print"},
+{ERR_FUNC(RSA_F_RSA_PRINT_FP),	"RSA_PRINT_FP"},
+{ERR_FUNC(RSA_F_RSA_SETUP_BLINDING),	"RSA_setup_blinding"},
+{ERR_FUNC(RSA_F_RSA_SIGN),	"RSA_sign"},
+{ERR_FUNC(RSA_F_RSA_SIGN_ASN1_OCTET_STRING),	"RSA_sign_ASN1_OCTET_STRING"},
+{ERR_FUNC(RSA_F_RSA_VERIFY),	"RSA_verify"},
+{ERR_FUNC(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING),	"RSA_verify_ASN1_OCTET_STRING"},
+{ERR_FUNC(RSA_F_RSA_VERIFY_PKCS1_PSS),	"RSA_verify_PKCS1_PSS"},
+{0,NULL}
+	};
+
+static ERR_STRING_DATA RSA_str_reasons[]=
+	{
+{ERR_REASON(RSA_R_ALGORITHM_MISMATCH)    ,"algorithm mismatch"},
+{ERR_REASON(RSA_R_BAD_E_VALUE)           ,"bad e value"},
+{ERR_REASON(RSA_R_BAD_FIXED_HEADER_DECRYPT),"bad fixed header decrypt"},
+{ERR_REASON(RSA_R_BAD_PAD_BYTE_COUNT)    ,"bad pad byte count"},
+{ERR_REASON(RSA_R_BAD_SIGNATURE)         ,"bad signature"},
+{ERR_REASON(RSA_R_BLOCK_TYPE_IS_NOT_01)  ,"block type is not 01"},
+{ERR_REASON(RSA_R_BLOCK_TYPE_IS_NOT_02)  ,"block type is not 02"},
+{ERR_REASON(RSA_R_DATA_GREATER_THAN_MOD_LEN),"data greater than mod len"},
+{ERR_REASON(RSA_R_DATA_TOO_LARGE)        ,"data too large"},
+{ERR_REASON(RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE),"data too large for key size"},
+{ERR_REASON(RSA_R_DATA_TOO_LARGE_FOR_MODULUS),"data too large for modulus"},
+{ERR_REASON(RSA_R_DATA_TOO_SMALL)        ,"data too small"},
+{ERR_REASON(RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE),"data too small for key size"},
+{ERR_REASON(RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY),"digest too big for rsa key"},
+{ERR_REASON(RSA_R_DMP1_NOT_CONGRUENT_TO_D),"dmp1 not congruent to d"},
+{ERR_REASON(RSA_R_DMQ1_NOT_CONGRUENT_TO_D),"dmq1 not congruent to d"},
+{ERR_REASON(RSA_R_D_E_NOT_CONGRUENT_TO_1),"d e not congruent to 1"},
+{ERR_REASON(RSA_R_FIRST_OCTET_INVALID)   ,"first octet invalid"},
+{ERR_REASON(RSA_R_INVALID_HEADER)        ,"invalid header"},
+{ERR_REASON(RSA_R_INVALID_MESSAGE_LENGTH),"invalid message length"},
+{ERR_REASON(RSA_R_INVALID_PADDING)       ,"invalid padding"},
+{ERR_REASON(RSA_R_INVALID_TRAILER)       ,"invalid trailer"},
+{ERR_REASON(RSA_R_IQMP_NOT_INVERSE_OF_Q) ,"iqmp not inverse of q"},
+{ERR_REASON(RSA_R_KEY_SIZE_TOO_SMALL)    ,"key size too small"},
+{ERR_REASON(RSA_R_LAST_OCTET_INVALID)    ,"last octet invalid"},
+{ERR_REASON(RSA_R_MODULUS_TOO_LARGE)     ,"modulus too large"},
+{ERR_REASON(RSA_R_NO_PUBLIC_EXPONENT)    ,"no public exponent"},
+{ERR_REASON(RSA_R_NULL_BEFORE_BLOCK_MISSING),"null before block missing"},
+{ERR_REASON(RSA_R_N_DOES_NOT_EQUAL_P_Q)  ,"n does not equal p q"},
+{ERR_REASON(RSA_R_OAEP_DECODING_ERROR)   ,"oaep decoding error"},
+{ERR_REASON(RSA_R_PADDING_CHECK_FAILED)  ,"padding check failed"},
+{ERR_REASON(RSA_R_P_NOT_PRIME)           ,"p not prime"},
+{ERR_REASON(RSA_R_Q_NOT_PRIME)           ,"q not prime"},
+{ERR_REASON(RSA_R_RSA_OPERATIONS_NOT_SUPPORTED),"rsa operations not supported"},
+{ERR_REASON(RSA_R_SLEN_CHECK_FAILED)     ,"salt length check failed"},
+{ERR_REASON(RSA_R_SLEN_RECOVERY_FAILED)  ,"salt length recovery failed"},
+{ERR_REASON(RSA_R_SSLV3_ROLLBACK_ATTACK) ,"sslv3 rollback attack"},
+{ERR_REASON(RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD),"the asn1 object identifier is not known for this md"},
+{ERR_REASON(RSA_R_UNKNOWN_ALGORITHM_TYPE),"unknown algorithm type"},
+{ERR_REASON(RSA_R_UNKNOWN_PADDING_TYPE)  ,"unknown padding type"},
+{ERR_REASON(RSA_R_WRONG_SIGNATURE_LENGTH),"wrong signature length"},
+{0,NULL}
+	};
+
+#endif
+
+void ERR_load_RSA_strings(void)
+	{
+	static int init=1;
+
+	if (init)
+		{
+		init=0;
+#ifndef OPENSSL_NO_ERR
+		ERR_load_strings(0,RSA_str_functs);
+		ERR_load_strings(0,RSA_str_reasons);
+#endif
+
+		}
+	}
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_gen.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_gen.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_gen.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_gen.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,194 @@
+/* crypto/rsa/rsa_gen.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+
+/* NB: these functions have been "upgraded", the deprecated versions (which are
+ * compatibility wrappers using these functions) are in rsa_depr.c.
+ * - Geoff
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+
+static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb);
+
+/* NB: this wrapper would normally be placed in rsa_lib.c and the static
+ * implementation would probably be in rsa_eay.c. Nonetheless, is kept here so
+ * that we don't introduce a new linker dependency. Eg. any application that
+ * wasn't previously linking object code related to key-generation won't have to
+ * now just because key-generation is part of RSA_METHOD. */
+int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
+	{
+	if(rsa->meth->rsa_keygen)
+		return rsa->meth->rsa_keygen(rsa, bits, e_value, cb);
+	return rsa_builtin_keygen(rsa, bits, e_value, cb);
+	}
+
+static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
+	{
+	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
+	int bitsp,bitsq,ok= -1,n=0;
+	BN_CTX *ctx=NULL;
+
+	ctx=BN_CTX_new();
+	if (ctx == NULL) goto err;
+	BN_CTX_start(ctx);
+	r0 = BN_CTX_get(ctx);
+	r1 = BN_CTX_get(ctx);
+	r2 = BN_CTX_get(ctx);
+	r3 = BN_CTX_get(ctx);
+	if (r3 == NULL) goto err;
+
+	bitsp=(bits+1)/2;
+	bitsq=bits-bitsp;
+
+	/* We need the RSA components non-NULL */
+	if(!rsa->n && ((rsa->n=BN_new()) == NULL)) goto err;
+	if(!rsa->d && ((rsa->d=BN_new()) == NULL)) goto err;
+	if(!rsa->e && ((rsa->e=BN_new()) == NULL)) goto err;
+	if(!rsa->p && ((rsa->p=BN_new()) == NULL)) goto err;
+	if(!rsa->q && ((rsa->q=BN_new()) == NULL)) goto err;
+	if(!rsa->dmp1 && ((rsa->dmp1=BN_new()) == NULL)) goto err;
+	if(!rsa->dmq1 && ((rsa->dmq1=BN_new()) == NULL)) goto err;
+	if(!rsa->iqmp && ((rsa->iqmp=BN_new()) == NULL)) goto err;
+
+	BN_copy(rsa->e, e_value);
+
+	/* generate p and q */
+	for (;;)
+		{
+		if(!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))
+			goto err;
+		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
+		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
+		if (BN_is_one(r1)) break;
+		if(!BN_GENCB_call(cb, 2, n++))
+			goto err;
+		}
+	if(!BN_GENCB_call(cb, 3, 0))
+		goto err;
+	for (;;)
+		{
+		/* When generating ridiculously small keys, we can get stuck
+		 * continually regenerating the same prime values. Check for
+		 * this and bail if it happens 3 times. */
+		unsigned int degenerate = 0;
+		do
+			{
+			if(!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))
+				goto err;
+			} while((BN_cmp(rsa->p, rsa->q) == 0) && (++degenerate < 3));
+		if(degenerate == 3)
+			{
+			ok = 0; /* we set our own err */
+			RSAerr(RSA_F_RSA_BUILTIN_KEYGEN,RSA_R_KEY_SIZE_TOO_SMALL);
+			goto err;
+			}
+		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
+		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
+		if (BN_is_one(r1))
+			break;
+		if(!BN_GENCB_call(cb, 2, n++))
+			goto err;
+		}
+	if(!BN_GENCB_call(cb, 3, 1))
+		goto err;
+	if (BN_cmp(rsa->p,rsa->q) < 0)
+		{
+		tmp=rsa->p;
+		rsa->p=rsa->q;
+		rsa->q=tmp;
+		}
+
+	/* calculate n */
+	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;
+
+	/* calculate d */
+	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
+	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
+	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */
+	if (!BN_mod_inverse(rsa->d,rsa->e,r0,ctx)) goto err;	/* d */
+
+	/* calculate d mod (p-1) */
+	if (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;
+
+	/* calculate d mod (q-1) */
+	if (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;
+
+	/* calculate inverse of q mod p */
+	if (!BN_mod_inverse(rsa->iqmp,rsa->q,rsa->p,ctx)) goto err;
+
+	ok=1;
+err:
+	if (ok == -1)
+		{
+		RSAerr(RSA_F_RSA_BUILTIN_KEYGEN,ERR_LIB_BN);
+		ok=0;
+		}
+	if (ctx != NULL)
+		{
+		BN_CTX_end(ctx);
+		BN_CTX_free(ctx);
+		}
+
+	return ok;
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa.h TurboSSL-0.9.8j/crypto/rsa_d/rsa.h
--- openssl-0.9.8j/crypto/rsa_d/rsa.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,491 @@
+/* crypto/rsa/rsa.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+ */
+
+
+#ifndef HEADER_RSA_H
+#define HEADER_RSA_H
+
+#include <openssl/asn1.h>
+
+#ifndef OPENSSL_NO_BIO
+#include <openssl/bio.h>
+#endif
+#include <openssl/crypto.h>
+#include <openssl/ossl_typ.h>
+#ifndef OPENSSL_NO_DEPRECATED
+#include <openssl/bn.h>
+#endif
+
+#ifdef OPENSSL_NO_RSA
+#error RSA is disabled.
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* Declared already in ossl_typ.h */
+/* typedef struct rsa_st RSA; */
+/* typedef struct rsa_meth_st RSA_METHOD; */
+
+struct rsa_meth_st
+	{
+	const char *name;
+	int (*rsa_pub_enc)(int flen,const unsigned char *from,
+			   unsigned char *to,
+			   RSA *rsa,int padding);
+	int (*rsa_pub_dec)(int flen,const unsigned char *from,
+			   unsigned char *to,
+			   RSA *rsa,int padding);
+	int (*rsa_priv_enc)(int flen,const unsigned char *from,
+			    unsigned char *to,
+			    RSA *rsa,int padding);
+	int (*rsa_priv_dec)(int flen,const unsigned char *from,
+			    unsigned char *to,
+			    RSA *rsa,int padding);
+	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa,BN_CTX *ctx); /* Can be null */
+	int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+			  const BIGNUM *m, BN_CTX *ctx,
+			  BN_MONT_CTX *m_ctx); /* Can be null */
+	int (*init)(RSA *rsa);		/* called at new */
+	int (*finish)(RSA *rsa);	/* called at free */
+	int flags;			/* RSA_METHOD_FLAG_* things */
+	char *app_data;			/* may be needed! */
+/* New sign and verify functions: some libraries don't allow arbitrary data
+ * to be signed/verified: this allows them to be used. Note: for this to work
+ * the RSA_public_decrypt() and RSA_private_encrypt() should *NOT* be used
+ * RSA_sign(), RSA_verify() should be used instead. Note: for backwards
+ * compatibility this functionality is only enabled if the RSA_FLAG_SIGN_VER
+ * option is set in 'flags'.
+ */
+	int (*rsa_sign)(int type,
+		const unsigned char *m, unsigned int m_length,
+		unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
+	int (*rsa_verify)(int dtype,
+		const unsigned char *m, unsigned int m_length,
+		unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);
+/* If this callback is NULL, the builtin software RSA key-gen will be used. This
+ * is for behavioural compatibility whilst the code gets rewired, but one day
+ * it would be nice to assume there are no such things as "builtin software"
+ * implementations. */
+	int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+	};
+
+struct rsa_st
+	{
+	/* The first parameter is used to pickup errors where
+	 * this is passed instead of aEVP_PKEY, it is set to 0 */
+	int pad;
+	long version;
+	const RSA_METHOD *meth;
+	/* functional reference if 'meth' is ENGINE-provided */
+	ENGINE *engine;
+	BIGNUM *n;
+	BIGNUM *e;
+	BIGNUM *d;
+	BIGNUM *p;
+	BIGNUM *q;
+	BIGNUM *dmp1;
+	BIGNUM *dmq1;
+	BIGNUM *iqmp;
+	/* be careful using this if the RSA structure is shared */
+	CRYPTO_EX_DATA ex_data;
+	int references;
+	int flags;
+
+	/* Used to cache montgomery values */
+	BN_MONT_CTX *_method_mod_n;
+	BN_MONT_CTX *_method_mod_p;
+	BN_MONT_CTX *_method_mod_q;
+
+	/* all BIGNUM values are actually in the following data, if it is not
+	 * NULL */
+	char *bignum_data;
+	BN_BLINDING *blinding;
+	BN_BLINDING *mt_blinding;
+	};
+
+#ifndef OPENSSL_RSA_MAX_MODULUS_BITS
+# define OPENSSL_RSA_MAX_MODULUS_BITS	16384
+#endif
+
+#ifndef OPENSSL_RSA_SMALL_MODULUS_BITS
+# define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
+#endif
+#ifndef OPENSSL_RSA_MAX_PUBEXP_BITS
+# define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "large" modulus only */
+#endif
+
+#define RSA_3	0x3L
+#define RSA_F4	0x10001L
+
+#define RSA_METHOD_FLAG_NO_CHECK	0x0001 /* don't check pub/private match */
+
+#define RSA_FLAG_CACHE_PUBLIC		0x0002
+#define RSA_FLAG_CACHE_PRIVATE		0x0004
+#define RSA_FLAG_BLINDING		0x0008
+#define RSA_FLAG_THREAD_SAFE		0x0010
+/* This flag means the private key operations will be handled by rsa_mod_exp
+ * and that they do not depend on the private key components being present:
+ * for example a key stored in external hardware. Without this flag bn_mod_exp
+ * gets called when private key components are absent.
+ */
+#define RSA_FLAG_EXT_PKEY		0x0020
+
+/* This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
+ */
+#define RSA_FLAG_SIGN_VER		0x0040
+
+#define RSA_FLAG_NO_BLINDING		0x0080 /* new with 0.9.6j and 0.9.7b; the built-in
+                                                * RSA implementation now uses blinding by
+                                                * default (ignoring RSA_FLAG_BLINDING),
+                                                * but other engines might not need it
+                                                */
+#define RSA_FLAG_NO_EXP_CONSTTIME	0x0100 /* new with 0.9.7h; the built-in RSA
+                                                * implementation now uses constant time
+                                                * modular exponentiation for secret exponents
+                                                * by default. This flag causes the
+                                                * faster variable sliding window method to
+                                                * be used for all exponents.
+                                                */
+
+#define RSA_PKCS1_PADDING	1
+#define RSA_SSLV23_PADDING	2
+#define RSA_NO_PADDING		3
+#define RSA_PKCS1_OAEP_PADDING	4
+#define RSA_X931_PADDING	5
+
+#define RSA_PKCS1_PADDING_SIZE	11
+
+#define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,arg)
+#define RSA_get_app_data(s)             RSA_get_ex_data(s,0)
+
+RSA *	RSA_new(void);
+RSA *	RSA_new_method(ENGINE *engine);
+int	RSA_size(const RSA *);
+
+/* Deprecated version */
+#ifndef OPENSSL_NO_DEPRECATED
+RSA *	RSA_generate_key(int bits, unsigned long e,void
+		(*callback)(int,int,void *),void *cb_arg);
+#endif /* !defined(OPENSSL_NO_DEPRECATED) */
+
+/* New version */
+int	RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+
+int	RSA_check_key(const RSA *);
+	/* next 4 return -1 on error */
+int	RSA_public_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+int	RSA_private_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+int	RSA_public_decrypt(int flen, const unsigned char *from, 
+		unsigned char *to, RSA *rsa,int padding);
+int	RSA_private_decrypt(int flen, const unsigned char *from, 
+		unsigned char *to, RSA *rsa,int padding);
+#ifdef CAVIUM_SSL
+int     RSA_public_encrypt_cav(void *s,int flen, const unsigned char *from,
+                unsigned char *to, RSA *rsa,int padding);
+int     RSA_private_encrypt_cav(void *s,int flen, const unsigned char *from,
+                unsigned char *to, RSA *rsa,int padding);
+int     RSA_public_decrypt_cav(void *s,int flen, const unsigned char *from,
+                unsigned char *to, RSA *rsa,int padding);
+//int   RSA_private_decrypt_cav(void *s,int flen, const unsigned char *from,
+//              unsigned char *to, RSA *rsa,int padding);
+
+#endif
+
+void	RSA_free (RSA *r);
+/* "up" the RSA object's reference count */
+int	RSA_up_ref(RSA *r);
+
+int	RSA_flags(const RSA *r);
+
+void RSA_set_default_method(const RSA_METHOD *meth);
+const RSA_METHOD *RSA_get_default_method(void);
+const RSA_METHOD *RSA_get_method(const RSA *rsa);
+int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
+
+/* This function needs the memory locking malloc callbacks to be installed */
+int RSA_memory_lock(RSA *r);
+
+/* these are the actual SSLeay RSA functions */
+const RSA_METHOD *RSA_PKCS1_SSLeay(void);
+
+const RSA_METHOD *RSA_null_method(void);
+
+DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPublicKey)
+DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPrivateKey)
+
+#ifndef OPENSSL_NO_FP_API
+int	RSA_print_fp(FILE *fp, const RSA *r,int offset);
+#endif
+
+#ifndef OPENSSL_NO_BIO
+int	RSA_print(BIO *bp, const RSA *r,int offset);
+#endif
+
+int i2d_RSA_NET(const RSA *a, unsigned char **pp,
+		int (*cb)(char *buf, int len, const char *prompt, int verify),
+		int sgckey);
+RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,
+		 int (*cb)(char *buf, int len, const char *prompt, int verify),
+		 int sgckey);
+
+int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,
+		     int (*cb)(char *buf, int len, const char *prompt,
+			       int verify));
+RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,
+		      int (*cb)(char *buf, int len, const char *prompt,
+				int verify));
+
+/* The following 2 functions sign and verify a X509_SIG ASN1 object
+ * inside PKCS#1 padded RSA encryption */
+int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
+	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
+#ifdef CAVIUM_SSL
+        int RSA_verify_cav(void *s,int type, const unsigned char *m, unsigned int m_length,
+                unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+        int RSA_sign_cav(void *s,int type, const unsigned char *m, unsigned int m_length,
+                unsigned char *sigret, unsigned int *siglen, RSA *rsa);
+#endif
+
+int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
+	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+
+/* The following 2 function sign and verify a ASN1_OCTET_STRING
+ * object inside PKCS#1 padded RSA encryption */
+int RSA_sign_ASN1_OCTET_STRING(int type,
+	const unsigned char *m, unsigned int m_length,
+	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
+int RSA_verify_ASN1_OCTET_STRING(int type,
+	const unsigned char *m, unsigned int m_length,
+	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+
+int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
+void RSA_blinding_off(RSA *rsa);
+BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);
+
+int RSA_padding_add_PKCS1_type_1(unsigned char *to,int tlen,
+	const unsigned char *f,int fl);
+int RSA_padding_check_PKCS1_type_1(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len);
+int RSA_padding_add_PKCS1_type_2(unsigned char *to,int tlen,
+	const unsigned char *f,int fl);
+int RSA_padding_check_PKCS1_type_2(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len);
+int PKCS1_MGF1(unsigned char *mask, long len,
+	const unsigned char *seed, long seedlen, const EVP_MD *dgst);
+int RSA_padding_add_PKCS1_OAEP(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,
+	const unsigned char *p,int pl);
+int RSA_padding_check_PKCS1_OAEP(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len,
+	const unsigned char *p,int pl);
+int RSA_padding_add_SSLv23(unsigned char *to,int tlen,
+	const unsigned char *f,int fl);
+int RSA_padding_check_SSLv23(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len);
+int RSA_padding_add_none(unsigned char *to,int tlen,
+	const unsigned char *f,int fl);
+int RSA_padding_check_none(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len);
+int RSA_padding_add_X931(unsigned char *to,int tlen,
+	const unsigned char *f,int fl);
+int RSA_padding_check_X931(unsigned char *to,int tlen,
+	const unsigned char *f,int fl,int rsa_len);
+int RSA_X931_hash_id(int nid);
+
+int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
+			const EVP_MD *Hash, const unsigned char *EM, int sLen);
+int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
+			const unsigned char *mHash,
+			const EVP_MD *Hash, int sLen);
+
+int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
+int RSA_set_ex_data(RSA *r,int idx,void *arg);
+void *RSA_get_ex_data(const RSA *r, int idx);
+
+RSA *RSAPublicKey_dup(RSA *rsa);
+RSA *RSAPrivateKey_dup(RSA *rsa);
+
+/* BEGIN ERROR CODES */
+/* The following lines are auto generated by the script mkerr.pl. Any changes
+ * made after this point may be overwritten when the script is next run.
+ */
+void ERR_load_RSA_strings(void);
+
+/* Error codes for the RSA functions. */
+
+/* Function codes. */
+#define RSA_F_MEMORY_LOCK				 100
+#define RSA_F_RSA_BUILTIN_KEYGEN			 129
+#define RSA_F_RSA_CHECK_KEY				 123
+#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			 101
+#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			 102
+#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			 103
+#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			 104
+#define RSA_F_RSA_GENERATE_KEY				 105
+#define RSA_F_RSA_MEMORY_LOCK				 130
+#define RSA_F_RSA_NEW_METHOD				 106
+#define RSA_F_RSA_NULL					 124
+#define RSA_F_RSA_NULL_MOD_EXP				 131
+#define RSA_F_RSA_NULL_PRIVATE_DECRYPT			 132
+#define RSA_F_RSA_NULL_PRIVATE_ENCRYPT			 133
+#define RSA_F_RSA_NULL_PUBLIC_DECRYPT			 134
+#define RSA_F_RSA_NULL_PUBLIC_ENCRYPT			 135
+#define RSA_F_RSA_PADDING_ADD_NONE			 107
+#define RSA_F_RSA_PADDING_ADD_PKCS1_OAEP		 121
+#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS			 125
+#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		 108
+#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		 109
+#define RSA_F_RSA_PADDING_ADD_SSLV23			 110
+#define RSA_F_RSA_PADDING_ADD_X931			 127
+#define RSA_F_RSA_PADDING_CHECK_NONE			 111
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP		 122
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1		 112
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2		 113
+#define RSA_F_RSA_PADDING_CHECK_SSLV23			 114
+#define RSA_F_RSA_PADDING_CHECK_X931			 128
+#define RSA_F_RSA_PRINT					 115
+#define RSA_F_RSA_PRINT_FP				 116
+#define RSA_F_RSA_SETUP_BLINDING			 136
+#define RSA_F_RSA_SIGN					 117
+#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		 118
+#define RSA_F_RSA_VERIFY				 119
+#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		 120
+#define RSA_F_RSA_VERIFY_PKCS1_PSS			 126
+
+/* Reason codes. */
+#define RSA_R_ALGORITHM_MISMATCH			 100
+#define RSA_R_BAD_E_VALUE				 101
+#define RSA_R_BAD_FIXED_HEADER_DECRYPT			 102
+#define RSA_R_BAD_PAD_BYTE_COUNT			 103
+#define RSA_R_BAD_SIGNATURE				 104
+#define RSA_R_BLOCK_TYPE_IS_NOT_01			 106
+#define RSA_R_BLOCK_TYPE_IS_NOT_02			 107
+#define RSA_R_DATA_GREATER_THAN_MOD_LEN			 108
+#define RSA_R_DATA_TOO_LARGE				 109
+#define RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE		 110
+#define RSA_R_DATA_TOO_LARGE_FOR_MODULUS		 132
+#define RSA_R_DATA_TOO_SMALL				 111
+#define RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE		 122
+#define RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY		 112
+#define RSA_R_DMP1_NOT_CONGRUENT_TO_D			 124
+#define RSA_R_DMQ1_NOT_CONGRUENT_TO_D			 125
+#define RSA_R_D_E_NOT_CONGRUENT_TO_1			 123
+#define RSA_R_FIRST_OCTET_INVALID			 133
+#define RSA_R_INVALID_HEADER				 137
+#define RSA_R_INVALID_MESSAGE_LENGTH			 131
+#define RSA_R_INVALID_PADDING				 138
+#define RSA_R_INVALID_TRAILER				 139
+#define RSA_R_IQMP_NOT_INVERSE_OF_Q			 126
+#define RSA_R_KEY_SIZE_TOO_SMALL			 120
+#define RSA_R_LAST_OCTET_INVALID			 134
+#define RSA_R_MODULUS_TOO_LARGE				 105
+#define RSA_R_NO_PUBLIC_EXPONENT			 140
+#define RSA_R_NULL_BEFORE_BLOCK_MISSING			 113
+#define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
+#define RSA_R_OAEP_DECODING_ERROR			 121
+#define RSA_R_PADDING_CHECK_FAILED			 114
+#define RSA_R_P_NOT_PRIME				 128
+#define RSA_R_Q_NOT_PRIME				 129
+#define RSA_R_RSA_OPERATIONS_NOT_SUPPORTED		 130
+#define RSA_R_SLEN_CHECK_FAILED				 136
+#define RSA_R_SLEN_RECOVERY_FAILED			 135
+#define RSA_R_SSLV3_ROLLBACK_ATTACK			 115
+#define RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD 116
+#define RSA_R_UNKNOWN_ALGORITHM_TYPE			 117
+#define RSA_R_UNKNOWN_PADDING_TYPE			 118
+#define RSA_R_WRONG_SIGNATURE_LENGTH			 119
+
+#ifdef  __cplusplus
+}
+#endif
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_lib.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_lib.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_lib.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_lib.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,603 @@
+/* crypto/rsa/rsa_lib.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+ */
+
+
+#include <stdio.h>
+#include <openssl/crypto.h>
+#include "cryptlib.h"
+#include <openssl/lhash.h>
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#ifndef OPENSSL_NO_ENGINE
+#include <openssl/engine.h>
+#endif
+#ifdef CAVIUM_SSL
+#include <openssl/cav_crypto_engine.h>
+#endif
+
+const char *RSA_version="RSA" OPENSSL_VERSION_PTEXT;
+
+static const RSA_METHOD *default_RSA_meth=NULL;
+
+RSA *RSA_new(void)
+	{
+	RSA *r=RSA_new_method(NULL);
+
+	return r;
+	}
+
+void RSA_set_default_method(const RSA_METHOD *meth)
+	{
+	default_RSA_meth = meth;
+	}
+
+const RSA_METHOD *RSA_get_default_method(void)
+	{
+	if (default_RSA_meth == NULL)
+		{
+#ifdef RSA_NULL
+		default_RSA_meth=RSA_null_method();
+#else
+#if 0 /* was: #ifdef RSAref */
+		default_RSA_meth=RSA_PKCS1_RSAref();
+#else
+		default_RSA_meth=RSA_PKCS1_SSLeay();
+#endif
+#endif
+		}
+
+	return default_RSA_meth;
+	}
+
+const RSA_METHOD *RSA_get_method(const RSA *rsa)
+	{
+	return rsa->meth;
+	}
+
+int RSA_set_method(RSA *rsa, const RSA_METHOD *meth)
+	{
+	/* NB: The caller is specifically setting a method, so it's not up to us
+	 * to deal with which ENGINE it comes from. */
+	const RSA_METHOD *mtmp;
+	mtmp = rsa->meth;
+	if (mtmp->finish) mtmp->finish(rsa);
+#ifndef OPENSSL_NO_ENGINE
+	if (rsa->engine)
+		{
+		ENGINE_finish(rsa->engine);
+		rsa->engine = NULL;
+		}
+#endif
+	rsa->meth = meth;
+	if (meth->init) meth->init(rsa);
+	return 1;
+	}
+
+RSA *RSA_new_method(ENGINE *engine)
+	{
+	RSA *ret;
+
+	ret=(RSA *)OPENSSL_malloc(sizeof(RSA));
+	if (ret == NULL)
+		{
+		RSAerr(RSA_F_RSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);
+		return NULL;
+		}
+
+	ret->meth = RSA_get_default_method();
+#ifndef OPENSSL_NO_ENGINE
+	if (engine)
+		{
+		if (!ENGINE_init(engine))
+			{
+			RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);
+			OPENSSL_free(ret);
+			return NULL;
+			}
+		ret->engine = engine;
+		}
+	else
+		ret->engine = ENGINE_get_default_RSA();
+	if(ret->engine)
+		{
+		ret->meth = ENGINE_get_RSA(ret->engine);
+		if(!ret->meth)
+			{
+			RSAerr(RSA_F_RSA_NEW_METHOD,
+				ERR_R_ENGINE_LIB);
+			ENGINE_finish(ret->engine);
+			OPENSSL_free(ret);
+			return NULL;
+			}
+		}
+#endif
+
+	ret->pad=0;
+	ret->version=0;
+	ret->n=NULL;
+	ret->e=NULL;
+	ret->d=NULL;
+	ret->p=NULL;
+	ret->q=NULL;
+	ret->dmp1=NULL;
+	ret->dmq1=NULL;
+	ret->iqmp=NULL;
+	ret->references=1;
+	ret->_method_mod_n=NULL;
+	ret->_method_mod_p=NULL;
+	ret->_method_mod_q=NULL;
+	ret->blinding=NULL;
+	ret->mt_blinding=NULL;
+	ret->bignum_data=NULL;
+	ret->flags=ret->meth->flags;
+	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);
+	if ((ret->meth->init != NULL) && !ret->meth->init(ret))
+		{
+#ifndef OPENSSL_NO_ENGINE
+		if (ret->engine)
+			ENGINE_finish(ret->engine);
+#endif
+		CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);
+		OPENSSL_free(ret);
+		ret=NULL;
+		}
+	return(ret);
+	}
+
+void RSA_free(RSA *r)
+	{
+	int i;
+
+	if (r == NULL) return;
+
+	i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);
+#ifdef REF_PRINT
+	REF_PRINT("RSA",r);
+#endif
+	if (i > 0) return;
+#ifdef REF_CHECK
+	if (i < 0)
+		{
+		fprintf(stderr,"RSA_free, bad reference count\n");
+		abort();
+		}
+#endif
+
+	if (r->meth->finish)
+		r->meth->finish(r);
+#ifndef OPENSSL_NO_ENGINE
+	if (r->engine)
+		ENGINE_finish(r->engine);
+#endif
+
+	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, r, &r->ex_data);
+
+	if (r->n != NULL) BN_clear_free(r->n);
+	if (r->e != NULL) BN_clear_free(r->e);
+	if (r->d != NULL) BN_clear_free(r->d);
+	if (r->p != NULL) BN_clear_free(r->p);
+	if (r->q != NULL) BN_clear_free(r->q);
+	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
+	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
+	if (r->iqmp != NULL) BN_clear_free(r->iqmp);
+	if (r->blinding != NULL) BN_BLINDING_free(r->blinding);
+	if (r->mt_blinding != NULL) BN_BLINDING_free(r->mt_blinding);
+	if (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);
+	OPENSSL_free(r);
+	}
+
+int RSA_up_ref(RSA *r)
+	{
+	int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_RSA);
+#ifdef REF_PRINT
+	REF_PRINT("RSA",r);
+#endif
+#ifdef REF_CHECK
+	if (i < 2)
+		{
+		fprintf(stderr, "RSA_up_ref, bad reference count\n");
+		abort();
+		}
+#endif
+	return ((i > 1) ? 1 : 0);
+	}
+
+int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
+	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
+        {
+	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, argl, argp,
+				new_func, dup_func, free_func);
+        }
+
+int RSA_set_ex_data(RSA *r, int idx, void *arg)
+	{
+	return(CRYPTO_set_ex_data(&r->ex_data,idx,arg));
+	}
+
+void *RSA_get_ex_data(const RSA *r, int idx)
+	{
+	return(CRYPTO_get_ex_data(&r->ex_data,idx));
+	}
+
+int RSA_size(const RSA *r)
+	{
+	return(BN_num_bytes(r->n));
+	}
+
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+
+int RSA_public_encrypt_cav(void *s,int flen, const unsigned char *from, unsigned char *to,
+             RSA *rsa, int padding)
+        {
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+                ret = pkp_rsa_public_encrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+
+                if (ret)
+                        return ret;
+        }
+        return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
+        }
+#endif
+
+int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
+	     RSA *rsa, int padding)
+	{
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+#if defined(CAVIUM_FIPS)
+                ret = pkp_rsa_public_encrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+                ret = pkp_rsa_public_encrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+                if(ret)
+                	return ret;
+        }
+#endif
+	return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
+	}
+
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+
+int RSA_private_encrypt_cav(void *s, int flen, const unsigned char *from, unsigned char *to,
+             RSA *rsa, int padding)
+        {
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+                ret = pkp_rsa_private_encrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+
+                if (ret)
+                        return ret;
+        }
+        return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
+        }
+
+#endif
+
+
+int RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to,
+	     RSA *rsa, int padding)
+	{
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+#if defined(CAVIUM_FIPS)
+                ret = pkp_rsa_private_encrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+                ret = pkp_rsa_private_encrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+                if(ret)
+                	return ret;
+        }
+#endif
+	return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
+	}
+
+int RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
+	     RSA *rsa, int padding)
+	{
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+#ifdef CAVIUM_FIPS
+                ret = pkp_rsa_private_decrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+                ret = pkp_rsa_private_decrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+                if(ret)
+                	return ret;
+        }
+#endif
+	return(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));
+	}
+
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+
+int RSA_public_decrypt_cav(void *s ,int flen, const unsigned char *from, unsigned char *to,
+             RSA *rsa, int padding)
+        {
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+                ret = pkp_rsa_public_decrypt_cav(s,flen, (unsigned char *)from, to, rsa);
+
+                if (ret)
+                        return ret;
+	}
+        return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
+        }
+#endif
+
+int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
+	     RSA *rsa, int padding)
+	{
+#if ((defined(CAVIUM_SSL) && !defined(PREDICTOR)) || defined(CAVIUM_FIPS))
+        if(padding == RSA_PKCS1_PADDING)
+        {
+                int ret;
+#ifdef CAVIUM_FIPS
+                ret = pkp_rsa_public_decrypt(flen, (unsigned char *)from, to, rsa , 0 );
+#else
+                ret = pkp_rsa_public_decrypt(flen, (unsigned char *)from, to, rsa );
+#endif
+                if(ret)
+                	return ret;
+        }
+#endif
+	return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
+	}
+
+int RSA_flags(const RSA *r)
+	{
+	return((r == NULL)?0:r->meth->flags);
+	}
+
+void RSA_blinding_off(RSA *rsa)
+	{
+	if (rsa->blinding != NULL)
+		{
+		BN_BLINDING_free(rsa->blinding);
+		rsa->blinding=NULL;
+		}
+	rsa->flags &= ~RSA_FLAG_BLINDING;
+	rsa->flags |= RSA_FLAG_NO_BLINDING;
+	}
+
+int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
+	{
+	int ret=0;
+
+	if (rsa->blinding != NULL)
+		RSA_blinding_off(rsa);
+
+	rsa->blinding = RSA_setup_blinding(rsa, ctx);
+	if (rsa->blinding == NULL)
+		goto err;
+
+	rsa->flags |= RSA_FLAG_BLINDING;
+	rsa->flags &= ~RSA_FLAG_NO_BLINDING;
+	ret=1;
+err:
+	return(ret);
+	}
+
+static BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,
+	const BIGNUM *q, BN_CTX *ctx)
+{
+	BIGNUM *ret = NULL, *r0, *r1, *r2;
+
+	if (d == NULL || p == NULL || q == NULL)
+		return NULL;
+
+	BN_CTX_start(ctx);
+	r0 = BN_CTX_get(ctx);
+	r1 = BN_CTX_get(ctx);
+	r2 = BN_CTX_get(ctx);
+	if (r2 == NULL)
+		goto err;
+
+	if (!BN_sub(r1, p, BN_value_one())) goto err;
+	if (!BN_sub(r2, q, BN_value_one())) goto err;
+	if (!BN_mul(r0, r1, r2, ctx)) goto err;
+
+	ret = BN_mod_inverse(NULL, d, r0, ctx);
+err:
+	BN_CTX_end(ctx);
+	return ret;
+}
+
+BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
+{
+	BIGNUM *e;
+	BN_CTX *ctx;
+	BN_BLINDING *ret = NULL;
+
+	if (in_ctx == NULL)
+		{
+		if ((ctx = BN_CTX_new()) == NULL) return 0;
+		}
+	else
+		ctx = in_ctx;
+
+	BN_CTX_start(ctx);
+	e  = BN_CTX_get(ctx);
+	if (e == NULL)
+		{
+		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if (rsa->e == NULL)
+		{
+		e = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);
+		if (e == NULL)
+			{
+			RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
+			goto err;
+			}
+		}
+	else
+		e = rsa->e;
+
+	
+	if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
+		{
+		/* if PRNG is not properly seeded, resort to secret
+		 * exponent as unpredictable seed */
+		RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);
+		}
+
+	ret = BN_BLINDING_create_param(NULL, e, rsa->n, ctx,
+			rsa->meth->bn_mod_exp, rsa->_method_mod_n);
+	if (ret == NULL)
+		{
+		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);
+		goto err;
+		}
+	BN_BLINDING_set_thread_id(ret, CRYPTO_thread_id());
+err:
+	BN_CTX_end(ctx);
+	if (in_ctx == NULL)
+		BN_CTX_free(ctx);
+	if(rsa->e == NULL)
+		BN_free(e);
+
+	return ret;
+}
+
+int RSA_memory_lock(RSA *r)
+	{
+	int i,j,k,off;
+	char *p;
+	BIGNUM *bn,**t[6],*b;
+	BN_ULONG *ul;
+
+	if (r->d == NULL) return(1);
+	t[0]= &r->d;
+	t[1]= &r->p;
+	t[2]= &r->q;
+	t[3]= &r->dmp1;
+	t[4]= &r->dmq1;
+	t[5]= &r->iqmp;
+	k=sizeof(BIGNUM)*6;
+	off=k/sizeof(BN_ULONG)+1;
+	j=1;
+	for (i=0; i<6; i++)
+		j+= (*t[i])->top;
+	if ((p=OPENSSL_malloc_locked((off+j)*sizeof(BN_ULONG))) == NULL)
+		{
+		RSAerr(RSA_F_RSA_MEMORY_LOCK,ERR_R_MALLOC_FAILURE);
+		return(0);
+		}
+	bn=(BIGNUM *)p;
+	ul=(BN_ULONG *)&(p[off]);
+	for (i=0; i<6; i++)
+		{
+		b= *(t[i]);
+		*(t[i])= &(bn[i]);
+		memcpy((char *)&(bn[i]),(char *)b,sizeof(BIGNUM));
+		bn[i].flags=BN_FLG_STATIC_DATA;
+		bn[i].d=ul;
+		memcpy((char *)ul,b->d,sizeof(BN_ULONG)*b->top);
+		ul+=b->top;
+		BN_clear_free(b);
+		}
+	
+	/* I should fix this so it can still be done */
+	r->flags&= ~(RSA_FLAG_CACHE_PRIVATE|RSA_FLAG_CACHE_PUBLIC);
+
+	r->bignum_data=p;
+	return(1);
+	}
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_none.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_none.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_none.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_none.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,98 @@
+/* crypto/rsa/rsa_none.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+int RSA_padding_add_none(unsigned char *to, int tlen,
+	const unsigned char *from, int flen)
+	{
+	if (flen > tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return(0);
+		}
+
+	if (flen < tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);
+		return(0);
+		}
+	
+	memcpy(to,from,(unsigned int)flen);
+	return(1);
+	}
+
+int RSA_padding_check_none(unsigned char *to, int tlen,
+	const unsigned char *from, int flen, int num)
+	{
+
+	if (flen > tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_NONE,RSA_R_DATA_TOO_LARGE);
+		return(-1);
+		}
+
+	memset(to,0,tlen-flen);
+	memcpy(to+tlen-flen,from,flen);
+	return(tlen);
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_null.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_null.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_null.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_null.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,151 @@
+/* rsa_null.c */
+/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL
+ * project 1999.
+ */
+/* ====================================================================
+ * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+/* This is a dummy RSA implementation that just returns errors when called.
+ * It is designed to allow some RSA functions to work while stopping those
+ * covered by the RSA patent. That is RSA, encryption, decryption, signing
+ * and verify is not allowed but RSA key generation, key checking and other
+ * operations (like storing RSA keys) are permitted.
+ */
+
+static int RSA_null_public_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_null_private_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_null_public_decrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+static int RSA_null_private_decrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa,int padding);
+#if 0 /* not currently used */
+static int RSA_null_mod_exp(const BIGNUM *r0, const BIGNUM *i, RSA *rsa);
+#endif
+static int RSA_null_init(RSA *rsa);
+static int RSA_null_finish(RSA *rsa);
+static RSA_METHOD rsa_null_meth={
+	"Null RSA",
+	RSA_null_public_encrypt,
+	RSA_null_public_decrypt,
+	RSA_null_private_encrypt,
+	RSA_null_private_decrypt,
+	NULL,
+	NULL,
+	RSA_null_init,
+	RSA_null_finish,
+	0,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+	};
+
+const RSA_METHOD *RSA_null_method(void)
+	{
+	return(&rsa_null_meth);
+	}
+
+static int RSA_null_public_encrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	RSAerr(RSA_F_RSA_NULL_PUBLIC_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+	return -1;
+	}
+
+static int RSA_null_private_encrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	RSAerr(RSA_F_RSA_NULL_PRIVATE_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+	return -1;
+	}
+
+static int RSA_null_private_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	RSAerr(RSA_F_RSA_NULL_PRIVATE_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+	return -1;
+	}
+
+static int RSA_null_public_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	RSAerr(RSA_F_RSA_NULL_PUBLIC_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+	return -1;
+	}
+
+#if 0 /* not currently used */
+static int RSA_null_mod_exp(BIGNUM *r0, BIGNUM *I, RSA *rsa)
+	{
+	...err(RSA_F_RSA_NULL_MOD_EXP, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+	return -1;
+	}
+#endif
+
+static int RSA_null_init(RSA *rsa)
+	{
+	return(1);
+	}
+
+static int RSA_null_finish(RSA *rsa)
+	{
+	return(1);
+	}
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_oaep.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_oaep.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_oaep.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_oaep.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,213 @@
+/* crypto/rsa/rsa_oaep.c */
+/* Written by Ulf Moeller. This software is distributed on an "AS IS"
+   basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. */
+
+/* EME-OAEP as defined in RFC 2437 (PKCS #1 v2.0) */
+
+/* See Victor Shoup, "OAEP reconsidered," Nov. 2000,
+ * <URL: http://www.shoup.net/papers/oaep.ps.Z>
+ * for problems with the security proof for the
+ * original OAEP scheme, which EME-OAEP is based on.
+ * 
+ * A new proof can be found in E. Fujisaki, T. Okamoto,
+ * D. Pointcheval, J. Stern, "RSA-OEAP is Still Alive!",
+ * Dec. 2000, <URL: http://eprint.iacr.org/2000/061/>.
+ * The new proof has stronger requirements for the
+ * underlying permutation: "partial-one-wayness" instead
+ * of one-wayness.  For the RSA function, this is
+ * an equivalent notion.
+ */
+
+
+#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
+
+int MGF1(unsigned char *mask, long len,
+	const unsigned char *seed, long seedlen);
+
+int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
+	const unsigned char *from, int flen,
+	const unsigned char *param, int plen)
+	{
+	int i, emlen = tlen - 1;
+	unsigned char *db, *seed;
+	unsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];
+
+	if (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,
+		   RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return 0;
+		}
+
+	if (emlen < 2 * SHA_DIGEST_LENGTH + 1)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);
+		return 0;
+		}
+
+	dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
+	if (dbmask == NULL)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
+		return 0;
+		}
+
+	to[0] = 0;
+	seed = to + 1;
+	db = to + SHA_DIGEST_LENGTH + 1;
+
+	EVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL);
+	memset(db + SHA_DIGEST_LENGTH, 0,
+		emlen - flen - 2 * SHA_DIGEST_LENGTH - 1);
+	db[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;
+	memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);
+	if (RAND_bytes(seed, SHA_DIGEST_LENGTH) <= 0)
+		return 0;
+#ifdef PKCS_TESTVECT
+	memcpy(seed,
+	   "\xaa\xfd\x12\xf6\x59\xca\xe6\x34\x89\xb4\x79\xe5\x07\x6d\xde\xc2\xf0\x6c\xb5\x8f",
+	   20);
+#endif
+
+	MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
+	for (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)
+		db[i] ^= dbmask[i];
+
+	MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
+	for (i = 0; i < SHA_DIGEST_LENGTH; i++)
+		seed[i] ^= seedmask[i];
+
+	OPENSSL_free(dbmask);
+	return 1;
+	}
+
+int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
+	const unsigned char *from, int flen, int num,
+	const unsigned char *param, int plen)
+	{
+	int i, dblen, mlen = -1;
+	const unsigned char *maskeddb;
+	int lzero;
+	unsigned char *db = NULL, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];
+	int bad = 0;
+
+	if (--num < 2 * SHA_DIGEST_LENGTH + 1)
+		/* 'num' is the length of the modulus, i.e. does not depend on the
+		 * particular ciphertext. */
+		goto decoding_err;
+
+	lzero = num - flen;
+	if (lzero < 0)
+		{
+		/* lzero == -1 */
+
+		/* signalling this error immediately after detection might allow
+		 * for side-channel attacks (e.g. timing if 'plen' is huge
+		 * -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA Optimal
+		 * Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001),
+		 * so we use a 'bad' flag */
+		bad = 1;
+		lzero = 0;
+		}
+	maskeddb = from - lzero + SHA_DIGEST_LENGTH;
+
+	dblen = num - SHA_DIGEST_LENGTH;
+	db = OPENSSL_malloc(dblen);
+	if (db == NULL)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
+		return -1;
+		}
+
+	MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
+	for (i = lzero; i < SHA_DIGEST_LENGTH; i++)
+		seed[i] ^= from[i - lzero];
+  
+	MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
+	for (i = 0; i < dblen; i++)
+		db[i] ^= maskeddb[i];
+
+	EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL);
+
+	if (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
+		goto decoding_err;
+	else
+		{
+		for (i = SHA_DIGEST_LENGTH; i < dblen; i++)
+			if (db[i] != 0x00)
+				break;
+		if (db[i] != 0x01 || i++ >= dblen)
+			goto decoding_err;
+		else
+			{
+			/* everything looks OK */
+
+			mlen = dblen - i;
+			if (tlen < mlen)
+				{
+				RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);
+				mlen = -1;
+				}
+			else
+				memcpy(to, db + i, mlen);
+			}
+		}
+	OPENSSL_free(db);
+	return mlen;
+
+decoding_err:
+	/* to avoid chosen ciphertext attacks, the error message should not reveal
+	 * which kind of decoding error happened */
+	RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
+	if (db != NULL) OPENSSL_free(db);
+	return -1;
+	}
+
+int PKCS1_MGF1(unsigned char *mask, long len,
+	const unsigned char *seed, long seedlen, const EVP_MD *dgst)
+	{
+	long i, outlen = 0;
+	unsigned char cnt[4];
+	EVP_MD_CTX c;
+	unsigned char md[EVP_MAX_MD_SIZE];
+	int mdlen;
+
+	EVP_MD_CTX_init(&c);
+	mdlen = EVP_MD_size(dgst);
+	for (i = 0; outlen < len; i++)
+		{
+		cnt[0] = (unsigned char)((i >> 24) & 255);
+		cnt[1] = (unsigned char)((i >> 16) & 255);
+		cnt[2] = (unsigned char)((i >> 8)) & 255;
+		cnt[3] = (unsigned char)(i & 255);
+		EVP_DigestInit_ex(&c,dgst, NULL);
+		EVP_DigestUpdate(&c, seed, seedlen);
+		EVP_DigestUpdate(&c, cnt, 4);
+		if (outlen + mdlen <= len)
+			{
+			EVP_DigestFinal_ex(&c, mask + outlen, NULL);
+			outlen += mdlen;
+			}
+		else
+			{
+			EVP_DigestFinal_ex(&c, md, NULL);
+			memcpy(mask + outlen, md, len - outlen);
+			outlen = len;
+			}
+		}
+	EVP_MD_CTX_cleanup(&c);
+	return 0;
+	}
+
+int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
+	{
+	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
+	}
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_pk1.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_pk1.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_pk1.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_pk1.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,224 @@
+/* crypto/rsa/rsa_pk1.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen)
+	{
+	int j;
+	unsigned char *p;
+
+	if (flen > (tlen-RSA_PKCS1_PADDING_SIZE))
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return(0);
+		}
+	
+	p=(unsigned char *)to;
+
+	*(p++)=0;
+	*(p++)=1; /* Private Key BT (Block Type) */
+
+	/* pad out with 0xff data */
+	j=tlen-3-flen;
+	memset(p,0xff,j);
+	p+=j;
+	*(p++)='\0';
+	memcpy(p,from,(unsigned int)flen);
+	return(1);
+	}
+
+int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen, int num)
+	{
+	int i,j;
+	const unsigned char *p;
+
+	p=from;
+	if ((num != (flen+1)) || (*(p++) != 01))
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BLOCK_TYPE_IS_NOT_01);
+		return(-1);
+		}
+
+	/* scan over padding data */
+	j=flen-1; /* one for type. */
+	for (i=0; i<j; i++)
+		{
+		if (*p != 0xff) /* should decrypt to 0xff */
+			{
+			if (*p == 0)
+				{ p++; break; }
+			else	{
+				RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_FIXED_HEADER_DECRYPT);
+				return(-1);
+				}
+			}
+		p++;
+		}
+
+	if (i == j)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_NULL_BEFORE_BLOCK_MISSING);
+		return(-1);
+		}
+
+	if (i < 8)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_PAD_BYTE_COUNT);
+		return(-1);
+		}
+	i++; /* Skip over the '\0' */
+	j-=i;
+	if (j > tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE);
+		return(-1);
+		}
+	memcpy(to,p,(unsigned int)j);
+
+	return(j);
+	}
+
+int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen)
+	{
+	int i,j;
+	unsigned char *p;
+	
+	if (flen > (tlen-11))
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return(0);
+		}
+	
+	p=(unsigned char *)to;
+
+	*(p++)=0;
+	*(p++)=2; /* Public Key BT (Block Type) */
+
+	/* pad out with non-zero random data */
+	j=tlen-3-flen;
+
+	if (RAND_bytes(p,j) <= 0)
+		return(0);
+	for (i=0; i<j; i++)
+		{
+		if (*p == '\0')
+			do	{
+				if (RAND_bytes(p,1) <= 0)
+					return(0);
+				} while (*p == '\0');
+		p++;
+		}
+
+	*(p++)='\0';
+
+	memcpy(p,from,(unsigned int)flen);
+	return(1);
+	}
+
+int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen, int num)
+	{
+	int i,j;
+	const unsigned char *p;
+
+	p=from;
+	if ((num != (flen+1)) || (*(p++) != 02))
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BLOCK_TYPE_IS_NOT_02);
+		return(-1);
+		}
+#ifdef PKCS1_CHECK
+	return(num-11);
+#endif
+
+	/* scan over padding data */
+	j=flen-1; /* one for type. */
+	for (i=0; i<j; i++)
+		if (*(p++) == 0) break;
+
+	if (i == j)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_NULL_BEFORE_BLOCK_MISSING);
+		return(-1);
+		}
+
+	if (i < 8)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BAD_PAD_BYTE_COUNT);
+		return(-1);
+		}
+	i++; /* Skip over the '\0' */
+	j-=i;
+	if (j > tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE);
+		return(-1);
+		}
+	memcpy(to,p,(unsigned int)j);
+
+	return(j);
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_pss.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_pss.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_pss.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_pss.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,269 @@
+/* rsa_pss.c */
+/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL
+ * project 2005.
+ */
+/* ====================================================================
+ * Copyright (c) 2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
+
+static const unsigned char zeroes[] = {0,0,0,0,0,0,0,0};
+
+#if defined(_MSC_VER) && defined(_ARM_)
+#pragma optimize("g", off)
+#endif
+
+int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
+			const EVP_MD *Hash, const unsigned char *EM, int sLen)
+	{
+	int i;
+	int ret = 0;
+	int hLen, maskedDBLen, MSBits, emLen;
+	const unsigned char *H;
+	unsigned char *DB = NULL;
+	EVP_MD_CTX ctx;
+	unsigned char H_[EVP_MAX_MD_SIZE];
+
+	hLen = EVP_MD_size(Hash);
+	/*
+	 * Negative sLen has special meanings:
+	 *	-1	sLen == hLen
+	 *	-2	salt length is autorecovered from signature
+	 *	-N	reserved
+	 */
+	if      (sLen == -1)	sLen = hLen;
+	else if (sLen == -2)	sLen = -2;
+	else if (sLen < -2)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);
+		goto err;
+		}
+
+	MSBits = (BN_num_bits(rsa->n) - 1) & 0x7;
+	emLen = RSA_size(rsa);
+	if (EM[0] & (0xFF << MSBits))
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_FIRST_OCTET_INVALID);
+		goto err;
+		}
+	if (MSBits == 0)
+		{
+		EM++;
+		emLen--;
+		}
+	if (emLen < (hLen + sLen + 2)) /* sLen can be small negative */
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_DATA_TOO_LARGE);
+		goto err;
+		}
+	if (EM[emLen - 1] != 0xbc)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_LAST_OCTET_INVALID);
+		goto err;
+		}
+	maskedDBLen = emLen - hLen - 1;
+	H = EM + maskedDBLen;
+	DB = OPENSSL_malloc(maskedDBLen);
+	if (!DB)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	PKCS1_MGF1(DB, maskedDBLen, H, hLen, Hash);
+	for (i = 0; i < maskedDBLen; i++)
+		DB[i] ^= EM[i];
+	if (MSBits)
+		DB[0] &= 0xFF >> (8 - MSBits);
+	for (i = 0; DB[i] == 0 && i < (maskedDBLen-1); i++) ;
+	if (DB[i++] != 0x1)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_RECOVERY_FAILED);
+		goto err;
+		}
+	if (sLen >= 0 && (maskedDBLen - i) != sLen)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);
+		goto err;
+		}
+	EVP_MD_CTX_init(&ctx);
+	EVP_DigestInit_ex(&ctx, Hash, NULL);
+	EVP_DigestUpdate(&ctx, zeroes, sizeof zeroes);
+	EVP_DigestUpdate(&ctx, mHash, hLen);
+	if (maskedDBLen - i)
+		EVP_DigestUpdate(&ctx, DB + i, maskedDBLen - i);
+	EVP_DigestFinal(&ctx, H_, NULL);
+	EVP_MD_CTX_cleanup(&ctx);
+	if (memcmp(H_, H, hLen))
+		{
+		RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_BAD_SIGNATURE);
+		ret = 0;
+		}
+	else 
+		ret = 1;
+
+	err:
+	if (DB)
+		OPENSSL_free(DB);
+
+	return ret;
+
+	}
+
+int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
+			const unsigned char *mHash,
+			const EVP_MD *Hash, int sLen)
+	{
+	int i;
+	int ret = 0;
+	int hLen, maskedDBLen, MSBits, emLen;
+	unsigned char *H, *salt = NULL, *p;
+	EVP_MD_CTX ctx;
+
+	hLen = EVP_MD_size(Hash);
+	/*
+	 * Negative sLen has special meanings:
+	 *	-1	sLen == hLen
+	 *	-2	salt length is maximized
+	 *	-N	reserved
+	 */
+	if      (sLen == -1)	sLen = hLen;
+	else if (sLen == -2)	sLen = -2;
+	else if (sLen < -2)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);
+		goto err;
+		}
+
+	MSBits = (BN_num_bits(rsa->n) - 1) & 0x7;
+	emLen = RSA_size(rsa);
+	if (MSBits == 0)
+		{
+		*EM++ = 0;
+		emLen--;
+		}
+	if (sLen == -2)
+		{
+		sLen = emLen - hLen - 2;
+		}
+	else if (emLen < (hLen + sLen + 2))
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS,
+		   RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		goto err;
+		}
+	if (sLen > 0)
+		{
+		salt = OPENSSL_malloc(sLen);
+		if (!salt)
+			{
+			RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS,
+		   		ERR_R_MALLOC_FAILURE);
+			goto err;
+			}
+		if (!RAND_bytes(salt, sLen))
+			goto err;
+		}
+	maskedDBLen = emLen - hLen - 1;
+	H = EM + maskedDBLen;
+	EVP_MD_CTX_init(&ctx);
+	EVP_DigestInit_ex(&ctx, Hash, NULL);
+	EVP_DigestUpdate(&ctx, zeroes, sizeof zeroes);
+	EVP_DigestUpdate(&ctx, mHash, hLen);
+	if (sLen)
+		EVP_DigestUpdate(&ctx, salt, sLen);
+	EVP_DigestFinal(&ctx, H, NULL);
+	EVP_MD_CTX_cleanup(&ctx);
+
+	/* Generate dbMask in place then perform XOR on it */
+	PKCS1_MGF1(EM, maskedDBLen, H, hLen, Hash);
+
+	p = EM;
+
+	/* Initial PS XORs with all zeroes which is a NOP so just update
+	 * pointer. Note from a test above this value is guaranteed to
+	 * be non-negative.
+	 */
+	p += emLen - sLen - hLen - 2;
+	*p++ ^= 0x1;
+	if (sLen > 0)
+		{
+		for (i = 0; i < sLen; i++)
+			*p++ ^= salt[i];
+		}
+	if (MSBits)
+		EM[0] &= 0xFF >> (8 - MSBits);
+
+	/* H is already in place so just set final 0xbc */
+
+	EM[emLen - 1] = 0xbc;
+
+	ret = 1;
+
+	err:
+	if (salt)
+		OPENSSL_free(salt);
+
+	return ret;
+
+	}
+
+#if defined(_MSC_VER)
+#pragma optimize("",on)
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_saos.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_saos.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_saos.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_saos.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,150 @@
+/* crypto/rsa/rsa_saos.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+
+int RSA_sign_ASN1_OCTET_STRING(int type,
+	const unsigned char *m, unsigned int m_len,
+	unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+	{
+	ASN1_OCTET_STRING sig;
+	int i,j,ret=1;
+	unsigned char *p,*s;
+
+	sig.type=V_ASN1_OCTET_STRING;
+	sig.length=m_len;
+	sig.data=(unsigned char *)m;
+
+	i=i2d_ASN1_OCTET_STRING(&sig,NULL);
+	j=RSA_size(rsa);
+	if (i > (j-RSA_PKCS1_PADDING_SIZE))
+		{
+		RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
+		return(0);
+		}
+	s=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+	if (s == NULL)
+		{
+		RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);
+		return(0);
+		}
+	p=s;
+	i2d_ASN1_OCTET_STRING(&sig,&p);
+	i=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);
+	if (i <= 0)
+		ret=0;
+	else
+		*siglen=i;
+
+	OPENSSL_cleanse(s,(unsigned int)j+1);
+	OPENSSL_free(s);
+	return(ret);
+	}
+
+int RSA_verify_ASN1_OCTET_STRING(int dtype,
+	const unsigned char *m,
+	unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,
+	RSA *rsa)
+	{
+	int i,ret=0;
+	unsigned char *s;
+	const unsigned char *p;
+	ASN1_OCTET_STRING *sig=NULL;
+
+	if (siglen != (unsigned int)RSA_size(rsa))
+		{
+		RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_WRONG_SIGNATURE_LENGTH);
+		return(0);
+		}
+
+	s=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);
+	if (s == NULL)
+		{
+		RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	i=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);
+
+	if (i <= 0) goto err;
+
+	p=s;
+	sig=d2i_ASN1_OCTET_STRING(NULL,&p,(long)i);
+	if (sig == NULL) goto err;
+
+	if (	((unsigned int)sig->length != m_len) ||
+		(memcmp(m,sig->data,m_len) != 0))
+		{
+		RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_BAD_SIGNATURE);
+		}
+	else
+		ret=1;
+err:
+	if (sig != NULL) M_ASN1_OCTET_STRING_free(sig);
+	if (s != NULL)
+		{
+		OPENSSL_cleanse(s,(unsigned int)siglen);
+		OPENSSL_free(s);
+		}
+	return(ret);
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_sign.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_sign.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_sign.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_sign.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,336 @@
+/* crypto/rsa/rsa_sign.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+ */
+
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+
+/* Size of an SSL signature: MD5+SHA1 */
+#define SSL_SIG_LENGTH	36
+
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+static int RSA_sign_cav2(int cav_mode,void *ssl,int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa);
+
+int RSA_sign_cav(void *ssl,int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+	{
+	return(RSA_sign_cav2(1,ssl,type,m,m_len,sigret,siglen,rsa));
+	}
+
+int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+	{
+	return(RSA_sign_cav2(0,NULL,type,m,m_len,sigret,siglen,rsa));
+	}
+
+static int RSA_sign_cav2(int cav_mode,void *ssl,int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+#else
+int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+#endif
+	{
+	X509_SIG sig;
+	ASN1_TYPE parameter;
+	int i,j,ret=1;
+	unsigned char *p, *tmps = NULL;
+	const unsigned char *s = NULL;
+	X509_ALGOR algor;
+	ASN1_OCTET_STRING digest;
+	if((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_sign)
+		{
+		return rsa->meth->rsa_sign(type, m, m_len,
+			sigret, siglen, rsa);
+		}
+	/* Special case: SSL signature, just check the length */
+	if(type == NID_md5_sha1) {
+		if(m_len != SSL_SIG_LENGTH) {
+			RSAerr(RSA_F_RSA_SIGN,RSA_R_INVALID_MESSAGE_LENGTH);
+			return(0);
+		}
+		i = SSL_SIG_LENGTH;
+		s = m;
+	} else {
+		sig.algor= &algor;
+		sig.algor->algorithm=OBJ_nid2obj(type);
+		if (sig.algor->algorithm == NULL)
+			{
+			RSAerr(RSA_F_RSA_SIGN,RSA_R_UNKNOWN_ALGORITHM_TYPE);
+			return(0);
+			}
+		if (sig.algor->algorithm->length == 0)
+			{
+			RSAerr(RSA_F_RSA_SIGN,RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
+			return(0);
+			}
+		parameter.type=V_ASN1_NULL;
+		parameter.value.ptr=NULL;
+		sig.algor->parameter= &parameter;
+
+		sig.digest= &digest;
+		sig.digest->data=(unsigned char *)m; /* TMP UGLY CAST */
+		sig.digest->length=m_len;
+
+		i=i2d_X509_SIG(&sig,NULL);
+	}
+	j=RSA_size(rsa);
+	if (i > (j-RSA_PKCS1_PADDING_SIZE))
+		{
+		RSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
+		return(0);
+		}
+	if(type != NID_md5_sha1) {
+		tmps=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		if (tmps == NULL)
+			{
+			RSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);
+			return(0);
+			}
+		p=tmps;
+		i2d_X509_SIG(&sig,&p);
+		s=tmps;
+	}
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	if (cav_mode) {
+		i=RSA_private_encrypt_cav(ssl,i,s,sigret,rsa,RSA_PKCS1_PADDING);
+		if ( i == -EAGAIN ) ret = i;
+	} else
+#endif
+	i=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);
+	if (i <= 0)
+		ret=0;
+	else
+		*siglen=i;
+
+	if(type != NID_md5_sha1) {
+		OPENSSL_cleanse(tmps,(unsigned int)j+1);
+		OPENSSL_free(tmps);
+	}
+	return(ret);
+	}
+
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+static int RSA_verify_cav2(int cav_mode, void *ssl,int dtype, const unsigned char *m, unsigned int m_len,
+             unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+
+int RSA_verify_cav(void *ssl,int dtype, const unsigned char *m, unsigned int m_len,
+             unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+{
+	return (RSA_verify_cav2(1,ssl,dtype,m,m_len,sigbuf,siglen,rsa));
+}
+
+int RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+{
+	return (RSA_verify_cav2(0,NULL,dtype,m,m_len,sigbuf,siglen,rsa));
+}
+
+static int RSA_verify_cav2(int cav_mode, void *ssl,int dtype, const unsigned char *m, unsigned int m_len,
+             unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+#else
+int RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
+	     unsigned char *sigbuf, unsigned int siglen, RSA *rsa)
+#endif
+	{
+	int i,ret=0,sigtype;
+	unsigned char *s;
+	X509_SIG *sig=NULL;
+
+	if (siglen != (unsigned int)RSA_size(rsa))
+		{
+		RSAerr(RSA_F_RSA_VERIFY,RSA_R_WRONG_SIGNATURE_LENGTH);
+		return(0);
+		}
+
+	if((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify)
+		{
+		return rsa->meth->rsa_verify(dtype, m, m_len,
+			sigbuf, siglen, rsa);
+		}
+
+	s=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);
+	if (s == NULL)
+		{
+		RSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	if((dtype == NID_md5_sha1) && (m_len != SSL_SIG_LENGTH) ) {
+			RSAerr(RSA_F_RSA_VERIFY,RSA_R_INVALID_MESSAGE_LENGTH);
+			goto err;
+	}
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+	if (cav_mode) {
+		i=RSA_public_decrypt_cav(ssl,(int)siglen,sigbuf,s,
+						rsa,RSA_PKCS1_PADDING);
+		if (i == -EAGAIN) {
+			ret = i;
+			goto err ;
+		}
+	} else
+#endif
+	i=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);
+
+	if (i <= 0) goto err;
+
+	/* Special case: SSL signature */
+	if(dtype == NID_md5_sha1) {
+		if((i != SSL_SIG_LENGTH) || memcmp(s, m, SSL_SIG_LENGTH))
+				RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+		else ret = 1;
+	} else {
+		const unsigned char *p=s;
+		sig=d2i_X509_SIG(NULL,&p,(long)i);
+
+		if (sig == NULL) goto err;
+
+		/* Excess data can be used to create forgeries */
+		if(p != s+i)
+			{
+			RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+			goto err;
+			}
+
+		/* Parameters to the signature algorithm can also be used to
+		   create forgeries */
+		if(sig->algor->parameter
+		   && ASN1_TYPE_get(sig->algor->parameter) != V_ASN1_NULL)
+			{
+			RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+			goto err;
+			}
+
+		sigtype=OBJ_obj2nid(sig->algor->algorithm);
+
+
+	#ifdef RSA_DEBUG
+		/* put a backward compatibility flag in EAY */
+		fprintf(stderr,"in(%s) expect(%s)\n",OBJ_nid2ln(sigtype),
+			OBJ_nid2ln(dtype));
+	#endif
+		if (sigtype != dtype)
+			{
+			if (((dtype == NID_md5) &&
+				(sigtype == NID_md5WithRSAEncryption)) ||
+				((dtype == NID_md2) &&
+				(sigtype == NID_md2WithRSAEncryption)))
+				{
+				/* ok, we will let it through */
+#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)
+				fprintf(stderr,"signature has problems, re-make with post SSLeay045\n");
+#endif
+				}
+			else
+				{
+				RSAerr(RSA_F_RSA_VERIFY,
+						RSA_R_ALGORITHM_MISMATCH);
+				goto err;
+				}
+			}
+		if (	((unsigned int)sig->digest->length != m_len) ||
+			(memcmp(m,sig->digest->data,m_len) != 0))
+			{
+			RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+			}
+		else
+			ret=1;
+	}
+err:
+	if (sig != NULL) X509_SIG_free(sig);
+	if (s != NULL)
+		{
+		OPENSSL_cleanse(s,(unsigned int)siglen);
+		OPENSSL_free(s);
+		}
+	return(ret);
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_ssl.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_ssl.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_ssl.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_ssl.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,154 @@
+/* crypto/rsa/rsa_ssl.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+
+int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
+	const unsigned char *from, int flen)
+	{
+	int i,j;
+	unsigned char *p;
+	
+	if (flen > (tlen-11))
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_SSLV23,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return(0);
+		}
+	
+	p=(unsigned char *)to;
+
+	*(p++)=0;
+	*(p++)=2; /* Public Key BT (Block Type) */
+
+	/* pad out with non-zero random data */
+	j=tlen-3-8-flen;
+
+	if (RAND_bytes(p,j) <= 0)
+		return(0);
+	for (i=0; i<j; i++)
+		{
+		if (*p == '\0')
+			do	{
+				if (RAND_bytes(p,1) <= 0)
+					return(0);
+				} while (*p == '\0');
+		p++;
+		}
+
+	memset(p,3,8);
+	p+=8;
+	*(p++)='\0';
+
+	memcpy(p,from,(unsigned int)flen);
+	return(1);
+	}
+
+int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
+	const unsigned char *from, int flen, int num)
+	{
+	int i,j,k;
+	const unsigned char *p;
+
+	p=from;
+	if (flen < 10)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_DATA_TOO_SMALL);
+		return(-1);
+		}
+	if ((num != (flen+1)) || (*(p++) != 02))
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_BLOCK_TYPE_IS_NOT_02);
+		return(-1);
+		}
+
+	/* scan over padding data */
+	j=flen-1; /* one for type */
+	for (i=0; i<j; i++)
+		if (*(p++) == 0) break;
+
+	if ((i == j) || (i < 8))
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_NULL_BEFORE_BLOCK_MISSING);
+		return(-1);
+		}
+	for (k= -8; k<0; k++)
+		{
+		if (p[k] !=  0x03) break;
+		}
+	if (k == -1)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_SSLV3_ROLLBACK_ATTACK);
+		return(-1);
+		}
+
+	i++; /* Skip over the '\0' */
+	j-=i;
+	if (j > tlen)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_DATA_TOO_LARGE);
+		return(-1);
+		}
+	memcpy(to,p,(unsigned int)j);
+
+	return(j);
+	}
+
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_test.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_test.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_test.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_test.c	2010-05-31 12:14:39.000000000 +0200
@@ -0,0 +1,402 @@
+/* test vectors from p1ovect1.txt */
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+ */
+
+
+#include <stdio.h>
+#include <string.h>
+
+#include "e_os.h"
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
+
+#include <openssl/crypto.h>
+#include <openssl/err.h>
+#include <openssl/rand.h>
+#include <openssl/bn.h>
+#ifdef OPENSSL_NO_RSA
+int main(int argc, char *argv[])
+{
+    printf("No RSA support\n");
+    return(0);
+}
+#else
+#include <openssl/rsa.h>
+
+#define SetKey \
+  key->n = BN_bin2bn(n, sizeof(n)-1, key->n); \
+  key->e = BN_bin2bn(e, sizeof(e)-1, key->e); \
+  key->d = BN_bin2bn(d, sizeof(d)-1, key->d); \
+  key->p = BN_bin2bn(p, sizeof(p)-1, key->p); \
+  key->q = BN_bin2bn(q, sizeof(q)-1, key->q); \
+  key->dmp1 = BN_bin2bn(dmp1, sizeof(dmp1)-1, key->dmp1); \
+  key->dmq1 = BN_bin2bn(dmq1, sizeof(dmq1)-1, key->dmq1); \
+  key->iqmp = BN_bin2bn(iqmp, sizeof(iqmp)-1, key->iqmp); \
+  memcpy(c, ctext_ex, sizeof(ctext_ex) - 1); \
+  return (sizeof(ctext_ex) - 1);
+
+static int key1(RSA *key, unsigned char *c)
+    {
+    static unsigned char n[] =
+"\x00\xAA\x36\xAB\xCE\x88\xAC\xFD\xFF\x55\x52\x3C\x7F\xC4\x52\x3F"
+"\x90\xEF\xA0\x0D\xF3\x77\x4A\x25\x9F\x2E\x62\xB4\xC5\xD9\x9C\xB5"
+"\xAD\xB3\x00\xA0\x28\x5E\x53\x01\x93\x0E\x0C\x70\xFB\x68\x76\x93"
+"\x9C\xE6\x16\xCE\x62\x4A\x11\xE0\x08\x6D\x34\x1E\xBC\xAC\xA0\xA1"
+"\xF5";
+
+    static unsigned char e[] = "\x11";
+
+    static unsigned char d[] =
+"\x0A\x03\x37\x48\x62\x64\x87\x69\x5F\x5F\x30\xBC\x38\xB9\x8B\x44"
+"\xC2\xCD\x2D\xFF\x43\x40\x98\xCD\x20\xD8\xA1\x38\xD0\x90\xBF\x64"
+"\x79\x7C\x3F\xA7\xA2\xCD\xCB\x3C\xD1\xE0\xBD\xBA\x26\x54\xB4\xF9"
+"\xDF\x8E\x8A\xE5\x9D\x73\x3D\x9F\x33\xB3\x01\x62\x4A\xFD\x1D\x51";
+
+    static unsigned char p[] =
+"\x00\xD8\x40\xB4\x16\x66\xB4\x2E\x92\xEA\x0D\xA3\xB4\x32\x04\xB5"
+"\xCF\xCE\x33\x52\x52\x4D\x04\x16\xA5\xA4\x41\xE7\x00\xAF\x46\x12"
+"\x0D";
+    
+    static unsigned char q[] =
+"\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
+"\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5A\x0F\x20\x35\x02\x8B\x9D"
+"\x89";
+
+    static unsigned char dmp1[] =
+"\x59\x0B\x95\x72\xA2\xC2\xA9\xC4\x06\x05\x9D\xC2\xAB\x2F\x1D\xAF"
+"\xEB\x7E\x8B\x4F\x10\xA7\x54\x9E\x8E\xED\xF5\xB4\xFC\xE0\x9E\x05";
+
+    static unsigned char dmq1[] =
+"\x00\x8E\x3C\x05\x21\xFE\x15\xE0\xEA\x06\xA3\x6F\xF0\xF1\x0C\x99"
+"\x52\xC3\x5B\x7A\x75\x14\xFD\x32\x38\xB8\x0A\xAD\x52\x98\x62\x8D"
+"\x51";
+
+    static unsigned char iqmp[] =
+"\x36\x3F\xF7\x18\x9D\xA8\xE9\x0B\x1D\x34\x1F\x71\xD0\x9B\x76\xA8"
+"\xA9\x43\xE1\x1D\x10\xB2\x4D\x24\x9F\x2D\xEA\xFE\xF8\x0C\x18\x26";
+
+    static unsigned char ctext_ex[] =
+"\x1b\x8f\x05\xf9\xca\x1a\x79\x52\x6e\x53\xf3\xcc\x51\x4f\xdb\x89"
+"\x2b\xfb\x91\x93\x23\x1e\x78\xb9\x92\xe6\x8d\x50\xa4\x80\xcb\x52"
+"\x33\x89\x5c\x74\x95\x8d\x5d\x02\xab\x8c\x0f\xd0\x40\xeb\x58\x44"
+"\xb0\x05\xc3\x9e\xd8\x27\x4a\x9d\xbf\xa8\x06\x71\x40\x94\x39\xd2";
+
+    SetKey;
+    }
+
+static int key2(RSA *key, unsigned char *c)
+    {
+    static unsigned char n[] =
+"\x00\xA3\x07\x9A\x90\xDF\x0D\xFD\x72\xAC\x09\x0C\xCC\x2A\x78\xB8"
+"\x74\x13\x13\x3E\x40\x75\x9C\x98\xFA\xF8\x20\x4F\x35\x8A\x0B\x26"
+"\x3C\x67\x70\xE7\x83\xA9\x3B\x69\x71\xB7\x37\x79\xD2\x71\x7B\xE8"
+"\x34\x77\xCF";
+
+    static unsigned char e[] = "\x3";
+
+    static unsigned char d[] =
+"\x6C\xAF\xBC\x60\x94\xB3\xFE\x4C\x72\xB0\xB3\x32\xC6\xFB\x25\xA2"
+"\xB7\x62\x29\x80\x4E\x68\x65\xFC\xA4\x5A\x74\xDF\x0F\x8F\xB8\x41"
+"\x3B\x52\xC0\xD0\xE5\x3D\x9B\x59\x0F\xF1\x9B\xE7\x9F\x49\xDD\x21"
+"\xE5\xEB";
+
+    static unsigned char p[] =
+"\x00\xCF\x20\x35\x02\x8B\x9D\x86\x98\x40\xB4\x16\x66\xB4\x2E\x92"
+"\xEA\x0D\xA3\xB4\x32\x04\xB5\xCF\xCE\x91";
+
+    static unsigned char q[] =
+"\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
+"\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5F";
+    
+    static unsigned char dmp1[] =
+"\x00\x8A\x15\x78\xAC\x5D\x13\xAF\x10\x2B\x22\xB9\x99\xCD\x74\x61"
+"\xF1\x5E\x6D\x22\xCC\x03\x23\xDF\xDF\x0B";
+
+    static unsigned char dmq1[] =
+"\x00\x86\x55\x21\x4A\xC5\x4D\x8D\x4E\xCD\x61\x77\xF1\xC7\x36\x90"
+"\xCE\x2A\x48\x2C\x8B\x05\x99\xCB\xE0\x3F";
+
+    static unsigned char iqmp[] =
+"\x00\x83\xEF\xEF\xB8\xA9\xA4\x0D\x1D\xB6\xED\x98\xAD\x84\xED\x13"
+"\x35\xDC\xC1\x08\xF3\x22\xD0\x57\xCF\x8D";
+
+    static unsigned char ctext_ex[] =
+"\x14\xbd\xdd\x28\xc9\x83\x35\x19\x23\x80\xe8\xe5\x49\xb1\x58\x2a"
+"\x8b\x40\xb4\x48\x6d\x03\xa6\xa5\x31\x1f\x1f\xd5\xf0\xa1\x80\xe4"
+"\x17\x53\x03\x29\xa9\x34\x90\x74\xb1\x52\x13\x54\x29\x08\x24\x52"
+"\x62\x51";
+
+    SetKey;
+    }
+
+static int key3(RSA *key, unsigned char *c)
+    {
+    static unsigned char n[] =
+"\x00\xBB\xF8\x2F\x09\x06\x82\xCE\x9C\x23\x38\xAC\x2B\x9D\xA8\x71"
+"\xF7\x36\x8D\x07\xEE\xD4\x10\x43\xA4\x40\xD6\xB6\xF0\x74\x54\xF5"
+"\x1F\xB8\xDF\xBA\xAF\x03\x5C\x02\xAB\x61\xEA\x48\xCE\xEB\x6F\xCD"
+"\x48\x76\xED\x52\x0D\x60\xE1\xEC\x46\x19\x71\x9D\x8A\x5B\x8B\x80"
+"\x7F\xAF\xB8\xE0\xA3\xDF\xC7\x37\x72\x3E\xE6\xB4\xB7\xD9\x3A\x25"
+"\x84\xEE\x6A\x64\x9D\x06\x09\x53\x74\x88\x34\xB2\x45\x45\x98\x39"
+"\x4E\xE0\xAA\xB1\x2D\x7B\x61\xA5\x1F\x52\x7A\x9A\x41\xF6\xC1\x68"
+"\x7F\xE2\x53\x72\x98\xCA\x2A\x8F\x59\x46\xF8\xE5\xFD\x09\x1D\xBD"
+"\xCB";
+
+    static unsigned char e[] = "\x11";
+
+    static unsigned char d[] =
+"\x00\xA5\xDA\xFC\x53\x41\xFA\xF2\x89\xC4\xB9\x88\xDB\x30\xC1\xCD"
+"\xF8\x3F\x31\x25\x1E\x06\x68\xB4\x27\x84\x81\x38\x01\x57\x96\x41"
+"\xB2\x94\x10\xB3\xC7\x99\x8D\x6B\xC4\x65\x74\x5E\x5C\x39\x26\x69"
+"\xD6\x87\x0D\xA2\xC0\x82\xA9\x39\xE3\x7F\xDC\xB8\x2E\xC9\x3E\xDA"
+"\xC9\x7F\xF3\xAD\x59\x50\xAC\xCF\xBC\x11\x1C\x76\xF1\xA9\x52\x94"
+"\x44\xE5\x6A\xAF\x68\xC5\x6C\x09\x2C\xD3\x8D\xC3\xBE\xF5\xD2\x0A"
+"\x93\x99\x26\xED\x4F\x74\xA1\x3E\xDD\xFB\xE1\xA1\xCE\xCC\x48\x94"
+"\xAF\x94\x28\xC2\xB7\xB8\x88\x3F\xE4\x46\x3A\x4B\xC8\x5B\x1C\xB3"
+"\xC1";
+
+    static unsigned char p[] =
+"\x00\xEE\xCF\xAE\x81\xB1\xB9\xB3\xC9\x08\x81\x0B\x10\xA1\xB5\x60"
+"\x01\x99\xEB\x9F\x44\xAE\xF4\xFD\xA4\x93\xB8\x1A\x9E\x3D\x84\xF6"
+"\x32\x12\x4E\xF0\x23\x6E\x5D\x1E\x3B\x7E\x28\xFA\xE7\xAA\x04\x0A"
+"\x2D\x5B\x25\x21\x76\x45\x9D\x1F\x39\x75\x41\xBA\x2A\x58\xFB\x65"
+"\x99";
+
+    static unsigned char q[] =
+"\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
+"\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5A\x0F\x20\x35\x02\x8B\x9D"
+"\x86\x98\x40\xB4\x16\x66\xB4\x2E\x92\xEA\x0D\xA3\xB4\x32\x04\xB5"
+"\xCF\xCE\x33\x52\x52\x4D\x04\x16\xA5\xA4\x41\xE7\x00\xAF\x46\x15"
+"\x03";
+
+    static unsigned char dmp1[] =
+"\x54\x49\x4C\xA6\x3E\xBA\x03\x37\xE4\xE2\x40\x23\xFC\xD6\x9A\x5A"
+"\xEB\x07\xDD\xDC\x01\x83\xA4\xD0\xAC\x9B\x54\xB0\x51\xF2\xB1\x3E"
+"\xD9\x49\x09\x75\xEA\xB7\x74\x14\xFF\x59\xC1\xF7\x69\x2E\x9A\x2E"
+"\x20\x2B\x38\xFC\x91\x0A\x47\x41\x74\xAD\xC9\x3C\x1F\x67\xC9\x81";
+
+    static unsigned char dmq1[] =
+"\x47\x1E\x02\x90\xFF\x0A\xF0\x75\x03\x51\xB7\xF8\x78\x86\x4C\xA9"
+"\x61\xAD\xBD\x3A\x8A\x7E\x99\x1C\x5C\x05\x56\xA9\x4C\x31\x46\xA7"
+"\xF9\x80\x3F\x8F\x6F\x8A\xE3\x42\xE9\x31\xFD\x8A\xE4\x7A\x22\x0D"
+"\x1B\x99\xA4\x95\x84\x98\x07\xFE\x39\xF9\x24\x5A\x98\x36\xDA\x3D";
+    
+    static unsigned char iqmp[] =
+"\x00\xB0\x6C\x4F\xDA\xBB\x63\x01\x19\x8D\x26\x5B\xDB\xAE\x94\x23"
+"\xB3\x80\xF2\x71\xF7\x34\x53\x88\x50\x93\x07\x7F\xCD\x39\xE2\x11"
+"\x9F\xC9\x86\x32\x15\x4F\x58\x83\xB1\x67\xA9\x67\xBF\x40\x2B\x4E"
+"\x9E\x2E\x0F\x96\x56\xE6\x98\xEA\x36\x66\xED\xFB\x25\x79\x80\x39"
+"\xF7";
+
+    static unsigned char ctext_ex[] =
+"\xb8\x24\x6b\x56\xa6\xed\x58\x81\xae\xb5\x85\xd9\xa2\x5b\x2a\xd7"
+"\x90\xc4\x17\xe0\x80\x68\x1b\xf1\xac\x2b\xc3\xde\xb6\x9d\x8b\xce"
+"\xf0\xc4\x36\x6f\xec\x40\x0a\xf0\x52\xa7\x2e\x9b\x0e\xff\xb5\xb3"
+"\xf2\xf1\x92\xdb\xea\xca\x03\xc1\x27\x40\x05\x71\x13\xbf\x1f\x06"
+"\x69\xac\x22\xe9\xf3\xa7\x85\x2e\x3c\x15\xd9\x13\xca\xb0\xb8\x86"
+"\x3a\x95\xc9\x92\x94\xce\x86\x74\x21\x49\x54\x61\x03\x46\xf4\xd4"
+"\x74\xb2\x6f\x7c\x48\xb4\x2e\xe6\x8e\x1f\x57\x2a\x1f\xc4\x02\x6a"
+"\xc4\x56\xb4\xf5\x9f\x7b\x62\x1e\xa1\xb9\xd8\x8f\x64\x20\x2f\xb1";
+
+    SetKey;
+    }
+
+static int pad_unknown(void)
+{
+    unsigned long l;
+    while ((l = ERR_get_error()) != 0)
+      if (ERR_GET_REASON(l) == RSA_R_UNKNOWN_PADDING_TYPE)
+	return(1);
+    return(0);
+}
+
+static const char rnd_seed[] = "string to make the random number generator think it has entropy";
+
+int main(int argc, char *argv[])
+    {
+    int err=0;
+    int v;
+    RSA *key;
+    unsigned char ptext[256];
+    unsigned char ctext[256];
+    static unsigned char ptext_ex[] = "\x54\x85\x9b\x34\x2c\x49\xea\x2a";
+    unsigned char ctext_ex[256];
+    int plen;
+    int clen = 0;
+    int num;
+#ifdef CAVIUM_SSL
+#if 0
+#ifndef CAVIUM_FIPS
+    int driver_open = 0;
+#ifdef CAVIUM_MULTICARD_API
+       if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        {
+           if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))	
+	           driver_open = 1;
+        }
+#else
+        if(CSP1_driver_handle == -1)
+        {
+          if(!Csp1Initialize(CAVIUM_DIRECT))
+	           driver_open = 1;
+        }
+#endif
+#else
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+         if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+         if(Cfm1Initialize(500,DIRECT))
+#endif
+		; /*return 0; */
+#endif
+#endif
+#endif
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    RAND_seed(rnd_seed, sizeof rnd_seed); /* or OAEP may fail */
+
+    plen = sizeof(ptext_ex) - 1;
+
+    for (v = 0; v < 6; v++)
+	{
+	key = RSA_new();
+	switch (v%3) {
+    case 0:
+	clen = key1(key, ctext_ex);
+	break;
+    case 1:
+	clen = key2(key, ctext_ex);
+	break;
+    case 2:
+	clen = key3(key, ctext_ex);
+	break;
+	}
+	if (v/3 > 1) key->flags |= RSA_FLAG_NO_EXP_CONSTTIME;
+
+	num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
+				 RSA_PKCS1_PADDING);
+	if (num != clen)
+	    {
+	    printf("PKCS#1 v1.5 encryption failed!\n");
+	    err=1;
+	    goto oaep;
+	    }
+  
+	num = RSA_private_decrypt(num, ctext, ptext, key,
+				  RSA_PKCS1_PADDING);
+	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+	    {
+	    printf("PKCS#1 v1.5 decryption failed!\n");
+	    err=1;
+	    }
+	else
+	    printf("PKCS #1 v1.5 encryption/decryption ok\n");
+
+    oaep:
+	ERR_clear_error();
+	num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
+				 RSA_PKCS1_OAEP_PADDING);
+	if (num == -1 && pad_unknown())
+	    {
+	    printf("No OAEP support\n");
+	    goto next;
+	    }
+	if (num != clen)
+	    {
+	    printf("OAEP encryption failed!\n");
+	    err=1;
+	    goto next;
+	    }
+  
+	num = RSA_private_decrypt(num, ctext, ptext, key,
+				  RSA_PKCS1_OAEP_PADDING);
+	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+	    {
+	    printf("OAEP decryption (encrypted data) failed!\n");
+	    err=1;
+	    }
+	else if (memcmp(ctext, ctext_ex, num) == 0)
+	    {
+	    printf("OAEP test vector %d passed!\n", v);
+	    goto next;
+	    }
+    
+	/* Different ciphertexts (rsa_oaep.c without -DPKCS_TESTVECT).
+	   Try decrypting ctext_ex */
+
+	num = RSA_private_decrypt(clen, ctext_ex, ptext, key,
+				  RSA_PKCS1_OAEP_PADDING);
+
+	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+	    {
+	    printf("OAEP decryption (test vector data) failed!\n");
+	    err=1;
+	    }
+	else
+	    printf("OAEP encryption/decryption ok\n");
+    next:
+	RSA_free(key);
+	}
+
+    CRYPTO_cleanup_all_ex_data();
+    ERR_remove_state(0);
+
+    CRYPTO_mem_leaks_fp(stderr);
+#ifdef CAVIUM_SSL
+#if 0
+#ifndef CAVIUM_FIPS
+     if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+        Csp1Shutdown();
+#endif
+#else
+        Cfm1Shutdown();
+#endif
+#endif
+#endif
+
+
+#ifdef OPENSSL_SYS_NETWARE
+    if (err) printf("ERROR: %d\n", err);
+#endif
+    return err;
+    }
+#endif
diff -Naur openssl-0.9.8j/crypto/rsa_d/rsa_x931.c TurboSSL-0.9.8j/crypto/rsa_d/rsa_x931.c
--- openssl-0.9.8j/crypto/rsa_d/rsa_x931.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/rsa_d/rsa_x931.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,177 @@
+/* rsa_x931.c */
+/* Written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL
+ * project 2005.
+ */
+/* ====================================================================
+ * Copyright (c) 2005 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include "cryptlib.h"
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+
+int RSA_padding_add_X931(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen)
+	{
+	int j;
+	unsigned char *p;
+
+	/* Absolute minimum amount of padding is 1 header nibble, 1 padding
+	 * nibble and 2 trailer bytes: but 1 hash if is already in 'from'.
+	 */
+
+	j = tlen - flen - 2;
+
+	if (j < 0)
+		{
+		RSAerr(RSA_F_RSA_PADDING_ADD_X931,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+		return -1;
+		}
+	
+	p=(unsigned char *)to;
+
+	/* If no padding start and end nibbles are in one byte */
+	if (j == 0)
+		*p++ = 0x6A;
+	else
+		{
+		*p++ = 0x6B;
+		if (j > 1)
+			{
+			memset(p, 0xBB, j - 1);
+			p += j - 1;
+			}
+		*p++ = 0xBA;
+		}
+	memcpy(p,from,(unsigned int)flen);
+	p += flen;
+	*p = 0xCC;
+	return(1);
+	}
+
+int RSA_padding_check_X931(unsigned char *to, int tlen,
+	     const unsigned char *from, int flen, int num)
+	{
+	int i = 0,j;
+	const unsigned char *p;
+
+	p=from;
+	if ((num != flen) || ((*p != 0x6A) && (*p != 0x6B)))
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_X931,RSA_R_INVALID_HEADER);
+		return -1;
+		}
+
+	if (*p++ == 0x6B)
+		{
+		j=flen-3;
+		for (i = 0; i < j; i++)
+			{
+			unsigned char c = *p++;
+			if (c == 0xBA)
+				break;
+			if (c != 0xBB)
+				{
+				RSAerr(RSA_F_RSA_PADDING_CHECK_X931,
+					RSA_R_INVALID_PADDING);
+				return -1;
+				}
+			}
+
+		j -= i;
+
+		if (i == 0)
+			{
+			RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);
+			return -1;
+			}
+
+		}
+	else j = flen - 2;
+
+	if (p[j] != 0xCC)
+		{
+		RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_TRAILER);
+		return -1;
+		}
+
+	memcpy(to,p,(unsigned int)j);
+
+	return(j);
+	}
+
+/* Translate between X931 hash ids and NIDs */
+
+int RSA_X931_hash_id(int nid)
+	{
+	switch (nid)
+		{
+		case NID_sha1:
+		return 0x33;
+
+		case NID_sha256:
+		return 0x34;
+
+		case NID_sha384:
+		return 0x36;
+
+		case NID_sha512:
+		return 0x35;
+
+		}
+	return -1;
+	}
+
diff -Naur openssl-0.9.8j/crypto/sha/Makefile TurboSSL-0.9.8j/crypto/sha/Makefile
--- openssl-0.9.8j/crypto/sha/Makefile	2008-10-06 12:35:29.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/sha/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -106,41 +106,3 @@
 	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-sha1_one.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-sha1_one.o: ../../include/openssl/opensslconf.h
-sha1_one.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-sha1_one.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
-sha1_one.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-sha1_one.o: sha1_one.c
-sha1dgst.o: ../../include/openssl/e_os2.h ../../include/openssl/fips.h
-sha1dgst.o: ../../include/openssl/opensslconf.h
-sha1dgst.o: ../../include/openssl/opensslv.h ../../include/openssl/sha.h
-sha1dgst.o: ../md32_common.h sha1dgst.c sha_locl.h
-sha256.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-sha256.o: ../../include/openssl/fips.h ../../include/openssl/opensslconf.h
-sha256.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-sha256.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
-sha256.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-sha256.o: ../md32_common.h sha256.c
-sha512.o: ../../e_os.h ../../include/openssl/bio.h
-sha512.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
-sha512.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-sha512.o: ../../include/openssl/fips.h ../../include/openssl/lhash.h
-sha512.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-sha512.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-sha512.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
-sha512.o: ../../include/openssl/symhacks.h ../cryptlib.h sha512.c
-sha_dgst.o: ../../include/openssl/bio.h ../../include/openssl/crypto.h
-sha_dgst.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-sha_dgst.o: ../../include/openssl/fips.h ../../include/openssl/lhash.h
-sha_dgst.o: ../../include/openssl/opensslconf.h
-sha_dgst.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-sha_dgst.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
-sha_dgst.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-sha_dgst.o: ../md32_common.h sha_dgst.c sha_locl.h
-sha_one.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-sha_one.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-sha_one.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-sha_one.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
-sha_one.o: ../../include/openssl/symhacks.h sha_one.c
diff -Naur openssl-0.9.8j/crypto/sha/Makefile.save TurboSSL-0.9.8j/crypto/sha/Makefile.save
--- openssl-0.9.8j/crypto/sha/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/sha/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,108 @@
+#
+# OpenSSL/crypto/sha/Makefile
+#
+
+DIR=    sha
+TOP=    ../..
+CC=     cc
+CPP=    $(CC) -E
+INCLUDES=
+CFLAG=-g
+MAKEFILE=       Makefile
+AR=             ar r
+
+SHA1_ASM_OBJ=
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+GENERAL=Makefile
+TEST=shatest.c sha1test.c sha256t.c sha512t.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=sha_dgst.c sha1dgst.c sha_one.c sha1_one.c sha256.c sha512.c
+LIBOBJ=sha_dgst.o sha1dgst.o sha_one.o sha1_one.o sha256.o sha512.o $(SHA1_ASM_OBJ)
+
+SRC= $(LIBSRC)
+
+EXHEADER= sha.h
+HEADER= sha_locl.h $(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:    lib
+
+lib:    $(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+# ELF
+sx86-elf.s: asm/sha1-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha1-586.pl elf $(CFLAGS) $(PROCESSOR) > ../$@)
+s512sse2-elf.s:	asm/sha512-sse2.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha512-sse2.pl elf $(CFLAGS) $(PROCESSOR) > ../$@)
+# COFF
+sx86-cof.s: asm/sha1-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha1-586.pl coff $(CFLAGS) $(PROCESSOR) > ../$@)
+s512sse2-cof.s:     asm/sha512-sse2.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha512-sse2.pl coff $(CFLAGS) $(PROCESSOR) > ../$@)
+# a.out
+sx86-out.s: asm/sha1-586.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha1-586.pl a.out $(CFLAGS) $(PROCESSOR) > ../$@)
+s512sse2-out.s:     asm/sha512-sse2.pl ../perlasm/x86asm.pl
+	(cd asm; $(PERL) sha512-sse2.pl a.out $(CFLAGS) $(PROCESSOR) > ../$@)
+
+sha1-ia64.s:   asm/sha1-ia64.pl
+	(cd asm; $(PERL) sha1-ia64.pl ../$@ $(CFLAGS))
+sha256-ia64.s: asm/sha512-ia64.pl
+	(cd asm; $(PERL) sha512-ia64.pl ../$@ $(CFLAGS))
+sha512-ia64.s: asm/sha512-ia64.pl
+	(cd asm; $(PERL) sha512-ia64.pl ../$@ $(CFLAGS))
+
+# Solaris make has to be explicitly told
+sha1-x86_64.s:	asm/sha1-x86_64.pl;	$(PERL) asm/sha1-x86_64.pl $@
+sha256-x86_64.s:asm/sha512-x86_64.pl;	$(PERL) asm/sha512-x86_64.pl $@
+sha512-x86_64.s:asm/sha512-x86_64.pl;	$(PERL) asm/sha512-x86_64.pl $@
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.s *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/sha/sha1test.c TurboSSL-0.9.8j/crypto/sha/sha1test.c
--- openssl-0.9.8j/crypto/sha/sha1test.c	2007-06-07 18:13:56.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/sha/sha1test.c	2010-05-31 12:13:09.000000000 +0200
@@ -72,6 +72,14 @@
 #include <openssl/evp.h>
 #include <openssl/sha.h>
 
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+#include "cavium_common.h"
+#else
+#include "luna_common.h"
+#endif
+#endif
+
 #ifdef CHARSET_EBCDIC
 #include <openssl/ebcdic.h>
 #endif
@@ -112,6 +120,33 @@
 	EVP_MD_CTX c;
 	unsigned char md[SHA_DIGEST_LENGTH];
 
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+    int driver_open = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+    if(gpkpdev_hdlr[CAVIUM_DEV_ID] == -1)
+        {
+        if(!Csp1Initialize(CAVIUM_DIRECT,CAVIUM_DEV_ID))
+	        driver_open = 1;
+        }
+#else
+    if(CSP1_driver_handle == -1)
+        {
+        if( !Csp1Initialize(CAVIUM_DIRECT))
+	        driver_open = 1;
+        }
+#endif /*MULTICARD_API*/
+#else /*FIPS*/
+#ifdef CAVIUM_SCATTER_GATHER_MODE
+    if(Cfm1Initialize(500,SCATTER_GATHER))
+#else
+        if(Cfm1Initialize(500,DIRECT))
+#endif
+		; /*	return 0; */
+#endif
+#endif
+
 #ifdef CHARSET_EBCDIC
 	ebcdic2ascii(test[0], test[0], strlen(test[0]));
 	ebcdic2ascii(test[1], test[1], strlen(test[1]));
@@ -161,6 +196,19 @@
 #ifdef OPENSSL_SYS_NETWARE
     if (err) printf("ERROR: %d\n", err);
 #endif
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+    if(driver_open)
+#ifdef CAVIUM_MULTICARD_API
+        Csp1Shutdown(CAVIUM_DEV_ID);
+#else
+        Csp1Shutdown();
+#endif
+#else
+        Cfm1Shutdown();
+#endif
+#endif
+
 	EXIT(err);
 	EVP_MD_CTX_cleanup(&c);
 	return(0);
diff -Naur openssl-0.9.8j/crypto/stack/Makefile TurboSSL-0.9.8j/crypto/stack/Makefile
--- openssl-0.9.8j/crypto/stack/Makefile	2008-09-16 23:44:54.000000000 +0200
+++ TurboSSL-0.9.8j/crypto/stack/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -73,12 +73,3 @@
 	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-stack.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
-stack.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
-stack.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-stack.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
-stack.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-stack.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-stack.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-stack.o: ../../include/openssl/symhacks.h ../cryptlib.h stack.c
diff -Naur openssl-0.9.8j/crypto/stack/Makefile.save TurboSSL-0.9.8j/crypto/stack/Makefile.save
--- openssl-0.9.8j/crypto/stack/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/stack/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,75 @@
+#
+# OpenSSL/crypto/stack/Makefile
+#
+
+DIR=	stack
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=stack.c
+LIBOBJ=stack.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= stack.h safestack.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/crypto/x509v3/Makefile.save TurboSSL-0.9.8j/crypto/x509v3/Makefile.save
--- openssl-0.9.8j/crypto/x509v3/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/crypto/x509v3/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,85 @@
+#
+# OpenSSL/crypto/x509v3/Makefile
+#
+
+DIR=	x509v3
+TOP=	../..
+CC=	cc
+INCLUDES= -I.. -I$(TOP) -I../../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=	v3_bcons.c v3_bitst.c v3_conf.c v3_extku.c v3_ia5.c v3_lib.c \
+v3_prn.c v3_utl.c v3err.c v3_genn.c v3_alt.c v3_skey.c v3_akey.c v3_pku.c \
+v3_int.c v3_enum.c v3_sxnet.c v3_cpols.c v3_crld.c v3_purp.c v3_info.c \
+v3_ocsp.c v3_akeya.c v3_pmaps.c v3_pcons.c v3_ncons.c v3_pcia.c v3_pci.c \
+pcy_cache.c pcy_node.c pcy_data.c pcy_map.c pcy_tree.c pcy_lib.c \
+v3_asid.c v3_addr.c
+LIBOBJ= v3_bcons.o v3_bitst.o v3_conf.o v3_extku.o v3_ia5.o v3_lib.o \
+v3_prn.o v3_utl.o v3err.o v3_genn.o v3_alt.o v3_skey.o v3_akey.o v3_pku.o \
+v3_int.o v3_enum.o v3_sxnet.o v3_cpols.o v3_crld.o v3_purp.o v3_info.o \
+v3_ocsp.o v3_akeya.o v3_pmaps.o v3_pcons.o v3_ncons.o v3_pcia.o v3_pci.o \
+pcy_cache.o pcy_node.o pcy_data.o pcy_map.o pcy_tree.o pcy_lib.o \
+v3_asid.o v3_addr.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= x509v3.h
+HEADER=	$(EXHEADER) pcy_int.h
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(ARX) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@[ -n "$(MAKEDEPEND)" ] # should be set by upper Makefile...
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/demos/easy_tls/cacerts.pem TurboSSL-0.9.8j/demos/easy_tls/cacerts.pem
--- openssl-0.9.8j/demos/easy_tls/cacerts.pem	2001-09-17 21:06:57.000000000 +0200
+++ TurboSSL-0.9.8j/demos/easy_tls/cacerts.pem	2010-05-31 12:13:09.000000000 +0200
@@ -1,4 +1,4 @@
-$Id: cacerts.pem,v 1.1 2001/09/17 19:06:57 bodo Exp $
+$Id: cacerts.pem,v 1.1 2009/05/13 07:29:09 aravikumar Exp $
 
 issuer= /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test PCA (1024 bit)
 subject=/C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)
diff -Naur openssl-0.9.8j/demos/easy_tls/cert.pem TurboSSL-0.9.8j/demos/easy_tls/cert.pem
--- openssl-0.9.8j/demos/easy_tls/cert.pem	2001-09-17 21:06:57.000000000 +0200
+++ TurboSSL-0.9.8j/demos/easy_tls/cert.pem	2010-05-31 12:13:09.000000000 +0200
@@ -1,4 +1,4 @@
-$Id: cert.pem,v 1.1 2001/09/17 19:06:57 bodo Exp $
+$Id: cert.pem,v 1.1 2009/05/13 07:29:09 aravikumar Exp $
 
 Example certificate and key.
 
diff -Naur openssl-0.9.8j/demos/easy_tls/easy-tls.c TurboSSL-0.9.8j/demos/easy_tls/easy-tls.c
--- openssl-0.9.8j/demos/easy_tls/easy-tls.c	2002-03-05 10:07:16.000000000 +0100
+++ TurboSSL-0.9.8j/demos/easy_tls/easy-tls.c	2010-05-31 12:13:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* -*- Mode: C; c-file-style: "bsd" -*- */
 /*
  * easy-tls.c -- generic TLS proxy.
- * $Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $
+ * $Id: easy-tls.c,v 1.1 2009/05/13 07:29:09 aravikumar Exp $
  */
 /*
  (c) Copyright 1999 Bodo Moeller.  All rights reserved.
@@ -73,7 +73,7 @@
  */
 
 static char const rcsid[] =
-"$Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $";
+"$Id: easy-tls.c,v 1.1 2009/05/13 07:29:09 aravikumar Exp $";
 
 #include <assert.h>
 #include <errno.h>
diff -Naur openssl-0.9.8j/demos/easy_tls/easy-tls.h TurboSSL-0.9.8j/demos/easy_tls/easy-tls.h
--- openssl-0.9.8j/demos/easy_tls/easy-tls.h	2001-09-17 21:06:59.000000000 +0200
+++ TurboSSL-0.9.8j/demos/easy_tls/easy-tls.h	2010-05-31 12:13:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* -*- Mode: C; c-file-style: "bsd" -*- */
 /*
  * easy-tls.h -- generic TLS proxy.
- * $Id: easy-tls.h,v 1.1 2001/09/17 19:06:59 bodo Exp $
+ * $Id: easy-tls.h,v 1.1 2009/05/13 07:29:09 aravikumar Exp $
  */
 /*
  * (c) Copyright 1999 Bodo Moeller.  All rights reserved.
diff -Naur openssl-0.9.8j/demos/easy_tls/Makefile TurboSSL-0.9.8j/demos/easy_tls/Makefile
--- openssl-0.9.8j/demos/easy_tls/Makefile	2001-09-18 11:15:40.000000000 +0200
+++ TurboSSL-0.9.8j/demos/easy_tls/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -1,5 +1,5 @@
 # Makefile for easy-tls example application (rudimentary client and server)
-# $Id: Makefile,v 1.2 2001/09/18 09:15:40 bodo Exp $
+# $Id: Makefile,v 1.1 2009/05/13 07:29:09 aravikumar Exp $
 
 SOLARIS_CFLAGS=-Wall -pedantic -g -O2
 SOLARIS_LIBS=-lxnet
diff -Naur openssl-0.9.8j/demos/easy_tls/test.c TurboSSL-0.9.8j/demos/easy_tls/test.c
--- openssl-0.9.8j/demos/easy_tls/test.c	2001-09-17 21:06:59.000000000 +0200
+++ TurboSSL-0.9.8j/demos/easy_tls/test.c	2010-05-31 12:13:09.000000000 +0200
@@ -1,5 +1,5 @@
 /* test.c */
-/* $Id: test.c,v 1.1 2001/09/17 19:06:59 bodo Exp $ */
+/* $Id: test.c,v 1.1 2009/05/13 07:29:09 aravikumar Exp $ */
 
 #define L_PORT 9999
 #define C_PORT 443
diff -Naur openssl-0.9.8j/engines/Makefile.save TurboSSL-0.9.8j/engines/Makefile.save
--- openssl-0.9.8j/engines/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/engines/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,141 @@
+#
+# OpenSSL/engines/Makefile
+#
+
+DIR=	engines
+TOP=	..
+CC=	cc
+INCLUDES= -I../include
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+
+PEX_LIBS=
+EX_LIBS=
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile engines.com install.com engine_vector.mar
+TEST=
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBNAMES= 4758cca aep atalla cswift gmp chil nuron sureware ubsec capi
+
+LIBSRC=	e_4758cca.c \
+	e_aep.c \
+	e_atalla.c \
+	e_cswift.c \
+	e_gmp.c \
+	e_chil.c \
+	e_nuron.c \
+	e_sureware.c \
+	e_ubsec.c \
+	e_capi.c
+LIBOBJ= e_4758cca.o \
+	e_aep.o \
+	e_atalla.o \
+	e_cswift.o \
+	e_gmp.o \
+	e_chil.o \
+	e_nuron.o \
+	e_sureware.o \
+	e_ubsec.o \
+	e_capi.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= 
+HEADER=	e_4758cca_err.c e_4758cca_err.h \
+	e_aep_err.c e_aep_err.h \
+	e_atalla_err.c e_atalla_err.h \
+	e_cswift_err.c e_cswift_err.h \
+	e_gmp_err.c e_gmp_err.h \
+	e_chil_err.c e_chil_err.h \
+	e_nuron_err.c e_nuron_err.h \
+	e_sureware_err.c e_sureware_err.h \
+	e_ubsec_err.c e_ubsec_err.h \
+	e_capi_err.c e_capi_err.h
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ..; $(MAKE) DIRS=$(DIR) all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	@if [ -n "$(SHARED_LIBS)" ]; then \
+		set -e; \
+		for l in $(LIBNAMES); do \
+			$(MAKE) -f ../Makefile.shared -e \
+				LIBNAME=$$l LIBEXTRAS=e_$$l.o \
+				LIBDEPS='-L.. -lcrypto $(EX_LIBS)' \
+				link_o.$(SHLIB_TARGET); \
+		done; \
+	else \
+		$(AR) $(LIB) $(LIBOBJ); \
+		$(RANLIB) $(LIB) || echo Never mind.; \
+	fi; \
+	touch lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+
+# XXXXX This currently only works on systems that use .so as suffix
+# for shared libraries as well as for Cygwin which uses the
+# dlfcn_name_converter and therefore stores the engines with .so suffix, too.
+# XXXXX This was extended to HP-UX dl targets, which use .sl suffix.
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@if [ -n "$(SHARED_LIBS)" ]; then \
+		set -e; \
+		for l in $(LIBNAMES); do \
+			( echo installing $$l; \
+			  if [ "$(PLATFORM)" != "Cygwin" ]; then \
+				case "$(CFLAGS)" in \
+				*DSO_DLFCN*)	sfx="so";;	\
+				*DSO_DL*)	sfx="sl";;	\
+				*)		sfx="bad";;	\
+				esac; \
+				cp lib$$l.$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/lib/engines/lib$$l.$$sfx.new; \
+			  else \
+			  	sfx="so"; \
+				cp cyg$$l.dll $(INSTALL_PREFIX)$(INSTALLTOP)/lib/engines/lib$$l.$$sfx.new; \
+			  fi; \
+			  chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/lib/engines/lib$$l.$$sfx.new; \
+			  mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/lib/engines/lib$$l.$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/lib/engines/lib$$l.$$sfx ); \
+		done; \
+	fi
+
+tags:
+	ctags $(SRC)
+
+errors:
+	set -e; for l in $(LIBNAMES); do \
+		$(PERL) ../util/mkerr.pl -conf e_$$l.ec \
+			-nostatic -staticloader -write e_$$l.c; \
+	done
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@if [ -z "$(THIS)" ]; then \
+	    $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; \
+	else \
+	    $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC); \
+	fi
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/engines/vendor_defns/hwcryptohook.h TurboSSL-0.9.8j/engines/vendor_defns/hwcryptohook.h
--- openssl-0.9.8j/engines/vendor_defns/hwcryptohook.h	2002-10-11 19:10:59.000000000 +0200
+++ TurboSSL-0.9.8j/engines/vendor_defns/hwcryptohook.h	2010-05-31 12:13:09.000000000 +0200
@@ -65,7 +65,7 @@
  * please contact nCipher.
  *
  *
- * $Id: hwcryptohook.h,v 1.1 2002/10/11 17:10:59 levitte Exp $
+ * $Id: hwcryptohook.h,v 1.1 2009/05/13 07:29:10 aravikumar Exp $
  */
 
 #ifndef HWCRYPTOHOOK_H
diff -Naur openssl-0.9.8j/fips/aes/Makefile TurboSSL-0.9.8j/fips/aes/Makefile
--- openssl-0.9.8j/fips/aes/Makefile	2008-10-26 19:42:03.000000000 +0100
+++ TurboSSL-0.9.8j/fips/aes/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -85,29 +85,3 @@
 clean:
 	rm -f *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff testlist
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-fips_aes_selftest.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-fips_aes_selftest.o: ../../include/openssl/crypto.h
-fips_aes_selftest.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_aes_selftest.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-fips_aes_selftest.o: ../../include/openssl/lhash.h
-fips_aes_selftest.o: ../../include/openssl/obj_mac.h
-fips_aes_selftest.o: ../../include/openssl/objects.h
-fips_aes_selftest.o: ../../include/openssl/opensslconf.h
-fips_aes_selftest.o: ../../include/openssl/opensslv.h
-fips_aes_selftest.o: ../../include/openssl/ossl_typ.h
-fips_aes_selftest.o: ../../include/openssl/safestack.h
-fips_aes_selftest.o: ../../include/openssl/stack.h
-fips_aes_selftest.o: ../../include/openssl/symhacks.h fips_aes_selftest.c
-fips_aesavs.o: ../../e_os.h ../../include/openssl/aes.h
-fips_aesavs.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-fips_aesavs.o: ../../include/openssl/bn.h ../../include/openssl/crypto.h
-fips_aesavs.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_aesavs.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-fips_aesavs.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
-fips_aesavs.o: ../../include/openssl/objects.h
-fips_aesavs.o: ../../include/openssl/opensslconf.h
-fips_aesavs.o: ../../include/openssl/opensslv.h
-fips_aesavs.o: ../../include/openssl/ossl_typ.h
-fips_aesavs.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-fips_aesavs.o: ../../include/openssl/symhacks.h ../fips_utl.h fips_aesavs.c
diff -Naur openssl-0.9.8j/fips/aes/Makefile.save TurboSSL-0.9.8j/fips/aes/Makefile.save
--- openssl-0.9.8j/fips/aes/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/fips/aes/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,87 @@
+#
+# OpenSSL/fips/aes/Makefile
+#
+
+DIR=	aes
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+INSTALL_PREFIX=
+OPENSSLDIR=     /usr/local/ssl
+INSTALLTOP=/usr/local/ssl
+MAKEDEPPROG=	makedepend
+MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
+MAKEFILE=	Makefile
+AR=		ar r
+
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST=fips_aesavs.c
+TESTDATA=fips_aes_data
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=fips_aes_selftest.c
+LIBOBJ=fips_aes_selftest.o
+
+SRC= $(LIBSRC)
+
+EXHEADER=
+HEADER=
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd $(TOP); $(MAKE) DIRS=fips FDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	@echo $(LIBOBJ) > lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/test $(TESTDATA)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/apps $(APPS)
+
+install:
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	  (cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	  chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+fips_test:
+	-find ../testvectors/aes/req -name '*.req' > testlist
+	-rm -rf ../testvectors/aes/rsp
+	mkdir ../testvectors/aes/rsp
+	if [ -s testlist ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_aesavs -d testlist; fi
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) \
+		$(SRC) $(TEST)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff testlist
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/fips/des/Makefile TurboSSL-0.9.8j/fips/des/Makefile
--- openssl-0.9.8j/fips/des/Makefile	2008-10-26 19:42:03.000000000 +0100
+++ TurboSSL-0.9.8j/fips/des/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -82,30 +82,3 @@
 clean:
 	rm -f *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff testlist
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-fips_des_selftest.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-fips_des_selftest.o: ../../include/openssl/crypto.h
-fips_des_selftest.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_des_selftest.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-fips_des_selftest.o: ../../include/openssl/lhash.h
-fips_des_selftest.o: ../../include/openssl/obj_mac.h
-fips_des_selftest.o: ../../include/openssl/objects.h
-fips_des_selftest.o: ../../include/openssl/opensslconf.h
-fips_des_selftest.o: ../../include/openssl/opensslv.h
-fips_des_selftest.o: ../../include/openssl/ossl_typ.h
-fips_des_selftest.o: ../../include/openssl/safestack.h
-fips_des_selftest.o: ../../include/openssl/stack.h
-fips_des_selftest.o: ../../include/openssl/symhacks.h fips_des_selftest.c
-fips_desmovs.o: ../../e_os.h ../../include/openssl/asn1.h
-fips_desmovs.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
-fips_desmovs.o: ../../include/openssl/crypto.h ../../include/openssl/des.h
-fips_desmovs.o: ../../include/openssl/des_old.h ../../include/openssl/e_os2.h
-fips_desmovs.o: ../../include/openssl/err.h ../../include/openssl/evp.h
-fips_desmovs.o: ../../include/openssl/fips.h ../../include/openssl/lhash.h
-fips_desmovs.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
-fips_desmovs.o: ../../include/openssl/opensslconf.h
-fips_desmovs.o: ../../include/openssl/opensslv.h
-fips_desmovs.o: ../../include/openssl/ossl_typ.h
-fips_desmovs.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-fips_desmovs.o: ../../include/openssl/symhacks.h ../../include/openssl/ui.h
-fips_desmovs.o: ../../include/openssl/ui_compat.h ../fips_utl.h fips_desmovs.c
diff -Naur openssl-0.9.8j/fips/des/Makefile.save TurboSSL-0.9.8j/fips/des/Makefile.save
--- openssl-0.9.8j/fips/des/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/fips/des/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,84 @@
+#
+# OpenSSL/fips/des/Makefile
+#
+
+DIR=	des
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+INSTALL_PREFIX=
+OPENSSLDIR=     /usr/local/ssl
+INSTALLTOP=/usr/local/ssl
+MAKEDEPPROG=	makedepend
+MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
+MAKEFILE=	Makefile
+AR=		ar r
+
+ASFLAGS= $(INCLUDES) $(ASFLAG)
+AFLAGS= $(ASFLAGS)
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= fips_desmovs.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=fips_des_selftest.c
+LIBOBJ=fips_des_selftest.o
+
+SRC= $(LIBSRC)
+
+EXHEADER=
+HEADER=
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd $(TOP); $(MAKE) DIRS=fips FDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	@echo $(LIBOBJ) > lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/apps $(APPS)
+
+install:
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do  \
+	  (cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	  chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+fips_test:
+	-find ../testvectors/tdes/req -name '*.req' > testlist
+	-rm -rf ../testvectors/tdes/rsp
+	mkdir ../testvectors/tdes/rsp
+	if [ -s testlist ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_desmovs -d testlist; fi
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) \
+		$(SRC) $(TEST)
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o asm/*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff testlist
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/fips/Makefile.save TurboSSL-0.9.8j/fips/Makefile.save
--- openssl-0.9.8j/fips/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/fips/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,205 @@
+#
+# OpenSSL/crypto/Makefile
+#
+
+DIR=		fips
+TOP=		..
+CC=		cc
+INCLUDE=	-I. -I$(TOP) -I../include
+# INCLUDES targets sudbirs!
+INCLUDES=	-I.. -I../.. -I../../include
+CFLAG=		-g
+MAKEDEPPROG=	makedepend
+MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
+MAKEFILE=       Makefile
+RM=             rm -f
+AR=		ar r
+ARD=		ar d
+TEST=		fips_test_suite.c
+FIPS_TVDIR=	testvectors
+FIPS_TVOK=	$$HOME/fips/tv.ok
+
+FIPSCANLOC=	$(FIPSLIBDIR)fipscanister.o
+
+RECURSIVE_MAKE=	[ -n "$(FDIRS)" ] && for i in $(FDIRS) ; do \
+		    (cd $$i && echo "making $$target in $(DIR)/$$i..." && \
+		    $(MAKE) -e TOP=../.. DIR=$$i INCLUDES='${INCLUDES}' $$target ) || exit 1; \
+		done;
+
+PEX_LIBS=
+EX_LIBS=
+ 
+CFLAGS= $(INCLUDE) $(CFLAG) -DHMAC_EXT=\"$${HMAC_EXT:-sha1}\"
+ASFLAGS= $(INCLUDE) $(ASFLAG)
+AFLAGS=$(ASFLAGS)
+
+LIBS=
+
+FDIRS=sha rand des aes dsa rsa dh hmac
+
+GENERAL=Makefile README fips-lib.com install.com
+
+LIB= $(TOP)/libcrypto.a
+SHARED_LIB= $(FIPSCANLIB)$(SHLIB_EXT)
+LIBSRC=fips.c 
+LIBOBJ=fips.o
+
+FIPS_OBJ_LISTS=sha/lib hmac/lib rand/lib des/lib aes/lib dsa/lib rsa/lib dh/lib
+
+SRC= $(LIBSRC)
+
+EXHEADER=fips.h
+HEADER=$(EXHEADER) fips_utl.h fips_locl.h
+EXE=fipsld
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	@(cd ..; $(MAKE) DIRS=$(DIR) all)
+
+testapps:
+	@if [ -z "$(THIS)" ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
+
+all:
+	@if [ -z "$(FIPSLIBDIR)" ]; then \
+		$(MAKE) -e subdirs lib fips_premain_dso$(EXE_EXT); \
+	else \
+		$(MAKE) -e lib fips_premain_dso$(EXE_EXT) fips_standalone_sha1$(EXE_EXT); \
+	fi
+
+# Idea behind fipscanister.o is to "seize" the sequestered code between
+# known symbols for fingerprinting purposes, which would be commonly
+# done with ld -r start.o ... end.o. The latter however presents a minor
+# challenge on multi-ABI platforms. As just implied, we'd rather use ld,
+# but the trouble is that we don't generally know how ABI-selection
+# compiler flag is translated to corresponding linker flag. All compiler
+# drivers seem to recognize -r flag and pass it down to linker, but some
+# of them, including gcc, erroneously add -lc, as well as run-time
+# components, such as crt1.o and alike. Fortunately among those vendor
+# compilers which were observed to misinterpret -r flag multi-ABI ones
+# are equipped with smart linkers, which don't require any ABI-selection
+# flag and simply assume that all objects are of the same type as first
+# one in command line. So the idea is to identify gcc and deficient
+# vendor compiler drivers...
+
+fipscanister.o: fips_start.o $(LIBOBJ) $(FIPS_OBJ_LISTS) fips_end.o
+	FIPS_ASM=""; \
+	list="$(BN_ASM)"; for i in $$list; do FIPS_ASM="$$FIPS_ASM ../crypto/bn/$$i" ; done; \
+	list="$(AES_ASM_OBJ)"; for i in $$list; do FIPS_ASM="$$FIPS_ASM ../crypto/aes/$$i" ; done; \
+	list="$(DES_ENC)"; for i in $$list; do FIPS_ASM="$$FIPS_ASM ../crypto/des/$$i" ; done; \
+	list="$(SHA1_ASM_OBJ)"; for i in $$list; do FIPS_ASM="$$FIPS_ASM ../crypto/sha/$$i" ; done; \
+	if [ -n "$(CPUID_OBJ)" ]; then \
+		CPUID=../crypto/$(CPUID_OBJ) ; \
+	else \
+		CPUID="" ; \
+	fi ; \
+	objs="fips_start.o $(LIBOBJ) $(FIPS_EX_OBJ) $$CPUID $$FIPS_ASM"; \
+	for i in $(FIPS_OBJ_LISTS); do \
+		dir=`dirname $$i`; script="s|^|$$dir/|;s| | $$dir/|g"; \
+		objs="$$objs `sed "$$script" $$i`"; \
+	done; \
+	objs="$$objs fips_end.o" ; \
+	os="`(uname -s) 2>/dev/null`"; cflags="$(CFLAGS)"; \
+	[ "$$os" = "AIX" ] && cflags="$$cflags -Wl,-bnoobjreorder"; \
+	if [ -n "${FIPS_SITE_LD}" ]; then \
+		set -x; ${FIPS_SITE_LD} -r -o $@ $$objs; \
+	elif $(CC) -dumpversion >/dev/null 2>&1; then \
+		set -x; $(CC) $$cflags -r -nostdlib -o $@ $$objs ; \
+	else case "$$os" in \
+		HP-UX|OSF1|SunOS) set -x; /usr/ccs/bin/ld -r -o $@ $$objs ;; \
+		*) set -x; $(CC) $$cflags -r -o $@ $$objs ;; \
+	esac fi
+	./fips_standalone_sha1 fipscanister.o > fipscanister.o.sha1
+
+# If another exception is immediately required, assign approprite
+# site-specific ld command to FIPS_SITE_LD environment variable.
+
+fips_start.o: fips_canister.c
+	$(CC) $(CFLAGS) -DFIPS_START -c -o $@ fips_canister.c
+fips_end.o: fips_canister.c
+	$(CC) $(CFLAGS) -DFIPS_END -c -o $@ fips_canister.c
+fips_premain_dso$(EXE_EXT): fips_premain.c
+	$(CC) $(CFLAGS) -DFINGERPRINT_PREMAIN_DSO_LOAD -o $@ fips_premain.c \
+		$(FIPSLIBDIR)fipscanister.o ../libcrypto.a $(EX_LIBS)
+# this is executed only when linking with external fipscanister.o
+fips_standalone_sha1$(EXE_EXT):	sha/fips_standalone_sha1.c
+	$(CC) $(CFLAGS) -DFIPSCANISTER_O -o $@ sha/fips_standalone_sha1.c $(FIPSLIBDIR)fipscanister.o
+
+subdirs:
+	@target=all; $(RECURSIVE_MAKE)
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+	@target=files; $(RECURSIVE_MAKE)
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl ../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../test $(TEST)
+	@target=links; $(RECURSIVE_MAKE)
+
+# lib: and $(LIB): are splitted to avoid end-less loop
+lib:	$(LIB)
+	if [ "$(FIPSCANISTERINTERNAL)" = "n" -a -n "$(FIPSCANLOC)" ]; then $(AR) ../$(FIPSCANLIB).a $(FIPSCANLOC); fi
+	@touch lib
+
+$(LIB):	$(FIPSLIBDIR)fipscanister.o
+	$(AR) $(LIB) $(FIPSLIBDIR)fipscanister.o
+	$(RANLIB) $(LIB) || echo Never mind.
+
+$(FIPSCANLIB):	$(FIPSCANLOC)
+	$(AR) ../$(FIPSCANLIB).a $(FIPSCANLOC)
+	if [ "$(FIPSCANLIB)" = "libfips" ]; then \
+		$(AR) $(LIB) $(FIPSCANLOC) ; \
+		$(RANLIB) $(LIB) || echo Never Mind. ; \
+	fi
+	$(RANLIB) ../$(FIPSCANLIB).a || echo Never mind.
+	@touch lib
+
+shared:	lib subdirs fips_premain_dso$(EXE_EXT)
+
+libs:
+	@target=lib; $(RECURSIVE_MAKE)
+
+fips_test: top
+	@target=fips_test; $(RECURSIVE_MAKE)
+
+fips_test_diff:
+	@if diff -b -B -I '^\#' -cr -X fips-nodiff.txt $(FIPS_TVDIR) $(FIPS_TVOK) ; then \
+		echo "FIPS diff OK" ; \
+	else \
+		echo "***FIPS DIFF ERROR***" ; exit 1 ; \
+	fi
+
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ;\
+	do \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+	@target=install; $(RECURSIVE_MAKE)
+	@cp -p -f fipscanister.o fipscanister.o.sha1 fips_premain.c \
+		fips_premain.c.sha1 \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/lib/; \
+	chmod 0444 $(INSTALL_PREFIX)$(INSTALLTOP)/lib/fips*
+
+lint:
+	@target=lint; $(RECURSIVE_MAKE)
+
+depend:
+	@[ -z "$(THIS)" ] || $(MAKEDEPEND) -- $(CFLAG) $(INCLUDE) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+	@[ -z "$(THIS)" ] || (set -e; target=depend; $(RECURSIVE_MAKE) )
+	@if [ -z "$(THIS)" ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
+
+clean:
+	rm -f fipscanister.o.sha1 fips_premain_dso$(EXE_EXT) fips_standalone_sha1$(EXE_EXT) \
+		*.s *.o */*.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+	@target=clean; $(RECURSIVE_MAKE)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+	@target=dclean; $(RECURSIVE_MAKE)
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/fips/rand/Makefile TurboSSL-0.9.8j/fips/rand/Makefile
--- openssl-0.9.8j/fips/rand/Makefile	2008-09-17 19:11:08.000000000 +0200
+++ TurboSSL-0.9.8j/fips/rand/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -87,63 +87,3 @@
 	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
 
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-
-fips_rand.o: ../../e_os.h ../../include/openssl/aes.h
-fips_rand.o: ../../include/openssl/bio.h ../../include/openssl/crypto.h
-fips_rand.o: ../../include/openssl/des.h ../../include/openssl/des_old.h
-fips_rand.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_rand.o: ../../include/openssl/fips.h ../../include/openssl/fips_rand.h
-fips_rand.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-fips_rand.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-fips_rand.o: ../../include/openssl/rand.h ../../include/openssl/safestack.h
-fips_rand.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-fips_rand.o: ../../include/openssl/ui.h ../../include/openssl/ui_compat.h
-fips_rand.o: ../fips_locl.h fips_rand.c
-fips_rand_selftest.o: ../../include/openssl/bio.h
-fips_rand_selftest.o: ../../include/openssl/crypto.h
-fips_rand_selftest.o: ../../include/openssl/des.h
-fips_rand_selftest.o: ../../include/openssl/des_old.h
-fips_rand_selftest.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_rand_selftest.o: ../../include/openssl/fips.h
-fips_rand_selftest.o: ../../include/openssl/fips_rand.h
-fips_rand_selftest.o: ../../include/openssl/lhash.h
-fips_rand_selftest.o: ../../include/openssl/opensslconf.h
-fips_rand_selftest.o: ../../include/openssl/opensslv.h
-fips_rand_selftest.o: ../../include/openssl/ossl_typ.h
-fips_rand_selftest.o: ../../include/openssl/rand.h
-fips_rand_selftest.o: ../../include/openssl/safestack.h
-fips_rand_selftest.o: ../../include/openssl/stack.h
-fips_rand_selftest.o: ../../include/openssl/symhacks.h
-fips_rand_selftest.o: ../../include/openssl/ui.h
-fips_rand_selftest.o: ../../include/openssl/ui_compat.h fips_rand_selftest.c
-fips_randtest.o: ../../e_os.h ../../include/openssl/bio.h
-fips_randtest.o: ../../include/openssl/bn.h ../../include/openssl/crypto.h
-fips_randtest.o: ../../include/openssl/des.h ../../include/openssl/des_old.h
-fips_randtest.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-fips_randtest.o: ../../include/openssl/fips_rand.h
-fips_randtest.o: ../../include/openssl/lhash.h
-fips_randtest.o: ../../include/openssl/opensslconf.h
-fips_randtest.o: ../../include/openssl/opensslv.h
-fips_randtest.o: ../../include/openssl/ossl_typ.h ../../include/openssl/rand.h
-fips_randtest.o: ../../include/openssl/safestack.h
-fips_randtest.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-fips_randtest.o: ../../include/openssl/ui.h ../../include/openssl/ui_compat.h
-fips_randtest.o: ../fips_utl.h fips_randtest.c
-fips_rngvs.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-fips_rngvs.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
-fips_rngvs.o: ../../include/openssl/conf.h ../../include/openssl/crypto.h
-fips_rngvs.o: ../../include/openssl/des.h ../../include/openssl/des_old.h
-fips_rngvs.o: ../../include/openssl/dsa.h ../../include/openssl/e_os2.h
-fips_rngvs.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
-fips_rngvs.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
-fips_rngvs.o: ../../include/openssl/evp.h ../../include/openssl/fips.h
-fips_rngvs.o: ../../include/openssl/fips_rand.h ../../include/openssl/lhash.h
-fips_rngvs.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
-fips_rngvs.o: ../../include/openssl/opensslconf.h
-fips_rngvs.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-fips_rngvs.o: ../../include/openssl/pkcs7.h ../../include/openssl/rand.h
-fips_rngvs.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
-fips_rngvs.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-fips_rngvs.o: ../../include/openssl/ui.h ../../include/openssl/ui_compat.h
-fips_rngvs.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
-fips_rngvs.o: ../../include/openssl/x509v3.h ../fips_utl.h fips_rngvs.c
diff -Naur openssl-0.9.8j/fips/rand/Makefile.save TurboSSL-0.9.8j/fips/rand/Makefile.save
--- openssl-0.9.8j/fips/rand/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/fips/rand/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,89 @@
+#
+# OpenSSL/fips/rand/Makefile
+#
+
+DIR=	rand
+TOP=	../..
+CC=	cc
+INCLUDES=
+CFLAG=-g
+INSTALL_PREFIX=
+OPENSSLDIR=     /usr/local/ssl
+INSTALLTOP=/usr/local/ssl
+MAKEDEPPROG=	makedepend
+MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
+MAKEFILE=	Makefile
+AR=		ar r
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile
+TEST= fips_randtest.c fips_rngvs.c
+APPS=
+
+LIB=$(TOP)/libcrypto.a
+LIBSRC=fips_rand.c fips_rand_selftest.c
+LIBOBJ=fips_rand.o fips_rand_selftest.o
+
+SRC= $(LIBSRC)
+
+EXHEADER= fips_rand.h
+HEADER=	$(EXHEADER)
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd $(TOP); $(MAKE) DIRS=fips SDIRS=$(DIR) sub_all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	@echo $(LIBOBJ) > lib
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl $(TOP)/apps $(APPS)
+
+install:
+	@headerlist="$(EXHEADER)"; for i in $$headerlist; \
+	do \
+	  (cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	  chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+Q=../testvectors/rng/req
+A=../testvectors/rng/rsp
+
+fips_test:
+	-rm -rf $(A)
+	mkdir $(A)
+	if [ -f $(Q)/ANSI931_AES128MCT.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs mct < $(Q)/ANSI931_AES128MCT.req > $(A)/ANSI931_AES128MCT.rsp; fi
+	if [ -f $(Q)/ANSI931_AES192MCT.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs mct < $(Q)/ANSI931_AES192MCT.req > $(A)/ANSI931_AES192MCT.rsp; fi
+	if [ -f $(Q)/ANSI931_AES256MCT.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs mct < $(Q)/ANSI931_AES256MCT.req > $(A)/ANSI931_AES256MCT.rsp; fi
+	if [ -f $(Q)/ANSI931_AES128VST.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs vst < $(Q)/ANSI931_AES128VST.req > $(A)/ANSI931_AES128VST.rsp; fi
+	if [ -f $(Q)/ANSI931_AES192VST.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs vst < $(Q)/ANSI931_AES192VST.req > $(A)/ANSI931_AES192VST.rsp; fi
+	if [ -f $(Q)/ANSI931_AES256VST.req ]; then $(TOP)/util/shlib_wrap.sh $(TOP)/test/fips_rngvs vst < $(Q)/ANSI931_AES256VST.req > $(A)/ANSI931_AES256VST.rsp; fi
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	$(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(SRC) $(TEST)
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/Makefile.org TurboSSL-0.9.8j/Makefile.org
--- openssl-0.9.8j/Makefile.org	2008-12-30 14:26:26.000000000 +0100
+++ TurboSSL-0.9.8j/Makefile.org	2010-05-31 12:13:09.000000000 +0200
@@ -15,6 +15,9 @@
 CONFIGURE_ARGS=
 SHLIB_TARGET=
 
+# Build the cavium SSL macro functions.
+CAVIUM=
+
 # HERE indicates where this Makefile lives.  This can be used to indicate
 # where sub-Makefiles are expected to be.  Currently has very limited usage,
 # and should probably not be bothered with at all.
@@ -77,7 +80,7 @@
 # dependent assembler flags. E.g. if you throw -mcpu=ultrasparc at SPARC
 # gcc, then the driver will automatically translate it to -xarch=v8plus
 # and pass it down to assembler.
-AS=$(CC) -c
+AS=$(CC) -c 
 ASFLAG=$(CFLAG)
 
 # For x86 assembler: Set PROCESSOR to 386 if you want to support
@@ -142,7 +145,7 @@
 	bn ec rsa dsa ecdsa dh ecdh dso engine \
 	buffer bio stack lhash rand err \
 	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
-	store cms pqueue jpake
+	store cms pqueue jpake $(CAVIUM)
 # keep in mind that the above list is adjusted by ./Configure
 # according to no-xxx arguments...
 
diff -Naur openssl-0.9.8j/ssl/cav_crypto_engine.h TurboSSL-0.9.8j/ssl/cav_crypto_engine.h
--- openssl-0.9.8j/ssl/cav_crypto_engine.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/cav_crypto_engine.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,61 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation and/or 
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived 
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws, 
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply 
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility 
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS 
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY 
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, 
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, 
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE 
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+#ifndef CAV_CRYPTO_ENGINE_H
+#define CAV_CRYPTO_ENGINE_H
+
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#ifdef CAVIUM_FIPS
+
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m);
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle);
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle);
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle);
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa, int is_key_handle);
+
+int add_pkcs5_padding(unsigned char* key, unsigned long *size);
+int fips_import_private_key(RSA* rsa, unsigned long long *key_handle);
+int fips_import_public_key(RSA* rsa, unsigned long long *key_handle);
+# else
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m);
+int pkp_rsa_public_decrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_encrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_encrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+#endif
+
+#endif
diff -Naur openssl-0.9.8j/ssl/cav_debug.h TurboSSL-0.9.8j/ssl/cav_debug.h
--- openssl-0.9.8j/ssl/cav_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/cav_debug.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,80 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation and/or 
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived 
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws, 
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply 
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility 
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS 
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY 
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, 
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, 
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE 
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+/*
+ * cav_debug.h:
+ *	Cavium Networks
+ *  author: Naveed Cochinwala
+ */
+FILE *cav_nb_fp;
+
+#ifdef CAV_DEBUG
+#define cav_printf(format, args...)        printf(format, ##args)
+#define cav_fprintf(cav_nb_fp, format, args...)   fprintf(cav_nb_fp, format, ##args)
+#else
+#define cav_printf(format, args...)
+#define cav_fprintf(format, args...)       
+#endif
+
+/* name of log file = cav_nb.log.%d (pid) */
+#define		CAV_NB_DEBUG_FILE			"cav_nb.log."
+
+
+/*
+ * define to indicate that more cavium crypto is needed
+ */
+#define		SSL_ERROR_WANT_CAVIUM_CRYPTO		54321
+
+/*
+ * defines for crypto states
+ */
+#define		CAV_ST_INVALID				-1
+#define		CAV_ST_NONE				0
+//#define		CAV_ST_IN_HANDSHAKE			1111
+//#define		CAV_ST_IN_HANDSHAKE		        2132	
+#define		CAV_ST_IN_DECRYPT			3333
+#define		CAV_ST_IN_ENCRYPT			5555
+#define		CAV_ST_IN_VRFY_CERT			8888
+#define		CAV_ST_IN_RESUME_HANDSHAKE	        9999	
+#define	        CAV_ST_IN_CHK_DEC_PEER                  2222 
+#define		CAV_ST_IN_PRE_MASTER_KEY		4444
+#define   	CAV_ST_IN_WRITE_CONTEXT			7777
+#define         CAV_ST_IN_CHK_DEC_PEER_2		6666
+
+/*
+ * function prototypes
+ */
+extern int cav_print_state(SSL *s, char *fname);
+extern void cav_set_nb_mode(SSL *s, int nb_mode);
+extern int cav_get_nb_mode(SSL *s);
+extern int cav_check_for_completion(SSL *s);
+
+
diff -Naur openssl-0.9.8j/ssl/cav_ecc_mul.h TurboSSL-0.9.8j/ssl/cav_ecc_mul.h
--- openssl-0.9.8j/ssl/cav_ecc_mul.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/cav_ecc_mul.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,56 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations,
+and may be
+ * subject to export or import regulations in other countries. You warrant that
+You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND
+WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS,
+IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS,
+QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+
+#ifndef CAV_ECC_MUL_H
+#define CAV_ECC_MUL_H
+#include<openssl/ec.h>
+#include<openssl/cavium_common.h>
+#include<openssl/objects.h>
+#include<openssl/bn.h>
+
+Uint64 Get_Curve_Id(const EC_GROUP *group);
+void* Allocate_Memory(int num);
+int Ecc_Alloc_Context(EC_GROUP *group,Uint64 cid);
+int Cav_Ecc_Mul(const EC_GROUP *group,Uint64 cid,EC_POINT *r,const BIGNUM *k,const EC_POINT *point,const BIGNUM *scalar,BN_CTX *ctx);
+int Fixed_Point_Mul(const EC_GROUP *group,EC_POINT *r,const BIGNUM *scalar,BN_CTX *ctx);
+int Unknown_Point_Mul(const EC_GROUP *group,EC_POINT *r,const EC_POINT *point,const BIGNUM *p_scalar,BN_CTX *ctx);
+
+/*  r=k*p(fixed)+point*scalar(unknown)  */
+
+int Simul_Point_Mul(const EC_GROUP *group,EC_POINT *r,const BIGNUM *k,const EC_POINT *point,const BIGNUM *scalar,BN_CTX *ctx);
+
+#endif
diff -Naur openssl-0.9.8j/ssl/cavium_ssl.h TurboSSL-0.9.8j/ssl/cavium_ssl.h
--- openssl-0.9.8j/ssl/cavium_ssl.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/cavium_ssl.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,3237 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation and/or 
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived 
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws, 
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply 
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility 
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS 
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY 
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, 
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, 
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE 
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+/******************************************/
+/* cavium_ssl.h                           */
+/*                                        */
+/* Copyright 2001 by Caveo Networks, Inc. */
+/*                                        */
+/* Structs used to transfer data between  */
+/* the shim layer and the driver.         */ 
+/******************************************/
+
+
+#ifndef _CAVIUM_SSL_H_
+#define _CAVIUM_SSL_H_
+
+#ifndef CSP1_KERNEL
+
+
+typedef enum {VER_TLS = 0, VER3_0 = 1} SslVersion;
+#ifdef MC2
+typedef enum {UNSUPPORTED_RC4 = -1, RC4_128 = 8, RC4_EXPORT_40 = 9, RC4_EXPORT_56 = 11} Rc4Type;
+typedef enum {UNSUPPORTED_DES = -1, DES = 12, DES_EXPORT_40 = 13, DES3_192 = 14} DesType;
+#else
+typedef enum {UNSUPPORTED_RC4 = -1, RC4_128 = 0, RC4_EXPORT_40 = 1, RC4_EXPORT_56 = 7} Rc4Type;
+typedef enum {UNSUPPORTED_DES = -1, DES = 0, DES_EXPORT_40 = 1, DES3_192 = 2} DesType;
+#endif
+typedef enum {CHANGE_CIPHER_SPEC = 0, ALERT = 1, HANDSHAKE = 2, APP_DATA = 3} MessageType;
+typedef enum {NOT_RETURNED = 0, RETURN_ENCRYPTED = 1} MasterSecretReturn;
+typedef enum {READ_FROM_CONTEXT = 0, INPUT_ENCRYPTED = 1} MasterSecretInput;
+typedef enum {RETURN_CFM_ENCRYPTED = 0, RETURN_CFM_UNENCRYPTED = 1} ClientFinishMessageOutput;
+typedef enum {RETURN_SFM_ENCRYPTED = 0, RETURN_SFM_UNENCRYPTED = 1} ServerFinishMessageOutput;
+typedef enum {SSL_SERVER = 0, SSL_CLIENT = 1} SslPartyType;
+
+
+/* SSLv2 specific Context Offsets */
+
+#define OFFSET_SSL2_MASTER_SECRET				16
+
+#define OFFSET_SSL2_3DES_SERVER_READ_SEQ		22
+#define OFFSET_SSL2_3DES_SERVER_READ_KM			24
+#define OFFSET_SSL2_3DES_SERVER_WRITE_SEQ		28
+#define OFFSET_SSL2_3DES_SERVER_WRITE_KM		30
+
+#define OFFSET_SSL2_RC4_SERVER_READ_SEQ			22
+#define OFFSET_SSL2_RC4_SERVER_READ_KM			24
+#define OFFSET_SSL2_RC4_SERVER_READ_STATE		26
+#define OFFSET_SSL2_RC4_SERVER_WRITE_SEQ		60
+#define OFFSET_SSL2_RC4_SERVER_WRITE_KM			62
+#define OFFSET_SSL2_RC4_SERVER_WRITE_STATE		64
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1GetDmaMode
+ * 
+ * Returns the current DMA mode
+ *
+ * Input
+ *  none
+ * 
+ * Ouput
+ *  none
+ *
+ * Return Value
+ * DmaMode: DIRECT=0, SCATTER_GATHER=1.
+ *
+ *-***************************************************************************/
+DmaMode 
+Csp1GetDmaMode(void);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1GetDriverState
+ * 
+ * Function to check whether the driver handle is initialzed or not.
+ *
+ * Input
+ *  none
+ * 
+ * Ouput
+ *  none
+ *
+ * Return Value
+ * 0  = driver handle is ready.
+ * -1 = driver handle is not initialized
+ *-***************************************************************************/
+int 
+Csp1GetDriverState(void);
+
+/*+****************************************************************************
+ *
+ * Csp1SetEncryptedMasterSecretKey
+ *
+ * Sets the key material for encryption of master secrets used by resume 
+ * operations.
+ *
+ * Input
+ *	key = pointer to 48 bytes of key material
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_IOCTL, or 
+ *	ERR_BAD_KEY_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1SetEncryptedMasterSecretKey(Uint8 *key);
+
+/*+****************************************************************************
+ *
+ * Csp1Handshake
+ *
+ * Calculates the hashes needed by the SSL handshake.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *	message = pointer to length bytes of input
+ *
+ * Output
+ *	md5_final_hash = pointer to the 4-word handshake intermediate result 
+ *	sha1_final_hash = pointer to the 5-word handshake intermediate result 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Handshake(Csp1RequestType request_type,
+			  Uint64 context_handle, 
+			  Uint16 message_length, 
+			  Uint8 *message, 
+			  Uint8 *md5_final_hash, 
+			  Uint8 *sha1_final_hash,
+			  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeStart
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *	message = pointer to length bytes of input
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HandshakeStart(Csp1RequestType request_type,
+				   Uint64 context_handle, 
+				   Uint16 message_length, 
+				   Uint8 *message,
+				   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeUpdate
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *	message = pointer to length bytes of input
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HandshakeUpdate(n1_request_type request_type,
+					Uint64 context_handle, 
+				    Uint16 message_length, 
+				    Uint8 *message,
+					Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeFinish
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *	message = pointer to length bytes of input
+ *
+ * Output
+ *	md5_final_hash = pointer to the 4-word handshake final result 
+ *	sha1_final_hash = pointer to the 5-word handshake final result 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HandshakeFinish(n1_request_type request_type,
+					Uint64 context_handle, 
+				    Uint16 message_length, 
+				    Uint8 *message, 
+				    Uint8 *md5_final_hash, 
+				    Uint8 *sha1_final_hash,
+					Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullRc4
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the RC4 cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE,  
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFullRc4(n1_request_type request_type,
+					 Uint64 context_handle, 
+				     Uint64 *key_handle, 
+				     HashType hash_type, 
+				     SslVersion ssl_version, 
+				     Rc4Type rc4_type,
+				     MasterSecretReturn master_secret_ret,
+				     Uint16 modlength, 
+				     Uint8 *encrypt_premaster_secret, 
+				     Uint8 *client_random, 
+				     Uint8 *server_random, 
+				     Uint16 handshake_length, 
+				     Uint8 *handshake, 
+				     Uint8 *client_finished_message,
+				     Uint8 *server_finished_message, 
+					 Uint8 *encrypt_master_secret,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullRc4Finish
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the RC4 cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request (previously hashed plus included 
+ * messsage data) should include all handshake message data after (and 
+ * including) the client hello message up until (but not including) the first 
+ * finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFullRc4Finish(n1_request_type request_type,
+						   Uint64 context_handle, 
+				           Uint64 *key_handle, 
+					       HashType hash_type, 
+					       SslVersion ssl_version, 
+					       Rc4Type rc4_type, 
+					       MasterSecretReturn master_secret_ret,
+					       Uint16 modlength, 
+					       Uint8 *encrypt_premaster_secret, 
+					       Uint8 *client_random, 
+					       Uint8 *server_random, 
+					       Uint16 handshake_length, 
+					       Uint8 *handshake, 
+					       Uint8 *client_finished_message,
+					       Uint8 *server_finished_message, 
+					       Uint8 *encrypt_master_secret,
+						   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyRc4
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message.  
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyRc4(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       Uint64 *key_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+				       Rc4Type rc4_type, 
+				       MasterSecretReturn master_secret_ret,
+				       Uint16 modlength, 
+				       Uint8 *encrypt_premaster_secret, 
+				       Uint8 *client_random, 
+				       Uint8 *server_random, 
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *verify_data,
+					   Uint8 *encrypt_master_secret,
+					   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyRc4Finish
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * Handshake data can be accumulated prior to this request by calls to 
+ * Handshake*, and this request will append the included handshake 
+ * message data to the pre-existing handshake hash state. The handshake message 
+ * data for this request (previously hashed plus included messsage data) should 
+ * include all handshake message data after (and including) the client hello 
+ * message up until (but not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyRc4Finish(n1_request_type request_type,
+							 Uint64 context_handle, 
+				             Uint64 *key_handle, 
+						     HashType hash_type, 
+						     SslVersion ssl_version, 
+						     Rc4Type rc4_type, 
+						     MasterSecretReturn master_secret_ret,
+						     Uint16 modlength, 
+						     Uint8 *encrypt_premaster_secret, 
+						     Uint8 *client_random, 
+						     Uint8 *server_random, 
+						     Uint16 handshake_length, 
+						     Uint8 *handshake, 
+						     Uint8 *verify_data,
+					         Uint8 *encrypt_master_secret,
+							 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFull3Des
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the DES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL,
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFull3Des(n1_request_type request_type,
+					  Uint64 context_handle, 
+				      Uint64 *key_handle, 
+				      HashType hash_type, 
+				      SslVersion ssl_version, 
+				      DesType des_type, 
+				      MasterSecretReturn master_secret_ret,
+					  ClientFinishMessageOutput clnt_fin_msg_out,
+					  ServerFinishMessageOutput srvr_fin_msg_out,
+				      Uint16 client_pad_length,
+				      Uint16 server_pad_length,
+				      Uint16 modlength, 
+				      Uint8 *encrypt_premaster_secret, 
+				      Uint8 *client_random, 
+				      Uint8 *server_random, 
+				      Uint16 handshake_length, 
+				      Uint8 *handshake, 
+				      Uint8 *client_finished_message,
+				      Uint8 *server_finished_message, 
+					  Uint8 *encrypt_master_secret,
+					  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFull3DesFinish
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the DES cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL,
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL,  
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE,  
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFull3DesFinish(n1_request_type request_type,
+							Uint64 context_handle, 
+				            Uint64 *key_handle, 
+					        HashType hash_type, 
+					        SslVersion ssl_version, 
+					        DesType des_type, 
+				            MasterSecretReturn master_secret_ret,
+							ClientFinishMessageOutput clnt_fin_msg_out,
+							ServerFinishMessageOutput srvr_fin_msg_out,
+					        Uint16 client_pad_length,
+					        Uint16 server_pad_length,
+					        Uint16 modlength, 
+					        Uint8 *encrypt_premaster_secret, 
+					        Uint8 *client_random, 
+					        Uint8 *server_random, 
+					        Uint16 handshake_length, 
+					        Uint8 *handshake, 
+					        Uint8 *client_finished_message,
+					        Uint8 *server_finished_message, 
+					        Uint8 *encrypt_master_secret,
+							Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerify3Des
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40, DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE,  
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerify3Des(n1_request_type request_type,
+						Uint64 context_handle, 
+				        Uint64 *key_handle, 
+				        HashType hash_type, 
+				        SslVersion ssl_version, 
+				        DesType des_type, 
+				        MasterSecretReturn master_secret_ret,
+				        Uint16 modlength, 
+				        Uint8 *encrypt_premaster_secret, 
+				        Uint8 *client_random, 
+				        Uint8 *server_random, 
+				        Uint16 handshake_length, 
+				        Uint8 *handshake, 
+				        Uint8 *verify_data,
+					    Uint8 *encrypt_master_secret,
+						Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerify3DesFinish
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL,  
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerify3DesFinish(n1_request_type request_type,
+							  Uint64 context_handle, 
+				              Uint64 *key_handle, 
+						      HashType hash_type, 
+						      SslVersion ssl_version, 
+						      DesType des_type, 
+						      MasterSecretReturn master_secret_ret,
+						      Uint16 modlength, 
+						      Uint8 *encrypt_premaster_secret, 
+						      Uint8 *client_random, 
+						      Uint8 *server_random, 
+						      Uint16 handshake_length, 
+						      Uint8 *handshake, 
+						      Uint8 *verify_data,
+					          Uint8 *encrypt_master_secret,
+							  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullAes
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the AES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL,  
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE,  
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFullAes(n1_request_type request_type,
+					 Uint64 context_handle, 
+				     Uint64 *key_handle, 
+				     HashType hash_type, 
+				     SslVersion ssl_version, 
+				     AesType aes_type, 
+				     MasterSecretReturn master_secret_ret,
+					 ClientFinishMessageOutput clnt_fin_msg_out,
+					 ServerFinishMessageOutput srvr_fin_msg_out,
+				     Uint16 client_pad_length,
+				     Uint16 server_pad_length,
+				     Uint16 modlength, 
+				     Uint8 *encrypt_premaster_secret, 
+				     Uint8 *client_random, 
+				     Uint8 *server_random, 
+				     Uint16 handshake_length, 
+				     Uint8 *handshake, 
+				     Uint8 *client_finished_message,
+				     Uint8 *server_finished_message, 
+					 Uint8 *encrypt_master_secret,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullAesFinish
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the aes cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerFullAesFinish(n1_request_type request_type,
+						   Uint64 context_handle, 
+				           Uint64 *key_handle, 
+					       HashType hash_type, 
+					       SslVersion ssl_version, 
+					       AesType aes_type, 
+					       MasterSecretReturn master_secret_ret,
+						   ClientFinishMessageOutput clnt_fin_msg_out,
+						   ServerFinishMessageOutput srvr_fin_msg_out,
+					       Uint16 client_pad_length,
+					       Uint16 server_pad_length,
+					       Uint16 modlength, 
+					       Uint8 *encrypt_premaster_secret, 
+					       Uint8 *client_random, 
+					       Uint8 *server_random, 
+					       Uint16 handshake_length, 
+					       Uint8 *handshake, 
+					       Uint8 *client_finished_message,
+					       Uint8 *server_finished_message, 
+					       Uint8 *encrypt_master_secret,
+						   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyAes
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyAes(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       Uint64 *key_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+				       AesType aes_type, 
+				       MasterSecretReturn master_secret_ret,
+				       Uint16 modlength, 
+				       Uint8 *encrypt_premaster_secret, 
+				       Uint8 *client_random, 
+				       Uint8 *server_random, 
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *verify_data,
+					   Uint8 *encrypt_master_secret,
+					   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyAesFinish
+ *
+ * With RSA <= 1024, do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL,
+ *	ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, ERR_BAD_IOCTL, 
+ *	ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, 
+ *	ERR_ILLEGAL_KEY_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyAesFinish(n1_request_type request_type,
+							 Uint64 context_handle, 
+				             Uint64 *key_handle, 
+						     HashType hash_type, 
+						     SslVersion ssl_version, 
+						     AesType aes_type, 
+						     MasterSecretReturn master_secret_ret,
+						     Uint16 modlength, 
+						     Uint8 *encrypt_premaster_secret, 
+						     Uint8 *client_random, 
+						     Uint8 *server_random, 
+						     Uint16 handshake_length, 
+						     Uint8 *handshake, 
+						     Uint8 *verify_data,
+					         Uint8 *encrypt_master_secret,
+							 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullRc4
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the RC4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFullRc4(n1_request_type request_type,
+				 Uint64 context_handle, 
+			     HashType hash_type, 
+			     SslVersion ssl_version, 
+			     Rc4Type rc4_type, 
+			     MasterSecretReturn master_secret_ret,
+			     Uint16 pre_master_length, 
+			     Uint8 *client_random, 
+			     Uint8 *server_random, 
+			     Uint16 handshake_length, 
+			     Uint8 *handshake, 
+			     Uint8 *client_finished_message,
+			     Uint8 *server_finished_message, 
+			     Uint8 *encrypt_master_secret,
+				 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullRc4Finish
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the rc4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFullRc4Finish(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+				       Rc4Type rc4_type, 
+				       MasterSecretReturn master_secret_ret,
+				       Uint16 pre_master_length, 
+				       Uint8 *client_random, 
+				       Uint8 *server_random, 
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *client_finished_message,
+				       Uint8 *server_finished_message, 
+					   Uint8 *encrypt_master_secret,
+					   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyRc4
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerifyRc4(n1_request_type request_type,
+				   Uint64 context_handle, 
+			       HashType hash_type, 
+			       SslVersion ssl_version, 
+			       Rc4Type rc4_type, 
+			       MasterSecretReturn master_secret_ret,
+			       Uint16 pre_master_length, 
+			       Uint8 *client_random, 
+			       Uint8 *server_random, 
+			       Uint16 handshake_length, 
+			       Uint8 *handshake, 
+			       Uint8 *verify_data,
+				   Uint8 *encrypt_master_secret,
+				   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyRc4Finish
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the rc4 cases.
+ *
+ * The handshake message data for this request should include all handshake message
+ * data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerifyRc4Finish(n1_request_type request_type,
+						 Uint64 context_handle, 
+					     HashType hash_type, 
+					     SslVersion ssl_version, 
+					     Rc4Type rc4_type, 
+					     MasterSecretReturn master_secret_ret,
+					     Uint16 pre_master_length, 
+					     Uint8 *client_random, 
+					     Uint8 *server_random, 
+					     Uint16 handshake_length, 
+					     Uint8 *handshake, 
+					     Uint8 *verify_data,
+					     Uint8 *encrypt_master_secret,
+						 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFull3Des
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFull3Des(n1_request_type request_type,
+				  Uint64 context_handle, 
+			      HashType hash_type, 
+			      SslVersion ssl_version, 
+			      DesType des_type, 
+			      MasterSecretReturn master_secret_ret,
+				  ClientFinishMessageOutput clnt_fin_msg_out,
+				  ServerFinishMessageOutput srvr_fin_msg_out,
+			      Uint16 client_pad_length,
+			      Uint16 server_pad_length,
+			      Uint16 pre_master_length, 
+			      Uint8 *client_random, 
+			      Uint8 *server_random, 
+			      Uint16 handshake_length, 
+			      Uint8 *handshake, 
+			      Uint8 *client_finished_message,
+			      Uint8 *server_finished_message, 
+				  Uint8 *encrypt_master_secret,
+				  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFull3DesFinish
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFull3DesFinish(n1_request_type request_type,
+						Uint64 context_handle, 
+				        HashType hash_type, 
+				        SslVersion ssl_version, 
+				        DesType des_type, 
+					    MasterSecretReturn master_secret_ret,
+					    ClientFinishMessageOutput clnt_fin_msg_out,
+					    ServerFinishMessageOutput srvr_fin_msg_out,
+				        Uint16 client_pad_length,
+				        Uint16 server_pad_length,
+				        Uint16 pre_master_length, 
+				        Uint8 *client_random, 
+				        Uint8 *server_random, 
+				        Uint16 handshake_length, 
+				        Uint8 *handshake, 
+				        Uint8 *client_finished_message,
+				        Uint8 *server_finished_message, 
+					    Uint8 *encrypt_master_secret,
+						Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerify3Des
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40, DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerify3Des(n1_request_type request_type,
+					Uint64 context_handle, 
+			        HashType hash_type, 
+			        SslVersion ssl_version, 
+			        DesType des_type, 
+				    MasterSecretReturn master_secret_ret,
+			        Uint16 pre_master_length, 
+			        Uint8 *client_random, 
+			        Uint8 *server_random, 
+			        Uint16 handshake_length, 
+			        Uint8 *handshake, 
+			        Uint8 *verify_data,
+					Uint8 *encrypt_master_secret,
+					Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerify3DesFinish
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or 
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerify3DesFinish(n1_request_type request_type,
+						  Uint64 context_handle, 
+					      HashType hash_type, 
+					      SslVersion ssl_version, 
+					      DesType des_type, 
+					      MasterSecretReturn master_secret_ret,
+					      Uint16 pre_master_length, 
+					      Uint8 *client_random, 
+					      Uint8 *server_random, 
+					      Uint16 handshake_length, 
+					      Uint8 *handshake, 
+					      Uint8 *verify_data,
+					      Uint8 *encrypt_master_secret,
+						  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullAes
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFullAes(n1_request_type request_type,
+				 Uint64 context_handle, 
+		    	 HashType hash_type, 
+			     SslVersion ssl_version, 
+			     AesType aes_type, 
+			     MasterSecretReturn master_secret_ret,
+				 ClientFinishMessageOutput clnt_fin_msg_out,
+				 ServerFinishMessageOutput srvr_fin_msg_out,
+			     Uint16 client_pad_length,
+			     Uint16 server_pad_length,
+			     Uint16 pre_master_length, 
+			     Uint8 *client_random, 
+			     Uint8 *server_random, 
+			     Uint16 handshake_length, 
+			     Uint8 *handshake, 
+			     Uint8 *client_finished_message,
+			     Uint8 *server_finished_message, 
+				 Uint8 *encrypt_master_secret,
+				 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullAesFinish
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherFullAesFinish(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+				       AesType aes_type, 
+				       MasterSecretReturn master_secret_ret,
+					   ClientFinishMessageOutput clnt_fin_msg_out,
+					   ServerFinishMessageOutput srvr_fin_msg_out,
+				       Uint16 client_pad_length,
+				       Uint16 server_pad_length,
+				       Uint16 pre_master_length, 
+				       Uint8 *client_random, 
+				       Uint8 *server_random, 
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *client_finished_message,
+				       Uint8 *server_finished_message, 
+					   Uint8 *encrypt_master_secret,
+					   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyAes
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or 
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerifyAes(n1_request_type request_type,
+				   Uint64 context_handle, 
+			       HashType hash_type, 
+			       SslVersion ssl_version, 
+			       AesType aes_type, 
+			       MasterSecretReturn master_secret_ret,
+			       Uint16 pre_master_length, 
+			       Uint8 *client_random, 
+			       Uint8 *server_random, 
+			       Uint16 handshake_length, 
+			       Uint8 *handshake, 
+			       Uint8 *verify_data,
+				   Uint8 *encrypt_master_secret,
+				   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyAesFinish
+ *
+ * When not (RSA <= 1024), do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or 
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1OtherVerifyAesFinish(n1_request_type request_type,
+						 Uint64 context_handle, 
+					     HashType hash_type, 
+				    	 SslVersion ssl_version, 
+					     AesType aes_type, 
+					     MasterSecretReturn master_secret_ret,
+					     Uint16 pre_master_length, 
+					     Uint8 *client_random, 
+					     Uint8 *server_random, 
+					     Uint16 handshake_length, 
+				    	 Uint8 *handshake, 
+				    	 Uint8 *verify_data,
+					     Uint8 *encrypt_master_secret,
+						 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1FinishedRc4Finish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the RC4 cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyRc4* or 
+ * OtherVerifyRc4*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1FinishedRc4Finish(n1_request_type request_type,
+					  Uint64 context_handle, 
+				      HashType hash_type, 
+				      SslVersion ssl_version, 
+				      Uint16 handshake_length, 
+				      Uint8 *handshake, 
+				      Uint8 *client_finished_message, 
+				      Uint8 *server_finished_message,
+					  Uint32 *request_id); 
+
+
+/*+****************************************************************************
+ *
+ * Csp1Finished3DesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all DES/3DES 
+ * cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerify3Des* or 
+ * OtherVerify3Des*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Finished3DesFinish(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+					   ClientFinishMessageOutput clnt_fin_msg_out,
+					   ServerFinishMessageOutput srvr_fin_msg_out,
+				       Uint16 client_pad_length,
+				       Uint16 server_pad_length,
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *client_finished_message, 
+				       Uint8 *server_finished_message,
+					   Uint32 *request_id); 
+
+
+/*+****************************************************************************
+ *
+ * Csp1FinishedAesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the AES cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyAes* or 
+ * OtherVerifyAes*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1FinishedAesFinish(n1_request_type request_type,
+					  Uint64 context_handle, 
+				      HashType hash_type, 
+				      SslVersion ssl_version, 
+				      AesType aes_type, 
+					  ClientFinishMessageOutput clnt_fin_msg_out,
+					  ServerFinishMessageOutput srvr_fin_msg_out,
+				      Uint16 client_pad_length,
+				      Uint16 server_pad_length,
+				      Uint16 handshake_length, 
+				      Uint8 *handshake, 
+				      Uint8 *client_finished_message, 
+				      Uint8 *server_finished_message,
+					  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeRc4
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1ResumeRc4(n1_request_type request_type,
+			  Uint64 context_handle, 
+		      HashType hash_type, 
+		      SslVersion ssl_version, 
+		      Rc4Type rc4_type,
+		      MasterSecretInput master_secret_inp,
+		      Uint8 *client_random, 
+		      Uint8 *server_random,
+		      Uint8 *encrypt_master_secret,
+		      Uint16 handshake_length, 
+		      Uint8 *handshake, 
+		      Uint8 *client_finished_message, 
+		      Uint8 *server_finished_message,
+			  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeRc4Finish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1ResumeRc4Finish(n1_request_type request_type,
+					Uint64 context_handle, 
+			    	HashType hash_type, 
+			    	SslVersion ssl_version, 
+			    	Rc4Type rc4_type, 
+			    	MasterSecretInput master_secret_inp,
+			    	Uint8 *client_random, 
+			    	Uint8 *server_random, 
+			    	Uint8 *encrypt_master_secret,
+			    	Uint16 handshake_length, 
+			    	Uint8 *handshake, 
+			    	Uint8 *client_finished_message, 
+			    	Uint8 *server_finished_message,
+					Uint32 *request_id); 
+
+
+/*+****************************************************************************
+ *
+ * Csp1Resume3Des
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Resume3Des(n1_request_type request_type,
+			   Uint64 context_handle, 
+		       HashType hash_type, 
+		       SslVersion ssl_version, 
+		       DesType des_type, 
+		       MasterSecretInput master_secret_inp,
+			   ClientFinishMessageOutput clnt_fin_msg_out,
+			   ServerFinishMessageOutput srvr_fin_msg_out,
+		       Uint16 client_pad_length,
+		       Uint16 server_pad_length,
+		       Uint8 *client_random, 
+		       Uint8 *server_random, 
+		       Uint8 *encrypt_master_secret,
+		       Uint16 handshake_length, 
+	   	       Uint8 *handshake, 
+		       Uint8 *client_finished_message, 
+		       Uint8 *server_finished_message,
+			   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1Resume3DesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Resume3DesFinish(n1_request_type request_type,
+					 Uint64 context_handle, 
+			    	 HashType hash_type, 
+			    	 SslVersion ssl_version, 
+			    	 DesType des_type, 
+			    	 MasterSecretInput master_secret_inp,
+					 ClientFinishMessageOutput clnt_fin_msg_out,
+					 ServerFinishMessageOutput srvr_fin_msg_out,
+			    	 Uint16 client_pad_length,
+			    	 Uint16 server_pad_length,
+			    	 Uint8 *client_random, 
+			    	 Uint8 *server_random, 
+			    	 Uint8 *encrypt_master_secret,
+			    	 Uint16 handshake_length, 
+			    	 Uint8 *handshake, 
+			    	 Uint8 *client_finished_message, 
+			    	 Uint8 *server_finished_message,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeAes
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1ResumeAes(n1_request_type request_type,
+			  Uint64 context_handle, 
+	    	  HashType hash_type, 
+	    	  SslVersion ssl_version, 
+	    	  AesType aes_type, 
+		      MasterSecretInput master_secret_inp,
+			  ClientFinishMessageOutput clnt_fin_msg_out,
+			  ServerFinishMessageOutput srvr_fin_msg_out,
+		      Uint16 client_pad_length,
+		      Uint16 server_pad_length,
+		      Uint8 *client_random, 
+	    	  Uint8 *server_random, 
+		      Uint8 *encrypt_master_secret,
+		      Uint16 handshake_length, 
+		      Uint8 *handshake, 
+		      Uint8 *client_finished_message, 
+		      Uint8 *server_finished_message,
+			  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeAesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_ENCRYPTED or RETURN_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, or ERR_ILLEGAL_CONTEXT_HANDLE
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1ResumeAesFinish(n1_request_type request_type,
+					Uint64 context_handle, 
+			    	HashType hash_type, 
+			    	SslVersion ssl_version, 
+			    	AesType aes_type, 
+			    	MasterSecretInput master_secret_inp,
+					ClientFinishMessageOutput clnt_fin_msg_out,
+					ServerFinishMessageOutput srvr_fin_msg_out,
+			    	Uint16 client_pad_length,
+			    	Uint16 server_pad_length,
+			    	Uint8 *client_random, 
+			    	Uint8 *server_random, 
+			    	Uint8 *encrypt_master_secret,
+			    	Uint16 handshake_length, 
+			    	Uint8 *handshake, 
+			    	Uint8 *client_finished_message, 
+			    	Uint8 *server_finished_message,
+					Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecordRc4
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	message_length = size of message in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to (length + hash_size) bytes of encrypted record 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1EncryptRecordRc4(n1_request_type request_type,
+					 Uint64 context_handle, 
+			HashType hash_type,  
+			SslVersion ssl_version, 
+			SslPartyType ssl_party,
+			MessageType message_type,
+			Uint16 message_length, 
+			Uint8 *message, 
+			Uint8 *record,
+			Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordRc4
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER3_1
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of record in bytes (0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to (record length - hash size) bytes 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_ILLEGAL_CONTEXT_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1DecryptRecordRc4(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+		 			 SslPartyType ssl_party,
+					 MessageType message_type, 
+					 Uint16 record_length, 
+					 Uint8 *record, 
+					 Uint8 *message,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecord3Des
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER3_1
+ *	pad_length = size of extra padding in 8-byte blocks
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	message_length = size of input in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte input message
+ *
+ * Output
+ *	record_length = pointer to length of the encrypted part of the record in bytes
+ *	record = pointer to *record_length-byte output 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1EncryptRecord3Des(n1_request_type request_type,
+					  Uint64 context_handle, 
+					  HashType hash_type, 
+					  SslVersion ssl_version, 
+					  SslPartyType ssl_party,
+					  MessageType message_type, 
+					  Uint16 pad_length,
+					  Uint16 message_length, 
+					  Uint8 *message, 
+					  Uint16 *record_length, 
+					  Uint8 *record,
+					  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecord3Des
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER3_1
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of the encrypted part of the input record in bytes 
+ *		(length%8=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of the input record
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_ILLEGAL_CONTEXT_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1DecryptRecord3Des(n1_request_type request_type,
+					  Uint64 context_handle, 
+					  HashType hash_type, 
+					  SslVersion ssl_version, 
+					  SslPartyType ssl_party,
+					  MessageType message_type,
+					  Uint16 record_length, 
+					  Uint8 *record, 
+					  Uint16 *message_length, 
+					  Uint8 *message,
+					  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecord3DesRecover
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER3_1
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of the encrypted part of the input record in bytes 
+ *		(length%8=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of the input record
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output, 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_ILLEGAL_CONTEXT_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1DecryptRecord3DesRecover(n1_request_type request_type,
+							 Uint64 context_handle, 
+							 HashType hash_type, 
+							 SslVersion ssl_version,
+				 			 SslPartyType ssl_party,
+							 MessageType message_type,
+							 Uint16 record_length, 
+							 Uint8 *record, 
+							 Uint16 *message_length, 
+							 Uint8 *message,
+							 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecordAes
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	pad_length = size of extra padding in 8-byte blocks
+ *	message_length = size of input in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte input
+ *
+ * Output
+ *	record_length = pointer to length of the encrypted part of the record in bytes
+ *	record = pointer to *record_length-byte output, 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, ERR_ILLEGAL_CONTEXT_HANDLE, or  
+ *	ERR_ILLEGAL_INPUT_LENGTH
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1EncryptRecordAes(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+		 			 SslPartyType ssl_party,
+					 AesType aes_type, 
+					 MessageType message_type,
+					 Uint16 pad_length,
+					 Uint16 message_length, 
+					 Uint8 *message, 
+					 Uint16 *record_length, 
+					 Uint8 *record,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordAes
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER3_1
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of input in bytes (length%16=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte input
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_ILLEGAL_CONTEXT_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH  
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1DecryptRecordAes(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+					 SslPartyType ssl_party,
+					 AesType aes_type, 
+					 MessageType message_type,
+					 Uint16 record_length, 
+					 Uint8 *record, 
+					 Uint16 *message_length, 
+					 Uint8 *message,
+					 Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordAesRecover
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ *	ssl_version = VER3_0 or VER3_1
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of input in bytes (length%16=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte input
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_ILLEGAL_CONTEXT_HANDLE, or ERR_ILLEGAL_INPUT_LENGTH 
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1DecryptRecordAesRecover(n1_request_type request_type,
+							Uint64 context_handle, 
+						    HashType hash_type, 
+						    SslVersion ssl_version, 
+						    AesType aes_type, 
+							SslPartyType ssl_party,
+					        MessageType message_type,
+					        Uint16 record_length, 
+						    Uint8 *record, 
+						    Uint16 *message_length, 
+						    Uint8 *message,
+							Uint32 *request_id);
+
+
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerFullRc4
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,ERR_OPERATION_NOT_SUPPORTED,
+ *	ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaSsl20ServerFullRc4(n1_request_type request_type,
+						  Uint64 context_handle,
+						  Uint64 *key_handle,
+						  Rc4Type rc4_type,
+						  Uint8 *client_master_secret,
+						  Uint16 clear_master_secret_length,
+						  Uint16 encrypted_master_secret_length,
+						  Uint16 modlength,
+						  Uint8 *challenge,
+						  Uint16 challenge_length,	
+						  Uint8 *connection_id,
+						  Uint8 *session_id,
+						  Uint8 *client_finished,	
+						  Uint8 *server_finished,	
+						  Uint8 *server_verify,		
+						  Uint8 *master_secret,
+						  Uint16 *master_secret_length,
+						  Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerClientAuthRc4
+ *
+ * Generates key material, and certificate req, verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,ERR_OPERATION_NOT_SUPPORTED,
+ *	ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuthRc4(
+					n1_request_type request_type,
+				 	Uint64 context_handle,
+				  	Uint64 *key_handle,
+				  	Rc4Type rc4_type,
+				  	Uint8 *client_master_secret,
+				  	Uint16 clear_master_secret_length,
+				  	Uint16 encrypted_master_secret_length,
+				  	Uint16 modlength,
+				  	Uint8 *challenge,
+				  	Uint16 challenge_length,	
+				  	Uint8 *connection_id,		
+				  	Uint8 *session_id,
+				  	Uint8 *client_finished,	
+					Uint8 auth_type,
+					Uint8 *cert_challenge,
+					Uint8 *cert_request,
+				  	Uint8 *server_verify,		
+				  	Uint8 *master_secret,
+				  	Uint16 *master_secret_length,
+					Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeRc4
+ *
+ * Resumes a previously negotiated session.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	master_secret = master secret from previous session.
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,
+ *	ERR_OPERATION_NOT_SUPPORTED, ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeRc4 (n1_request_type request_type,
+			Uint64 context_handle,
+			Uint64 *key_handle,
+			Rc4Type rc4_type,
+			Uint8 *master_secret,
+			Uint16 master_secret_length,
+			Uint8 *challenge,
+			Uint16 challenge_length,	
+			Uint8 *connection_id,		
+			Uint8 *session_id,
+			Uint8 *client_finished,	
+			Uint8 *server_finished,	
+			Uint8 *server_verify,
+			Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeClientAuthRc4
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	master_secret = master secret from previous session.
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	auth_type = client auth type
+ *	cert_challenge = cert challenge
+ *
+ * Output
+ *	cert_request = pointer to encrypted part of cert request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,
+ *	ERR_OPERATION_NOT_SUPPORTED, ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeClientAuthRc4 (n1_request_type request_type,
+					Uint64 context_handle,
+					Uint64 *key_handle,
+					Rc4Type rc4_type,
+					Uint8 *master_secret,
+					Uint16 master_secret_length,
+					Uint8 *challenge,
+					Uint16 challenge_length,	
+					Uint8 *connection_id,		
+					Uint8 *session_id,
+					Uint8 *client_finished,	
+					Uint8 auth_type,
+					Uint8 *cert_challenge,
+					Uint8 *cert_request,
+					Uint8 *server_verify,
+					Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerFull3Des
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,ERR_OPERATION_NOT_SUPPORTED,
+ *	ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaSsl20ServerFull3Des(n1_request_type request_type,
+						   Uint64 context_handle,
+						  Uint64 *key_handle,
+						  DesType des_type,
+						  Uint8 *client_master_secret,
+						  Uint16 clear_master_secret_length,
+						  Uint16 encrypted_master_secret_length,
+						  Uint16 modlength,
+						  Uint8 *challenge,
+						  Uint16 challenge_length,	
+						  Uint8 *connection_id,		
+						  Uint8 *session_id,
+						  Uint8 *iv,
+						  Uint8 *client_finished,	
+						  Uint8 *server_finished,	
+						  Uint8 *server_verify,		
+						  Uint8 *master_secret,
+						  Uint16 *master_secret_length,
+						  Uint32 *request_id);
+
+
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerClientAuth3Des
+ *
+ * Generates key material, verifies cllient finished msg, creates server verify
+ * and cert request messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *	auth_type =  client auth type
+ *	cert_challenge =  certficate challenge.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	cert_request = pointer to encrypted part of certificate request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_PKCS_PAD_OR_LENGTH, ERR_BAD_PKCS_TYPE, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,ERR_OPERATION_NOT_SUPPORTED,
+ *	ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuth3Des(
+						n1_request_type request_type,
+						Uint64 context_handle,
+						Uint64 *key_handle,
+						DesType des_type,
+						Uint8 *client_master_secret,
+						Uint16 clear_master_secret_length,
+						Uint16 encrypted_master_secret_length,
+						Uint16 modlength,
+						Uint8 *challenge,
+						Uint16 challenge_length,	
+						Uint8 *connection_id,		
+						Uint8 *session_id,
+						Uint8 *iv,
+						Uint8 *client_finished,	
+						Uint8 auth_type,
+						Uint8 *cert_challenge,
+						Uint8 *cert_request,	
+						Uint8 *server_verify,		
+						Uint8 *master_secret,
+						Uint16 *master_secret_length,
+						Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20Resume3Des
+ *
+ * Resumes a previouly negotiated handshake. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	master_secret = master key generated in previous handshake
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,
+ *	ERR_OPERATION_NOT_SUPPORTED,ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20Resume3Des(
+			n1_request_type request_type,
+			Uint64 context_handle,
+		  Uint64 *key_handle,
+		  DesType des_type,
+		  Uint8 *master_secret,
+		  Uint16 master_secret_length,
+		  Uint8 *challenge,
+		  Uint16 challenge_length,	
+		  Uint8 *connection_id,		
+		  Uint8 *session_id,
+		  Uint8 *iv,
+		  Uint8 *client_finished,	
+		  Uint8 *server_finished,	
+		  Uint8 *server_verify,
+		  Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeClientAuth3Des
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	master_secret = master key generated in previous handshake
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	auth_type =  client authentication type
+ *	cert_challenge = cert request challenge
+ *	cert_request = certificate request
+ *
+ *
+ * Output
+
+ *	cert_request = pointer to encrypted part of cert request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *
+ * Return Value
+ *	completion code = 0 (for success), ERR_MEMORY_ALLOC_FAILURE,
+ *	ERR_BAD_SIZE_OR_DLEN_VAL, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT,
+ *	ERR_OPERATION_NOT_SUPPORTED,ERR_BAD_RECORD
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20ResumeClientAuth3Des(
+			n1_request_type request_type,
+			Uint64 context_handle,
+		  Uint64 *key_handle,
+		  DesType des_type,
+		  Uint8 *master_secret,
+		  Uint16 master_secret_length,
+		  Uint8 *challenge,
+		  Uint16 challenge_length,	
+		  Uint8 *connection_id,		
+		  Uint8 *session_id,
+		  Uint8 *iv,
+		  Uint8 *client_finished,
+		  Uint8 auth_type,
+		  Uint8 *cert_challenge,
+		  Uint8 *cert_request,	
+		  Uint8 *server_verify,
+		  Uint32 *request_id);
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20DecryptRecordRc4
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	record_length = size of record in bytes (0<=length<=2^16-1)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to decrypted message 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_BAD_RECORD
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20DecryptRecordRc4(
+				n1_request_type request_type,
+				Uint64 context_handle,
+				Uint16 record_length,
+				Uint8 *record,
+				Uint8 *message,
+				Uint32 *request_id);
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20EncryptRecordRc4
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of message in bytes (0<=length<=2^16-1)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to encrypted record 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20EncryptRecordRc4(
+				n1_request_type request_type,
+				Uint64 context_handle,
+				Uint16 message_length,
+				Uint8 *message,
+				Uint8 *record,
+				Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20DecryptRecord3Des
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	des_type = DES or DES3_192
+ *	record_length = size of record in bytes (0<=length<=2^16-1)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to decrypted message 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_RECORD, ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT, 
+ *	ERR_BAD_RECORD
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Ssl20DecryptRecord3Des(
+					n1_request_type request_type,
+					Uint64 context_handle,
+				   DesType des_type,
+				   Uint16 record_length,
+				   Uint8 *record,
+				   Uint8 *message,
+				   Uint32 *request_id);
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20EncryptRecord3Des
+ *
+ * Input
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+  *	des_type = DES or DES3_192
+ *	message_length = size of message in bytes (0<=length<=2^16-1)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to encrypted record 
+ *
+ * Return Value
+ *	completion_code = 0 (for success), ERR_BAD_SIZE_OR_DLEN_VAL, 
+ *	ERR_BAD_IOCTL, ERR_INSTRUCTION_TIMEOUT
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20EncryptRecord3Des(	
+				n1_request_type request_type,
+				Uint64 context_handle,
+				DesType des_type,
+				Uint16 message_length,
+				Uint8 *message,
+				Uint16 *record_length,
+				Uint8 *record,
+				Uint32 *request_id);
+
+
+
+
+#endif /* CSP1_KERNEL */
+
+#endif /* _CAVIUM_SSL_H_ */
diff -Naur openssl-0.9.8j/ssl/cav_specific.c TurboSSL-0.9.8j/ssl/cav_specific.c
--- openssl-0.9.8j/ssl/cav_specific.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/cav_specific.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,276 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation and/or 
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived 
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws, 
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply 
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility 
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS 
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY 
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, 
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, 
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE 
+ * OF THE SOFTWARE LIES WITH YOU.
+*/
+#include <errno.h>
+#include "openssl/ssl.h"
+
+#ifdef CAVIUM_SSL
+#include "openssl/cav_crypto_engine.h"
+#include "ssl_engine.h"
+#include "openssl/cav_debug.h"
+#include "ssl/cav_debug.h"
+#endif
+
+
+#ifdef CAVIUM_NB_CRYPTO
+int cav_print_state(SSL *s, char *fname)
+{
+	cav_fprintf(cav_nb_fp,"%s: state = %d, 0x%0x\n", fname, s->state, s->state);
+	
+	switch (s->state) {
+
+		case SSL_ST_RENEGOTIATE:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_RENEGOTIATE\n", fname);
+			break;
+
+		case SSL_ST_BEFORE:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_BEFORE\n", fname);
+
+		case SSL_ST_ACCEPT:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_ACCEPT\n", fname);
+			break;
+
+		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_BEFORE|SSL_ST_ACCEPT\n", fname);
+			break;
+
+		case SSL_ST_OK|SSL_ST_ACCEPT:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_OK|SSL_ST_ACCEPT\n", fname);
+			break;
+
+		case SSL3_ST_SW_HELLO_REQ_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_HELLO_REQ_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_HELLO_REQ_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_HELLO_REQ_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_HELLO_REQ_C:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_HELLO_REQ_C\n", fname);
+			break;
+
+		case SSL3_ST_SR_CLNT_HELLO_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CLNT_HELLO_A\n", fname);
+			break;
+
+		case SSL3_ST_SR_CLNT_HELLO_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CLNT_HELLO_B\n", fname);
+			break;
+
+		case SSL3_ST_SR_CLNT_HELLO_C:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CLNT_HELLO_C\n", fname);
+			break;
+
+		case SSL3_ST_SW_SRVR_HELLO_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_SRVR_HELLO_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_SRVR_HELLO_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_SRVR_HELLO_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_CERT_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CERT_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_CERT_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CERT_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_KEY_EXCH_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_KEY_EXCH_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_KEY_EXCH_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_KEY_EXCH_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_CERT_REQ_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CERT_REQ_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_CERT_REQ_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CERT_REQ_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_SRVR_DONE_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_SRVR_DONE_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_SRVR_DONE_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_SRVR_DONE_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_FLUSH:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_FLUSH\n", fname);
+			break;
+
+		case SSL3_ST_SR_CERT_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CERT_A\n", fname);
+			break;
+
+		case SSL3_ST_SR_CERT_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CERT_B\n", fname);
+			break;
+
+		case SSL3_ST_SR_KEY_EXCH_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_KEY_EXCH_A\n", fname);
+			break;
+
+		case SSL3_ST_SR_KEY_EXCH_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_KEY_EXCH_B\n", fname);
+			break;
+
+		case SSL3_ST_SR_CERT_VRFY_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CERT_VRFY_A\n", fname);
+			break;
+
+		case SSL3_ST_SR_CERT_VRFY_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_CERT_VRFY_B\n", fname);
+			break;
+
+		case SSL3_ST_SR_FINISHED_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_FINISHED_A\n", fname);
+			break;
+
+		case SSL3_ST_SR_FINISHED_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SR_FINISHED_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_CHANGE_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CHANGE_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_CHANGE_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_CHANGE_B\n", fname);
+			break;
+
+		case SSL3_ST_SW_FINISHED_A:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_FINISHED_A\n", fname);
+			break;
+
+		case SSL3_ST_SW_FINISHED_B:
+			cav_fprintf(cav_nb_fp,"%s: case SSL3_ST_SW_FINISHED_B\n", fname);
+			break;
+
+		case SSL_ST_OK:
+			cav_fprintf(cav_nb_fp,"%s: case SSL_ST_OK\n", fname);
+			break;
+
+		case CAV_ST_IN_HANDSHAKE:
+			cav_fprintf(cav_nb_fp,"%s: case CAV_ST_IN_HANDSHAKE\n", fname);
+			break;
+
+		case CAV_ST_IN_VRFY_CERT:
+			cav_fprintf(cav_nb_fp,"%s: case CAV_ST_IN_VRFY_CERT\n", fname);
+			break;
+
+		default:
+			cav_fprintf(cav_nb_fp,"%s: default\n", fname);
+			break;
+
+	} // end switch
+
+	return(0);
+
+} // end cav_print_state()
+
+
+void cav_set_nb_mode(SSL *s, int nb_mode)
+{
+#ifndef CAVIUM_FIPS
+	if ( nb_mode ) 
+		s->cav_nb_mode = CAVIUM_NON_BLOCKING;
+	else
+		s->cav_nb_mode = CAVIUM_BLOCKING;
+#else
+	if ( nb_mode ) 
+		s->cav_nb_mode = OP_NON_BLOCKING;
+	else
+		s->cav_nb_mode = OP_BLOCKING;
+#endif
+}
+
+
+int cav_get_nb_mode(SSL *s)
+{
+	return(s->cav_nb_mode);
+}
+
+
+int cav_check_for_completion(SSL *s)
+{
+	int rc;
+	
+#ifdef CAVIUM_FIPS
+			rc = Cfm1CheckForCompletion(s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+	rc = Csp1CheckForCompletion(s->cav_req_id,s->dev_id);
+#else
+	rc = Csp1CheckForCompletion(s->cav_req_id);
+#endif
+#endif
+	//if ( rc == 0 )
+	if ( rc != EAGAIN )
+		s->cav_req_id_check_done = 1;
+
+	return(rc);
+}
+
+void print_hex(char *label, Uint8 *datap, int len)
+{
+int i;
+
+	if ( label != NULL )
+		cav_fprintf(cav_nb_fp, "%s\n", label);
+		for (i = 0; i < len; i++) {
+			cav_fprintf(cav_nb_fp, "0x%0x ", datap[i]);
+		}
+		cav_fprintf(cav_nb_fp, "\n");
+}
+
+#else
+int cav_print_state(SSL *s, char *fname) { }
+
+void print_hex(char *label, Uint8 *datap, int len)
+{
+int i;
+
+	if ( label != NULL )
+		cav_fprintf(cav_nb_fp, "%s\n", label);
+		for (i = 0; i < len; i++) {
+			cav_fprintf(cav_nb_fp, "0x%0x ", datap[i]);
+		}
+		cav_fprintf(cav_nb_fp, "\n");
+}
+#endif
diff -Naur openssl-0.9.8j/ssl/Makefile TurboSSL-0.9.8j/ssl/Makefile
--- openssl-0.9.8j/ssl/Makefile	2008-09-17 19:11:09.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/Makefile	2010-05-31 12:14:23.000000000 +0200
@@ -5,7 +5,18 @@
 DIR=	ssl
 TOP=	..
 CC=	cc
-INCLUDES= -I../crypto -I$(TOP) -I../include $(KRB5_INCLUDES)
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+else
+CAVIUM_INCLUDEDIR := .  
+endif
+
+INCLUDES= -I../crypto -I$(TOP) -I../include $(KRB5_INCLUDES) -I$(CAVIUM_INCLUDEDIR) 
 CFLAG=-g
 MAKEFILE=	Makefile
 AR=		ar r
@@ -18,6 +29,11 @@
 TEST=ssltest.c
 APPS=
 
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+CAVIUM_OBJ=ssl_engine.o cav_specific.o
+CAVIUM_SRC=ssl_engine.c cav_specific.c
+endif
+
 LIB=$(TOP)/libssl.a
 SHARED_LIB= libssl$(SHLIB_EXT)
 LIBSRC=	\
@@ -30,7 +46,8 @@
 	ssl_lib.c ssl_err2.c ssl_cert.c ssl_sess.c \
 	ssl_ciph.c ssl_stat.c ssl_rsa.c \
 	ssl_asn1.c ssl_txt.c ssl_algs.c \
-	bio_ssl.c ssl_err.c kssl.c
+	bio_ssl.c ssl_err.c kssl.c \
+	$(CAVIUM_SRC)
 LIBOBJ= \
 	s2_meth.o  s2_srvr.o  s2_clnt.o  s2_lib.o  s2_enc.o s2_pkt.o \
 	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o s3_pkt.o s3_both.o \
@@ -41,11 +58,21 @@
 	ssl_lib.o ssl_err2.o ssl_cert.o ssl_sess.o \
 	ssl_ciph.o ssl_stat.o ssl_rsa.o \
 	ssl_asn1.o ssl_txt.o ssl_algs.o \
-	bio_ssl.o ssl_err.o kssl.o
+	bio_ssl.o ssl_err.o kssl.o \
+	$(CAVIUM_OBJ)
 
 SRC= $(LIBSRC)
 
-EXHEADER= ssl.h ssl2.h ssl3.h ssl23.h tls1.h dtls1.h kssl.h
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+EXHEADER= cav_crypto_engine.h cav_debug.h  luna_common.h luna_ssl.h luna_api.h luna_private.h luna_structs.h luna_ioctl.h
+else
+EXHEADER= cav_crypto_engine.h cav_debug.h cav_ecc_mul.h
+endif
+EXHEADER+= ssl.h ssl2.h ssl3.h ssl23.h tls1.h dtls1.h kssl.h
+endif
+
 HEADER=	$(EXHEADER) ssl_locl.h kssl_lcl.h
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
@@ -69,6 +96,32 @@
 	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
 
 links:
+
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+	if test -f $(CAVIUM_INCLUDEDIR)/luna_common.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_api.h luna_api.h;     \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_common.h luna_common.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_ioctl.h luna_ioctl.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_private.h luna_private.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_ssl.h luna_ssl.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_structs.h luna_structs.h;\
+	fi
+
+	if test -f $(CAVIUM_INCLUDEDIR)/cavium_common.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_ssl.h ../include/openssl/cavium_ssl.h;     \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_common.h ../include/openssl/cavium_common.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_sysdep.h ../include/openssl/cavium_sysdep.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_ioctl.h ../include/openssl/cavium_ioctl.h;\
+    ln -fs  $(CAVIUM_INCLUDEDIR)/app_defines.h ../include/openssl/app_defines.h;\
+	fi
+	if test -f $(CAVIUM_INCLUDEDIR)/linux_sysdep.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/linux_sysdep.h ../include/openssl/linux_sysdep.h;\
+	fi
+	
+	if test -f $(CAVIUM_INCLUDEDIR)/freebsd_sysdep.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/freebsd_sysdep.h ../include/openssl/freebsd_sysdep.h;\
+	fi
+endif
 	@$(PERL) $(TOP)/util/mklink.pl ../include/openssl $(EXHEADER)
 	@$(PERL) $(TOP)/util/mklink.pl ../test $(TEST)
 	@$(PERL) $(TOP)/util/mklink.pl ../apps $(APPS)
@@ -80,6 +133,16 @@
 	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
 	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
 	done;
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+ifneq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_common.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_ssl.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_sysdep.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	#@cp $(CAVIUM_INCLUDEDIR)/cavium_ecc.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/app_defines.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/linux_sysdep.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+endif
+endif
 
 tags:
 	ctags $(SRC)
diff -Naur openssl-0.9.8j/ssl/Makefile.save TurboSSL-0.9.8j/ssl/Makefile.save
--- openssl-0.9.8j/ssl/Makefile.save	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/Makefile.save	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,169 @@
+#
+# OpenSSL/ssl/Makefile
+#
+
+DIR=	ssl
+TOP=	..
+CC=	cc
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api -I$(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include -I$(shell /bin/pwd)/../../../api
+endif
+else
+CAVIUM_INCLUDEDIR := .  
+endif
+
+INCLUDES= -I../crypto -I$(TOP) -I../include $(KRB5_INCLUDES) -I$(CAVIUM_INCLUDEDIR) 
+CFLAG=-g
+MAKEFILE=	Makefile
+AR=		ar r
+# KRB5 stuff
+KRB5_INCLUDES=
+
+CFLAGS= $(INCLUDES) $(CFLAG)
+
+GENERAL=Makefile README ssl-lib.com install.com
+TEST=ssltest.c
+APPS=
+
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+CAVIUM_OBJ=ssl_engine.o cav_specific.o
+CAVIUM_SRC=ssl_engine.c cav_specific.c
+endif
+
+LIB=$(TOP)/libssl.a
+SHARED_LIB= libssl$(SHLIB_EXT)
+LIBSRC=	\
+	s2_meth.c   s2_srvr.c s2_clnt.c  s2_lib.c  s2_enc.c s2_pkt.c \
+	s3_meth.c   s3_srvr.c s3_clnt.c  s3_lib.c  s3_enc.c s3_pkt.c s3_both.c \
+	s23_meth.c s23_srvr.c s23_clnt.c s23_lib.c          s23_pkt.c \
+	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c \
+	d1_meth.c   d1_srvr.c d1_clnt.c  d1_lib.c  d1_pkt.c \
+	d1_both.c d1_enc.c \
+	ssl_lib.c ssl_err2.c ssl_cert.c ssl_sess.c \
+	ssl_ciph.c ssl_stat.c ssl_rsa.c \
+	ssl_asn1.c ssl_txt.c ssl_algs.c \
+	bio_ssl.c ssl_err.c kssl.c \
+	$(CAVIUM_SRC)
+LIBOBJ= \
+	s2_meth.o  s2_srvr.o  s2_clnt.o  s2_lib.o  s2_enc.o s2_pkt.o \
+	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o s3_pkt.o s3_both.o \
+	s23_meth.o s23_srvr.o s23_clnt.o s23_lib.o          s23_pkt.o \
+	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o \
+	d1_meth.o   d1_srvr.o d1_clnt.o  d1_lib.o  d1_pkt.o \
+	d1_both.o d1_enc.o \
+	ssl_lib.o ssl_err2.o ssl_cert.o ssl_sess.o \
+	ssl_ciph.o ssl_stat.o ssl_rsa.o \
+	ssl_asn1.o ssl_txt.o ssl_algs.o \
+	bio_ssl.o ssl_err.o kssl.o \
+	$(CAVIUM_OBJ)
+
+SRC= $(LIBSRC)
+
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+EXHEADER= cav_crypto_engine.h cav_debug.h  luna_common.h luna_ssl.h luna_api.h luna_private.h luna_structs.h luna_ioctl.h
+else
+EXHEADER= cav_crypto_engine.h cav_debug.h cav_ecc_mul.h
+endif
+EXHEADER+= ssl.h ssl2.h ssl3.h ssl23.h tls1.h dtls1.h kssl.h
+endif
+
+HEADER=	$(EXHEADER) ssl_locl.h kssl_lcl.h
+
+ALL=    $(GENERAL) $(SRC) $(HEADER)
+
+top:
+	(cd ..; $(MAKE) DIRS=$(DIR) all)
+
+all:	lib
+
+lib:	$(LIBOBJ)
+	$(AR) $(LIB) $(LIBOBJ)
+	$(RANLIB) $(LIB) || echo Never mind.
+	@touch lib
+
+shared: lib
+	if [ -n "$(SHARED_LIBS)" ]; then \
+		(cd ..; $(MAKE) $(SHARED_LIB)); \
+	fi
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
+
+links:
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+	if test -f $(CAVIUM_INCLUDEDIR)/luna_common.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_api.h luna_api.h;     \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_common.h luna_common.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_ioctl.h luna_ioctl.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_private.h luna_private.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_ssl.h luna_ssl.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/luna_structs.h luna_structs.h;\
+	fi
+
+	if test -f $(CAVIUM_INCLUDEDIR)/cavium_common.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_ssl.h ../include/openssl/cavium_ssl.h;     \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_common.h ../include/openssl/cavium_common.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_sysdep.h ../include/openssl/cavium_sysdep.h;\
+	ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_ioctl.h ../include/openssl/cavium_ioctl.h;\
+	fi
+	if test -f $(CAVIUM_INCLUDEDIR)/cavium_ecc.h; then \
+        ln -fs  $(CAVIUM_INCLUDEDIR)/cavium_ecc.h ../include/openssl/cavium_ecc.h;\
+        ln -fs  $(CAVIUM_INCLUDEDIR)/app_defines.h ../include/openssl/app_defines.h;\
+	fi		
+	if test -f $(CAVIUM_INCLUDEDIR)/linux_sysdep.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/linux_sysdep.h ../include/openssl/linux_sysdep.h;\
+	fi
+	
+	if test -f $(CAVIUM_INCLUDEDIR)/freebsd_sysdep.h; then \
+	ln -fs  $(CAVIUM_INCLUDEDIR)/freebsd_sysdep.h ../include/openssl/freebsd_sysdep.h;\
+	fi
+endif
+	@$(PERL) $(TOP)/util/mklink.pl ../include/openssl $(EXHEADER)
+	@$(PERL) $(TOP)/util/mklink.pl ../test $(TEST)
+	@$(PERL) $(TOP)/util/mklink.pl ../apps $(APPS)
+
+install:
+	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@headerlist="$(EXHEADER)"; for i in $$headerlist ; \
+	do  \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+ifeq ($(findstring CAVIUM_SSL,$(CFLAG)),CAVIUM_SSL)
+ifneq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_common.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_ssl.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_sysdep.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+	@cp $(CAVIUM_INCLUDEDIR)/cavium_ecc.h  $(INSTALL_PREFIX)$(INSTALLTOP)/include/
+endif
+endif
+
+tags:
+	ctags $(SRC)
+
+tests:
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+depend:
+	@if [ -z "$(THIS)" ]; then \
+	    $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; \
+	else \
+	    $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC); \
+	fi
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -Naur openssl-0.9.8j/ssl/s23_clnt.c TurboSSL-0.9.8j/ssl/s23_clnt.c
--- openssl-0.9.8j/ssl/s23_clnt.c	2008-06-16 18:56:41.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s23_clnt.c	2010-05-31 12:14:16.000000000 +0200
@@ -62,6 +62,16 @@
 #include <openssl/rand.h>
 #include <openssl/objects.h>
 #include <openssl/evp.h>
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include "ssl_engine.h"
+#endif
 
 static SSL_METHOD *ssl23_get_client_method(int ver);
 static int ssl23_client_hello(SSL *s);
@@ -88,12 +98,16 @@
 int ssl23_connect(SSL *s)
 	{
 	BUF_MEM *buf=NULL;
+#ifndef CAVIUM_SSL
 	unsigned long Time=(unsigned long)time(NULL);
+#endif	
 	void (*cb)(const SSL *ssl,int type,int val)=NULL;
 	int ret= -1;
 	int new_state,state;
 
+#ifndef CAVIUM_SSL
 	RAND_add(&Time,sizeof(Time),0);
+#endif	
 	ERR_clear_error();
 	clear_sys_error();
 
@@ -104,6 +118,9 @@
 	
 	s->in_handshake++;
 	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
+#ifdef CAVIUM_SSL
+    init_supported_cipher_list(s);
+#endif
 
 	for (;;)
 		{
@@ -203,7 +220,11 @@
 	unsigned char *buf;
 	unsigned char *p,*d;
 	int i,j,ch_len;
+#ifndef CAVIUM_SSL
 	unsigned long Time,l;
+#else
+    unsigned long l;
+#endif
 	int ssl2_compat;
 	int version = 0, version_major, version_minor;
 	SSL_COMP *comp;
@@ -247,11 +268,12 @@
 #endif
 
 		p=s->s3->client_random;
+#ifndef CAVIUM_SSL
 		Time=(unsigned long)time(NULL);		/* Time */
 		l2n(Time,p);
+#endif
 		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
 			return -1;
-
 		if (version == TLS1_VERSION)
 			{
 			version_major = TLS1_VERSION_MAJOR;
@@ -326,7 +348,6 @@
 			memset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);
 			if (RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)
 				return -1;
-
 			memcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);
 			p+=i;
 
diff -Naur openssl-0.9.8j/ssl/s23_srvr.c TurboSSL-0.9.8j/ssl/s23_srvr.c
--- openssl-0.9.8j/ssl/s23_srvr.c	2008-06-16 18:56:41.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s23_srvr.c	2010-05-31 12:13:09.000000000 +0200
@@ -140,12 +140,16 @@
 int ssl23_accept(SSL *s)
 	{
 	BUF_MEM *buf;
+#ifndef CAVIUM_SSL
 	unsigned long Time=(unsigned long)time(NULL);
+#endif	
 	void (*cb)(const SSL *ssl,int type,int val)=NULL;
 	int ret= -1;
 	int new_state,state;
 
+#ifndef CAVIUM_SSL
 	RAND_add(&Time,sizeof(Time),0);
+#endif	
 	ERR_clear_error();
 	clear_sys_error();
 
diff -Naur openssl-0.9.8j/ssl/s2_pkt.c TurboSSL-0.9.8j/ssl/s2_pkt.c
--- openssl-0.9.8j/ssl/s2_pkt.c	2003-12-27 17:10:30.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/s2_pkt.c	2010-05-31 12:13:09.000000000 +0200
@@ -114,6 +114,9 @@
 #include <stdio.h>
 #include <errno.h>
 #define USE_SOCKETS
+#ifdef CAVIUM_SSL
+#include "ssl_engine.h"
+#endif
 
 static int read_n(SSL *s,unsigned int n,unsigned int max,unsigned int extend);
 static int do_ssl_write(SSL *s, const unsigned char *buf, unsigned int len);
@@ -238,11 +241,28 @@
 			mac_size = 0;
 			s->s2->mac_data=p;
 			s->s2->ract_data=p;
+#ifdef CAVIUM_SSL
+            s->s2->padding=0;
+#else
 			if (s->s2->padding)
 				{
 				SSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_ILLEGAL_PADDING);
 				return(-1);
 				}
+#endif
+#ifdef CAVIUM_SSL
+            if(s->state == SSL2_ST_GET_CLIENT_FINISHED_A)
+            	{
+                memcpy(s->client_finished, s->s2->mac_data, s->s2->rlength);
+                s->client_finished_len = s->s2->rlength;
+                /* copy client finished first byte to a temporary location.
+                   This will deceive the get_client_finished function that 
+				   it is decrypted */
+                s->peer_finish_first_four[0] = s->client_finished[0];
+                s->s2->mac_data[0] = 3; /* message type client finished */
+            	}
+#endif /*CAVIUM_SSL */
+
 			}
 		else
 			{
@@ -263,6 +283,21 @@
 		if ((!s->s2->clear_text) &&
 			(s->s2->rlength >= mac_size))
 			{
+#ifdef CAVIUM_SSL
+                if(s->cipher_support)
+                {
+                    int ret;
+                    ret = pkp_decrypt_record_20(s);
+                    if(ret < 0)
+                   	{
+                        SSLerr(SSL_F_SSL2_READ,SSL_R_BAD_MAC_DECODE);
+                        return(-1);
+                   	}
+                }
+                else
+                {
+#endif
+
 			ssl2_enc(s,0);
 			s->s2->ract_data_length-=mac_size;
 			ssl2_mac(s,mac,0);
@@ -274,6 +309,9 @@
 				SSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_BAD_MAC_DECODE);
 				return(-1);
 				}
+#ifdef CAVIUM_SSL
+			}
+#endif  /* CAVIUM_SSL */
 			}
 		INC32(s->s2->read_sequence); /* expect next number */
 		/* s->s2->ract_data is now available for processing */
@@ -534,11 +572,20 @@
 	/* lets set the pad p */
 	if (s->s2->clear_text)
 		{
+#ifdef CAVIUM_SSL
+        if(s->s2->tmp.cavium_block_cipher)
+        	{
+            p = s->s2->tmp.cavium_pad;
+            s->s2->three_byte_header=1;
+        	}
+        else
+#endif
+        {
 		if (len > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)
-			len=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;
+		    len=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;
 		p=0;
 		s->s2->three_byte_header=0;
-		/* len=len; */
+       	}
 		}
 	else
 		{
@@ -607,11 +654,24 @@
 
 	if (!s->s2->clear_text)
 		{
+#ifdef CAVIUM_SSL
+        if(s->cipher_support)
+        {
+            int ret;
+            s->s2->wact_data_length=len;
+            ret = pkp_encrypt_record_20(s);
+            if(ret < 0)
+                return -1;
+        }
+        else
+#endif
+		{
 		s->s2->wact_data_length=len+p;
 		ssl2_mac(s,s->s2->mac_data,1);
 		s->s2->wlength+=p+mac_size;
 		ssl2_enc(s,1);
 		}
+		}
 
 	/* package up the header */
 	s->s2->wpend_len=s->s2->wlength;
diff -Naur openssl-0.9.8j/ssl/s2_srvr.c TurboSSL-0.9.8j/ssl/s2_srvr.c
--- openssl-0.9.8j/ssl/s2_srvr.c	2009-01-07 11:48:23.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/s2_srvr.c	2010-05-31 12:14:16.000000000 +0200
@@ -116,6 +116,18 @@
 #include <openssl/rand.h>
 #include <openssl/objects.h>
 #include <openssl/evp.h>
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include <openssl/cav_crypto_engine.h>
+#include <openssl/cav_debug.h>
+#include "ssl_engine.h"
+#endif
 
 static SSL_METHOD *ssl2_get_server_method(int ver);
 static int get_client_master_key(SSL *s);
@@ -144,14 +156,18 @@
 
 int ssl2_accept(SSL *s)
 	{
+#ifndef CAVIUM_SSL
 	unsigned long l=(unsigned long)time(NULL);
+#endif
 	BUF_MEM *buf=NULL;
 	int ret= -1;
 	long num1;
 	void (*cb)(const SSL *ssl,int type,int val)=NULL;
 	int new_state,state;
 
+#ifndef CAVIUM_SSL
 	RAND_add(&l,sizeof(l),0);
+#endif
 	ERR_clear_error();
 	clear_sys_error();
 
@@ -171,6 +187,13 @@
 		}
 
 	clear_sys_error();
+#ifdef CAVIUM_SSL
+    init_supported_cipher_list(s);
+#ifndef CAVIUM_BROWSER_ISSUE
+    s->cipher_support = 0;
+#endif
+#endif
+
 	for (;;)
 		{
 		state=s->state;
@@ -240,6 +263,9 @@
 			 * be encrypted. */
 			if (!ssl2_enc_init(s,0))
 				{ ret= -1; goto end; }
+#ifdef CAVIUM_SSL
+            if(!s->cipher_support)
+#endif
 			s->s2->clear_text=0;
 			s->state=SSL2_ST_SEND_SERVER_VERIFY_A;
 			BREAK;
@@ -399,6 +425,11 @@
 			return(-1);
 			}
 		s->session->cipher= cp;
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_BROWSER_ISSUE
+        s->cipher_support = find_cipher(s, cp->id);
+#endif
+#endif
 
 		p+=3;
 		n2s(p,i); s->s2->tmp.clear=i;
@@ -445,6 +476,12 @@
 		SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_NO_PRIVATEKEY);
 		return(-1);
 		}
+#ifdef CAVIUM_SSL
+    memcpy(s->client_master_secret, p, s->s2->tmp.clear + s->s2->tmp.enc);
+    s->client_master_secret_len = s->s2->tmp.clear + s->s2->tmp.enc;
+    if(s->cipher_support)
+	    return(1);
+#endif
 	i=ssl_rsa_private_decrypt(s->cert,s->s2->tmp.enc,
 		&(p[s->s2->tmp.clear]),&(p[s->s2->tmp.clear]),
 		(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);
@@ -606,8 +643,24 @@
 		}
 	else
 		{
+#ifdef CAVIUM_SSL
+
+#ifndef NO_SESSION_CACHE
+        i=ssl_get_prev_session(s,&(p[s->s2->tmp.cipher_spec_length]),
+				s->s2->tmp.session_id_length, NULL);
+        if(i==1)
+#ifndef CAVIUM_BROWSER_ISSUE
+            s->cipher_support = find_cipher(s, s->session->cipher->id);
+#endif
+            ;
+#else
+        i=0;
+#endif
+
+#else /*CAVIUM_SSL*/
 		i=ssl_get_prev_session(s,&(p[s->s2->tmp.cipher_spec_length]),
 			s->s2->tmp.session_id_length, NULL);
+#endif			
 		if (i == 1)
 			{ /* previous session */
 			s->hit=1;
@@ -859,6 +912,11 @@
 	if (s->msg_callback)
 		s->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg); /* CLIENT-FINISHED */
 	p += 1;
+#ifdef CAVIUM_SSL
+    if(s->cipher_support)
+        /* cipher is supported. Don't need to do anything here*/
+        return 1;
+#endif
 	if (memcmp(p,s->s2->conn_id,s->s2->conn_id_length) != 0)
 		{
 		ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);
@@ -871,6 +929,11 @@
 static int server_verify(SSL *s)
 	{
 	unsigned char *p;
+#ifdef CAVIUM_SSL
+    if(s->cipher_support)
+        /* cipher is supported. Don't need to do anything here*/
+        return 1;
+#endif
 
 	if (s->state == SSL2_ST_SEND_SERVER_VERIFY_A)
 		{
@@ -894,6 +957,49 @@
 static int server_finish(SSL *s)
 	{
 	unsigned char *p;
+#ifdef CAVIUM_SSL
+   int ret;
+
+   if(s->cipher_support)
+   {
+        // swapped if and else (and some condition)
+        if ( s->verify_mode & SSL_VERIFY_PEER )
+        {
+            cav_fprintf(cav_nb_fp, "server_finish(): %s\n", "SSL_VERIFY_PEER");
+
+            if (s->state == SSL2_ST_SEND_SERVER_FINISHED_A)
+            {
+                p=(unsigned char *)s->init_buf->data;
+                *(p++)=SSL2_MT_SERVER_FINISHED;
+
+                if (s->session->session_id_length > sizeof s->session->session_id)
+                {
+                    SSLerr(SSL_F_SERVER_FINISH, ERR_R_INTERNAL_ERROR);
+                    return -1;
+                }
+                memcpy(p,s->session->session_id, (unsigned int)s->session->session_id_length);
+                /* p+=s->session->session_id_length; */
+
+                s->state=SSL2_ST_SEND_SERVER_FINISHED_B;
+                s->init_num=s->session->session_id_length+1;
+                s->init_off=0;
+            }
+
+            /* SSL2_ST_SEND_SERVER_FINISHED_B */
+            return(ssl2_do_write(s));
+        }
+        else
+        {
+            cav_fprintf(cav_nb_fp, "server_finish(): %s\n", "normal or resume");
+                   /* time for some real action */
+            if(s->hit)
+                ret = pkp_resume_handshake_20(s);
+            else
+                ret = pkp_handshake_20(s);
+            return ret;
+        }
+    }/* cipher suport*/
+#endif
 
 	if (s->state == SSL2_ST_SEND_SERVER_FINISHED_A)
 		{
@@ -929,6 +1035,23 @@
 	STACK_OF(X509) *sk=NULL;
 
 	ccd=s->s2->tmp.ccl;
+#ifdef CAVIUM_SSL //&& !defined (MC2)
+    if(s->cipher_support)
+    {
+        pkp_get_random((char *)ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH,s);
+        if (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_A)
+        {
+            ret = pkp_handshake_client_auth_20(s);
+            if(ret <= 0)
+                goto end;
+            s->init_num=0;
+            s->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_C;
+        }
+    }
+    else
+    {
+#endif
+
 	if (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_A)
 		{
 		p=(unsigned char *)s->init_buf->data;
@@ -955,6 +1078,9 @@
 		s->init_num=0;
 		s->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_C;
 		}
+#ifdef CAVIUM_SSL // && !defined (MC2)
+        }
+#endif
 
 	if (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_C)
 		{
@@ -1058,6 +1184,124 @@
 		{
 		EVP_MD_CTX ctx;
 		EVP_PKEY *pkey=NULL;
+#ifdef CAVIUM_SSL
+        DesType des_type;
+        int cipher_type, key_size;
+        unsigned char km[32];
+#ifndef CAVIUM_FIPS
+        Uint32 req_id;
+#endif
+        if(s->cipher_support)
+        {
+            cipher_type = EVP_CIPHER_CTX_nid(s->enc_write_ctx);
+            switch(cipher_type)
+                {
+                case NID_rc4:
+                case NID_rc4_40:
+                    key_size = 16;
+#ifdef CAVIUM_FIPS
+                    if(Cfm1ReadContext())
+#else
+                    if(Csp1ReadContext(
+                        CAVIUM_BLOCKING,
+                        s->context_pointer+(8*OFFSET_SSL2_RC4_SERVER_WRITE_KM),
+                        key_size,
+                        s->s2->key_material,
+#ifdef CAVIUM_MULTICARD_API
+                        &req_id,s->dev_id
+#else
+                        &req_id
+#endif
+                                        ))
+#endif
+                        {
+                            SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                                  goto msg_end;
+                        }
+#ifdef CAVIUM_FIPS
+                        if(Cfm1ReadContext())
+#else
+                        if(Csp1ReadContext(CAVIUM_BLOCKING,
+                                        s->context_pointer+(8*OFFSET_SSL2_RC4_SERVER_READ_KM),
+                                        key_size,
+                                        &s->s2->key_material[key_size],
+#ifdef CAVIUM_MULTICARD_API
+                                        &req_id,s->dev_id
+#else
+                                        &req_id
+#endif
+                                      ))
+#endif
+                        {
+                                SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                                goto msg_end;
+                        }
+                        s->s2->key_material_length = key_size*2;
+                        break;
+
+                case NID_des_ede3_cbc:
+                case NID_des_cbc:
+                        des_type = get_Des_type(s->session->cipher->id);
+
+                        if(des_type == DES)
+                                key_size = 8;
+                        else if(des_type == DES3_192)
+                                           key_size = 24;
+                        else
+                        {
+                                SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                                goto msg_end;
+                        }
+#ifdef CAVIUM_FIPS
+                        if(Cfm1ReadContext())
+#else
+                        if(Csp1ReadContext(CAVIUM_BLOCKING,
+                                        s->context_pointer+(8*OFFSET_SSL2_3DES_SERVER_WRITE_KM),
+                                8+key_size,
+                                km,
+#ifdef CAVIUM_MULTICARD_API
+                                &req_id,s->dev_id
+#else
+                                &req_id
+#endif
+                            ))
+#endif
+                        {
+                                SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                                goto msg_end;
+                        }
+
+                        memcpy(s->s2->key_material, &km[8], key_size);
+#ifdef CAVIUM_FIPS
+                        if(Cfm1ReadContext())
+#else
+                        if(Csp1ReadContext(CAVIUM_BLOCKING,
+                                 s->context_pointer+(8*OFFSET_SSL2_3DES_SERVER_READ_KM),
+                                        8+key_size,
+                                        km,
+#ifdef CAVIUM_MULTICARD_API
+                                &req_id,s->dev_id
+#else
+                                &req_id
+#endif
+                               ))
+#endif
+                        {
+                                SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                                goto msg_end;
+                        }
+
+                        memcpy(&s->s2->key_material[key_size], &km[8], key_size);
+
+                       s->s2->key_material_length = key_size*2;
+                       break;
+
+                default:
+                        SSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);
+                        goto msg_end;
+                }
+        }
+#endif
 
 		EVP_MD_CTX_init(&ctx);
 		EVP_VerifyInit_ex(&ctx,s->ctx->rsa_md5, NULL);
@@ -1082,6 +1326,17 @@
 		i=EVP_VerifyFinal(&ctx,cp,s->s2->tmp.rlen,pkey);
 		EVP_PKEY_free(pkey);
 		EVP_MD_CTX_cleanup(&ctx);
+#ifdef CAVIUM_SSL
+        if ( i == 0 ) {
+            if ( s->version == SSL2_VERSION) {
+                if ( s->cav_crypto_state == 0 ) {
+                    // since we do server full, this is ok!
+                    i = 1;
+                    ERR_get_error();
+                }
+            }
+        }
+#endif
 
 		if (i > 0)
 			{
@@ -1139,5 +1394,4 @@
 # if PEDANTIC
 static void *dummy=&dummy;
 # endif
-
-#endif
+# endif
diff -Naur openssl-0.9.8j/ssl/s3_both.c TurboSSL-0.9.8j/ssl/s3_both.c
--- openssl-0.9.8j/ssl/s3_both.c	2005-04-26 18:02:39.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s3_both.c	2010-05-31 12:13:09.000000000 +0200
@@ -123,14 +123,43 @@
 #include <openssl/objects.h>
 #include <openssl/evp.h>
 #include <openssl/x509.h>
+#ifdef CAVIUM_SSL
+
+#include "ssl_engine.h"
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include "openssl/cav_debug.h"
+
+#ifdef linux
+#include <sys/mman.h>
+#endif
+#ifndef CAVIUM_NOMMAP
+extern int CSP1_driver_handle;
+#endif
+
+#endif
 
 /* send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or SSL3_RT_CHANGE_CIPHER_SPEC) */
 int ssl3_do_write(SSL *s, int type)
 	{
 	int ret;
-
+#ifdef CAVIUM_SSL	
+    cav_fprintf(cav_nb_fp, "ssl3_do_write(): before ssl3_write_bytes!\n");
+    cav_print_state(s, "ssl3_dowrite(): ");
+#endif	
 	ret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],
 	                     s->init_num);
+#ifdef CAVIUM_SSL	
+    cav_fprintf(cav_nb_fp,
+                      "ssl3_do_write(): after ssl3_write_bytes! : %d \n" , ret);
+    cav_print_state(s, "ssl3_dowrite(): ");
+#endif	
+
 	if (ret < 0) return(-1);
 	if (type == SSL3_RT_HANDSHAKE)
 		/* should not be done for 'Hello Request's, but in that case
@@ -139,6 +168,12 @@
 	
 	if (ret == s->init_num)
 		{
+#ifdef CAVIUM_SSL	
+		if( s->state == SSL3_ST_CW_FINISHED_B || 
+			s->state == SSL3_ST_SW_FINISHED_B )
+	        	s->init_buf->data[0] = SSL3_MT_FINISHED;
+#endif
+
 		if (s->msg_callback)
 			s->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);
 		return(1);
@@ -189,13 +224,81 @@
 
 int ssl3_get_finished(SSL *s, int a, int b)
 	{
-	int al,i,ok;
+	int al=0,i,ok;
 	long n;
 	unsigned char *p;
+#ifdef CAVIUM_SSL
+    int rc = 0;
+    int ret = 0;
+    int ttmp =0, ttmp1 =0, ttmp2 =0 , ttmp3= 0 , ttmp4 =0;
+    unsigned char  dec_peer_client_finished[80];
+    unsigned short peer_len=0;
+#ifdef CAVIUM_FIPS
+    Uint32 req_id;
+#endif
+#endif
 
 	/* the mac has already been generated when we received the
 	 * change cipher spec message and is in s->s3->tmp.peer_finish_md
 	 */ 
+#ifdef CAVIUM_SSL
+    if (s->cav_renego > 0 && s->cav_nb_mode == 1 ) {
+
+        if (s->cav_crypto_state == CAV_ST_IN_ENCRYPT){
+
+            if (s->server) {
+
+                s->state=SSL3_ST_SW_CHANGE_B;
+                rc = ssl3_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC);
+
+                if ( rc == 0 ) {
+                    s->state = SSL3_ST_SR_FINISHED_A ;
+                    return(0);
+                }
+                s->write_cipher_active = 0;
+                goto reneg ;
+            }
+        }
+    }
+    if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER_2) {
+
+        rc = check_dec_peer_completion(s,
+                                        &ttmp,
+                                        &ttmp1,
+                                        &ttmp2,
+                                        &ttmp3,
+                                        &ttmp4,
+                                        &peer_len,
+                                        (char *)dec_peer_client_finished);
+        if (rc == 1) {
+            s->peer_len = peer_len ;
+            if((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA) ||
+                    (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA))
+
+                if(s->server){
+                    goto dec_peer1;
+                }
+                else    goto dec_peer3;
+            else
+                if(s->server){
+                    goto dec_peer;
+                }
+                else   goto dec_peer2;
+        }
+
+        if ( rc == 0 ) {
+            cav_fprintf(cav_nb_fp,"ssl3_get_finished(): %s\n",
+                  "check_dec_peer_completion() not completed");
+            return(0);
+        }
+        else if ( rc == -1 ) {
+            cav_fprintf(cav_nb_fp,"ssl3_get_finished(): %s\n",
+                    "ERROR check_dec_peer_completion() failed");
+            return(-1);
+        }
+
+    } /* end if .. CAV_ST_IN_HANDSHAKE */
+#endif
 
 	n=s->method->ssl_get_message(s,
 		a,
@@ -215,6 +318,665 @@
 		}
 	s->s3->change_cipher_spec=0;
 
+#ifdef CAVIUM_SSL
+
+	if(s->cipher_support)
+	{
+		p = (unsigned char *)s->init_msg;
+
+		if(s->server)
+		{
+			if(s->hit)
+			{
+				/* Since it is a hit and CAVIUM_SSL is defined so we compare the
+                   client finish with the locally calculated message handshake 
+                   hashes. Local handshake hashes were caluculated when change 
+                   cipher spec was sent to client */
+				int cipher_type, digest_type;
+				const EVP_MD *hash;
+				const EVP_CIPHER *c;
+				SSL_COMP *comp;
+				HashType hash_type;
+				SslVersion ssl_version;
+
+				/* now replace first four bytes of client finish message.*/
+				memcpy(&(s->hs_msgs[s->client_finish_msg_offset]),s->peer_finish_first_four,4);
+
+				if((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+										 ||
+				 (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+			 							 ||
+				 (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+			 							 ||
+				 (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+				{
+
+					if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
+						{
+						SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+						ret = 0;
+						goto f_err;
+						}
+
+					digest_type = EVP_MD_type(hash);
+					cipher_type = EVP_CIPHER_nid(c);
+
+					if(digest_type == NID_md5)   
+						hash_type = MD5_TYPE;
+
+					else if(digest_type == NID_sha1) 
+						hash_type = SHA1_TYPE;
+
+					else
+					{
+					   ret = 0;
+					   goto f_err;
+					}
+
+					if(s->version > SSL3_VERSION)
+					{
+						ssl_version = VER_TLS;
+					}
+					else
+					{
+						ssl_version = VER3_0;
+					}
+
+					/* decrypt the received client finished */
+					if(ssl_version == VER_TLS)
+					{
+						if (memcmp(&s->hs_msgs[s->client_finish_msg_offset], s->client_finished, n) != 0)
+						{
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+					else
+					{
+#ifdef CAVIUM_FIPS
+				        i = Cfm1DecryptRecord3DesRecover(OP_BLOCKING,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_SERVER,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->client_finish_msg_offset),  
+									 &s->hs_msgs[s->client_finish_msg_offset], 
+									 &peer_len, 
+									 dec_peer_client_finished,
+									 &req_id
+									 );
+#else
+#ifndef MC2
+					    i = Csp1DecryptRecord3DesRecover
+#else
+					    i = Csp1DecryptRecord3Des
+#endif
+									(
+								         s->cav_nb_mode	,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_SERVER,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->client_finish_msg_offset),  
+									 &s->hs_msgs[s->client_finish_msg_offset], 
+									 &s->peer_len, 
+									 s->dec_peer_client_finished,
+
+#ifdef CAVIUM_MULTICARD_API
+									 &s->cav_req_id,s->dev_id
+#else
+									 &s->cav_req_id
+#endif
+                                   );
+#endif
+						if ( i== 0 ){
+			                memcpy (dec_peer_client_finished, s->dec_peer_client_finished,s->peer_len);
+                     	}
+
+				        if ( i == EAGAIN ) {
+                         	cav_fprintf(cav_nb_fp,"pkp_resume_handshake(): %s\n",
+		                        	"ssl3_get_finished() EAGAIN");
+	        		        s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER_2;
+			                s->cav_saved_state = s->state;
+                                        s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                	        s->cav_req_id_check_done = 0;
+		                    s->rwstate = SSL_NITROX_BUSY;
+                		}
+	                    if ( i != 0)
+		        	    {
+                	        ret = 0 ;
+                		    return ret;
+                        }
+
+
+dec_peer:				if( memcmp(dec_peer_client_finished, s->client_finished,s->peer_len) != 0)
+						{
+                            cav_fprintf(cav_nb_fp,"pkp_resume_handshake(): %s\n",
+		                        	"ssl3_get_finished() FAILED");
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+				}
+				else if(
+				 (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+				 ||
+				 (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+				 	)
+				{
+
+					if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
+						{
+						SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+						ret = 0;
+						goto f_err;
+						}
+
+					digest_type = EVP_MD_type(hash);
+					cipher_type = EVP_CIPHER_nid(c);
+
+					if(digest_type == NID_md5)   
+						hash_type = MD5_TYPE;
+
+					else if(digest_type == NID_sha1) 
+						hash_type = SHA1_TYPE;
+
+					else
+					{
+					    ret = 0;
+					    goto f_err;
+					}
+
+					if(s->version > SSL3_VERSION)
+					{
+						ssl_version = VER_TLS;
+					}
+					else
+					{
+						ssl_version = VER3_0;
+					}
+
+					/* decrypt the received client finished */
+					if(ssl_version == VER_TLS)
+					{
+						if (memcmp(&s->hs_msgs[s->client_finish_msg_offset], s->client_finished, n) != 0)
+						{
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+					else
+					{
+						AesType aes_type = get_Aes_type(s->session->cipher->id);
+#ifdef CAVIUM_FIPS
+
+						i = Cfm1DecryptRecordAesRecover(
+									 OP_BLOCKING,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_SERVER,
+									 aes_type,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->client_finish_msg_offset),  
+									 &s->hs_msgs[s->client_finish_msg_offset], 
+									 &s->peer_len, 
+									 s->dec_peer_client_finished,
+									 &req_id
+									 );
+#else						
+#ifndef MC2
+						i = Csp1DecryptRecordAesRecover
+#else
+						i = Csp1DecryptRecordAes
+#endif
+
+									(
+								         s->cav_nb_mode	,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_SERVER,
+									 aes_type,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->client_finish_msg_offset),  
+									 &s->hs_msgs[s->client_finish_msg_offset], 
+									 &s->peer_len, 
+									 s->dec_peer_client_finished,
+
+#ifdef CAVIUM_MULTICARD_API
+									 &s->cav_req_id,s->dev_id
+#else
+									 &s->cav_req_id
+#endif
+                                                                 );
+#endif
+						
+						if ( i== 0 ){
+                            memcpy (dec_peer_client_finished, s->dec_peer_client_finished, s->peer_len);
+                        }
+
+                        if ( i == EAGAIN ) {
+                            cav_fprintf(cav_nb_fp,"pkp_resume_handshake(): %s\n",
+                                    "ssl3_get_finished() EAGAIN");
+                            s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER_2;
+                            s->cav_saved_state = s->state;
+                            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                            s->cav_req_id_check_done = 0;
+                            s->rwstate = SSL_NITROX_BUSY;
+                        }
+                        if ( i != 0)
+                        {
+                            ret = 0 ;
+                            return ret;
+                        }
+
+
+dec_peer1:				if( memcmp(dec_peer_client_finished, s->client_finished,s->peer_len ) != 0)
+						{
+							cav_fprintf(cav_nb_fp, "%s %s\n",
+								"ssl3_get_finished(): memcmp after ",
+								"server side Csp1DecryptRecordAesRecover() failed");
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+
+				}
+				else
+				{
+					if (memcmp(&s->hs_msgs[s->client_finish_msg_offset], s->client_finished, n) != 0)
+						{
+						cav_fprintf(cav_nb_fp, "%s %s\n",
+							"ssl3_get_finished(): memcmp after ",
+								"RC4 FAILED");
+						ret =0;
+						al=SSL_AD_DECRYPT_ERROR;
+						SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+						goto f_err;
+						}
+				}
+				s->read_cipher_active = 1;
+				ret = 1;
+			} // end s->hit
+			else
+			{
+reneg:			if(!(SSL_get_verify_mode(s) & SSL_VERIFY_PEER))
+				{
+					if(s->s3->tmp.use_rsa_tmp){
+						ret = pkp_ephemeral_handshake(s);
+					}
+					else {
+						// call chip for handshake
+						cav_print_state(s, 
+							"ssl3_get_finished(): before pkp_handshake");
+						ret = pkp_handshake(s);
+						if ( ret > 0 ) {
+							cav_fprintf(cav_nb_fp,
+								"ssl3_get_finished(): %s %d\n",
+								"pkp_handshake() is done, ret = ",
+								ret);
+						}
+						else {
+							cav_fprintf(cav_nb_fp,
+								"ssl3_get_finished(): %s %d\n",
+								"pkp_handshake() is NOT done, ret = ",
+								ret);
+						}
+					}
+				}
+
+				else 
+					ret = pkp_handshake_client_auth(s);
+					
+			} /* if no hit */
+		} /* if server */
+
+		else /* if client */
+		{
+			if(s->hit)
+			{
+				if( pkp_client_resume_handshake(s))
+				{
+					s->read_cipher_active = 1;
+					ret = 1;
+				}
+				else
+				{
+					ret = 0;
+					if (s->cav_nb_mode == 1 ) {
+						s->read_cipher_active = 1;
+						return ret ;
+					}
+					else {
+						al=SSL_AD_DECRYPT_ERROR;
+						SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+						goto f_err;
+					}
+				}
+			}
+			else
+			{
+				int cipher_type, digest_type;
+				const EVP_MD *hash;
+				const EVP_CIPHER *c;
+				SSL_COMP *comp;
+				HashType hash_type;
+				SslVersion ssl_version;
+				unsigned char *p1;
+
+				p1 = &s->hs_msgs[s->server_finish_msg_offset];
+
+				/* now replace first four bytes of server finish message.*/
+				memcpy(p1,s->peer_finish_first_four,4);
+
+				if((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+										 ||
+				 (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+			 							 ||
+				 (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+			 							 ||
+				 (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+				{
+
+					if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
+						{
+						SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+						ret = 0;
+						goto f_err;
+						}
+
+					digest_type = EVP_MD_type(hash);
+					cipher_type = EVP_CIPHER_nid(c);
+
+					if(digest_type == NID_md5)   
+						hash_type = MD5_TYPE;
+
+					else if(digest_type == NID_sha1) 
+						hash_type = SHA1_TYPE;
+
+					else
+					{
+					 ret = 0;
+					 goto f_err;
+					}
+
+					if(s->version > SSL3_VERSION)
+					{
+						ssl_version = VER_TLS;
+					}
+					else
+					{
+						ssl_version = VER3_0;
+					}
+
+					/* decrypt the received finished */
+					if(ssl_version == VER_TLS)
+					{
+						if (memcmp(&s->hs_msgs[s->server_finish_msg_offset], s->server_finished, n) != 0)
+						{
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+					else
+					{
+#ifdef CAVIUM_FIPS
+					i = Cfm1DecryptRecord3DesRecover(
+									 OP_BLOCKING,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_CLIENT,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->server_finish_msg_offset),  
+									 &s->hs_msgs[s->server_finish_msg_offset], 
+									 &s->peer_len,
+									 s->dec_peer_client_finished,
+									 &req_id
+									 );
+#else
+#ifndef MC2
+					i = Csp1DecryptRecord3DesRecover
+#else
+					i = Csp1DecryptRecord3Des
+#endif
+								   (
+									 s->cav_nb_mode,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_CLIENT,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->server_finish_msg_offset),  
+									 &s->hs_msgs[s->server_finish_msg_offset], 
+									 &s->peer_len,
+									 s->dec_peer_client_finished,
+
+#ifdef CAVIUM_MULTICARD_API
+									 &s->cav_req_id,s->dev_id
+#else
+									 &s->cav_req_id
+#endif
+                                                               );
+
+#endif
+					if ( i== 0 ){
+			             memcpy (dec_peer_client_finished, s->dec_peer_client_finished,s->peer_len);
+                    }
+				    if ( i == EAGAIN ) {
+                        cav_fprintf(cav_nb_fp,"pkp_client_handshake(): %s\n",
+		                       	"ssl3_get_finished() EAGAIN");
+	        		    s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER_2;
+			            s->cav_saved_state = s->state;
+                                    s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                	        s->cav_req_id_check_done = 0;
+		                    s->rwstate = SSL_NITROX_BUSY;
+                	}
+					
+                    if ( i != 0)
+                    {
+                        ret = 0 ;
+                        return ret;
+                    }
+
+dec_peer2:
+					if( memcmp(dec_peer_client_finished, s->server_finished,s->peer_len) != 0)
+					{
+
+						cav_fprintf(cav_nb_fp, "%s %s\n",
+							"ssl3_get_finished(): memcmp after ",
+							"client side Csp1DecryptRecordDesRecover() failed");
+						ret =0;
+						al=SSL_AD_DECRYPT_ERROR;
+						SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+						goto f_err;
+						}
+					}
+
+				} // end if ... DES
+				else if(
+				 (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+				 ||
+				 (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+				 	)
+				{
+
+					if (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))
+						{
+						SSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+						ret = 0;
+						goto f_err;
+						}
+
+					digest_type = EVP_MD_type(hash);
+					cipher_type = EVP_CIPHER_nid(c);
+
+					if(digest_type == NID_md5)   
+						hash_type = MD5_TYPE;
+
+					else if(digest_type == NID_sha1) 
+						hash_type = SHA1_TYPE;
+
+					else
+					{
+					    ret = 0;
+					    goto f_err;
+					}
+
+					if(s->version > SSL3_VERSION)
+					{
+						ssl_version = VER_TLS;
+					}
+					else
+					{
+						ssl_version = VER3_0;
+					}
+
+					/* decrypt the received finished */
+					if(ssl_version == VER_TLS)
+					{
+						if (memcmp(&s->hs_msgs[s->server_finish_msg_offset], s->server_finished, n) != 0)
+						{
+							ret =0;
+							al=SSL_AD_DECRYPT_ERROR;
+							SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+							goto f_err;
+						}
+					}
+					else
+					{
+						AesType aes_type = get_Aes_type(s->session->cipher->id);
+#ifdef CAVIUM_FIPS
+						i = Cfm1DecryptRecordAesRecover(
+									 OP_BLOCKING,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_CLIENT,
+									 aes_type,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->server_finish_msg_offset),  
+									 &s->hs_msgs[s->server_finish_msg_offset], 
+									 &s->peer_len,
+									 s->dec_peer_client_finished,
+									 &req_id
+									 );
+#else
+#ifndef MC2
+ 
+						i = Csp1DecryptRecordAesRecover
+#else
+						i = Csp1DecryptRecordAes
+#endif
+							(
+									 s->cav_nb_mode,
+									 s->context_pointer, 
+									 hash_type, 
+									 ssl_version, 
+									 SSL_CLIENT,
+									 aes_type,
+									 HANDSHAKE,
+									 (short)(s->hs_msgs_len - s->server_finish_msg_offset),  
+									 &s->hs_msgs[s->server_finish_msg_offset], 
+									 &s->peer_len,
+									 s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+									 &s->cav_req_id,s->dev_id
+#else
+									 &s->cav_req_id
+#endif
+                                                                    );
+#endif
+
+					if ( i== 0 ){
+			            memcpy (dec_peer_client_finished, s->dec_peer_client_finished,s->peer_len);
+                                                                                                                             
+                    }
+				    if ( i == EAGAIN ) {
+                       	cav_fprintf(cav_nb_fp,"pkp_client_handshake(): %s\n",
+		                           	"ssl3_get_finished() EAGAIN");
+	        		    s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER_2;
+			            s->cav_saved_state = s->state;
+                                    s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                	        s->cav_req_id_check_done = 0;
+		                    s->rwstate = SSL_NITROX_BUSY;
+                	}
+					
+                    if ( i != 0)
+                    {
+                        ret = 0 ;
+                        return ret;
+                    }
+
+dec_peer3:			
+					if( memcmp(dec_peer_client_finished, s->server_finished,s->peer_len) != 0)
+					{
+						ret =0;
+						al=SSL_AD_DECRYPT_ERROR;
+						SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+						goto f_err;
+					}
+				}
+
+				} // end else ... AES
+				else
+				{
+					if (memcmp(p1, s->server_finished, n+4) != 0)
+					{
+						ret =0;
+						al=SSL_AD_DECRYPT_ERROR;
+						SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+						goto f_err;
+					}
+				}
+
+				s->read_cipher_active = 1;
+				ret = 1;
+
+			} /* if no hit */
+
+		}/* if client */
+	}
+	else {
+		// In 0.96g turbossl it was:
+		//p = (unsigned char *)s->init_buf->data;
+		p = (unsigned char *)s->init_msg;
+		i = s->s3->tmp.peer_finish_md_len;
+
+		if (i != n)
+			{
+			al=SSL_AD_DECODE_ERROR;
+			SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_BAD_DIGEST_LENGTH);
+			goto f_err;
+			}
+
+		if (memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)
+			{
+			al=SSL_AD_DECRYPT_ERROR;
+			SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
+			goto f_err;
+			}
+		ret = 1;
+
+	}
+
+	/* finally */
+
+	return (ret);
+#else
 	p = (unsigned char *)s->init_msg;
 	i = s->s3->tmp.peer_finish_md_len;
 
@@ -231,7 +993,7 @@
 		SSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);
 		goto f_err;
 		}
-
+#endif
 	return(1);
 f_err:
 	ssl3_send_alert(s,SSL3_AL_FATAL,al);
@@ -599,9 +1361,31 @@
 		else
 			extra=0;
 		len = SSL3_RT_MAX_PACKET_SIZE + extra;
+#ifdef CAVIUM_SSL
+
+#if !defined  (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+        p = (unsigned char *)mmap(NULL, (5*4096), PROT_READ|PROT_WRITE,
+                        MAP_SHARED , CSP1_driver_handle, 0);
+        if((unsigned long)p == -1)
+        {
+            goto err;
+        }
+        s->s3->o_rbuf_buf=p;
+        s->s3->rbuf.buf=p+3;
+        s->s3->rbuf.buf[0]=1;
+        cav_fprintf(cav_nb_fp, "ssl3_setup_buffers(): %s %p\n",
+                             "mmap'ed s->s3->o_rbuf_buf = ", s->s3->o_rbuf_buf);
+#else
+        if ((p=OPENSSL_malloc(len)) == NULL)
+            goto err;
+        s->s3->rbuf.buf = p;
+#endif  // end ifndef CAVIUM_NOMMAP
+
+#else
 		if ((p=OPENSSL_malloc(len)) == NULL)
 			goto err;
 		s->s3->rbuf.buf = p;
+#endif
 		s->s3->rbuf.len = len;
 		}
 
@@ -609,12 +1393,75 @@
 		{
 		len = SSL3_RT_MAX_PACKET_SIZE;
 		len += SSL3_RT_HEADER_LENGTH + 256; /* extra space for empty fragment */
+#ifdef CAVIUM_SSL
+
+#if !defined  (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+        p = (unsigned char *)mmap(NULL, (5*4096), PROT_READ|PROT_WRITE,
+                MAP_SHARED  , CSP1_driver_handle, 0);
+        if((unsigned long)p == -1)
+        {
+            goto err;
+        }
+        s->s3->o_wbuf_buf=p;
+        s->s3->wbuf.buf=p+3;
+        s->s3->wbuf.buf[0]=1;
+        cav_fprintf(cav_nb_fp, "ssl3_setup_buffers(): %s %p\n",
+                             "mmap'ed s->s3->o_wbuf_buf = ", s->s3->o_wbuf_buf);
+#else
+        if ((p=OPENSSL_malloc(len)) == NULL)
+            goto err;
+        s->s3->wbuf.buf = p;
+#endif  // end ifndef CAVIUM_NOMMAP
+
+#else
 		if ((p=OPENSSL_malloc(len)) == NULL)
 			goto err;
 		s->s3->wbuf.buf = p;
+#endif
 		s->s3->wbuf.len = len;
 		}
 	s->packet= &(s->s3->rbuf.buf[0]);
+#ifdef CAVIUM_SSL
+
+    /* If CAVEO-SSL is defined then allocate hs_msgs buffer and initialize 
+       offsets. It is initialzed to CH_SR_MSGS_LEN, defined in ssl.h but at 
+       run-time reallocates more memory if required */
+
+    if(s->in_handshake && s->hs_msgs == NULL)
+    {
+        if ((s->hs_msgs = OPENSSL_malloc(CH_SR_MSGS_LEN)) == NULL)
+            goto err;
+        s->hs_msgs_len = 0;
+        s->hs_msgs_total_len = CH_SR_MSGS_LEN;
+        /*
+         ** Renegotiation fix
+         **/
+        cav_fprintf(cav_nb_fp,
+               "ssl3_setup_buffers(): s->cav_renego is :  %d\n", s->cav_renego);
+
+        if ( s->cav_renego == 0 ) {
+            cav_fprintf(cav_nb_fp,
+            "ssl3_setup_buffers(): s->cav_renego is 0\n");
+            s->read_cipher_active=0;
+            s->write_cipher_active=0;
+            s->cipher_support = 0;
+            s->handshake_support = 0;
+            s->record_process = 0;
+        }
+        else {
+            cav_fprintf(cav_nb_fp,
+                    "ssl3_setup_buffers(): s->cav_renego is 1\n");
+        }
+
+        /* Following two buffers are only used in session resumption */
+        /*These are not rellocated as finish messages are always 40 bytes in size.
+        MD5 digest : 16 B
+        SHA1 digest: 20 B
+        header     :  4 B
+        */
+
+    }
+#endif
 	return(1);
 err:
 	SSLerr(SSL_F_SSL3_SETUP_BUFFERS,ERR_R_MALLOC_FAILURE);
diff -Naur openssl-0.9.8j/ssl/s3_clnt.c TurboSSL-0.9.8j/ssl/s3_clnt.c
--- openssl-0.9.8j/ssl/s3_clnt.c	2009-01-07 11:48:23.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/s3_clnt.c	2010-05-31 12:14:16.000000000 +0200
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -63,7 +63,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -111,7 +111,7 @@
 /* ====================================================================
  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
  *
- * Portions of the attached software ("Contribution") are developed by 
+ * Portions of the attached software ("Contribution") are developed by
  * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.
  *
  * The Contribution is licensed pursuant to the OpenSSL open source
@@ -142,6 +142,19 @@
 #include <openssl/engine.h>
 #endif
 
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include "ssl_engine.h"
+#include "openssl/cav_debug.h"
+#include "cav_crypto_engine.h"
+#endif
+
 static SSL_METHOD *ssl3_get_client_method(int ver);
 static int ca_dn_cmp(const X509_NAME * const *a,const X509_NAME * const *b);
 #ifndef OPENSSL_NO_TLSEXT
@@ -154,1448 +167,1699 @@
 #endif
 
 static SSL_METHOD *ssl3_get_client_method(int ver)
-	{
-	if (ver == SSL3_VERSION)
-		return(SSLv3_client_method());
-	else
-		return(NULL);
-	}
+        {
+        if (ver == SSL3_VERSION)
+                return(SSLv3_client_method());
+        else
+                return(NULL);
+        }
 
 IMPLEMENT_ssl3_meth_func(SSLv3_client_method,
-			ssl_undefined_function,
-			ssl3_connect,
-			ssl3_get_client_method)
+                        ssl_undefined_function,
+                        ssl3_connect,
+                        ssl3_get_client_method)
 
 int ssl3_connect(SSL *s)
-	{
-	BUF_MEM *buf=NULL;
-	unsigned long Time=(unsigned long)time(NULL),l;
-	long num1;
-	void (*cb)(const SSL *ssl,int type,int val)=NULL;
-	int ret= -1;
-	int new_state,state,skip=0;;
-
-	RAND_add(&Time,sizeof(Time),0);
-	ERR_clear_error();
-	clear_sys_error();
-
-	if (s->info_callback != NULL)
-		cb=s->info_callback;
-	else if (s->ctx->info_callback != NULL)
-		cb=s->ctx->info_callback;
-	
-	s->in_handshake++;
-	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); 
-
-	for (;;)
-		{
-		state=s->state;
-
-		switch(s->state)
-			{
-		case SSL_ST_RENEGOTIATE:
-			s->new_session=1;
-			s->state=SSL_ST_CONNECT;
-			s->ctx->stats.sess_connect_renegotiate++;
-			/* break */
-		case SSL_ST_BEFORE:
-		case SSL_ST_CONNECT:
-		case SSL_ST_BEFORE|SSL_ST_CONNECT:
-		case SSL_ST_OK|SSL_ST_CONNECT:
-
-			s->server=0;
-			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
-
-			if ((s->version & 0xff00 ) != 0x0300)
-				{
-				SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
-				ret = -1;
-				goto end;
-				}
-				
-			/* s->version=SSL3_VERSION; */
-			s->type=SSL_ST_CONNECT;
-
-			if (s->init_buf == NULL)
-				{
-				if ((buf=BUF_MEM_new()) == NULL)
-					{
-					ret= -1;
-					goto end;
-					}
-				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
-					{
-					ret= -1;
-					goto end;
-					}
-				s->init_buf=buf;
-				buf=NULL;
-				}
-
-			if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }
-
-			/* setup buffing BIO */
-			if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }
-
-			/* don't push the buffering BIO quite yet */
-
-			ssl3_init_finished_mac(s);
-
-			s->state=SSL3_ST_CW_CLNT_HELLO_A;
-			s->ctx->stats.sess_connect++;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CW_CLNT_HELLO_A:
-		case SSL3_ST_CW_CLNT_HELLO_B:
-
-			s->shutdown=0;
-			ret=ssl3_client_hello(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CR_SRVR_HELLO_A;
-			s->init_num=0;
-
-			/* turn on buffering for the next lot of output */
-			if (s->bbio != s->wbio)
-				s->wbio=BIO_push(s->bbio,s->wbio);
-
-			break;
-
-		case SSL3_ST_CR_SRVR_HELLO_A:
-		case SSL3_ST_CR_SRVR_HELLO_B:
-			ret=ssl3_get_server_hello(s);
-			if (ret <= 0) goto end;
-			if (s->hit)
-				s->state=SSL3_ST_CR_FINISHED_A;
-			else
-				s->state=SSL3_ST_CR_CERT_A;
-			s->init_num=0;
-			break;
+        {
+        BUF_MEM *buf=NULL;
+#ifdef CAVIUM_SSL
+        unsigned long l;
+#else
+        unsigned long Time=(unsigned long)time(NULL),l;
+#endif
+        long num1;
+        void (*cb)(const SSL *ssl,int type,int val)=NULL;
+        int ret= -1;
+        int new_state,state,skip=0;;
+
+#ifndef CAVIUM_SSL
+        RAND_add(&Time,sizeof(Time),0);
+#endif
+        ERR_clear_error();
+        clear_sys_error();
+
+        if (s->info_callback != NULL)
+                cb=s->info_callback;
+        else if (s->ctx->info_callback != NULL)
+                cb=s->ctx->info_callback;
+
+        s->in_handshake++;
+
+#ifdef CAVIUM_SSL
+        init_supported_cipher_list(s);
+
+#ifdef CAVIUM_NB_CRYPTO
+        if (!SSL_in_init(s) || SSL_in_before(s)) {
+            cav_print_state(s, "ssl3_connect(): ");
+
+            if ( s->cav_crypto_state == 0 ) {
+                cav_fprintf(cav_nb_fp,"ssl3_connect(): will call SSL_clear()\n");
+                SSL_clear(s);
+            }
+            else {
+                cav_fprintf(cav_nb_fp,"ssl3_connect(): will skip SSL_clear()\n");
+            }
+        }
+#endif
 
-		case SSL3_ST_CR_CERT_A:
-		case SSL3_ST_CR_CERT_B:
+#else
+        if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
+#endif
+
+        for (;;)
+                {
+                state=s->state;
+
+                switch(s->state)
+                        {
+                case SSL_ST_RENEGOTIATE:
+                        s->new_session=1;
+                        s->state=SSL_ST_CONNECT;
+                        s->ctx->stats.sess_connect_renegotiate++;
+
+#ifdef CAVIUM_SSL
+
+            cav_fprintf(cav_nb_fp,"ssl3_connect(): setting the renego flag\n");
+            s->cav_renego = 1;
+
+            if(s->handshake_support && pkp_write_updated_ssl_session_context(s))
+            {
+                s->cipher_support = 1;
+                s->handshake_support = 0;
+            }
+            else if(s->record_process && pkp_read_updated_ssl_session_context(s))
+                s->cipher_support = 0;
+
+            SSL_set_verify(s, s->verify_mode, NULL);
+
+#endif
+                        /* break */
+                case SSL_ST_BEFORE:
+                case SSL_ST_CONNECT:
+                case SSL_ST_BEFORE|SSL_ST_CONNECT:
+                case SSL_ST_OK|SSL_ST_CONNECT:
+
+                        s->server=0;
+                        if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
+
+                        if ((s->version & 0xff00 ) != 0x0300)
+                                {
+                                SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);
+                                ret = -1;
+                                goto end;
+                                }
+
+                        /* s->version=SSL3_VERSION; */
+                        s->type=SSL_ST_CONNECT;
+
+                        if (s->init_buf == NULL)
+                                {
+                                if ((buf=BUF_MEM_new()) == NULL)
+                                        {
+                                        ret= -1;
+                                        goto end;
+                                        }
+                                if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
+                                        {
+                                        ret= -1;
+                                        goto end;
+                                        }
+                                s->init_buf=buf;
+                                buf=NULL;
+                                }
+
+                        if (!ssl3_setup_buffers(s)) { ret= -1; goto end; }
+
+                        /* setup buffing BIO */
+                        if (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }
+
+                        /* don't push the buffering BIO quite yet */
+
+                        ssl3_init_finished_mac(s);
+
+                        s->state=SSL3_ST_CW_CLNT_HELLO_A;
+                        s->ctx->stats.sess_connect++;
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CW_CLNT_HELLO_A:
+                case SSL3_ST_CW_CLNT_HELLO_B:
+
+                        s->shutdown=0;
+                        ret=ssl3_client_hello(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CR_SRVR_HELLO_A;
+                        s->init_num=0;
+
+                        /* turn on buffering for the next lot of output */
+                        if (s->bbio != s->wbio)
+                                s->wbio=BIO_push(s->bbio,s->wbio);
+
+                        break;
+
+                case SSL3_ST_CR_SRVR_HELLO_A:
+                case SSL3_ST_CR_SRVR_HELLO_B:
+                        ret=ssl3_get_server_hello(s);
+                        if (ret <= 0) goto end;
+                        if (s->hit)
+                                s->state=SSL3_ST_CR_FINISHED_A;
+                        else
+                                s->state=SSL3_ST_CR_CERT_A;
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CR_CERT_A:
+                case SSL3_ST_CR_CERT_B:
 #ifndef OPENSSL_NO_TLSEXT
-			ret=ssl3_check_finished(s);
-			if (ret <= 0) goto end;
-			if (ret == 2)
-				{
-				s->hit = 1;
-				if (s->tlsext_ticket_expected)
-					s->state=SSL3_ST_CR_SESSION_TICKET_A;
-				else
-					s->state=SSL3_ST_CR_FINISHED_A;
-				s->init_num=0;
-				break;
-				}
-#endif
-			/* Check if it is anon DH/ECDH */
-			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
-				{
-				ret=ssl3_get_server_certificate(s);
-				if (ret <= 0) goto end;
+                        ret=ssl3_check_finished(s);
+                        if (ret <= 0) goto end;
+                        if (ret == 2)
+                                {
+                                s->hit = 1;
+                                if (s->tlsext_ticket_expected)
+                                        s->state=SSL3_ST_CR_SESSION_TICKET_A;
+                                else
+                                        s->state=SSL3_ST_CR_FINISHED_A;
+                                s->init_num=0;
+                                break;
+                                }
+#endif
+                        /* Check if it is anon DH/ECDH */
+                        if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
+                                {
+                                ret=ssl3_get_server_certificate(s);
+                                if (ret <= 0) goto end;
 #ifndef OPENSSL_NO_TLSEXT
-				if (s->tlsext_status_expected)
-					s->state=SSL3_ST_CR_CERT_STATUS_A;
-				else
-					s->state=SSL3_ST_CR_KEY_EXCH_A;
-				}
-			else
-				{
-				skip = 1;
-				s->state=SSL3_ST_CR_KEY_EXCH_A;
-				}
-#else
-				}
-			else
-				skip=1;
-
-			s->state=SSL3_ST_CR_KEY_EXCH_A;
-#endif
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CR_KEY_EXCH_A:
-		case SSL3_ST_CR_KEY_EXCH_B:
-			ret=ssl3_get_key_exchange(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CR_CERT_REQ_A;
-			s->init_num=0;
-
-			/* at this point we check that we have the
-			 * required stuff from the server */
-			if (!ssl3_check_cert_and_algorithm(s))
-				{
-				ret= -1;
-				goto end;
-				}
-			break;
-
-		case SSL3_ST_CR_CERT_REQ_A:
-		case SSL3_ST_CR_CERT_REQ_B:
-			ret=ssl3_get_certificate_request(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CR_SRVR_DONE_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CR_SRVR_DONE_A:
-		case SSL3_ST_CR_SRVR_DONE_B:
-			ret=ssl3_get_server_done(s);
-			if (ret <= 0) goto end;
-			if (s->s3->tmp.cert_req)
-				s->state=SSL3_ST_CW_CERT_A;
-			else
-				s->state=SSL3_ST_CW_KEY_EXCH_A;
-			s->init_num=0;
-
-			break;
-
-		case SSL3_ST_CW_CERT_A:
-		case SSL3_ST_CW_CERT_B:
-		case SSL3_ST_CW_CERT_C:
-		case SSL3_ST_CW_CERT_D:
-			ret=ssl3_send_client_certificate(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CW_KEY_EXCH_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CW_KEY_EXCH_A:
-		case SSL3_ST_CW_KEY_EXCH_B:
-			ret=ssl3_send_client_key_exchange(s);
-			if (ret <= 0) goto end;
-			l=s->s3->tmp.new_cipher->algorithms;
-			/* EAY EAY EAY need to check for DH fix cert
-			 * sent back */
-			/* For TLS, cert_req is set to 2, so a cert chain
-			 * of nothing is sent, but no verify packet is sent */
-			/* XXX: For now, we do not support client 
-			 * authentication in ECDH cipher suites with
-			 * ECDH (rather than ECDSA) certificates.
-			 * We need to skip the certificate verify 
-			 * message when client's ECDH public key is sent 
-			 * inside the client certificate.
-			 */
-			if (s->s3->tmp.cert_req == 1)
-				{
-				s->state=SSL3_ST_CW_CERT_VRFY_A;
-				}
-			else
-				{
-				s->state=SSL3_ST_CW_CHANGE_A;
-				s->s3->change_cipher_spec=0;
-				}
-
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CW_CERT_VRFY_A:
-		case SSL3_ST_CW_CERT_VRFY_B:
-			ret=ssl3_send_client_verify(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CW_CHANGE_A;
-			s->init_num=0;
-			s->s3->change_cipher_spec=0;
-			break;
-
-		case SSL3_ST_CW_CHANGE_A:
-		case SSL3_ST_CW_CHANGE_B:
-			ret=ssl3_send_change_cipher_spec(s,
-				SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CW_FINISHED_A;
-			s->init_num=0;
+                                if (s->tlsext_status_expected)
+                                        s->state=SSL3_ST_CR_CERT_STATUS_A;
+                                else
+                                        s->state=SSL3_ST_CR_KEY_EXCH_A;
+                                }
+                        else
+                                {
+                                skip = 1;
+                                s->state=SSL3_ST_CR_KEY_EXCH_A;
+                                }
+#else
+                                }
+                        else
+                                skip=1;
+
+                        s->state=SSL3_ST_CR_KEY_EXCH_A;
+#endif
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CR_KEY_EXCH_A:
+                case SSL3_ST_CR_KEY_EXCH_B:
+                        ret=ssl3_get_key_exchange(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CR_CERT_REQ_A;
+                        s->init_num=0;
+
+                        /* at this point we check that we have the
+                         * required stuff from the server */
+                        if (!ssl3_check_cert_and_algorithm(s))
+                                {
+                                ret= -1;
+                                goto end;
+                                }
+                        break;
+
+                case SSL3_ST_CR_CERT_REQ_A:
+                case SSL3_ST_CR_CERT_REQ_B:
+                        ret=ssl3_get_certificate_request(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CR_SRVR_DONE_A;
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CR_SRVR_DONE_A:
+                case SSL3_ST_CR_SRVR_DONE_B:
+                        ret=ssl3_get_server_done(s);
+                        if (ret <= 0) goto end;
+                        if (s->s3->tmp.cert_req)
+                                s->state=SSL3_ST_CW_CERT_A;
+                        else
+                                s->state=SSL3_ST_CW_KEY_EXCH_A;
+                        s->init_num=0;
+
+                        break;
+
+                case SSL3_ST_CW_CERT_A:
+                case SSL3_ST_CW_CERT_B:
+                case SSL3_ST_CW_CERT_C:
+                case SSL3_ST_CW_CERT_D:
+                        ret=ssl3_send_client_certificate(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CW_KEY_EXCH_A;
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CW_KEY_EXCH_A:
+                case SSL3_ST_CW_KEY_EXCH_B:
+                        ret=ssl3_send_client_key_exchange(s);
+                        if (ret <= 0) goto end;
+                        l=s->s3->tmp.new_cipher->algorithms;
+                        /* EAY EAY EAY need to check for DH fix cert
+                         * sent back */
+                        /* For TLS, cert_req is set to 2, so a cert chain
+                         * of nothing is sent, but no verify packet is sent */
+                        /* XXX: For now, we do not support client
+                         * authentication in ECDH cipher suites with
+                         * ECDH (rather than ECDSA) certificates.
+                         * We need to skip the certificate verify
+                         * message when client's ECDH public key is sent
+                         * inside the client certificate.
+                         */
+                        if (s->s3->tmp.cert_req == 1)
+                                {
+                                s->state=SSL3_ST_CW_CERT_VRFY_A;
+                                }
+                        else
+                                {
+#ifdef CAVIUM_SSL
+                                if(s->cipher_support)
+                                       s->state = SSL3_ST_CW_FINISHED_A ;
+                                else
+#endif
+                                s->state=SSL3_ST_CW_CHANGE_A;
+                                s->s3->change_cipher_spec=0;
+                                }
+
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CW_CERT_VRFY_A:
+                case SSL3_ST_CW_CERT_VRFY_B:
+                        ret=ssl3_send_client_verify(s);
+                        if (ret <= 0) goto end;
+#ifdef CAVIUM_SSL
+                        if(s->cipher_support)
+                            s->state = SSL3_ST_CW_FINISHED_A ;
+                        else
+#endif
+                        s->state=SSL3_ST_CW_CHANGE_A;
+                        s->init_num=0;
+                        s->s3->change_cipher_spec=0;
+                        break;
+
+                case SSL3_ST_CW_CHANGE_A:
+                case SSL3_ST_CW_CHANGE_B:
+                        ret=ssl3_send_change_cipher_spec(s,
+                                SSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CW_FINISHED_A;
+                        s->init_num=0;
 
-			s->session->cipher=s->s3->tmp.new_cipher;
+                        s->session->cipher=s->s3->tmp.new_cipher;
 #ifdef OPENSSL_NO_COMP
-			s->session->compress_meth=0;
+                        s->session->compress_meth=0;
 #else
-			if (s->s3->tmp.new_compression == NULL)
-				s->session->compress_meth=0;
-			else
-				s->session->compress_meth=
-					s->s3->tmp.new_compression->id;
-#endif
-			if (!s->method->ssl3_enc->setup_key_block(s))
-				{
-				ret= -1;
-				goto end;
-				}
-
-			if (!s->method->ssl3_enc->change_cipher_state(s,
-				SSL3_CHANGE_CIPHER_CLIENT_WRITE))
-				{
-				ret= -1;
-				goto end;
-				}
-
-			break;
-
-		case SSL3_ST_CW_FINISHED_A:
-		case SSL3_ST_CW_FINISHED_B:
-			ret=ssl3_send_finished(s,
-				SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
-				s->method->ssl3_enc->client_finished_label,
-				s->method->ssl3_enc->client_finished_label_len);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CW_FLUSH;
-
-			/* clear flags */
-			s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
-			if (s->hit)
-				{
-				s->s3->tmp.next_state=SSL_ST_OK;
-				if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
-					{
-					s->state=SSL_ST_OK;
-					s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
-					s->s3->delay_buf_pop_ret=0;
-					}
-				}
-			else
-				{
+                        if (s->s3->tmp.new_compression == NULL)
+                                s->session->compress_meth=0;
+                        else
+                                s->session->compress_meth=
+                                        s->s3->tmp.new_compression->id;
+#endif
+                        if (!s->method->ssl3_enc->setup_key_block(s))
+                                {
+                                ret= -1;
+                                goto end;
+                                }
+
+                        if (!s->method->ssl3_enc->change_cipher_state(s,
+                                SSL3_CHANGE_CIPHER_CLIENT_WRITE))
+                                {
+                                ret= -1;
+                                goto end;
+                                }
+
+                        break;
+
+                case SSL3_ST_CW_FINISHED_A:
+                case SSL3_ST_CW_FINISHED_B:
+#ifdef CAVIUM_SSL
+                if ((s->cav_renego > 0)  && (s->reneg_flag)) 
+                {
+                   s->state=SSL3_ST_CW_CHANGE_B;
+                   ret = ssl3_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC);
+                   if (ret != 0 )
+                   {
+                      s->session->cipher=s->s3->tmp.new_cipher;
+                      if (s->s3->tmp.new_compression == NULL)
+                         s->session->compress_meth=0;
+                      else
+                         s->session->compress_meth=
+                                    s->s3->tmp.new_compression->id;
+                       s->write_cipher_active = 0 ;
+                   }
+                   else 
+                   {
+                       ret = 0 ;
+                       s->state = SSL3_ST_CW_FINISHED_A ;
+                       goto end;
+                   }
+                }
+                if(s->cipher_support)
+                {
+                    if(s->s3->tmp.cert_req == 1)
+                    {
+                        ret = pkp_client_handshake_client_auth(s);
+                    }
+                    else
+                    {
+                        /* generate master secret, key blob and two finished
+                        messages. s->server_finished, s->client_finished.
+                        Only write_cipher is activated. Read cipher is activated
+                        after receiving server finished message.*/
+                        ret = pkp_client_handshake(s);
+                    }
+
+                    if (ret <= 0) goto end;
+                }
+                else
+                {
+#endif
+                        ret=ssl3_send_finished(s,
+                                SSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,
+                                s->method->ssl3_enc->client_finished_label,
+                                s->method->ssl3_enc->client_finished_label_len);
+                        if (ret <= 0) goto end;
+#ifdef CAVIUM_SSL
+                 }
+finish1_cav:
+#endif/* CAVIUM_SSL*/
+                        s->state=SSL3_ST_CW_FLUSH;
+
+                        /* clear flags */
+                        s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
+                        if (s->hit)
+                                {
+                                s->s3->tmp.next_state=SSL_ST_OK;
+                                if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
+                                        {
+                                        s->state=SSL_ST_OK;
+                                        s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
+                                        s->s3->delay_buf_pop_ret=0;
+                                        }
+                                }
+                        else
+                                {
 #ifndef OPENSSL_NO_TLSEXT
-				/* Allow NewSessionTicket if ticket expected */
-				if (s->tlsext_ticket_expected)
-					s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
-				else
-#endif
-				
-				s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
-				}
-			s->init_num=0;
-			break;
+                                /* Allow NewSessionTicket if ticket expected */
+                                if (s->tlsext_ticket_expected)
+                                        s->s3->tmp.next_state=SSL3_ST_CR_SESSION_TICKET_A;
+                                else
+#endif
+
+                                s->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;
+                                }
+                        s->init_num=0;
+                        break;
 
 #ifndef OPENSSL_NO_TLSEXT
-		case SSL3_ST_CR_SESSION_TICKET_A:
-		case SSL3_ST_CR_SESSION_TICKET_B:
-			ret=ssl3_get_new_session_ticket(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CR_FINISHED_A;
-			s->init_num=0;
-		break;
-
-		case SSL3_ST_CR_CERT_STATUS_A:
-		case SSL3_ST_CR_CERT_STATUS_B:
-			ret=ssl3_get_cert_status(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_CR_KEY_EXCH_A;
-			s->init_num=0;
-		break;
-#endif
-
-		case SSL3_ST_CR_FINISHED_A:
-		case SSL3_ST_CR_FINISHED_B:
-
-			ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
-				SSL3_ST_CR_FINISHED_B);
-			if (ret <= 0) goto end;
-
-			if (s->hit)
-				s->state=SSL3_ST_CW_CHANGE_A;
-			else
-				s->state=SSL_ST_OK;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_CW_FLUSH:
-			/* number of bytes to be flushed */
-			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
-			if (num1 > 0)
-				{
-				s->rwstate=SSL_WRITING;
-				num1=BIO_flush(s->wbio);
-				if (num1 <= 0) { ret= -1; goto end; }
-				s->rwstate=SSL_NOTHING;
-				}
-
-			s->state=s->s3->tmp.next_state;
-			break;
-
-		case SSL_ST_OK:
-			/* clean a few things up */
-			ssl3_cleanup_key_block(s);
-
-			if (s->init_buf != NULL)
-				{
-				BUF_MEM_free(s->init_buf);
-				s->init_buf=NULL;
-				}
-
-			/* If we are not 'joining' the last two packets,
-			 * remove the buffering now */
-			if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
-				ssl_free_wbio_buffer(s);
-			/* else do it later in ssl3_write */
-
-			s->init_num=0;
-			s->new_session=0;
-
-			ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
-			if (s->hit) s->ctx->stats.sess_hit++;
-
-			ret=1;
-			/* s->server=0; */
-			s->handshake_func=ssl3_connect;
-			s->ctx->stats.sess_connect_good++;
-
-			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
-
-			goto end;
-			/* break; */
-			
-		default:
-			SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
-			ret= -1;
-			goto end;
-			/* break; */
-			}
-
-		/* did we do anything */
-		if (!s->s3->tmp.reuse_message && !skip)
-			{
-			if (s->debug)
-				{
-				if ((ret=BIO_flush(s->wbio)) <= 0)
-					goto end;
-				}
-
-			if ((cb != NULL) && (s->state != state))
-				{
-				new_state=s->state;
-				s->state=state;
-				cb(s,SSL_CB_CONNECT_LOOP,1);
-				s->state=new_state;
-				}
-			}
-		skip=0;
-		}
+                case SSL3_ST_CR_SESSION_TICKET_A:
+                case SSL3_ST_CR_SESSION_TICKET_B:
+                        ret=ssl3_get_new_session_ticket(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CR_FINISHED_A;
+                        s->init_num=0;
+                break;
+
+                case SSL3_ST_CR_CERT_STATUS_A:
+                case SSL3_ST_CR_CERT_STATUS_B:
+                        ret=ssl3_get_cert_status(s);
+                        if (ret <= 0) goto end;
+                        s->state=SSL3_ST_CR_KEY_EXCH_A;
+                        s->init_num=0;
+                break;
+#endif
+
+                case SSL3_ST_CR_FINISHED_A:
+                case SSL3_ST_CR_FINISHED_B:
+
+                        ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
+                                SSL3_ST_CR_FINISHED_B);
+                        if (ret <= 0) goto end;
+#ifdef CAVIUM_SSL
+finish_cav:
+                        if(s->cipher_support)
+                        {
+                            if(s->hit)
+                            {
+                                s->state=SSL3_ST_CW_FLUSH;
+
+                                /* clear flags */
+                                s->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;
+                                s->s3->tmp.next_state=SSL_ST_OK;
+                                if (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)
+                                {
+                                        s->state=SSL_ST_OK;
+                                        s->s3->flags|=SSL3_FLAGS_POP_BUFFER;
+                                        s->s3->delay_buf_pop_ret=0;
+                                }
+                                s->init_num=0;
+                            }
+                            else /* no hit */
+                                s->state=SSL_ST_OK;
+                        }
+                        else {
+#endif
+                        if (s->hit)
+                                s->state=SSL3_ST_CW_CHANGE_A;
+                        else
+                                s->state=SSL_ST_OK;
+#ifdef CAVIUM_SSL
+                        }
+#endif
+                        s->init_num=0;
+                        break;
+
+                case SSL3_ST_CW_FLUSH:
+                        /* number of bytes to be flushed */
+                        num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
+                        if (num1 > 0)
+                                {
+                                s->rwstate=SSL_WRITING;
+                                num1=BIO_flush(s->wbio);
+                                if (num1 <= 0) { ret= -1; goto end; }
+                                s->rwstate=SSL_NOTHING;
+                                }
+
+                        s->state=s->s3->tmp.next_state;
+                        break;
+
+                case SSL_ST_OK:
+                        /* clean a few things up */
+#ifdef CAVIUM_SSL
+                       if(s->hs_msgs != NULL)
+                       {
+                           OPENSSL_free(s->hs_msgs);
+                           s->hs_msgs=NULL;
+                       }
+#endif
+                        ssl3_cleanup_key_block(s);
+
+                        if (s->init_buf != NULL)
+                                {
+                                BUF_MEM_free(s->init_buf);
+                                s->init_buf=NULL;
+                                }
+
+                        /* If we are not 'joining' the last two packets,
+                         * remove the buffering now */
+                        if (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))
+                                ssl_free_wbio_buffer(s);
+                        /* else do it later in ssl3_write */
+
+                        s->init_num=0;
+                        s->new_session=0;
+#ifdef CAVIUM_SSL
+#ifndef NO_SESSION_CACHE
+                       ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
+                       if (s->hit) s->ctx->stats.sess_hit++;
+#endif
+#else
+                        ssl_update_cache(s,SSL_SESS_CACHE_CLIENT);
+                        if (s->hit) s->ctx->stats.sess_hit++;
+#endif
+                        ret=1;
+                        /* s->server=0; */
+                        s->handshake_func=ssl3_connect;
+                        s->ctx->stats.sess_connect_good++;
+
+#ifdef CAVIUM_SSL
+#if !defined(RECORD_PROCESS_OFFLOAD) && defined(HANDSHAKE_OFFLOAD)
+                        if(s->cipher_support && pkp_read_ssl_session_context(s))
+                        {
+                            s->cipher_support = 0;
+                            s->handshake_support = 1;
+                        }
+#endif
+                       if(s->record_process && pkp_write_ssl_session_context(s))
+                           s->cipher_support = 1;
+#endif
+
+                        if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
+
+                        goto end;
+                        /* break; */
+
+#if defined (CAVIUM_SSL) && defined (CAVIUM_NB_CRYPTO)
+
+                case CAV_ST_IN_RESUME_HANDSHAKE:
+
+                       if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER_2) {
+           
+                           ret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,
+                                   SSL3_ST_CR_FINISHED_B);
+                       }
+                       else {
+                           ret = pkp_client_resume_handshake(s);
+                       }
+           
+                       if (ret <= 0) {
+                           goto end;
+                       }
+                       goto finish_cav;
+                       break;
+
+                case CAV_ST_IN_VRFY_CERT:
+
+                      ret = pkp_client_cert_verify_mac(s);
+                      if ( ret <= 0 ) {
+                          goto end;
+                      }
+                      s->state = SSL3_ST_CW_CERT_VRFY_A ;
+                      s->flag1 = 1 ;
+                      break;
+          
+                case CAV_ST_IN_PRE_MASTER_KEY:
+                     ret = ssl3_send_client_verify(s);
+                     if ( ret <= 0 ) {
+                         goto end;
+                     }
+                     s->state = SSL3_ST_CW_FINISHED_A ;
+                     s->init_num=0;
+                     s->s3->change_cipher_spec=0;
+                     break;
+
+                case CAV_ST_IN_HANDSHAKE:
+                    if(s->s3->tmp.cert_req == 1){
+                        ret = pkp_client_handshake_client_auth(s);
+                    }
+                    else {
+                        ret = pkp_client_handshake(s);
+                    }
+                    if ( ret <= 0 ) {
+                        goto end;
+                    }
+                    goto finish1_cav;
+                    break;
+#endif
+                default:
+                        SSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);
+                        ret= -1;
+                        goto end;
+                        /* break; */
+                        }
+
+                /* did we do anything */
+                if (!s->s3->tmp.reuse_message && !skip)
+                        {
+                        if (s->debug)
+                                {
+                                if ((ret=BIO_flush(s->wbio)) <= 0)
+                                        goto end;
+                                }
+
+                        if ((cb != NULL) && (s->state != state))
+                                {
+                                new_state=s->state;
+                                s->state=state;
+                                cb(s,SSL_CB_CONNECT_LOOP,1);
+                                s->state=new_state;
+                                }
+                        }
+                skip=0;
+                }
 end:
-	s->in_handshake--;
-	if (buf != NULL)
-		BUF_MEM_free(buf);
-	if (cb != NULL)
-		cb(s,SSL_CB_CONNECT_EXIT,ret);
-	return(ret);
-	}
+        s->in_handshake--;
+        if (buf != NULL)
+                BUF_MEM_free(buf);
+        if (cb != NULL)
+                cb(s,SSL_CB_CONNECT_EXIT,ret);
+        return(ret);
+        }
 
 
 int ssl3_client_hello(SSL *s)
-	{
-	unsigned char *buf;
-	unsigned char *p,*d;
-	int i;
-	unsigned long Time,l;
+        {
+        unsigned char *buf;
+        unsigned char *p,*d;
+        int i;
+        unsigned long Time;
+#if !defined (CAVIUM_SSL)
+        unsigned long Time;
+#endif
+        unsigned long l;
 #ifndef OPENSSL_NO_COMP
-	int j;
-	SSL_COMP *comp;
+        int j;
+        SSL_COMP *comp;
 #endif
 
-	buf=(unsigned char *)s->init_buf->data;
-	if (s->state == SSL3_ST_CW_CLNT_HELLO_A)
-		{
-		if ((s->session == NULL) ||
-			(s->session->ssl_version != s->version) ||
-			(s->session->not_resumable))
-			{
-			if (!ssl_get_new_session(s,0))
-				goto err;
-			}
-		/* else use the pre-loaded session */
-
-		p=s->s3->client_random;
-		Time=(unsigned long)time(NULL);			/* Time */
-		l2n(Time,p);
-		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
-			goto err;
-
-		/* Do the message type and length last */
-		d=p= &(buf[4]);
-
-		*(p++)=s->version>>8;
-		*(p++)=s->version&0xff;
-		s->client_version=s->version;
-
-		/* Random stuff */
-		memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
-		p+=SSL3_RANDOM_SIZE;
-
-		/* Session ID */
-		if (s->new_session)
-			i=0;
-		else
-			i=s->session->session_id_length;
-		*(p++)=i;
-		if (i != 0)
-			{
-			if (i > (int)sizeof(s->session->session_id))
-				{
-				SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
-				goto err;
-				}
-			memcpy(p,s->session->session_id,i);
-			p+=i;
-			}
-		
-		/* Ciphers supported */
-		i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);
-		if (i == 0)
-			{
-			SSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
-			goto err;
-			}
-		s2n(i,p);
-		p+=i;
+        buf=(unsigned char *)s->init_buf->data;
+        if (s->state == SSL3_ST_CW_CLNT_HELLO_A)
+                {
+                if ((s->session == NULL) ||
+                        (s->session->ssl_version != s->version) ||
+                        (s->session->not_resumable))
+                        {
+                        if (!ssl_get_new_session(s,0))
+                                goto err;
+                        }
+                /* else use the pre-loaded session */
+
+                p=s->s3->client_random;
+                   return (0);
+                Time=(unsigned long)time(NULL);         /* Time */
+                l2n(Time,p);
+                if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
+                        goto err;
+                /* Do the message type and length last */
+                d=p= &(buf[4]);
+
+                *(p++)=s->version>>8;
+                *(p++)=s->version&0xff;
+                s->client_version=s->version;
+
+                /* Random stuff */
+                memcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);
+                p+=SSL3_RANDOM_SIZE;
+
+                /* Session ID */
+                if (s->new_session)
+                        i=0;
+                else
+                        i=s->session->session_id_length;
+                *(p++)=i;
+                if (i != 0)
+                        {
+                        if (i > (int)sizeof(s->session->session_id))
+                                {
+                                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
+                                goto err;
+                                }
+                        memcpy(p,s->session->session_id,i);
+                        p+=i;
+                        }
+
+                /* Ciphers supported */
+                i=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);
+                if (i == 0)
+                        {
+                        SSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);
+                        goto err;
+                        }
+                s2n(i,p);
+                p+=i;
 
-		/* COMPRESSION */
+                /* COMPRESSION */
 #ifdef OPENSSL_NO_COMP
-		*(p++)=1;
+                *(p++)=1;
 #else
-		if (s->ctx->comp_methods == NULL)
-			j=0;
-		else
-			j=sk_SSL_COMP_num(s->ctx->comp_methods);
-		*(p++)=1+j;
-		for (i=0; i<j; i++)
-			{
-			comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
-			*(p++)=comp->id;
-			}
+                if (s->ctx->comp_methods == NULL)
+                        j=0;
+                else
+                        j=sk_SSL_COMP_num(s->ctx->comp_methods);
+                *(p++)=1+j;
+                for (i=0; i<j; i++)
+                        {
+                        comp=sk_SSL_COMP_value(s->ctx->comp_methods,i);
+                        *(p++)=comp->id;
+                        }
 #endif
-		*(p++)=0; /* Add the NULL method */
+                *(p++)=0; /* Add the NULL method */
 #ifndef OPENSSL_NO_TLSEXT
-		if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-#endif		
-		l=(p-d);
-		d=buf;
-		*(d++)=SSL3_MT_CLIENT_HELLO;
-		l2n3(l,d);
-
-		s->state=SSL3_ST_CW_CLNT_HELLO_B;
-		/* number of bytes to write */
-		s->init_num=p-buf;
-		s->init_off=0;
-		}
+                if ((p = ssl_add_clienthello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
+                        {
+                        SSLerr(SSL_F_SSL3_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+#endif
+                l=(p-d);
+                d=buf;
+                *(d++)=SSL3_MT_CLIENT_HELLO;
+                l2n3(l,d);
+
+                s->state=SSL3_ST_CW_CLNT_HELLO_B;
+                /* number of bytes to write */
+                s->init_num=p-buf;
+                s->init_off=0;
+                }
 
-	/* SSL3_ST_CW_CLNT_HELLO_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+        /* SSL3_ST_CW_CLNT_HELLO_B */
+        return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
 err:
-	return(-1);
-	}
+        return(-1);
+        }
 
 int ssl3_get_server_hello(SSL *s)
-	{
-	STACK_OF(SSL_CIPHER) *sk;
-	SSL_CIPHER *c;
-	unsigned char *p,*d;
-	int i,al,ok;
-	unsigned int j;
-	long n;
+        {
+        STACK_OF(SSL_CIPHER) *sk;
+        SSL_CIPHER *c;
+        unsigned char *p,*d;
+        int i,al,ok;
+        unsigned int j;
+        long n;
 #ifndef OPENSSL_NO_COMP
-	SSL_COMP *comp;
+        SSL_COMP *comp;
 #endif
 
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_SRVR_HELLO_A,
-		SSL3_ST_CR_SRVR_HELLO_B,
-		-1,
-		20000, /* ?? */
-		&ok);
-
-	if (!ok) return((int)n);
-
-	if ( SSL_version(s) == DTLS1_VERSION)
-		{
-		if ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)
-			{
-			if ( s->d1->send_cookie == 0)
-				{
-				s->s3->tmp.reuse_message = 1;
-				return 1;
-				}
-			else /* already sent a cookie */
-				{
-				al=SSL_AD_UNEXPECTED_MESSAGE;
-				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
-				goto f_err;
-				}
-			}
-		}
-	
-	if ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)
-		{
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
-		goto f_err;
-		}
-
-	d=p=(unsigned char *)s->init_msg;
-
-	if ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))
-		{
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);
-		s->version=(s->version&0xff00)|p[1];
-		al=SSL_AD_PROTOCOL_VERSION;
-		goto f_err;
-		}
-	p+=2;
-
-	/* load the server hello data */
-	/* load the server random */
-	memcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);
-	p+=SSL3_RANDOM_SIZE;
-
-	/* get the session-id */
-	j= *(p++);
-
-	if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))
-		{
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);
-		goto f_err;
-		}
-
-	if (j != 0 && j == s->session->session_id_length
-	    && memcmp(p,s->session->session_id,j) == 0)
-	    {
-	    if(s->sid_ctx_length != s->session->sid_ctx_length
-	       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))
-		{
-		/* actually a client application bug */
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
-		goto f_err;
-		}
-	    s->hit=1;
-	    }
-	else	/* a miss or crap from the other end */
-		{
-		/* If we were trying for session-id reuse, make a new
-		 * SSL_SESSION so we don't stuff up other people */
-		s->hit=0;
-		if (s->session->session_id_length > 0)
-			{
-			if (!ssl_get_new_session(s,0))
-				{
-				al=SSL_AD_INTERNAL_ERROR;
-				goto f_err;
-				}
-			}
-		s->session->session_id_length=j;
-		memcpy(s->session->session_id,p,j); /* j could be 0 */
-		}
-	p+=j;
-	c=ssl_get_cipher_by_char(s,p);
-	if (c == NULL)
-		{
-		/* unknown cipher */
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);
-		goto f_err;
-		}
-	p+=ssl_put_cipher_by_char(s,NULL,NULL);
-
-	sk=ssl_get_ciphers_by_id(s);
-	i=sk_SSL_CIPHER_find(sk,c);
-	if (i < 0)
-		{
-		/* we did not say we would use this cipher */
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
-		goto f_err;
-		}
-
-	/* Depending on the session caching (internal/external), the cipher
-	   and/or cipher_id values may not be set. Make sure that
-	   cipher_id is set and use it for comparison. */
-	if (s->session->cipher)
-		s->session->cipher_id = s->session->cipher->id;
-	if (s->hit && (s->session->cipher_id != c->id))
-		{
-		if (!(s->options &
-			SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
-			{
-			al=SSL_AD_ILLEGAL_PARAMETER;
-			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
-			goto f_err;
-			}
-		}
-	s->s3->tmp.new_cipher=c;
-
-	/* lets get the compression algorithm */
-	/* COMPRESSION */
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_SRVR_HELLO_A,
+                SSL3_ST_CR_SRVR_HELLO_B,
+                -1,
+                20000, /* ?? */
+                &ok);
+
+        if (!ok) return((int)n);
+
+        if ( SSL_version(s) == DTLS1_VERSION)
+                {
+                if ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)
+                        {
+                        if ( s->d1->send_cookie == 0)
+                                {
+                                s->s3->tmp.reuse_message = 1;
+                                return 1;
+                                }
+                        else /* already sent a cookie */
+                                {
+                                al=SSL_AD_UNEXPECTED_MESSAGE;
+                                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
+                                goto f_err;
+                                }
+                        }
+                }
+
+        if ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)
+                {
+                al=SSL_AD_UNEXPECTED_MESSAGE;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
+                goto f_err;
+                }
+
+        d=p=(unsigned char *)s->init_msg;
+
+        if ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))
+                {
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);
+                s->version=(s->version&0xff00)|p[1];
+                al=SSL_AD_PROTOCOL_VERSION;
+                goto f_err;
+                }
+        p+=2;
+
+        /* load the server hello data */
+        /* load the server random */
+        memcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);
+        p+=SSL3_RANDOM_SIZE;
+
+        /* get the session-id */
+        j= *(p++);
+
+        if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))
+                {
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);
+                goto f_err;
+                }
+
+        if (j != 0 && j == s->session->session_id_length
+            && memcmp(p,s->session->session_id,j) == 0)
+            {
+            if(s->sid_ctx_length != s->session->sid_ctx_length
+               || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))
+                {
+                /* actually a client application bug */
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
+                goto f_err;
+                }
+            s->hit=1;
+            }
+        else        /* a miss or crap from the other end */
+                {
+                /* If we were trying for session-id reuse, make a new
+                 * SSL_SESSION so we don't stuff up other people */
+                s->hit=0;
+                if (s->session->session_id_length > 0)
+                        {
+                        if (!ssl_get_new_session(s,0))
+                                {
+                                al=SSL_AD_INTERNAL_ERROR;
+                                goto f_err;
+                                }
+                        }
+                s->session->session_id_length=j;
+                memcpy(s->session->session_id,p,j); /* j could be 0 */
+                }
+        p+=j;
+        c=ssl_get_cipher_by_char(s,p);
+        if (c == NULL)
+                {
+                /* unknown cipher */
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);
+                goto f_err;
+                }
+        p+=ssl_put_cipher_by_char(s,NULL,NULL);
+
+        sk=ssl_get_ciphers_by_id(s);
+        i=sk_SSL_CIPHER_find(sk,c);
+        if (i < 0)
+                {
+                /* we did not say we would use this cipher */
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
+                goto f_err;
+                }
+
+        /* Depending on the session caching (internal/external), the cipher
+           and/or cipher_id values may not be set. Make sure that
+           cipher_id is set and use it for comparison. */
+        if (s->session->cipher)
+                s->session->cipher_id = s->session->cipher->id;
+        if (s->hit && (s->session->cipher_id != c->id))
+                {
+                if (!(s->options &
+                        SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
+                        {
+                        al=SSL_AD_ILLEGAL_PARAMETER;
+                        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
+                        goto f_err;
+                        }
+                }
+        s->s3->tmp.new_cipher=c;
+#ifdef CAVIUM_SSL
+        s->cipher_support = find_cipher(s, c->id);
+#if defined(RECORD_PROCESS_OFFLOAD) && !defined(HANDSHAKE_OFFLOAD)
+        if(s->cipher_support)
+        {
+                s->record_process = 1;
+                s->cipher_support = 0;
+        }
+#endif
+#endif
+        /* lets get the compression algorithm */
+        /* COMPRESSION */
 #ifdef OPENSSL_NO_COMP
-	if (*(p++) != 0)
-		{
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
-		goto f_err;
-		}
-#else
-	j= *(p++);
-	if (j == 0)
-		comp=NULL;
-	else
-		comp=ssl3_comp_find(s->ctx->comp_methods,j);
-	
-	if ((j != 0) && (comp == NULL))
-		{
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
-		goto f_err;
-		}
-	else
-		{
-		s->s3->tmp.new_compression=comp;
-		}
+        if (*(p++) != 0)
+                {
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+                goto f_err;
+                }
+#else
+        j= *(p++);
+        if (j == 0)
+                comp=NULL;
+        else
+                comp=ssl3_comp_find(s->ctx->comp_methods,j);
+
+        if ((j != 0) && (comp == NULL))
+                {
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+                goto f_err;
+                }
+        else
+                {
+                s->s3->tmp.new_compression=comp;
+                }
 #endif
 #ifndef OPENSSL_NO_TLSEXT
-	/* TLS extensions*/
-	if (s->version > SSL3_VERSION)
-		{
-		if (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))
-			{
-			/* 'al' set by ssl_parse_serverhello_tlsext */
-			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);
-			goto f_err; 
-			}
-		if (ssl_check_serverhello_tlsext(s) <= 0)
-			{
-			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
-				goto err;
-			}
-		}
+        /* TLS extensions*/
+        if (s->version > SSL3_VERSION)
+                {
+                if (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))
+                        {
+                        /* 'al' set by ssl_parse_serverhello_tlsext */
+                        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);
+                        goto f_err;
+                        }
+                if (ssl_check_serverhello_tlsext(s) <= 0)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
+                                goto err;
+                        }
+                }
 #endif
 
 
-	if (p != (d+n))
-		{
-		/* wrong packet length */
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);
-		goto err;
-		}
+        if (p != (d+n))
+                {
+                /* wrong packet length */
+                al=SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);
+                goto err;
+                }
 
-	return(1);
+        return(1);
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
-	return(-1);
-	}
+        return(-1);
+        }
 
 int ssl3_get_server_certificate(SSL *s)
-	{
-	int al,i,ok,ret= -1;
-	unsigned long n,nc,llen,l;
-	X509 *x=NULL;
-	const unsigned char *q,*p;
-	unsigned char *d;
-	STACK_OF(X509) *sk=NULL;
-	SESS_CERT *sc;
-	EVP_PKEY *pkey=NULL;
-	int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_CERT_A,
-		SSL3_ST_CR_CERT_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-
-	if (!ok) return((int)n);
-
-	if ((s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) ||
-		((s->s3->tmp.new_cipher->algorithms & SSL_aKRB5) && 
-		(s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)))
-		{
-		s->s3->tmp.reuse_message=1;
-		return(1);
-		}
-
-	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
-		{
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_BAD_MESSAGE_TYPE);
-		goto f_err;
-		}
-	p=d=(unsigned char *)s->init_msg;
-
-	if ((sk=sk_X509_new_null()) == NULL)
-		{
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-
-	n2l3(p,llen);
-	if (llen+3 != n)
-		{
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	for (nc=0; nc<llen; )
-		{
-		n2l3(p,l);
-		if ((l+nc+3) > llen)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
-			goto f_err;
-			}
-
-		q=p;
-		x=d2i_X509(NULL,&q,l);
-		if (x == NULL)
-			{
-			al=SSL_AD_BAD_CERTIFICATE;
-			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_ASN1_LIB);
-			goto f_err;
-			}
-		if (q != (p+l))
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
-			goto f_err;
-			}
-		if (!sk_X509_push(sk,x))
-			{
-			SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		x=NULL;
-		nc+=l+3;
-		p=q;
-		}
+        {
+        int al,i,ok,ret= -1;
+        unsigned long n,nc,llen,l;
+        X509 *x=NULL;
+        const unsigned char *q,*p;
+        unsigned char *d;
+        STACK_OF(X509) *sk=NULL;
+        SESS_CERT *sc;
+        EVP_PKEY *pkey=NULL;
+        int need_cert = 1; /* VRS: 0=> will allow null cert if auth == KRB5 */
+
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_CERT_A,
+                SSL3_ST_CR_CERT_B,
+                -1,
+                s->max_cert_list,
+                &ok);
+
+        if (!ok) return((int)n);
+
+        if ((s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE) ||
+                ((s->s3->tmp.new_cipher->algorithms & SSL_aKRB5) &&
+                (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)))
+                {
+                s->s3->tmp.reuse_message=1;
+                return(1);
+                }
+
+        if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
+                {
+                al=SSL_AD_UNEXPECTED_MESSAGE;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_BAD_MESSAGE_TYPE);
+                goto f_err;
+                }
+        p=d=(unsigned char *)s->init_msg;
+
+        if ((sk=sk_X509_new_null()) == NULL)
+                {
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+
+        n2l3(p,llen);
+        if (llen+3 != n)
+                {
+                al=SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
+                goto f_err;
+                }
+        for (nc=0; nc<llen; )
+                {
+                n2l3(p,l);
+                if ((l+nc+3) > llen)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
+                        goto f_err;
+                        }
+
+                q=p;
+                x=d2i_X509(NULL,&q,l);
+                if (x == NULL)
+                        {
+                        al=SSL_AD_BAD_CERTIFICATE;
+                        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_ASN1_LIB);
+                        goto f_err;
+                        }
+                if (q != (p+l))
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
+                        goto f_err;
+                        }
+                if (!sk_X509_push(sk,x))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);
+                        goto err;
+                        }
+                x=NULL;
+                nc+=l+3;
+                p=q;
+                }
 
-	i=ssl_verify_cert_chain(s,sk);
-	if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
+        i=ssl_verify_cert_chain(s,sk);
+        if ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0)
 #ifndef OPENSSL_NO_KRB5
-	        && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
-	        != (SSL_aKRB5|SSL_kKRB5)
+                && (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))
+                != (SSL_aKRB5|SSL_kKRB5)
 #endif /* OPENSSL_NO_KRB5 */
-	        )
-		{
-		al=ssl_verify_alarm_type(s->verify_result);
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);
-		goto f_err; 
-		}
-	ERR_clear_error(); /* but we keep s->verify_result */
-
-	sc=ssl_sess_cert_new();
-	if (sc == NULL) goto err;
-
-	if (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);
-	s->session->sess_cert=sc;
-
-	sc->cert_chain=sk;
-	/* Inconsistency alert: cert_chain does include the peer's
-	 * certificate, which we don't include in s3_srvr.c */
-	x=sk_X509_value(sk,0);
-	sk=NULL;
- 	/* VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end*/
-
-	pkey=X509_get_pubkey(x);
-
-	/* VRS: allow null cert if auth == KRB5 */
-	need_cert =	((s->s3->tmp.new_cipher->algorithms
-	                 & (SSL_MKEY_MASK|SSL_AUTH_MASK))
-	                 == (SSL_aKRB5|SSL_kKRB5))? 0: 1;
+                )
+                {
+                al=ssl_verify_alarm_type(s->verify_result);
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);
+                goto f_err;
+                }
+        ERR_clear_error(); /* but we keep s->verify_result */
+
+        sc=ssl_sess_cert_new();
+        if (sc == NULL) goto err;
+
+        if (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);
+        s->session->sess_cert=sc;
+
+        sc->cert_chain=sk;
+        /* Inconsistency alert: cert_chain does include the peer's
+         * certificate, which we don't include in s3_srvr.c */
+        x=sk_X509_value(sk,0);
+        sk=NULL;
+         /* VRS 19990621: possible memory leak; sk=null ==> !sk_pop_free() @end*/
+
+        pkey=X509_get_pubkey(x);
+
+        /* VRS: allow null cert if auth == KRB5 */
+        need_cert =        ((s->s3->tmp.new_cipher->algorithms
+                         & (SSL_MKEY_MASK|SSL_AUTH_MASK))
+                         == (SSL_aKRB5|SSL_kKRB5))? 0: 1;
 
 #ifdef KSSL_DEBUG
-	printf("pkey,x = %p, %p\n", (void *)pkey,(void *)x);
-	printf("ssl_cert_type(x,pkey) = %d\n", ssl_cert_type(x,pkey));
-	printf("cipher, alg, nc = %s, %lx, %d\n", s->s3->tmp.new_cipher->name,
-	        s->s3->tmp.new_cipher->algorithms, need_cert);
+        printf("pkey,x = %p, %p\n", (void *)pkey,(void *)x);
+        printf("ssl_cert_type(x,pkey) = %d\n", ssl_cert_type(x,pkey));
+        printf("cipher, alg, nc = %s, %lx, %d\n", s->s3->tmp.new_cipher->name,
+                s->s3->tmp.new_cipher->algorithms, need_cert);
 #endif    /* KSSL_DEBUG */
 
-	if (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey)))
-		{
-		x=NULL;
-		al=SSL3_AL_FATAL;
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
-			SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
-		goto f_err;
-		}
-
-	i=ssl_cert_type(x,pkey);
-	if (need_cert && i < 0)
-		{
-		x=NULL;
-		al=SSL3_AL_FATAL;
-		SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
-			SSL_R_UNKNOWN_CERTIFICATE_TYPE);
-		goto f_err;
-		}
-
-	if (need_cert)
-		{
-		sc->peer_cert_type=i;
-		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
-		/* Why would the following ever happen?
-		 * We just created sc a couple of lines ago. */
-		if (sc->peer_pkeys[i].x509 != NULL)
-			X509_free(sc->peer_pkeys[i].x509);
-		sc->peer_pkeys[i].x509=x;
-		sc->peer_key= &(sc->peer_pkeys[i]);
-
-		if (s->session->peer != NULL)
-			X509_free(s->session->peer);
-		CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
-		s->session->peer=x;
-		}
-	else
-		{
-		sc->peer_cert_type=i;
-		sc->peer_key= NULL;
-
-		if (s->session->peer != NULL)
-			X509_free(s->session->peer);
-		s->session->peer=NULL;
-		}
-	s->session->verify_result = s->verify_result;
+        if (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey)))
+                {
+                x=NULL;
+                al=SSL3_AL_FATAL;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                        SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);
+                goto f_err;
+                }
+
+        i=ssl_cert_type(x,pkey);
+        if (need_cert && i < 0)
+                {
+                x=NULL;
+                al=SSL3_AL_FATAL;
+                SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,
+                        SSL_R_UNKNOWN_CERTIFICATE_TYPE);
+                goto f_err;
+                }
+
+        if (need_cert)
+                {
+                sc->peer_cert_type=i;
+                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
+                /* Why would the following ever happen?
+                 * We just created sc a couple of lines ago. */
+                if (sc->peer_pkeys[i].x509 != NULL)
+                        X509_free(sc->peer_pkeys[i].x509);
+                sc->peer_pkeys[i].x509=x;
+                sc->peer_key= &(sc->peer_pkeys[i]);
+
+                if (s->session->peer != NULL)
+                        X509_free(s->session->peer);
+                CRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);
+                s->session->peer=x;
+                }
+        else
+                {
+                sc->peer_cert_type=i;
+                sc->peer_key= NULL;
+
+                if (s->session->peer != NULL)
+                        X509_free(s->session->peer);
+                s->session->peer=NULL;
+                }
+        s->session->verify_result = s->verify_result;
 
-	x=NULL;
-	ret=1;
+        x=NULL;
+        ret=1;
 
-	if (0)
-		{
+        if (0)
+                {
 f_err:
-		ssl3_send_alert(s,SSL3_AL_FATAL,al);
-		}
+                ssl3_send_alert(s,SSL3_AL_FATAL,al);
+                }
 err:
-	EVP_PKEY_free(pkey);
-	X509_free(x);
-	sk_X509_pop_free(sk,X509_free);
-	return(ret);
-	}
+        EVP_PKEY_free(pkey);
+        X509_free(x);
+        sk_X509_pop_free(sk,X509_free);
+        return(ret);
+        }
 
 int ssl3_get_key_exchange(SSL *s)
-	{
+        {
 #ifndef OPENSSL_NO_RSA
-	unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
+#ifdef CAVIUM_SSL
+        unsigned char *q,md_buf[EVP_MAX_MD_SIZE*4];
+#else
+        unsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];
 #endif
-	EVP_MD_CTX md_ctx;
-	unsigned char *param,*p;
-	int al,i,j,param_len,ok;
-	long n,alg;
-	EVP_PKEY *pkey=NULL;
+#endif
+        EVP_MD_CTX md_ctx;
+        unsigned char *param,*p;
+        int al,i,j,param_len,ok;
+        long n,alg;
+        EVP_PKEY *pkey=NULL;
 #ifndef OPENSSL_NO_RSA
-	RSA *rsa=NULL;
+        RSA *rsa=NULL;
 #endif
 #ifndef OPENSSL_NO_DH
-	DH *dh=NULL;
+        DH *dh=NULL;
 #endif
 #ifndef OPENSSL_NO_ECDH
-	EC_KEY *ecdh = NULL;
-	BN_CTX *bn_ctx = NULL;
-	EC_POINT *srvr_ecpoint = NULL;
-	int curve_nid = 0;
-	int encoded_pt_len = 0;
-#endif
-
-	/* use same message size as in ssl3_get_certificate_request()
-	 * as ServerKeyExchange message may be skipped */
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_KEY_EXCH_A,
-		SSL3_ST_CR_KEY_EXCH_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-
-	if (!ok) return((int)n);
-
-	if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
-		{
-		s->s3->tmp.reuse_message=1;
-		return(1);
-		}
+        EC_KEY *ecdh = NULL;
+        BN_CTX *bn_ctx = NULL;
+        EC_POINT *srvr_ecpoint = NULL;
+        int curve_nid = 0;
+        int encoded_pt_len = 0;
+#endif
+#ifdef CAVIUM_SSL
+    /*relocate the call. This only sets the fields of md_ctx to 0*/
+        EVP_MD_CTX_init(&md_ctx);
+#ifndef CAVIUM_FIPS
+        if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY)
+                        goto vrfy_cav;
+#endif
+#endif
 
-	param=p=(unsigned char *)s->init_msg;
+        /* use same message size as in ssl3_get_certificate_request()
+         * as ServerKeyExchange message may be skipped */
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_KEY_EXCH_A,
+                SSL3_ST_CR_KEY_EXCH_B,
+                -1,
+                s->max_cert_list,
+                &ok);
+
+        if (!ok) return((int)n);
+
+        if (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)
+                {
+                s->s3->tmp.reuse_message=1;
+                return(1);
+                }
 
-	if (s->session->sess_cert != NULL)
-		{
+        param=p=(unsigned char *)s->init_msg;
+
+        if (s->session->sess_cert != NULL)
+                {
 #ifndef OPENSSL_NO_RSA
-		if (s->session->sess_cert->peer_rsa_tmp != NULL)
-			{
-			RSA_free(s->session->sess_cert->peer_rsa_tmp);
-			s->session->sess_cert->peer_rsa_tmp=NULL;
-			}
+                if (s->session->sess_cert->peer_rsa_tmp != NULL)
+                        {
+                        RSA_free(s->session->sess_cert->peer_rsa_tmp);
+                        s->session->sess_cert->peer_rsa_tmp=NULL;
+                        }
 #endif
 #ifndef OPENSSL_NO_DH
-		if (s->session->sess_cert->peer_dh_tmp)
-			{
-			DH_free(s->session->sess_cert->peer_dh_tmp);
-			s->session->sess_cert->peer_dh_tmp=NULL;
-			}
+                if (s->session->sess_cert->peer_dh_tmp)
+                        {
+                        DH_free(s->session->sess_cert->peer_dh_tmp);
+                        s->session->sess_cert->peer_dh_tmp=NULL;
+                        }
 #endif
 #ifndef OPENSSL_NO_ECDH
-		if (s->session->sess_cert->peer_ecdh_tmp)
-			{
-			EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
-			s->session->sess_cert->peer_ecdh_tmp=NULL;
-			}
-#endif
-		}
-	else
-		{
-		s->session->sess_cert=ssl_sess_cert_new();
-		}
-
-	param_len=0;
-	alg=s->s3->tmp.new_cipher->algorithms;
-	EVP_MD_CTX_init(&md_ctx);
+                if (s->session->sess_cert->peer_ecdh_tmp)
+                        {
+                        EC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);
+                        s->session->sess_cert->peer_ecdh_tmp=NULL;
+                        }
+#endif
+                }
+        else
+                {
+                s->session->sess_cert=ssl_sess_cert_new();
+                }
+
+        param_len=0;
+        alg=s->s3->tmp.new_cipher->algorithms;
+#ifndef CAVIUM_SSL
+        EVP_MD_CTX_init(&md_ctx);
+#endif
 
 #ifndef OPENSSL_NO_RSA
-	if (alg & SSL_kRSA)
-		{
-		if ((rsa=RSA_new()) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		n2s(p,i);
-		param_len=i+2;
-		if (param_len > n)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
-			goto f_err;
-			}
-		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
-		p+=i;
-
-		n2s(p,i);
-		param_len+=i+2;
-		if (param_len > n)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
-			goto f_err;
-			}
-		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
-		p+=i;
-		n-=param_len;
-
-		/* this should be because we are using an export cipher */
-		if (alg & SSL_aRSA)
-			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
-		else
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		s->session->sess_cert->peer_rsa_tmp=rsa;
-		rsa=NULL;
-		}
+        if (alg & SSL_kRSA)
+                {
+                if ((rsa=RSA_new()) == NULL)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                        goto err;
+                        }
+                n2s(p,i);
+                param_len=i+2;
+                if (param_len > n)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
+                        goto f_err;
+                        }
+                if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
+                        goto err;
+                        }
+                p+=i;
+
+                n2s(p,i);
+                param_len+=i+2;
+                if (param_len > n)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
+                        goto f_err;
+                        }
+                if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
+                        goto err;
+                        }
+                p+=i;
+                n-=param_len;
+
+                /* this should be because we are using an export cipher */
+                if (alg & SSL_aRSA)
+                        pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+                else
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+                s->session->sess_cert->peer_rsa_tmp=rsa;
+                rsa=NULL;
+                }
 #else /* OPENSSL_NO_RSA */
-	if (0)
-		;
+        if (0)
+                ;
 #endif
 #ifndef OPENSSL_NO_DH
-	else if (alg & SSL_kEDH)
-		{
-		if ((dh=DH_new()) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
-			goto err;
-			}
-		n2s(p,i);
-		param_len=i+2;
-		if (param_len > n)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
-			goto f_err;
-			}
-		if (!(dh->p=BN_bin2bn(p,i,NULL)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
-		p+=i;
-
-		n2s(p,i);
-		param_len+=i+2;
-		if (param_len > n)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
-			goto f_err;
-			}
-		if (!(dh->g=BN_bin2bn(p,i,NULL)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
-		p+=i;
-
-		n2s(p,i);
-		param_len+=i+2;
-		if (param_len > n)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
-			goto f_err;
-			}
-		if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
-		p+=i;
-		n-=param_len;
+        else if (alg & SSL_kEDH)
+                {
+                if ((dh=DH_new()) == NULL)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);
+                        goto err;
+                        }
+                n2s(p,i);
+                param_len=i+2;
+                if (param_len > n)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);
+                        goto f_err;
+                        }
+                if (!(dh->p=BN_bin2bn(p,i,NULL)))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
+                        goto err;
+                        }
+                p+=i;
+
+                n2s(p,i);
+                param_len+=i+2;
+                if (param_len > n)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);
+                        goto f_err;
+                        }
+                if (!(dh->g=BN_bin2bn(p,i,NULL)))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
+                        goto err;
+                        }
+                p+=i;
+
+                n2s(p,i);
+                param_len+=i+2;
+                if (param_len > n)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);
+                        goto f_err;
+                        }
+                if (!(dh->pub_key=BN_bin2bn(p,i,NULL)))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
+                        goto err;
+                        }
+                p+=i;
+                n-=param_len;
 
 #ifndef OPENSSL_NO_RSA
-		if (alg & SSL_aRSA)
-			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+                if (alg & SSL_aRSA)
+                        pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
 #else
-		if (0)
-			;
+                if (0)
+                        ;
 #endif
 #ifndef OPENSSL_NO_DSA
-		else if (alg & SSL_aDSS)
-			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
+                else if (alg & SSL_aDSS)
+                        pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);
 #endif
-		/* else anonymous DH, so no certificate or pkey. */
+                /* else anonymous DH, so no certificate or pkey. */
 
-		s->session->sess_cert->peer_dh_tmp=dh;
-		dh=NULL;
-		}
-	else if ((alg & SSL_kDHr) || (alg & SSL_kDHd))
-		{
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
-		goto f_err;
-		}
+                s->session->sess_cert->peer_dh_tmp=dh;
+                dh=NULL;
+                }
+        else if ((alg & SSL_kDHr) || (alg & SSL_kDHd))
+                {
+                al=SSL_AD_ILLEGAL_PARAMETER;
+                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
+                goto f_err;
+                }
 #endif /* !OPENSSL_NO_DH */
 
 #ifndef OPENSSL_NO_ECDH
-	else if (alg & SSL_kECDHE)
-		{
-		EC_GROUP *ngroup;
-		const EC_GROUP *group;
-
-		if ((ecdh=EC_KEY_new()) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-
-		/* Extract elliptic curve parameters and the
-		 * server's ephemeral ECDH public key.
-		 * Keep accumulating lengths of various components in
-		 * param_len and make sure it never exceeds n.
-		 */
-
-		/* XXX: For now we only support named (not generic) curves
-		 * and the ECParameters in this case is just three bytes.
-		 */
-		param_len=3;
-		if ((param_len > n) ||
-		    (*p != NAMED_CURVE_TYPE) || 
-		    ((curve_nid = curve_id2nid(*(p + 2))) == 0)) 
-			{
-			al=SSL_AD_INTERNAL_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
-			goto f_err;
-			}
-
-		ngroup = EC_GROUP_new_by_curve_name(curve_nid);
-		if (ngroup == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
-			goto err;
-			}
-		if (EC_KEY_set_group(ecdh, ngroup) == 0)
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
-			goto err;
-			}
-		EC_GROUP_free(ngroup);
-
-		group = EC_KEY_get0_group(ecdh);
-
-		if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
-		    (EC_GROUP_get_degree(group) > 163))
-			{
-			al=SSL_AD_EXPORT_RESTRICTION;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
-			goto f_err;
-			}
-
-		p+=3;
-
-		/* Next, get the encoded ECPoint */
-		if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
-		    ((bn_ctx = BN_CTX_new()) == NULL))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-
-		encoded_pt_len = *p;  /* length of encoded point */
-		p+=1;
-		param_len += (1 + encoded_pt_len);
-		if ((param_len > n) ||
-		    (EC_POINT_oct2point(group, srvr_ecpoint, 
-			p, encoded_pt_len, bn_ctx) == 0))
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
-			goto f_err;
-			}
-
-		n-=param_len;
-		p+=encoded_pt_len;
-
-		/* The ECC/TLS specification does not mention
-		 * the use of DSA to sign ECParameters in the server
-		 * key exchange message. We do support RSA and ECDSA.
-		 */
-		if (0) ;
+        else if (alg & SSL_kECDHE)
+                {
+                EC_GROUP *ngroup;
+                const EC_GROUP *group;
+
+                if ((ecdh=EC_KEY_new()) == NULL)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                        goto err;
+                        }
+
+                /* Extract elliptic curve parameters and the
+                 * server's ephemeral ECDH public key.
+                 * Keep accumulating lengths of various components in
+                 * param_len and make sure it never exceeds n.
+                 */
+
+                /* XXX: For now we only support named (not generic) curves
+                 * and the ECParameters in this case is just three bytes.
+                 */
+                param_len=3;
+                if ((param_len > n) ||
+                    (*p != NAMED_CURVE_TYPE) ||
+                    ((curve_nid = curve_id2nid(*(p + 2))) == 0))
+                        {
+                        al=SSL_AD_INTERNAL_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);
+                        goto f_err;
+                        }
+
+                ngroup = EC_GROUP_new_by_curve_name(curve_nid);
+                if (ngroup == NULL)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
+                        goto err;
+                        }
+                if (EC_KEY_set_group(ecdh, ngroup) == 0)
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);
+                        goto err;
+                        }
+                EC_GROUP_free(ngroup);
+
+                group = EC_KEY_get0_group(ecdh);
+
+                if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
+                    (EC_GROUP_get_degree(group) > 163))
+                        {
+                        al=SSL_AD_EXPORT_RESTRICTION;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
+                        goto f_err;
+                        }
+
+                p+=3;
+
+                /* Next, get the encoded ECPoint */
+                if (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||
+                    ((bn_ctx = BN_CTX_new()) == NULL))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                        goto err;
+                        }
+
+                encoded_pt_len = *p;  /* length of encoded point */
+                p+=1;
+                param_len += (1 + encoded_pt_len);
+                if ((param_len > n) ||
+                    (EC_POINT_oct2point(group, srvr_ecpoint,
+                        p, encoded_pt_len, bn_ctx) == 0))
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);
+                        goto f_err;
+                        }
+
+                n-=param_len;
+                p+=encoded_pt_len;
+
+                /* The ECC/TLS specification does not mention
+                 * the use of DSA to sign ECParameters in the server
+                 * key exchange message. We do support RSA and ECDSA.
+                 */
+                if (0) ;
 #ifndef OPENSSL_NO_RSA
-		else if (alg & SSL_aRSA)
-			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+                else if (alg & SSL_aRSA)
+                        pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
 #endif
 #ifndef OPENSSL_NO_ECDSA
-		else if (alg & SSL_aECDSA)
-			pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
+                else if (alg & SSL_aECDSA)
+                        pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
 #endif
-		/* else anonymous ECDH, so no certificate or pkey. */
-		EC_KEY_set_public_key(ecdh, srvr_ecpoint);
-		s->session->sess_cert->peer_ecdh_tmp=ecdh;
-		ecdh=NULL;
-		BN_CTX_free(bn_ctx);
-		EC_POINT_free(srvr_ecpoint);
-		srvr_ecpoint = NULL;
-		}
-	else if (alg & SSL_kECDH)
-		{
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
-		goto f_err;
-		}
+                /* else anonymous ECDH, so no certificate or pkey. */
+                EC_KEY_set_public_key(ecdh, srvr_ecpoint);
+                s->session->sess_cert->peer_ecdh_tmp=ecdh;
+                ecdh=NULL;
+                BN_CTX_free(bn_ctx);
+                EC_POINT_free(srvr_ecpoint);
+                srvr_ecpoint = NULL;
+                }
+        else if (alg & SSL_kECDH)
+                {
+                al=SSL_AD_UNEXPECTED_MESSAGE;
+                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
+                goto f_err;
+                }
 #endif /* !OPENSSL_NO_ECDH */
-	if (alg & SSL_aFZA)
-		{
-		al=SSL_AD_HANDSHAKE_FAILURE;
-		SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
-		goto f_err;
-		}
-
-
-	/* p points to the next byte, there are 'n' bytes left */
-
-	/* if it was signed, check the signature */
-	if (pkey != NULL)
-		{
-		n2s(p,i);
-		n-=2;
-		j=EVP_PKEY_size(pkey);
-
-		if ((i != n) || (n > j) || (n <= 0))
-			{
-			/* wrong packet length */
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
-			goto f_err;
-			}
+        if (alg & SSL_aFZA)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);
+                goto f_err;
+                }
+
+
+        /* p points to the next byte, there are 'n' bytes left */
+
+        /* if it was signed, check the signature */
+        if (pkey != NULL)
+                {
+                n2s(p,i);
+                n-=2;
+                j=EVP_PKEY_size(pkey);
+
+                if ((i != n) || (n > j) || (n <= 0))
+                        {
+                        /* wrong packet length */
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);
+                        goto f_err;
+                        }
 
 #ifndef OPENSSL_NO_RSA
-		if (pkey->type == EVP_PKEY_RSA)
-			{
-			int num;
-
-			j=0;
-			q=md_buf;
-			for (num=2; num > 0; num--)
-				{
-				EVP_MD_CTX_set_flags(&md_ctx,
-					EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
-				EVP_DigestInit_ex(&md_ctx,(num == 2)
-					?s->ctx->md5:s->ctx->sha1, NULL);
-				EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-				EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-				EVP_DigestUpdate(&md_ctx,param,param_len);
-				EVP_DigestFinal_ex(&md_ctx,q,(unsigned int *)&i);
-				q+=i;
-				j+=i;
-				}
-			i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
-								pkey->pkey.rsa);
-			if (i < 0)
-				{
-				al=SSL_AD_DECRYPT_ERROR;
-				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
-				goto f_err;
-				}
-			if (i == 0)
-				{
-				/* bad signature */
-				al=SSL_AD_DECRYPT_ERROR;
-				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
-				goto f_err;
-				}
-			}
-		else
+                if (pkey->type == EVP_PKEY_RSA)
+                        {
+                        int num;
+
+                        j=0;
+                        q=md_buf;
+                        for (num=2; num > 0; num--)
+                                {
+                                EVP_MD_CTX_set_flags(&md_ctx,
+                                        EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
+                                EVP_DigestInit_ex(&md_ctx,(num == 2)
+                                        ?s->ctx->md5:s->ctx->sha1, NULL);
+                                EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                                EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                                EVP_DigestUpdate(&md_ctx,param,param_len);
+                                EVP_DigestFinal_ex(&md_ctx,q,(unsigned int *)&i);
+                                q+=i;
+                                j+=i;
+                                }
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+            if (s->cipher_support){
+                s->pkey = pkey ;
+                s->j_clnt = j ;
+                s->p_vrfy_cert = p ;
+                s->n_clnt  = n ;
+                memcpy (s->md_buf, md_buf, sizeof(md_buf));
+
+vrfy_cav:
+               i=RSA_verify_cav(s,NID_md5_sha1, s->md_buf, s->j_clnt, s->p_vrfy_cert, s->n_clnt,s->pkey->pkey.rsa);
+
+               if (i == -EAGAIN ) {
+                   return 0;
+               }
+
+               pkey = s->pkey ;
+               j = s->j_clnt ;
+               p = s->p_vrfy_cert ;
+               n = s->n_clnt ;
+               memcpy ((void*)md_buf, (void*)s->md_buf, sizeof(s->md_buf));
+            }
+            else
+#endif
+                        i=RSA_verify(NID_md5_sha1, md_buf, j, p, n,
+                                                                pkey->pkey.rsa);
+                        if (i < 0)
+                                {
+                                al=SSL_AD_DECRYPT_ERROR;
+                                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);
+                                goto f_err;
+                                }
+                        if (i == 0)
+                                {
+                                /* bad signature */
+                                al=SSL_AD_DECRYPT_ERROR;
+                                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
+                                goto f_err;
+                                }
+                        }
+                else
 #endif
 #ifndef OPENSSL_NO_DSA
-			if (pkey->type == EVP_PKEY_DSA)
-			{
-			/* lets do DSS */
-			EVP_VerifyInit_ex(&md_ctx,EVP_dss1(), NULL);
-			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-			EVP_VerifyUpdate(&md_ctx,param,param_len);
-			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
-				{
-				/* bad signature */
-				al=SSL_AD_DECRYPT_ERROR;
-				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
-				goto f_err;
-				}
-			}
-		else
+                        if (pkey->type == EVP_PKEY_DSA)
+                        {
+                        /* lets do DSS */
+                        EVP_VerifyInit_ex(&md_ctx,EVP_dss1(), NULL);
+                        EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                        EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                        EVP_VerifyUpdate(&md_ctx,param,param_len);
+                        if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
+                                {
+                                /* bad signature */
+                                al=SSL_AD_DECRYPT_ERROR;
+                                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
+                                goto f_err;
+                                }
+                        }
+                else
 #endif
 #ifndef OPENSSL_NO_ECDSA
-			if (pkey->type == EVP_PKEY_EC)
-			{
-			/* let's do ECDSA */
-			EVP_VerifyInit_ex(&md_ctx,EVP_ecdsa(), NULL);
-			EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-			EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-			EVP_VerifyUpdate(&md_ctx,param,param_len);
-			if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
-				{
-				/* bad signature */
-				al=SSL_AD_DECRYPT_ERROR;
-				SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
-				goto f_err;
-				}
-			}
-		else
-#endif
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		}
-	else
-		{
-		/* still data left over */
-		if (!(alg & SSL_aNULL))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		if (n != 0)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
-			goto f_err;
-			}
-		}
-	EVP_PKEY_free(pkey);
-	EVP_MD_CTX_cleanup(&md_ctx);
-	return(1);
+                        if (pkey->type == EVP_PKEY_EC)
+                        {
+                        /* let's do ECDSA */
+                        EVP_VerifyInit_ex(&md_ctx,EVP_ecdsa(), NULL);
+                        EVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                        EVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                        EVP_VerifyUpdate(&md_ctx,param,param_len);
+                        if (EVP_VerifyFinal(&md_ctx,p,(int)n,pkey) <= 0)
+                                {
+                                /* bad signature */
+                                al=SSL_AD_DECRYPT_ERROR;
+                                SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);
+                                goto f_err;
+                                }
+                        }
+                else
+#endif
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+                }
+        else
+                {
+                /* still data left over */
+                if (!(alg & SSL_aNULL))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+                if (n != 0)
+                        {
+                        al=SSL_AD_DECODE_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);
+                        goto f_err;
+                        }
+                }
+        EVP_PKEY_free(pkey);
+        EVP_MD_CTX_cleanup(&md_ctx);
+        return(1);
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
-	EVP_PKEY_free(pkey);
+        EVP_PKEY_free(pkey);
 #ifndef OPENSSL_NO_RSA
-	if (rsa != NULL)
-		RSA_free(rsa);
+        if (rsa != NULL)
+                RSA_free(rsa);
 #endif
 #ifndef OPENSSL_NO_DH
-	if (dh != NULL)
-		DH_free(dh);
+        if (dh != NULL)
+                DH_free(dh);
 #endif
 #ifndef OPENSSL_NO_ECDH
-	BN_CTX_free(bn_ctx);
-	EC_POINT_free(srvr_ecpoint);
-	if (ecdh != NULL)
-		EC_KEY_free(ecdh);
-#endif
-	EVP_MD_CTX_cleanup(&md_ctx);
-	return(-1);
-	}
+        BN_CTX_free(bn_ctx);
+        EC_POINT_free(srvr_ecpoint);
+        if (ecdh != NULL)
+                EC_KEY_free(ecdh);
+#endif
+        EVP_MD_CTX_cleanup(&md_ctx);
+        return(-1);
+        }
 
 int ssl3_get_certificate_request(SSL *s)
-	{
-	int ok,ret=0;
-	unsigned long n,nc,l;
-	unsigned int llen,ctype_num,i;
-	X509_NAME *xn=NULL;
-	const unsigned char *p,*q;
-	unsigned char *d;
-	STACK_OF(X509_NAME) *ca_sk=NULL;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_CERT_REQ_A,
-		SSL3_ST_CR_CERT_REQ_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-
-	if (!ok) return((int)n);
-
-	s->s3->tmp.cert_req=0;
-
-	if (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)
-		{
-		s->s3->tmp.reuse_message=1;
-		return(1);
-		}
-
-	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST)
-		{
-		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
-		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_WRONG_MESSAGE_TYPE);
-		goto err;
-		}
-
-	/* TLS does not like anon-DH with client cert */
-	if (s->version > SSL3_VERSION)
-		{
-		l=s->s3->tmp.new_cipher->algorithms;
-		if (l & SSL_aNULL)
-			{
-			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
-			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
-			goto err;
-			}
-		}
-
-	p=d=(unsigned char *)s->init_msg;
-
-	if ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)
-		{
-		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-
-	/* get the certificate types */
-	ctype_num= *(p++);
-	if (ctype_num > SSL3_CT_NUMBER)
-		ctype_num=SSL3_CT_NUMBER;
-	for (i=0; i<ctype_num; i++)
-		s->s3->tmp.ctype[i]= p[i];
-	p+=ctype_num;
+        {
+        int ok,ret=0;
+        unsigned long n,nc,l;
+        unsigned int llen,ctype_num,i;
+        X509_NAME *xn=NULL;
+        const unsigned char *p,*q;
+        unsigned char *d;
+        STACK_OF(X509_NAME) *ca_sk=NULL;
+
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_CERT_REQ_A,
+                SSL3_ST_CR_CERT_REQ_B,
+                -1,
+                s->max_cert_list,
+                &ok);
+
+        if (!ok) return((int)n);
+
+        s->s3->tmp.cert_req=0;
+
+        if (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)
+                {
+                s->s3->tmp.reuse_message=1;
+                return(1);
+                }
+
+        if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST)
+                {
+                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
+                SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_WRONG_MESSAGE_TYPE);
+                goto err;
+                }
+
+        /* TLS does not like anon-DH with client cert */
+        if (s->version > SSL3_VERSION)
+                {
+                l=s->s3->tmp.new_cipher->algorithms;
+                if (l & SSL_aNULL)
+                        {
+                        ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
+                        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);
+                        goto err;
+                        }
+                }
+
+        p=d=(unsigned char *)s->init_msg;
+
+        if ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)
+                {
+                SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+
+        /* get the certificate types */
+        ctype_num= *(p++);
+        if (ctype_num > SSL3_CT_NUMBER)
+                ctype_num=SSL3_CT_NUMBER;
+        for (i=0; i<ctype_num; i++)
+                s->s3->tmp.ctype[i]= p[i];
+        p+=ctype_num;
 
-	/* get the CA RDNs */
-	n2s(p,llen);
+        /* get the CA RDNs */
+        n2s(p,llen);
 #if 0
 {
 FILE *out;
@@ -1605,1089 +1869,1370 @@
 }
 #endif
 
-	if ((llen+ctype_num+2+1) != n)
-		{
-		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
-		SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_LENGTH_MISMATCH);
-		goto err;
-		}
-
-	for (nc=0; nc<llen; )
-		{
-		n2s(p,l);
-		if ((l+nc+2) > llen)
-			{
-			if ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
-				goto cont; /* netscape bugs */
-			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
-			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_TOO_LONG);
-			goto err;
-			}
-
-		q=p;
-
-		if ((xn=d2i_X509_NAME(NULL,&q,l)) == NULL)
-			{
-			/* If netscape tolerance is on, ignore errors */
-			if (s->options & SSL_OP_NETSCAPE_CA_DN_BUG)
-				goto cont;
-			else
-				{
-				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
-				SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_ASN1_LIB);
-				goto err;
-				}
-			}
-
-		if (q != (p+l))
-			{
-			ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
-			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_LENGTH_MISMATCH);
-			goto err;
-			}
-		if (!sk_X509_NAME_push(ca_sk,xn))
-			{
-			SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-
-		p+=l;
-		nc+=l+2;
-		}
+        if ((llen+ctype_num+2+1) != n)
+                {
+                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
+                SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_LENGTH_MISMATCH);
+                goto err;
+                }
+
+        for (nc=0; nc<llen; )
+                {
+                n2s(p,l);
+                if ((l+nc+2) > llen)
+                        {
+                        if ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
+                                goto cont; /* netscape bugs */
+                        ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
+                        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_TOO_LONG);
+                        goto err;
+                        }
+
+                q=p;
+
+                if ((xn=d2i_X509_NAME(NULL,&q,l)) == NULL)
+                        {
+                        /* If netscape tolerance is on, ignore errors */
+                        if (s->options & SSL_OP_NETSCAPE_CA_DN_BUG)
+                                goto cont;
+                        else
+                                {
+                                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
+                                SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_ASN1_LIB);
+                                goto err;
+                                }
+                        }
+
+                if (q != (p+l))
+                        {
+                        ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
+                        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_LENGTH_MISMATCH);
+                        goto err;
+                        }
+                if (!sk_X509_NAME_push(ca_sk,xn))
+                        {
+                        SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);
+                        goto err;
+                        }
+
+                p+=l;
+                nc+=l+2;
+                }
 
-	if (0)
-		{
+        if (0)
+                {
 cont:
-		ERR_clear_error();
-		}
+                ERR_clear_error();
+                }
 
-	/* we should setup a certificate to return.... */
-	s->s3->tmp.cert_req=1;
-	s->s3->tmp.ctype_num=ctype_num;
-	if (s->s3->tmp.ca_names != NULL)
-		sk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);
-	s->s3->tmp.ca_names=ca_sk;
-	ca_sk=NULL;
+        /* we should setup a certificate to return.... */
+        s->s3->tmp.cert_req=1;
+        s->s3->tmp.ctype_num=ctype_num;
+        if (s->s3->tmp.ca_names != NULL)
+                sk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);
+        s->s3->tmp.ca_names=ca_sk;
+        ca_sk=NULL;
 
-	ret=1;
+        ret=1;
 err:
-	if (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);
-	return(ret);
-	}
+        if (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);
+        return(ret);
+        }
 
 static int ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
-	{
-	return(X509_NAME_cmp(*a,*b));
-	}
+        {
+        return(X509_NAME_cmp(*a,*b));
+        }
 #ifndef OPENSSL_NO_TLSEXT
 int ssl3_get_new_session_ticket(SSL *s)
-	{
-	int ok,al,ret=0, ticklen;
-	long n;
-	const unsigned char *p;
-	unsigned char *d;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_SESSION_TICKET_A,
-		SSL3_ST_CR_SESSION_TICKET_B,
-		-1,
-		16384,
-		&ok);
-
-	if (!ok)
-		return((int)n);
-
-	if (s->s3->tmp.message_type == SSL3_MT_FINISHED)
-		{
-		s->s3->tmp.reuse_message=1;
-		return(1);
-		}
-	if (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET)
-		{
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_BAD_MESSAGE_TYPE);
-		goto f_err;
-		}
-	if (n < 6)
-		{
-		/* need at least ticket_lifetime_hint + ticket length */
-		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	p=d=(unsigned char *)s->init_msg;
-	n2l(p, s->session->tlsext_tick_lifetime_hint);
-	n2s(p, ticklen);
-	/* ticket_lifetime_hint + ticket_length + ticket */
-	if (ticklen + 6 != n)
-		{
-		al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	if (s->session->tlsext_tick)
-		{
-		OPENSSL_free(s->session->tlsext_tick);
-		s->session->tlsext_ticklen = 0;
-		}
-	s->session->tlsext_tick = OPENSSL_malloc(ticklen);
-	if (!s->session->tlsext_tick)
-		{
-		SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-	memcpy(s->session->tlsext_tick, p, ticklen);
-	s->session->tlsext_ticklen = ticklen;
-	
-	ret=1;
-	return(ret);
+        {
+        int ok,al,ret=0, ticklen;
+        long n;
+        const unsigned char *p;
+        unsigned char *d;
+
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_SESSION_TICKET_A,
+                SSL3_ST_CR_SESSION_TICKET_B,
+                -1,
+                16384,
+                &ok);
+
+        if (!ok)
+                return((int)n);
+
+        if (s->s3->tmp.message_type == SSL3_MT_FINISHED)
+                {
+                s->s3->tmp.reuse_message=1;
+                return(1);
+                }
+        if (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET)
+                {
+                al=SSL_AD_UNEXPECTED_MESSAGE;
+                SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_BAD_MESSAGE_TYPE);
+                goto f_err;
+                }
+        if (n < 6)
+                {
+                /* need at least ticket_lifetime_hint + ticket length */
+                al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
+                goto f_err;
+                }
+        p=d=(unsigned char *)s->init_msg;
+        n2l(p, s->session->tlsext_tick_lifetime_hint);
+        n2s(p, ticklen);
+        /* ticket_lifetime_hint + ticket_length + ticket */
+        if (ticklen + 6 != n)
+                {
+                al = SSL3_AL_FATAL,SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);
+                goto f_err;
+                }
+        if (s->session->tlsext_tick)
+                {
+                OPENSSL_free(s->session->tlsext_tick);
+                s->session->tlsext_ticklen = 0;
+                }
+        s->session->tlsext_tick = OPENSSL_malloc(ticklen);
+        if (!s->session->tlsext_tick)
+                {
+                SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+        memcpy(s->session->tlsext_tick, p, ticklen);
+        s->session->tlsext_ticklen = ticklen;
+
+        ret=1;
+        return(ret);
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
-	return(-1);
-	}
+        return(-1);
+        }
 
 int ssl3_get_cert_status(SSL *s)
-	{
-	int ok, al;
-	unsigned long resplen;
-	long n;
-	const unsigned char *p;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_CERT_STATUS_A,
-		SSL3_ST_CR_CERT_STATUS_B,
-		SSL3_MT_CERTIFICATE_STATUS,
-		16384,
-		&ok);
-
-	if (!ok) return((int)n);
-	if (n < 4)
-		{
-		/* need at least status type + length */
-		al = SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	p = (unsigned char *)s->init_msg;
-	if (*p++ != TLSEXT_STATUSTYPE_ocsp)
-		{
-		al = SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_UNSUPPORTED_STATUS_TYPE);
-		goto f_err;
-		}
-	n2l3(p, resplen);
-	if (resplen + 4 != (unsigned long)n)
-		{
-		al = SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	if (s->tlsext_ocsp_resp)
-		OPENSSL_free(s->tlsext_ocsp_resp);
-	s->tlsext_ocsp_resp = BUF_memdup(p, resplen);
-	if (!s->tlsext_ocsp_resp)
-		{
-		al = SSL_AD_INTERNAL_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
-		goto f_err;
-		}
-	s->tlsext_ocsp_resplen = resplen;
-	if (s->ctx->tlsext_status_cb)
-		{
-		int ret;
-		ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
-		if (ret == 0)
-			{
-			al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
-			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_INVALID_STATUS_RESPONSE);
-			goto f_err;
-			}
-		if (ret < 0)
-			{
-			al = SSL_AD_INTERNAL_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
-			goto f_err;
-			}
-		}
-	return 1;
+        {
+        int ok, al;
+        unsigned long resplen;
+        long n;
+        const unsigned char *p;
+
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_CERT_STATUS_A,
+                SSL3_ST_CR_CERT_STATUS_B,
+                SSL3_MT_CERTIFICATE_STATUS,
+                16384,
+                &ok);
+
+        if (!ok) return((int)n);
+        if (n < 4)
+                {
+                /* need at least status type + length */
+                al = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
+                goto f_err;
+                }
+        p = (unsigned char *)s->init_msg;
+        if (*p++ != TLSEXT_STATUSTYPE_ocsp)
+                {
+                al = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_UNSUPPORTED_STATUS_TYPE);
+                goto f_err;
+                }
+        n2l3(p, resplen);
+        if (resplen + 4 != (unsigned long)n)
+                {
+                al = SSL_AD_DECODE_ERROR;
+                SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_LENGTH_MISMATCH);
+                goto f_err;
+                }
+        if (s->tlsext_ocsp_resp)
+                OPENSSL_free(s->tlsext_ocsp_resp);
+        s->tlsext_ocsp_resp = BUF_memdup(p, resplen);
+        if (!s->tlsext_ocsp_resp)
+                {
+                al = SSL_AD_INTERNAL_ERROR;
+                SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
+                goto f_err;
+                }
+        s->tlsext_ocsp_resplen = resplen;
+        if (s->ctx->tlsext_status_cb)
+                {
+                int ret;
+                ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);
+                if (ret == 0)
+                        {
+                        al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
+                        SSLerr(SSL_F_SSL3_GET_CERT_STATUS,SSL_R_INVALID_STATUS_RESPONSE);
+                        goto f_err;
+                        }
+                if (ret < 0)
+                        {
+                        al = SSL_AD_INTERNAL_ERROR;
+                        SSLerr(SSL_F_SSL3_GET_CERT_STATUS,ERR_R_MALLOC_FAILURE);
+                        goto f_err;
+                        }
+                }
+        return 1;
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
-	return(-1);
-	}
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        return(-1);
+        }
 #endif
 
 int ssl3_get_server_done(SSL *s)
-	{
-	int ok,ret=0;
-	long n;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_SRVR_DONE_A,
-		SSL3_ST_CR_SRVR_DONE_B,
-		SSL3_MT_SERVER_DONE,
-		30, /* should be very small, like 0 :-) */
-		&ok);
-
-	if (!ok) return((int)n);
-	if (n > 0)
-		{
-		/* should contain no data */
-		ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
-		SSLerr(SSL_F_SSL3_GET_SERVER_DONE,SSL_R_LENGTH_MISMATCH);
-		return -1;
-		}
-	ret=1;
-	return(ret);
-	}
+        {
+        int ok,ret=0;
+        long n;
+
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_SRVR_DONE_A,
+                SSL3_ST_CR_SRVR_DONE_B,
+                SSL3_MT_SERVER_DONE,
+                30, /* should be very small, like 0 :-) */
+                &ok);
+
+        if (!ok) return((int)n);
+        if (n > 0)
+                {
+                /* should contain no data */
+                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);
+                SSLerr(SSL_F_SSL3_GET_SERVER_DONE,SSL_R_LENGTH_MISMATCH);
+                return -1;
+                }
+        ret=1;
+        return(ret);
+        }
 
 
 int ssl3_send_client_key_exchange(SSL *s)
-	{
-	unsigned char *p,*d;
-	int n;
-	unsigned long l;
+        {
+        unsigned char *p,*d;
+        int n;
+        unsigned long l;
 #ifndef OPENSSL_NO_RSA
-	unsigned char *q;
-	EVP_PKEY *pkey=NULL;
+        unsigned char *q;
+        EVP_PKEY *pkey=NULL;
 #endif
 #ifndef OPENSSL_NO_KRB5
-	KSSL_ERR kssl_err;
+        KSSL_ERR kssl_err;
 #endif /* OPENSSL_NO_KRB5 */
 #ifndef OPENSSL_NO_ECDH
-	EC_KEY *clnt_ecdh = NULL;
-	const EC_POINT *srvr_ecpoint = NULL;
-	EVP_PKEY *srvr_pub_pkey = NULL;
-	unsigned char *encodedPoint = NULL;
-	int encoded_pt_len = 0;
-	BN_CTX * bn_ctx = NULL;
-#endif
-
-	if (s->state == SSL3_ST_CW_KEY_EXCH_A)
-		{
-		d=(unsigned char *)s->init_buf->data;
-		p= &(d[4]);
+        EC_KEY *clnt_ecdh = NULL;
+        const EC_POINT *srvr_ecpoint = NULL;
+        EVP_PKEY *srvr_pub_pkey = NULL;
+        unsigned char *encodedPoint = NULL;
+        int encoded_pt_len = 0;
+        BN_CTX * bn_ctx = NULL;
+#endif
+#if  defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+        int rc ;
+        if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY) {
+            goto pubenc_cav;
+        }
+    
+        else if (s->cav_crypto_state == CAV_ST_IN_WRITE_CONTEXT) {
+            s->state = s->cav_saved_state;
+            if ( s->cav_req_id_check_done ) {
+                rc = 0;
+            }
+            else {
+                    // should check for cmd completion here
+#ifdef CAVIUM_MULTICARD_API
+               rc = Csp1CheckForCompletion(s->cav_req_id,s->dev_id);
+#else
+               rc = Csp1CheckForCompletion(s->cav_req_id);
+#endif
+            }
+        switch(rc) {
+            case EAGAIN:
+                return(0);
+            case 0:
+                s->cav_crypto_state = 0;
+                s->cav_req_id_check_done = 1;
+                s->rwstate = SSL_NOTHING;
+                goto exchng_cav;
+                //break;
+            default:
+                s->cav_crypto_state = 0;
+                s->cav_req_id_check_done = 1;
+                s->rwstate = SSL_NOTHING;
+                return(-1);
+            } // end switch
+        }
+#endif
+
+        if (s->state == SSL3_ST_CW_KEY_EXCH_A)
+                {
+                d=(unsigned char *)s->init_buf->data;
+                p= &(d[4]);
 
-		l=s->s3->tmp.new_cipher->algorithms;
+                l=s->s3->tmp.new_cipher->algorithms;
 
-		/* Fool emacs indentation */
-		if (0) {}
+                /* Fool emacs indentation */
+                if (0) {}
 #ifndef OPENSSL_NO_RSA
-		else if (l & SSL_kRSA)
-			{
-			RSA *rsa;
-			unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
-
-			if (s->session->sess_cert->peer_rsa_tmp != NULL)
-				rsa=s->session->sess_cert->peer_rsa_tmp;
-			else
-				{
-				pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
-				if ((pkey == NULL) ||
-					(pkey->type != EVP_PKEY_RSA) ||
-					(pkey->pkey.rsa == NULL))
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
-					goto err;
-					}
-				rsa=pkey->pkey.rsa;
-				EVP_PKEY_free(pkey);
-				}
-				
-			tmp_buf[0]=s->client_version>>8;
-			tmp_buf[1]=s->client_version&0xff;
-			if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
-					goto err;
-
-			s->session->master_key_length=sizeof tmp_buf;
-
-			q=p;
-			/* Fix buf for TLS and beyond */
-			if (s->version > SSL3_VERSION)
-				p+=2;
-			n=RSA_public_encrypt(sizeof tmp_buf,
-				tmp_buf,p,rsa,RSA_PKCS1_PADDING);
-#ifdef PKCS1_CHECK
-			if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;
-			if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;
+                else if (l & SSL_kRSA)
+                        {
+                        RSA *rsa;
+                        unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
+
+                        if (s->session->sess_cert->peer_rsa_tmp != NULL)
+                                rsa=s->session->sess_cert->peer_rsa_tmp;
+                        else
+                                {
+                                pkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);
+                                if ((pkey == NULL) ||
+                                        (pkey->type != EVP_PKEY_RSA) ||
+                                        (pkey->pkey.rsa == NULL))
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);
+                                        goto err;
+                                        }
+                                rsa=pkey->pkey.rsa;
+                                EVP_PKEY_free(pkey);
+                                }
+
+                        tmp_buf[0]=s->client_version>>8;
+                        tmp_buf[1]=s->client_version&0xff;
+#if defined(CAVIUM_SSL) && defined(CAVIUM_FIPS)
+                        if ((s->cav_renego > 0)  && (s->s3->tmp.cert_req == 1)) 
+                        {  
+                          Cfm1AllocContext(CONTEXT_SSL, 
+                                         &s->s3->tmp.ctx_ptr, NULL);
+                         if(Cfm1GeneratePremasterSecret(s->s3->tmp.ctx_ptr+128,
+                                          s->client_version>>8,
+                                          s->client_version & 0xff, 
+                                          tmp_buf)) 
+                         {
+                             goto err;
+                         }
+                        }
+                        else {
+                         if (Cfm1GeneratePremasterSecret(s->context_pointer+128,
+                                          s->client_version>>8,
+                                          s->client_version & 0xff,
+                                          tmp_buf))
+                         {
+                             goto err;
+                         }
+                        }
+                        s->session->master_key_length=sizeof tmp_buf;
+                        q = p ;
+                        /* Fix buf for TLS and beyond */
+                        if (s->version > SSL3_VERSION)
+                                p+=2;
+                        n=RSA_public_encrypt(sizeof tmp_buf, tmp_buf,
+                                              p,rsa,RSA_PKCS1_PADDING);
+#else
+                        if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
+                                goto err;
+#endif
+                        s->session->master_key_length=sizeof tmp_buf;
+#ifdef CAVIUM_SSL
+                       if(s->cipher_support)
+                       {
+                           s->p_vrfy_cert = p ;
+                           s->rsa = rsa ;
+                           s->d_vrfy_cert = d ;
+                           memcpy (s->tmp_buf , tmp_buf, sizeof tmp_buf);
+                           if ((s->cav_renego > 0)  && (s->s3->tmp.cert_req == 1))
+                           {
+#ifdef CAVIUM_MULTICARD_API
+                             Csp1AllocContext(CONTEXT_SSL, &s->s3->tmp.ctx_ptr,s->dev_id);
+#else
+                             Csp1AllocContext(CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+
+                     /* just store pre-master secret to context memory */
+                            rc= Csp1WriteContext(s->cav_nb_mode,
+                                   s->s3->tmp.ctx_ptr+128, 
+                                   SSL_MAX_MASTER_KEY_LENGTH, 
+                                   s->tmp_buf,
+#ifdef CAVIUM_MULTICARD_API
+                                   &s->cav_req_id,s->dev_id
+#else
+                                   &s->cav_req_id
+#endif
+                                   );
+                           }
+                           else {
+                               /* just store pre-master secret to context memory */
+                               rc = Csp1WriteContext(s->cav_nb_mode,
+                                       s->context_pointer+128, 
+                                       SSL_MAX_MASTER_KEY_LENGTH, 
+                                       s->tmp_buf,
+#ifdef CAVIUM_MULTICARD_API
+                                       &s->cav_req_id,s->dev_id
+#else
+                                       &s->cav_req_id
+#endif
+                                       );
+                           }
+                           if (rc == EAGAIN ) {
+                               cav_fprintf(cav_nb_fp,"client key exchange(): %s\n",
+                                          "Csp1WriteContext() EAGAIN");
+                               s->cav_crypto_state = CAV_ST_IN_WRITE_CONTEXT;
+                               s->cav_saved_state = s->state;
+                               s->state = SSL3_ST_CW_KEY_EXCH_A;
+                               s->cav_req_id_check_done = 0;
+                               s->rwstate = SSL_NITROX_BUSY;
+                               return 0;
+                           }
+exchng_cav:
+                           s->q_vrfy_cert=s->p_vrfy_cert;
+                           /* Fix buf for TLS and beyond */
+                           if (s->version > SSL3_VERSION)
+                               s->p_vrfy_cert+=2;
+pubenc_cav:
+                           n=RSA_public_encrypt_cav(s, 
+                                   sizeof (s->tmp_buf), s->tmp_buf, 
+                                   s->p_vrfy_cert, s->rsa, RSA_PKCS1_PADDING);
+           
+                           if ( n == -EAGAIN)
+                               return 0;
+                           else if (n <= 0)
+                           {
+                               SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);
+                               goto err;
+                           }
+                           p = s->p_vrfy_cert ;
+                           d = s->d_vrfy_cert ;
+                           rsa = s->rsa ;
+                           q = s->q_vrfy_cert ;
+                           memcpy (tmp_buf , s->tmp_buf, sizeof (s->tmp_buf));
+                       }
+                       else {
+                           if (s->cav_renego > 0  && s->s3->tmp.cert_req)
+                           {
+#ifdef CAVIUM_MULTICARD_API
+                             Csp1AllocContext(CONTEXT_SSL, &s->s3->tmp.ctx_ptr,s->dev_id);
+#else
+                             Csp1AllocContext(CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
 #endif
-			if (n <= 0)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);
-				goto err;
-				}
-
-			/* Fix buf for TLS and beyond */
-			if (s->version > SSL3_VERSION)
-				{
-				s2n(n,q);
-				n+=2;
-				}
-
-			s->session->master_key_length=
-				s->method->ssl3_enc->generate_master_secret(s,
-					s->session->master_key,
-					tmp_buf,sizeof tmp_buf);
-			OPENSSL_cleanse(tmp_buf,sizeof tmp_buf);
-			}
+                             /* just store pre-master secret to context memory */
+                             rc= Csp1WriteContext(s->cav_nb_mode, 
+                                     s->s3->tmp.ctx_ptr+128,
+                                     SSL_MAX_MASTER_KEY_LENGTH, 
+                                     tmp_buf,
+#ifdef CAVIUM_MULTICARD_API
+                                     &s->cav_req_id,s->dev_id
+#else
+                                     &s->cav_req_id
+#endif
+                                     );
+                           }
+                           else {
+                               /* just store pre-master secret to context memory */
+                               rc = Csp1WriteContext(s->cav_nb_mode,
+                                        s->context_pointer+128,
+                                        SSL_MAX_MASTER_KEY_LENGTH, 
+                                        tmp_buf,
+#ifdef CAVIUM_MULTICARD_API
+                                        &s->cav_req_id,s->dev_id
+#else
+                                        &s->cav_req_id
+#endif
+                                        );
+                           }
+                           q = p ;
+                           /* Fix buf for TLS and beyond */
+                           if (s->version > SSL3_VERSION)
+                               p+=2;
+                           n=RSA_public_encrypt(sizeof tmp_buf, tmp_buf, 
+                                                p,rsa,RSA_PKCS1_PADDING);
+                       }
+#else
+                       q=p;
+                       /* Fix buf for TLS and beyond */
+                       if (s->version > SSL3_VERSION)
+                               p+=2;
+                       n=RSA_public_encrypt(sizeof tmp_buf, tmp_buf, 
+                                             p,rsa,RSA_PKCS1_PADDING);
+#endif
+#endif
+
+#ifdef PKCS1_CHECK
+                        if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;
+                        if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;
 #endif
+                        if (n <= 0)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);
+                                goto err;
+                                }
+
+                        /* Fix buf for TLS and beyond */
+                        if (s->version > SSL3_VERSION)
+                                {
+                                s2n(n,q);
+                                n+=2;
+                                }
+
+                        s->session->master_key_length=
+                                s->method->ssl3_enc->generate_master_secret(s,
+                                        s->session->master_key,
+                                        tmp_buf,sizeof tmp_buf);
+                        OPENSSL_cleanse(tmp_buf,sizeof tmp_buf);
+                        }
 #ifndef OPENSSL_NO_KRB5
-		else if (l & SSL_kKRB5)
-			{
-			krb5_error_code	krb5rc;
-			KSSL_CTX	*kssl_ctx = s->kssl_ctx;
-			/*  krb5_data	krb5_ap_req;  */
-			krb5_data	*enc_ticket;
-			krb5_data	authenticator, *authp = NULL;
-			EVP_CIPHER_CTX	ciph_ctx;
-			EVP_CIPHER	*enc = NULL;
-			unsigned char	iv[EVP_MAX_IV_LENGTH];
-			unsigned char	tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
-			unsigned char	epms[SSL_MAX_MASTER_KEY_LENGTH 
-						+ EVP_MAX_IV_LENGTH];
-			int 		padl, outl = sizeof(epms);
+                else if (l & SSL_kKRB5)
+                        {
+                        krb5_error_code        krb5rc;
+                        KSSL_CTX        *kssl_ctx = s->kssl_ctx;
+                        /*  krb5_data        krb5_ap_req;  */
+                        krb5_data        *enc_ticket;
+                        krb5_data        authenticator, *authp = NULL;
+                        EVP_CIPHER_CTX        ciph_ctx;
+                        EVP_CIPHER        *enc = NULL;
+                        unsigned char        iv[EVP_MAX_IV_LENGTH];
+                        unsigned char        tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
+                        unsigned char        epms[SSL_MAX_MASTER_KEY_LENGTH
+                                                + EVP_MAX_IV_LENGTH];
+                        int                 padl, outl = sizeof(epms);
 
-			EVP_CIPHER_CTX_init(&ciph_ctx);
+                        EVP_CIPHER_CTX_init(&ciph_ctx);
 
 #ifdef KSSL_DEBUG
-			printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
-			        l, SSL_kKRB5);
-#endif	/* KSSL_DEBUG */
+                        printf("ssl3_send_client_key_exchange(%lx & %lx)\n",
+                                l, SSL_kKRB5);
+#endif        /* KSSL_DEBUG */
 
-			authp = NULL;
+                        authp = NULL;
 #ifdef KRB5SENDAUTH
-			if (KRB5SENDAUTH)  authp = &authenticator;
-#endif	/* KRB5SENDAUTH */
+                        if (KRB5SENDAUTH)  authp = &authenticator;
+#endif        /* KRB5SENDAUTH */
 
-			krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
-				&kssl_err);
-			enc = kssl_map_enc(kssl_ctx->enctype);
-			if (enc == NULL)
-			    goto err;
+                        krb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,
+                                &kssl_err);
+                        enc = kssl_map_enc(kssl_ctx->enctype);
+                        if (enc == NULL)
+                            goto err;
 #ifdef KSSL_DEBUG
-			{
-			printf("kssl_cget_tkt rtn %d\n", krb5rc);
-			if (krb5rc && kssl_err.text)
-			  printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
-			}
-#endif	/* KSSL_DEBUG */
-
-			if (krb5rc)
-				{
-				ssl3_send_alert(s,SSL3_AL_FATAL,
-						SSL_AD_HANDSHAKE_FAILURE);
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
-						kssl_err.reason);
-				goto err;
-				}
-
-			/*  20010406 VRS - Earlier versions used KRB5 AP_REQ
-			**  in place of RFC 2712 KerberosWrapper, as in:
-			**
-			**  Send ticket (copy to *p, set n = length)
-			**  n = krb5_ap_req.length;
-			**  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
-			**  if (krb5_ap_req.data)  
-			**    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
-			**
-			**  Now using real RFC 2712 KerberosWrapper
-			**  (Thanks to Simon Wilkinson <sxw@sxw.org.uk>)
-			**  Note: 2712 "opaque" types are here replaced
-			**  with a 2-byte length followed by the value.
-			**  Example:
-			**  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
-			**  Where "xx xx" = length bytes.  Shown here with
-			**  optional authenticator omitted.
-			*/
-
-			/*  KerberosWrapper.Ticket		*/
-			s2n(enc_ticket->length,p);
-			memcpy(p, enc_ticket->data, enc_ticket->length);
-			p+= enc_ticket->length;
-			n = enc_ticket->length + 2;
-
-			/*  KerberosWrapper.Authenticator	*/
-			if (authp  &&  authp->length)  
-				{
-				s2n(authp->length,p);
-				memcpy(p, authp->data, authp->length);
-				p+= authp->length;
-				n+= authp->length + 2;
-				
-				free(authp->data);
-				authp->data = NULL;
-				authp->length = 0;
-				}
-			else
-				{
-				s2n(0,p);/*  null authenticator length	*/
-				n+=2;
-				}
- 
-			    tmp_buf[0]=s->client_version>>8;
-			    tmp_buf[1]=s->client_version&0xff;
-			    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
-				goto err;
-
-			/*  20010420 VRS.  Tried it this way; failed.
-			**	EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
-			**	EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
-			**				kssl_ctx->length);
-			**	EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
-			*/
-
-			memset(iv, 0, sizeof iv);  /* per RFC 1510 */
-			EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,
-				kssl_ctx->key,iv);
-			EVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,
-				sizeof tmp_buf);
-			EVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);
-			outl += padl;
-			if (outl > sizeof epms)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
-				goto err;
-				}
-			EVP_CIPHER_CTX_cleanup(&ciph_ctx);
-
-			/*  KerberosWrapper.EncryptedPreMasterSecret	*/
-			s2n(outl,p);
-			memcpy(p, epms, outl);
-			p+=outl;
-			n+=outl + 2;
-
-			s->session->master_key_length=
-			        s->method->ssl3_enc->generate_master_secret(s,
-					s->session->master_key,
-					tmp_buf, sizeof tmp_buf);
-
-			OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
-			OPENSSL_cleanse(epms, outl);
-			}
+                        {
+                        printf("kssl_cget_tkt rtn %d\n", krb5rc);
+                        if (krb5rc && kssl_err.text)
+                          printf("kssl_cget_tkt kssl_err=%s\n", kssl_err.text);
+                        }
+#endif        /* KSSL_DEBUG */
+
+                        if (krb5rc)
+                                {
+                                ssl3_send_alert(s,SSL3_AL_FATAL,
+                                                SSL_AD_HANDSHAKE_FAILURE);
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                                                kssl_err.reason);
+                                goto err;
+                                }
+
+                        /*  20010406 VRS - Earlier versions used KRB5 AP_REQ
+                        **  in place of RFC 2712 KerberosWrapper, as in:
+                        **
+                        **  Send ticket (copy to *p, set n = length)
+                        **  n = krb5_ap_req.length;
+                        **  memcpy(p, krb5_ap_req.data, krb5_ap_req.length);
+                        **  if (krb5_ap_req.data)
+                        **    kssl_krb5_free_data_contents(NULL,&krb5_ap_req);
+                        **
+                        **  Now using real RFC 2712 KerberosWrapper
+                        **  (Thanks to Simon Wilkinson <sxw@sxw.org.uk>)
+                        **  Note: 2712 "opaque" types are here replaced
+                        **  with a 2-byte length followed by the value.
+                        **  Example:
+                        **  KerberosWrapper= xx xx asn1ticket 0 0 xx xx encpms
+                        **  Where "xx xx" = length bytes.  Shown here with
+                        **  optional authenticator omitted.
+                        */
+
+                        /*  KerberosWrapper.Ticket                */
+                        s2n(enc_ticket->length,p);
+                        memcpy(p, enc_ticket->data, enc_ticket->length);
+                        p+= enc_ticket->length;
+                        n = enc_ticket->length + 2;
+
+                        /*  KerberosWrapper.Authenticator        */
+                        if (authp  &&  authp->length)
+                                {
+                                s2n(authp->length,p);
+                                memcpy(p, authp->data, authp->length);
+                                p+= authp->length;
+                                n+= authp->length + 2;
+
+                                free(authp->data);
+                                authp->data = NULL;
+                                authp->length = 0;
+                                }
+                        else
+                                {
+                                s2n(0,p);/*  null authenticator length        */
+                                n+=2;
+                                }
+
+                            tmp_buf[0]=s->client_version>>8;
+                            tmp_buf[1]=s->client_version&0xff;
+                            if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)
+                                goto err;
+
+                        /*  20010420 VRS.  Tried it this way; failed.
+                        **        EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,NULL);
+                        **        EVP_CIPHER_CTX_set_key_length(&ciph_ctx,
+                        **                                kssl_ctx->length);
+                        **        EVP_EncryptInit_ex(&ciph_ctx,NULL, key,iv);
+                        */
+
+                        memset(iv, 0, sizeof iv);  /* per RFC 1510 */
+                        EVP_EncryptInit_ex(&ciph_ctx,enc, NULL,
+                                kssl_ctx->key,iv);
+                        EVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,
+                                sizeof tmp_buf);
+                        EVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);
+                        outl += padl;
+                        if (outl > sizeof epms)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
+                                goto err;
+                                }
+                        EVP_CIPHER_CTX_cleanup(&ciph_ctx);
+
+                        /*  KerberosWrapper.EncryptedPreMasterSecret        */
+                        s2n(outl,p);
+                        memcpy(p, epms, outl);
+                        p+=outl;
+                        n+=outl + 2;
+
+                        s->session->master_key_length=
+                                s->method->ssl3_enc->generate_master_secret(s,
+                                        s->session->master_key,
+                                        tmp_buf, sizeof tmp_buf);
+
+                        OPENSSL_cleanse(tmp_buf, sizeof tmp_buf);
+                        OPENSSL_cleanse(epms, outl);
+                        }
 #endif
 #ifndef OPENSSL_NO_DH
-		else if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
-			{
-			DH *dh_srvr,*dh_clnt;
-
-			if (s->session->sess_cert == NULL) 
-				{
-				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
-				goto err;
-			        }
-
-			if (s->session->sess_cert->peer_dh_tmp != NULL)
-				dh_srvr=s->session->sess_cert->peer_dh_tmp;
-			else
-				{
-				/* we get them from the cert */
-				ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
-				goto err;
-				}
-			
-			/* generate a new random key */
-			if ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
-				goto err;
-				}
-			if (!DH_generate_key(dh_clnt))
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
-				goto err;
-				}
-
-			/* use the 'p' output buffer for the DH key, but
-			 * make sure to clear it out afterwards */
-
-			n=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);
-
-			if (n <= 0)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
-				goto err;
-				}
-
-			/* generate master key from the result */
-			s->session->master_key_length=
-				s->method->ssl3_enc->generate_master_secret(s,
-					s->session->master_key,p,n);
-			/* clean up */
-			memset(p,0,n);
-
-			/* send off the data */
-			n=BN_num_bytes(dh_clnt->pub_key);
-			s2n(n,p);
-			BN_bn2bin(dh_clnt->pub_key,p);
-			n+=2;
-
-			DH_free(dh_clnt);
-
-			/* perhaps clean things up a bit EAY EAY EAY EAY*/
-			}
-#endif
-
-#ifndef OPENSSL_NO_ECDH 
-		else if ((l & SSL_kECDH) || (l & SSL_kECDHE))
-			{
-			const EC_GROUP *srvr_group = NULL;
-			EC_KEY *tkey;
-			int ecdh_clnt_cert = 0;
-			int field_size = 0;
-
-			/* Did we send out the client's
-			 * ECDH share for use in premaster
-			 * computation as part of client certificate?
-			 * If so, set ecdh_clnt_cert to 1.
-			 */
-			if ((l & SSL_kECDH) && (s->cert != NULL)) 
-				{
-				/* XXX: For now, we do not support client
-				 * authentication using ECDH certificates.
-				 * To add such support, one needs to add
-				 * code that checks for appropriate 
-				 * conditions and sets ecdh_clnt_cert to 1.
-				 * For example, the cert have an ECC
-				 * key on the same curve as the server's
-				 * and the key should be authorized for
-				 * key agreement.
-				 *
-				 * One also needs to add code in ssl3_connect
-				 * to skip sending the certificate verify
-				 * message.
-				 *
-				 * if ((s->cert->key->privatekey != NULL) &&
-				 *     (s->cert->key->privatekey->type ==
-				 *      EVP_PKEY_EC) && ...)
-				 * ecdh_clnt_cert = 1;
-				 */
-				}
-
-			if (s->session->sess_cert->peer_ecdh_tmp != NULL)
-				{
-				tkey = s->session->sess_cert->peer_ecdh_tmp;
-				}
-			else
-				{
-				/* Get the Server Public Key from Cert */
-				srvr_pub_pkey = X509_get_pubkey(s->session-> \
-				    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
-				if ((srvr_pub_pkey == NULL) ||
-				    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
-				    (srvr_pub_pkey->pkey.ec == NULL))
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
-					    ERR_R_INTERNAL_ERROR);
-					goto err;
-					}
-
-				tkey = srvr_pub_pkey->pkey.ec;
-				}
-
-			srvr_group   = EC_KEY_get0_group(tkey);
-			srvr_ecpoint = EC_KEY_get0_public_key(tkey);
-
-			if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
-				    ERR_R_INTERNAL_ERROR);
-				goto err;
-				}
-
-			if ((clnt_ecdh=EC_KEY_new()) == NULL) 
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-				goto err;
-				}
-
-			if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
-				goto err;
-				}
-			if (ecdh_clnt_cert) 
-				{ 
-				/* Reuse key info from our certificate
-				 * We only need our private key to perform
-				 * the ECDH computation.
-				 */
-				const BIGNUM *priv_key;
-				tkey = s->cert->key->privatekey->pkey.ec;
-				priv_key = EC_KEY_get0_private_key(tkey);
-				if (priv_key == NULL)
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-					goto err;
-					}
-				if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
-					goto err;
-					}
-				}
-			else 
-				{
-				/* Generate a new ECDH key pair */
-				if (!(EC_KEY_generate_key(clnt_ecdh)))
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
-					goto err;
-					}
-				}
-
-			/* use the 'p' output buffer for the ECDH key, but
-			 * make sure to clear it out afterwards
-			 */
-
-			field_size = EC_GROUP_get_degree(srvr_group);
-			if (field_size <= 0)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
-				       ERR_R_ECDH_LIB);
-				goto err;
-				}
-			n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
-			if (n <= 0)
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, 
-				       ERR_R_ECDH_LIB);
-				goto err;
-				}
-
-			/* generate master key from the result */
-			s->session->master_key_length = s->method->ssl3_enc \
-			    -> generate_master_secret(s, 
-				s->session->master_key,
-				p, n);
-
-			memset(p, 0, n); /* clean up */
-
-			if (ecdh_clnt_cert) 
-				{
-				/* Send empty client key exch message */
-				n = 0;
-				}
-			else 
-				{
-				/* First check the size of encoding and
-				 * allocate memory accordingly.
-				 */
-				encoded_pt_len = 
-				    EC_POINT_point2oct(srvr_group, 
-					EC_KEY_get0_public_key(clnt_ecdh), 
-					POINT_CONVERSION_UNCOMPRESSED, 
-					NULL, 0, NULL);
-
-				encodedPoint = (unsigned char *) 
-				    OPENSSL_malloc(encoded_pt_len * 
-					sizeof(unsigned char)); 
-				bn_ctx = BN_CTX_new();
-				if ((encodedPoint == NULL) || 
-				    (bn_ctx == NULL)) 
-					{
-					SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-					goto err;
-					}
-
-				/* Encode the public key */
-				n = EC_POINT_point2oct(srvr_group, 
-				    EC_KEY_get0_public_key(clnt_ecdh), 
-				    POINT_CONVERSION_UNCOMPRESSED, 
-				    encodedPoint, encoded_pt_len, bn_ctx);
-
-				*p = n; /* length of encoded point */
-				/* Encoded point will be copied here */
-				p += 1; 
-				/* copy the point */
-				memcpy((unsigned char *)p, encodedPoint, n);
-				/* increment n to account for length field */
-				n += 1; 
-				}
-
-			/* Free allocated memory */
-			BN_CTX_free(bn_ctx);
-			if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
-			if (clnt_ecdh != NULL) 
-				 EC_KEY_free(clnt_ecdh);
-			EVP_PKEY_free(srvr_pub_pkey);
-			}
+                else if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
+                        {
+                        DH *dh_srvr,*dh_clnt;
+
+                        if (s->session->sess_cert == NULL)
+                                {
+                                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);
+                                goto err;
+                                }
+
+                        if (s->session->sess_cert->peer_dh_tmp != NULL)
+                                dh_srvr=s->session->sess_cert->peer_dh_tmp;
+                        else
+                                {
+                                /* we get them from the cert */
+                                ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);
+                                goto err;
+                                }
+
+                        /* generate a new random key */
+                        if ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
+                                goto err;
+                                }
+                        if (!DH_generate_key(dh_clnt))
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
+                                goto err;
+                                }
+
+                        /* use the 'p' output buffer for the DH key, but
+                         * make sure to clear it out afterwards */
+
+                        n=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);
+
+                        if (n <= 0)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
+                                goto err;
+                                }
+
+                        /* generate master key from the result */
+                        s->session->master_key_length=
+                                s->method->ssl3_enc->generate_master_secret(s,
+                                        s->session->master_key,p,n);
+                        /* clean up */
+                        memset(p,0,n);
+
+                        /* send off the data */
+                        n=BN_num_bytes(dh_clnt->pub_key);
+                        s2n(n,p);
+                        BN_bn2bin(dh_clnt->pub_key,p);
+                        n+=2;
+
+                        DH_free(dh_clnt);
+
+                        /* perhaps clean things up a bit EAY EAY EAY EAY*/
+                        }
+#endif
+
+#ifndef OPENSSL_NO_ECDH
+                else if ((l & SSL_kECDH) || (l & SSL_kECDHE))
+                        {
+                        const EC_GROUP *srvr_group = NULL;
+                        EC_KEY *tkey;
+                        int ecdh_clnt_cert = 0;
+                        int field_size = 0;
+
+                        /* Did we send out the client's
+                         * ECDH share for use in premaster
+                         * computation as part of client certificate?
+                         * If so, set ecdh_clnt_cert to 1.
+                         */
+                        if ((l & SSL_kECDH) && (s->cert != NULL))
+                                {
+                                /* XXX: For now, we do not support client
+                                 * authentication using ECDH certificates.
+                                 * To add such support, one needs to add
+                                 * code that checks for appropriate
+                                 * conditions and sets ecdh_clnt_cert to 1.
+                                 * For example, the cert have an ECC
+                                 * key on the same curve as the server's
+                                 * and the key should be authorized for
+                                 * key agreement.
+                                 *
+                                 * One also needs to add code in ssl3_connect
+                                 * to skip sending the certificate verify
+                                 * message.
+                                 *
+                                 * if ((s->cert->key->privatekey != NULL) &&
+                                 *     (s->cert->key->privatekey->type ==
+                                 *      EVP_PKEY_EC) && ...)
+                                 * ecdh_clnt_cert = 1;
+                                 */
+                                }
+
+                        if (s->session->sess_cert->peer_ecdh_tmp != NULL)
+                                {
+                                tkey = s->session->sess_cert->peer_ecdh_tmp;
+                                }
+                        else
+                                {
+                                /* Get the Server Public Key from Cert */
+                                srvr_pub_pkey = X509_get_pubkey(s->session-> \
+                                    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);
+                                if ((srvr_pub_pkey == NULL) ||
+                                    (srvr_pub_pkey->type != EVP_PKEY_EC) ||
+                                    (srvr_pub_pkey->pkey.ec == NULL))
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                                            ERR_R_INTERNAL_ERROR);
+                                        goto err;
+                                        }
+
+                                tkey = srvr_pub_pkey->pkey.ec;
+                                }
+
+                        srvr_group   = EC_KEY_get0_group(tkey);
+                        srvr_ecpoint = EC_KEY_get0_public_key(tkey);
+
+                        if ((srvr_group == NULL) || (srvr_ecpoint == NULL))
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                                    ERR_R_INTERNAL_ERROR);
+                                goto err;
+                                }
+
+                        if ((clnt_ecdh=EC_KEY_new()) == NULL)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                                goto err;
+                                }
+
+                        if (!EC_KEY_set_group(clnt_ecdh, srvr_group))
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
+                                goto err;
+                                }
+                        if (ecdh_clnt_cert)
+                                {
+                                /* Reuse key info from our certificate
+                                 * We only need our private key to perform
+                                 * the ECDH computation.
+                                 */
+                                const BIGNUM *priv_key;
+                                tkey = s->cert->key->privatekey->pkey.ec;
+                                priv_key = EC_KEY_get0_private_key(tkey);
+                                if (priv_key == NULL)
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                                        goto err;
+                                        }
+                                if (!EC_KEY_set_private_key(clnt_ecdh, priv_key))
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);
+                                        goto err;
+                                        }
+                                }
+                        else
+                                {
+                                /* Generate a new ECDH key pair */
+                                if (!(EC_KEY_generate_key(clnt_ecdh)))
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);
+                                        goto err;
+                                        }
+                                }
+
+                        /* use the 'p' output buffer for the ECDH key, but
+                         * make sure to clear it out afterwards
+                         */
+
+                        field_size = EC_GROUP_get_degree(srvr_group);
+                        if (field_size <= 0)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                                       ERR_R_ECDH_LIB);
+                                goto err;
+                                }
+                        n=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);
+                        if (n <= 0)
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                                       ERR_R_ECDH_LIB);
+                                goto err;
+                                }
+
+                        /* generate master key from the result */
+                        s->session->master_key_length = s->method->ssl3_enc \
+                            -> generate_master_secret(s,
+                                s->session->master_key,
+                                p, n);
+
+                        memset(p, 0, n); /* clean up */
+
+                        if (ecdh_clnt_cert)
+                                {
+                                /* Send empty client key exch message */
+                                n = 0;
+                                }
+                        else
+                                {
+                                /* First check the size of encoding and
+                                 * allocate memory accordingly.
+                                 */
+                                encoded_pt_len =
+                                    EC_POINT_point2oct(srvr_group,
+                                        EC_KEY_get0_public_key(clnt_ecdh),
+                                        POINT_CONVERSION_UNCOMPRESSED,
+                                        NULL, 0, NULL);
+
+                                encodedPoint = (unsigned char *)
+                                    OPENSSL_malloc(encoded_pt_len *
+                                        sizeof(unsigned char));
+                                bn_ctx = BN_CTX_new();
+                                if ((encodedPoint == NULL) ||
+                                    (bn_ctx == NULL))
+                                        {
+                                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
+                                        goto err;
+                                        }
+
+                                /* Encode the public key */
+                                n = EC_POINT_point2oct(srvr_group,
+                                    EC_KEY_get0_public_key(clnt_ecdh),
+                                    POINT_CONVERSION_UNCOMPRESSED,
+                                    encodedPoint, encoded_pt_len, bn_ctx);
+
+                                *p = n; /* length of encoded point */
+                                /* Encoded point will be copied here */
+                                p += 1;
+                                /* copy the point */
+                                memcpy((unsigned char *)p, encodedPoint, n);
+                                /* increment n to account for length field */
+                                n += 1;
+                                }
+
+                        /* Free allocated memory */
+                        BN_CTX_free(bn_ctx);
+                        if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
+                        if (clnt_ecdh != NULL)
+                                 EC_KEY_free(clnt_ecdh);
+                        EVP_PKEY_free(srvr_pub_pkey);
+                        }
 #endif /* !OPENSSL_NO_ECDH */
-		else
-			{
-			ssl3_send_alert(s, SSL3_AL_FATAL,
-			    SSL_AD_HANDSHAKE_FAILURE);
-			SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
-			    ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		
-		*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;
-		l2n3(n,d);
-
-		s->state=SSL3_ST_CW_KEY_EXCH_B;
-		/* number of bytes to write */
-		s->init_num=n+4;
-		s->init_off=0;
-		}
+                else
+                        {
+                        ssl3_send_alert(s, SSL3_AL_FATAL,
+                            SSL_AD_HANDSHAKE_FAILURE);
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,
+                            ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+
+                *(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;
+                l2n3(n,d);
+
+                s->state=SSL3_ST_CW_KEY_EXCH_B;
+                /* number of bytes to write */
+                s->init_num=n+4;
+                s->init_off=0;
+                }
+#ifdef CAVIUM_SSL
+                s->client_key_exch_msg_offset = s->hs_msgs_len;
+#endif
 
-	/* SSL3_ST_CW_KEY_EXCH_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+        /* SSL3_ST_CW_KEY_EXCH_B */
+        return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
 err:
 #ifndef OPENSSL_NO_ECDH
-	BN_CTX_free(bn_ctx);
-	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
-	if (clnt_ecdh != NULL) 
-		EC_KEY_free(clnt_ecdh);
-	EVP_PKEY_free(srvr_pub_pkey);
+        BN_CTX_free(bn_ctx);
+        if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
+        if (clnt_ecdh != NULL)
+                EC_KEY_free(clnt_ecdh);
+        EVP_PKEY_free(srvr_pub_pkey);
 #endif
-	return(-1);
-	}
+        return(-1);
+        }
 
 int ssl3_send_client_verify(SSL *s)
-	{
-	unsigned char *p,*d;
-	unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
-	EVP_PKEY *pkey;
+        {
+        unsigned char *p=NULL, *d=NULL;
+        unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
+        EVP_PKEY *pkey = NULL;
+        int key_type = -1;
 #ifndef OPENSSL_NO_RSA
-	unsigned u=0;
+        unsigned u=0;
 #endif
-	unsigned long n;
+        unsigned long n;
 #if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)
-	int j;
+        int j;
+#endif
+#ifdef CAVIUM_SSL
+        if (s->flag1 == 1 )
+           goto rsa_key;
+#ifndef CAVIUM_FIPS
+        else if (s->state == CAV_ST_IN_PRE_MASTER_KEY)
+           goto sign_cav;
+#endif
+#endif
+        if (s->state == SSL3_ST_CW_CERT_VRFY_A)
+                {
+                d=(unsigned char *)s->init_buf->data;
+                p= &(d[4]);
+                pkey=s->cert->key->privatekey;
+#ifdef CAVIUM_SSL
+        if(s->cipher_support)
+        {
+            s->p_vrfy_cert = p ;
+            s->pkey = pkey ;
+            s->d_vrfy_cert = d ;
+
+            if(!pkp_client_cert_verify_mac(s))
+            {
+                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
+                goto err;
+            }
+        }
+        else
+        {
+            s->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),
+                               &(data[MD5_DIGEST_LENGTH]));
+        }
+#else
+        s->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),
+                        &(data[MD5_DIGEST_LENGTH]));
 #endif
-
-	if (s->state == SSL3_ST_CW_CERT_VRFY_A)
-		{
-		d=(unsigned char *)s->init_buf->data;
-		p= &(d[4]);
-		pkey=s->cert->key->privatekey;
-
-		s->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),
-			&(data[MD5_DIGEST_LENGTH]));
-
 #ifndef OPENSSL_NO_RSA
-		if (pkey->type == EVP_PKEY_RSA)
-			{
-			s->method->ssl3_enc->cert_verify_mac(s,
-				&(s->s3->finish_dgst1),&(data[0]));
-			if (RSA_sign(NID_md5_sha1, data,
-					 MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
-					&(p[2]), &u, pkey->pkey.rsa) <= 0 )
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
-				goto err;
-				}
-			s2n(u,p);
-			n=u+2;
-			}
-		else
+#ifdef CAVIUM_SSL
+rsa_key:
+        if (s->cipher_support)
+            pkey = s->pkey ;
+#ifdef CAVIUM_FIPS
+        key_type = s->ctx->pkey_info.type;
+#else
+        key_type = pkey->type;
+#endif
+#endif
+        if (key_type == EVP_PKEY_RSA)
+        {
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+            if(!s->cipher_support)
+            {
+                s->method->ssl3_enc->cert_verify_mac(s,
+                        &(s->s3->finish_dgst1),&(data[0]));
+                if (RSA_sign(NID_md5_sha1,data,
+                                 MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
+                                &(p[2]), &u, pkey->pkey.rsa) <= 0 )
+                {
+                    SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
+                    goto err;
+                }
+            }
+            else
+            {
+sign_cav:
+                s->flag1 = 0 ;
+                if (RSA_sign_cav(s ,NID_md5_sha1, s->data_sign,
+                            MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
+                            &(s->p_vrfy_cert[2]), &u, s->pkey->pkey.rsa) <= 0 )
+                                {
+                    goto err ;
+                }
+                p = s->p_vrfy_cert;
+                d = s->d_vrfy_cert;
+                pkey = s->pkey ;
+                memcpy (data, s->data_sign,sizeof(s->data_sign));
+            }
+#elif defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+            if(!s->cipher_support) {
+                s->method->ssl3_enc->cert_verify_mac(s,
+                                    &(s->s3->finish_dgst1),&(data[0]));
+                if(pkp_rsa_private_encrypt(MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, data, &(p[2]), (RSA *)s, 1) == 0) {
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
+                        goto err;
+                }
+                u=s->ctx->pkey_info.size;
+            }
+            else {
+                s->flag1 = 0 ;
+                if (pkp_rsa_private_encrypt(MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, s->data_sign,&(s->p_vrfy_cert[2]), (RSA *)s, 1) <= 0 ) {
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
+                        goto err ;
+                }
+                u=s->ctx->pkey_info.size;
+                p = s->p_vrfy_cert;
+                d = s->d_vrfy_cert;
+                pkey = s->pkey ;
+                memcpy (data, s->data_sign,sizeof(s->data_sign));
+           }
+#else
+           s->method->ssl3_enc->cert_verify_mac(s,
+                   &(s->s3->finish_dgst1),&(data[0]));
+           if (RSA_sign(NID_md5_sha1, data, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,
+                           &(p[2]), &u, pkey->pkey.rsa) <= 0 )
+           {
+                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);
+                goto err;
+           }
+#endif
+            s2n(u,p);
+            n=u+2;
+        }
+        else
 #endif
 #ifndef OPENSSL_NO_DSA
-			if (pkey->type == EVP_PKEY_DSA)
-			{
-			if (!DSA_sign(pkey->save_type,
-				&(data[MD5_DIGEST_LENGTH]),
-				SHA_DIGEST_LENGTH,&(p[2]),
-				(unsigned int *)&j,pkey->pkey.dsa))
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);
-				goto err;
-				}
-			s2n(j,p);
-			n=j+2;
-			}
-		else
+                        if (pkey->type == EVP_PKEY_DSA)
+                        {
+                        if (!DSA_sign(pkey->save_type,
+                                &(data[MD5_DIGEST_LENGTH]),
+                                SHA_DIGEST_LENGTH,&(p[2]),
+                                (unsigned int *)&j,pkey->pkey.dsa))
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);
+                                goto err;
+                                }
+                        s2n(j,p);
+                        n=j+2;
+                        }
+                else
 #endif
 #ifndef OPENSSL_NO_ECDSA
-			if (pkey->type == EVP_PKEY_EC)
-			{
-			if (!ECDSA_sign(pkey->save_type,
-				&(data[MD5_DIGEST_LENGTH]),
-				SHA_DIGEST_LENGTH,&(p[2]),
-				(unsigned int *)&j,pkey->pkey.ec))
-				{
-				SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
-				    ERR_R_ECDSA_LIB);
-				goto err;
-				}
-			s2n(j,p);
-			n=j+2;
-			}
-		else
-#endif
-			{
-			SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		*(d++)=SSL3_MT_CERTIFICATE_VERIFY;
-		l2n3(n,d);
-
-		s->state=SSL3_ST_CW_CERT_VRFY_B;
-		s->init_num=(int)n+4;
-		s->init_off=0;
-		}
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+                        if (pkey->type == EVP_PKEY_EC)
+                        {
+                        if (!ECDSA_sign(pkey->save_type,
+                                &(data[MD5_DIGEST_LENGTH]),
+                                SHA_DIGEST_LENGTH,&(p[2]),
+                                (unsigned int *)&j,pkey->pkey.ec))
+                                {
+                                SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
+                                    ERR_R_ECDSA_LIB);
+                                goto err;
+                                }
+                        s2n(j,p);
+                        n=j+2;
+                        }
+                else
+#endif
+                        {
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);
+                        goto err;
+                        }
+                *(d++)=SSL3_MT_CERTIFICATE_VERIFY;
+                l2n3(n,d);
+
+                s->state=SSL3_ST_CW_CERT_VRFY_B;
+                s->init_num=(int)n+4;
+                s->init_off=0;
+                }
+#ifdef CAVIUM_SSL
+                s->client_cert_verify_msg_offset = s->hs_msgs_len;
+#endif
+        return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
 err:
-	return(-1);
-	}
+        return(-1);
+        }
 
 int ssl3_send_client_certificate(SSL *s)
-	{
-	X509 *x509=NULL;
-	EVP_PKEY *pkey=NULL;
-	int i;
-	unsigned long l;
-
-	if (s->state ==	SSL3_ST_CW_CERT_A)
-		{
-		if ((s->cert == NULL) ||
-			(s->cert->key->x509 == NULL) ||
-			(s->cert->key->privatekey == NULL))
-			s->state=SSL3_ST_CW_CERT_B;
-		else
-			s->state=SSL3_ST_CW_CERT_C;
-		}
-
-	/* We need to get a client cert */
-	if (s->state == SSL3_ST_CW_CERT_B)
-		{
-		/* If we get an error, we need to
-		 * ssl->rwstate=SSL_X509_LOOKUP; return(-1);
-		 * We then get retied later */
-		i=0;
-		i = ssl_do_client_cert_cb(s, &x509, &pkey);
-		if (i < 0)
-			{
-			s->rwstate=SSL_X509_LOOKUP;
-			return(-1);
-			}
-		s->rwstate=SSL_NOTHING;
-		if ((i == 1) && (pkey != NULL) && (x509 != NULL))
-			{
-			s->state=SSL3_ST_CW_CERT_B;
-			if (	!SSL_use_certificate(s,x509) ||
-				!SSL_use_PrivateKey(s,pkey))
-				i=0;
-			}
-		else if (i == 1)
-			{
-			i=0;
-			SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
-			}
-
-		if (x509 != NULL) X509_free(x509);
-		if (pkey != NULL) EVP_PKEY_free(pkey);
-		if (i == 0)
-			{
-			if (s->version == SSL3_VERSION)
-				{
-				s->s3->tmp.cert_req=0;
-				ssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);
-				return(1);
-				}
-			else
-				{
-				s->s3->tmp.cert_req=2;
-				}
-			}
-
-		/* Ok, we have a cert */
-		s->state=SSL3_ST_CW_CERT_C;
-		}
-
-	if (s->state == SSL3_ST_CW_CERT_C)
-		{
-		s->state=SSL3_ST_CW_CERT_D;
-		l=ssl3_output_cert_chain(s,
-			(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);
-		s->init_num=(int)l;
-		s->init_off=0;
-		}
-	/* SSL3_ST_CW_CERT_D */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+        {
+        X509 *x509=NULL;
+        EVP_PKEY *pkey=NULL;
+        int i;
+        unsigned long l;
+
+        if (s->state ==        SSL3_ST_CW_CERT_A)
+                {
+                if ((s->cert == NULL) ||
+                        (s->cert->key->x509 == NULL) ||
+                        (s->cert->key->privatekey == NULL))
+                        s->state=SSL3_ST_CW_CERT_B;
+                else
+                        s->state=SSL3_ST_CW_CERT_C;
+                }
+
+        /* We need to get a client cert */
+        if (s->state == SSL3_ST_CW_CERT_B)
+                {
+                /* If we get an error, we need to
+                 * ssl->rwstate=SSL_X509_LOOKUP; return(-1);
+                 * We then get retied later */
+                i=0;
+                i = ssl_do_client_cert_cb(s, &x509, &pkey);
+                if (i < 0)
+                        {
+                        s->rwstate=SSL_X509_LOOKUP;
+                        return(-1);
+                        }
+                s->rwstate=SSL_NOTHING;
+                if ((i == 1) && (pkey != NULL) && (x509 != NULL))
+                        {
+                        s->state=SSL3_ST_CW_CERT_B;
+                        if (        !SSL_use_certificate(s,x509) ||
+                                !SSL_use_PrivateKey(s,pkey))
+                                i=0;
+                        }
+                else if (i == 1)
+                        {
+                        i=0;
+                        SSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);
+                        }
+
+                if (x509 != NULL) X509_free(x509);
+                if (pkey != NULL) EVP_PKEY_free(pkey);
+                if (i == 0)
+                        {
+                        if (s->version == SSL3_VERSION)
+                                {
+                                s->s3->tmp.cert_req=0;
+#ifdef CAVIUM_SSL
+                               if (s->cav_nb_mode == 0)
+#endif
+                                ssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);
+                                return(1);
+                                }
+                        else
+                                {
+                                s->s3->tmp.cert_req=2;
+                                }
+                        }
+
+                /* Ok, we have a cert */
+                s->state=SSL3_ST_CW_CERT_C;
+                }
+
+        if (s->state == SSL3_ST_CW_CERT_C)
+                {
+                s->state=SSL3_ST_CW_CERT_D;
+                l=ssl3_output_cert_chain(s,
+                        (s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);
+                s->init_num=(int)l;
+                s->init_off=0;
+                }
+        /* SSL3_ST_CW_CERT_D */
+        return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+        }
 
-#define has_bits(i,m)	(((i)&(m)) == (m))
+#define has_bits(i,m)        (((i)&(m)) == (m))
 
 int ssl3_check_cert_and_algorithm(SSL *s)
-	{
-	int i,idx;
-	long algs;
-	EVP_PKEY *pkey=NULL;
-	SESS_CERT *sc;
+        {
+        int i,idx;
+        long algs;
+        EVP_PKEY *pkey=NULL;
+        SESS_CERT *sc;
 #ifndef OPENSSL_NO_RSA
-	RSA *rsa;
+        RSA *rsa;
 #endif
 #ifndef OPENSSL_NO_DH
-	DH *dh;
+        DH *dh;
 #endif
 
-	sc=s->session->sess_cert;
+        sc=s->session->sess_cert;
 
-	algs=s->s3->tmp.new_cipher->algorithms;
+        algs=s->s3->tmp.new_cipher->algorithms;
 
-	/* we don't have a certificate */
-	if (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))
-		return(1);
+        /* we don't have a certificate */
+        if (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))
+                return(1);
 
-	if (sc == NULL)
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);
-		goto err;
-		}
+        if (sc == NULL)
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);
+                goto err;
+                }
 
 #ifndef OPENSSL_NO_RSA
-	rsa=s->session->sess_cert->peer_rsa_tmp;
+        rsa=s->session->sess_cert->peer_rsa_tmp;
 #endif
 #ifndef OPENSSL_NO_DH
-	dh=s->session->sess_cert->peer_dh_tmp;
+        dh=s->session->sess_cert->peer_dh_tmp;
 #endif
 
-	/* This is the passed certificate */
+        /* This is the passed certificate */
 
-	idx=sc->peer_cert_type;
+        idx=sc->peer_cert_type;
 #ifndef OPENSSL_NO_ECDH
-	if (idx == SSL_PKEY_ECC)
-		{
-		if (check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
-		    s->s3->tmp.new_cipher) == 0) 
-			{ /* check failed */
-			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_BAD_ECC_CERT);
-			goto f_err;			
-			}
-		else 
-			{
-			return 1;
-			}
-		}
-#endif
-	pkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);
-	i=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);
-	EVP_PKEY_free(pkey);
-
-	
-	/* Check that we have a certificate if we require one */
-	if ((algs & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_SIGNING_CERT);
-		goto f_err;
-		}
+        if (idx == SSL_PKEY_ECC)
+                {
+                if (check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,
+                    s->s3->tmp.new_cipher) == 0)
+                        { /* check failed */
+                        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_BAD_ECC_CERT);
+                        goto f_err;
+                        }
+                else
+                        {
+                        return 1;
+                        }
+                }
+#endif
+        pkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);
+        i=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);
+        EVP_PKEY_free(pkey);
+
+
+        /* Check that we have a certificate if we require one */
+        if ((algs & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_SIGNING_CERT);
+                goto f_err;
+                }
 #ifndef OPENSSL_NO_DSA
-	else if ((algs & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DSA_SIGNING_CERT);
-		goto f_err;
-		}
+        else if ((algs & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DSA_SIGNING_CERT);
+                goto f_err;
+                }
 #endif
 #ifndef OPENSSL_NO_RSA
-	if ((algs & SSL_kRSA) &&
-		!(has_bits(i,EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL)))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_ENCRYPTING_CERT);
-		goto f_err;
-		}
+        if ((algs & SSL_kRSA) &&
+                !(has_bits(i,EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL)))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_ENCRYPTING_CERT);
+                goto f_err;
+                }
 #endif
 #ifndef OPENSSL_NO_DH
-	if ((algs & SSL_kEDH) &&
-		!(has_bits(i,EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL)))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_KEY);
-		goto f_err;
-		}
-	else if ((algs & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_RSA_CERT);
-		goto f_err;
-		}
+        if ((algs & SSL_kEDH) &&
+                !(has_bits(i,EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL)))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_KEY);
+                goto f_err;
+                }
+        else if ((algs & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_RSA_CERT);
+                goto f_err;
+                }
 #ifndef OPENSSL_NO_DSA
-	else if ((algs & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))
-		{
-		SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_DSA_CERT);
-		goto f_err;
-		}
+        else if ((algs & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))
+                {
+                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_DSA_CERT);
+                goto f_err;
+                }
 #endif
 #endif
 
-	if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i,EVP_PKT_EXP))
-		{
+        if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i,EVP_PKT_EXP))
+                {
 #ifndef OPENSSL_NO_RSA
-		if (algs & SSL_kRSA)
-			{
-			if (rsa == NULL
-			    || RSA_size(rsa)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
-				{
-				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_RSA_KEY);
-				goto f_err;
-				}
-			}
-		else
+                if (algs & SSL_kRSA)
+                        {
+#ifdef CAVIUM_SSL
+                        if (rsa == NULL)
+#else
+                        if (rsa == NULL
+                            || RSA_size(rsa)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
+#endif
+                                {
+                                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_RSA_KEY);
+                                goto f_err;
+                                }
+                        }
+                else
 #endif
 #ifndef OPENSSL_NO_DH
-			if (algs & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
-			    {
-			    if (dh == NULL
-				|| DH_size(dh)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
-				{
-				SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_DH_KEY);
-				goto f_err;
-				}
-			}
-		else
-#endif
-			{
-			SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
-			goto f_err;
-			}
-		}
-	return(1);
+                        if (algs & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
+                            {
+                            if (dh == NULL
+                                || DH_size(dh)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))
+                                {
+                                SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_DH_KEY);
+                                goto f_err;
+                                }
+                        }
+                else
+#endif
+                        {
+                        SSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
+                        goto f_err;
+                        }
+                }
+        return(1);
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
+        ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);
 err:
-	return(0);
-	}
+        return(0);
+        }
 
 
 #ifndef OPENSSL_NO_ECDH
 /* This is the complement of nid2curve_id in s3_srvr.c. */
 static int curve_id2nid(int curve_id)
 {
-	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
-	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
-	static int nid_list[26] =
-	{
-		0,
-		NID_sect163k1, /* sect163k1 (1) */
-		NID_sect163r1, /* sect163r1 (2) */
-		NID_sect163r2, /* sect163r2 (3) */
-		NID_sect193r1, /* sect193r1 (4) */ 
-		NID_sect193r2, /* sect193r2 (5) */ 
-		NID_sect233k1, /* sect233k1 (6) */
-		NID_sect233r1, /* sect233r1 (7) */ 
-		NID_sect239k1, /* sect239k1 (8) */ 
-		NID_sect283k1, /* sect283k1 (9) */
-		NID_sect283r1, /* sect283r1 (10) */ 
-		NID_sect409k1, /* sect409k1 (11) */ 
-		NID_sect409r1, /* sect409r1 (12) */
-		NID_sect571k1, /* sect571k1 (13) */ 
-		NID_sect571r1, /* sect571r1 (14) */ 
-		NID_secp160k1, /* secp160k1 (15) */
-		NID_secp160r1, /* secp160r1 (16) */ 
-		NID_secp160r2, /* secp160r2 (17) */ 
-		NID_secp192k1, /* secp192k1 (18) */
-		NID_X9_62_prime192v1, /* secp192r1 (19) */ 
-		NID_secp224k1, /* secp224k1 (20) */ 
-		NID_secp224r1, /* secp224r1 (21) */
-		NID_secp256k1, /* secp256k1 (22) */ 
-		NID_X9_62_prime256v1, /* secp256r1 (23) */ 
-		NID_secp384r1, /* secp384r1 (24) */
-		NID_secp521r1  /* secp521r1 (25) */	
-	};
-	
-	if ((curve_id < 1) || (curve_id > 25)) return 0;
+        /* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
+         * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
+        static int nid_list[26] =
+        {
+                0,
+                NID_sect163k1, /* sect163k1 (1) */
+                NID_sect163r1, /* sect163r1 (2) */
+                NID_sect163r2, /* sect163r2 (3) */
+                NID_sect193r1, /* sect193r1 (4) */
+                NID_sect193r2, /* sect193r2 (5) */
+                NID_sect233k1, /* sect233k1 (6) */
+                NID_sect233r1, /* sect233r1 (7) */
+                NID_sect239k1, /* sect239k1 (8) */
+                NID_sect283k1, /* sect283k1 (9) */
+                NID_sect283r1, /* sect283r1 (10) */
+                NID_sect409k1, /* sect409k1 (11) */
+                NID_sect409r1, /* sect409r1 (12) */
+                NID_sect571k1, /* sect571k1 (13) */
+                NID_sect571r1, /* sect571r1 (14) */
+                NID_secp160k1, /* secp160k1 (15) */
+                NID_secp160r1, /* secp160r1 (16) */
+                NID_secp160r2, /* secp160r2 (17) */
+                NID_secp192k1, /* secp192k1 (18) */
+                NID_X9_62_prime192v1, /* secp192r1 (19) */
+                NID_secp224k1, /* secp224k1 (20) */
+                NID_secp224r1, /* secp224r1 (21) */
+                NID_secp256k1, /* secp256k1 (22) */
+                NID_X9_62_prime256v1, /* secp256r1 (23) */
+                NID_secp384r1, /* secp384r1 (24) */
+                NID_secp521r1  /* secp521r1 (25) */
+        };
+
+        if ((curve_id < 1) || (curve_id > 25)) return 0;
 
-	return nid_list[curve_id];
+        return nid_list[curve_id];
 }
 #endif
 
@@ -2698,47 +3243,47 @@
 
 #ifndef OPENSSL_NO_TLSEXT
 static int ssl3_check_finished(SSL *s)
-	{
-	int ok;
-	long n;
-	/* If we have no ticket or session ID is non-zero length (a match of
-	 * a non-zero session length would never reach here) it cannot be a
-	 * resumed session.
-	 */
-	if (!s->session->tlsext_tick || s->session->session_id_length)
-		return 1;
-	/* this function is called when we really expect a Certificate
-	 * message, so permit appropriate message length */
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_CR_CERT_A,
-		SSL3_ST_CR_CERT_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-	if (!ok) return((int)n);
-	s->s3->tmp.reuse_message = 1;
-	if ((s->s3->tmp.message_type == SSL3_MT_FINISHED)
-		|| (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))
-		return 2;
+        {
+        int ok;
+        long n;
+        /* If we have no ticket or session ID is non-zero length (a match of
+         * a non-zero session length would never reach here) it cannot be a
+         * resumed session.
+         */
+        if (!s->session->tlsext_tick || s->session->session_id_length)
+                return 1;
+        /* this function is called when we really expect a Certificate
+         * message, so permit appropriate message length */
+        n=s->method->ssl_get_message(s,
+                SSL3_ST_CR_CERT_A,
+                SSL3_ST_CR_CERT_B,
+                -1,
+                s->max_cert_list,
+                &ok);
+        if (!ok) return((int)n);
+        s->s3->tmp.reuse_message = 1;
+        if ((s->s3->tmp.message_type == SSL3_MT_FINISHED)
+                || (s->s3->tmp.message_type == SSL3_MT_NEWSESSION_TICKET))
+                return 2;
 
-	return 1;
-	}
+        return 1;
+        }
 #endif
 
 int ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey)
-	{
-	int i = 0;
+        {
+        int i = 0;
 #ifndef OPENSSL_NO_ENGINE
-	if (s->ctx->client_cert_engine)
-		{
-		i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,
-						SSL_get_client_CA_list(s),
-						px509, ppkey, NULL, NULL, NULL);
-		if (i != 0)
-			return i;
-		}
-#endif
-	if (s->ctx->client_cert_cb)
-		i = s->ctx->client_cert_cb(s,px509,ppkey);
-	return i;
-	}
+        if (s->ctx->client_cert_engine)
+                {
+                i = ENGINE_load_ssl_client_cert(s->ctx->client_cert_engine, s,
+                                                SSL_get_client_CA_list(s),
+                                                px509, ppkey, NULL, NULL, NULL);
+                if (i != 0)
+                        return i;
+                }
+#endif
+        if (s->ctx->client_cert_cb)
+                i = s->ctx->client_cert_cb(s,px509,ppkey);
+        return i;
+        }
diff -Naur openssl-0.9.8j/ssl/s3_enc.c TurboSSL-0.9.8j/ssl/s3_enc.c
--- openssl-0.9.8j/ssl/s3_enc.c	2008-06-16 18:56:41.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s3_enc.c	2010-05-31 12:14:39.000000000 +0200
@@ -204,6 +204,10 @@
 	EVP_MD_CTX md;
 	int is_exp,n,i,j,k,cl;
 	int reuse_dd = 0;
+#ifdef CAVIUM_SSL
+        if(s->cipher_support)
+                return 1;
+#endif /*cavium_ssl */
 
 	is_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
 	c=s->s3->tmp.new_sym_enc;
@@ -365,6 +369,10 @@
 	int num;
 	int ret = 0;
 	SSL_COMP *comp;
+#ifdef CAVIUM_SSL
+	if (s->cipher_support)
+		return(1);
+#endif
 
 	if (s->s3->tmp.key_block_length != 0)
 		return(1);
@@ -517,18 +525,68 @@
 	return(1);
 	}
 
+/**************************************************************************
+ * OpenSSL uses this function to initialize handhsake hashes  contexts.   *
+ * If CAVIUM_SSL is defined then initialze separate contexts to be used   *
+ * by TurboSSL.                                                           *
+ **************************************************************************/
 void ssl3_init_finished_mac(SSL *s)
 	{
 	EVP_MD_CTX_set_flags(&(s->s3->finish_dgst1),
 		EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
+#ifdef CAVIUM_SSL
+    s->hs_msgs_len = 0;
+#endif	
+
 	EVP_DigestInit_ex(&(s->s3->finish_dgst1),s->ctx->md5, NULL);
 	EVP_DigestInit_ex(&(s->s3->finish_dgst2),s->ctx->sha1, NULL);
 	}
 
+/**************************************************************************
+ * OpenSSL uses this function to update handhsake hashes when it recives  *
+ * or sends a handshake message. If CAVIUM_SSL is defined then instead    *
+ * of updating hashes, we store the messages in hs_msgs buffer.           *
+ **************************************************************************/
 void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)
 	{
+#ifdef CAVIUM_SSL
+    if((s->cipher_support) || (s->state==SSL3_ST_SR_CLNT_HELLO_B)
+                    ||  (s->state==SSL3_ST_SR_CLNT_HELLO_C)
+                    || (s->state==SSL23_ST_SR_CLNT_HELLO_B)
+                    ||(s->state==SSL3_ST_CW_CLNT_HELLO_A)
+                    ||(s->state==SSL3_ST_CW_CLNT_HELLO_B)
+                    ||(s->state==SSL3_ST_CR_SRVR_HELLO_A)
+                    ||(s->state==SSL3_ST_CR_SRVR_HELLO_B)
+                    ||(s->state==SSL23_ST_CW_CLNT_HELLO_A)
+                    ||(s->state==SSL23_ST_CW_CLNT_HELLO_B)
+                    ||(s->state==SSL23_ST_CR_SRVR_HELLO_A)
+                    ||(s->state==SSL23_ST_CR_SRVR_HELLO_B))
+    {
+
+        /* check to see if we have enough space in buffer */
+        if(s->hs_msgs_len+len >= s->hs_msgs_total_len)
+        {
+            /* re-allocate some more memory*/
+            s->hs_msgs_total_len += len + CH_SR_MSGS_LEN;
+            s->hs_msgs = OPENSSL_realloc(s->hs_msgs,s->hs_msgs_total_len);
+            /* check for NULL returned from reaaloc */
+        }
+
+        /* copy ther handshake message */
+        memcpy(&(s->hs_msgs[s->hs_msgs_len]),(unsigned char*)buf,len);
+        /* update message length */
+        s->hs_msgs_len += len;
+    }
+    if(!s->cipher_support)
+    {
+        EVP_DigestUpdate(&(s->s3->finish_dgst1),buf,len);
+        EVP_DigestUpdate(&(s->s3->finish_dgst2),buf,len);
+    }
+
+#else
 	EVP_DigestUpdate(&(s->s3->finish_dgst1),buf,len);
 	EVP_DigestUpdate(&(s->s3->finish_dgst2),buf,len);
+#endif	
 	}
 
 int ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *ctx, unsigned char *p)
@@ -588,6 +646,9 @@
 	unsigned char *mac_sec,*seq;
 	EVP_MD_CTX md_ctx;
 	const EVP_MD *hash;
+#ifndef CAVIUM_SSL	
+    unsigned char *ipad,*opad;  
+#endif		
 	unsigned char *p,rec_char;
 	unsigned int md_size;
 	int npad;
@@ -597,6 +658,10 @@
 		rec= &(ssl->s3->wrec);
 		mac_sec= &(ssl->s3->write_mac_secret[0]);
 		seq= &(ssl->s3->write_sequence[0]);
+#ifndef CAVIUM_SSL
+                ipad = &(ssl->s3->write_ipad_hash[0]);
+                opad = &(ssl->s3->write_opad_hash[0]);
+#endif
 		hash=ssl->write_hash;
 		}
 	else
@@ -604,6 +669,10 @@
 		rec= &(ssl->s3->rrec);
 		mac_sec= &(ssl->s3->read_mac_secret[0]);
 		seq= &(ssl->s3->read_sequence[0]);
+#ifndef CAVIUM_SSL
+                ipad = &(ssl->s3->read_ipad_hash[0]);
+                opad = &(ssl->s3->read_opad_hash[0]);
+#endif
 		hash=ssl->read_hash;
 		}
 
@@ -614,8 +683,18 @@
 	EVP_MD_CTX_init(&md_ctx);
 
 	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
+#ifndef CAVIUM_SSL
+    if(ssl->handshake_support && EVP_MD_type(hash) == NID_md5)
+        EVP_Digest_new_init(&md_ctx,ipad);
+    else {
+#endif
 	EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
 	EVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);
+#ifndef CAVIUM_SSL
+    }
+    if(ssl->record_process && EVP_MD_type(hash) == NID_md5)
+        EVP_Copy_Pad(&md_ctx,ipad);
+#endif
 	EVP_DigestUpdate(&md_ctx,seq,8);
 	rec_char=rec->type;
 	EVP_DigestUpdate(&md_ctx,&rec_char,1);
@@ -626,8 +705,18 @@
 	EVP_DigestFinal_ex( &md_ctx,md,NULL);
 
 	EVP_DigestInit_ex(  &md_ctx,hash, NULL);
+#ifndef CAVIUM_SSL
+    if(ssl->handshake_support && EVP_MD_type(hash) == NID_md5)
+        EVP_Digest_new_init(&md_ctx,opad);
+    else {
+#endif
 	EVP_DigestUpdate(&md_ctx,mac_sec,md_size);
 	EVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);
+#ifndef CAVIUM_SSL
+    }
+    if(ssl->record_process && EVP_MD_type(hash) == NID_md5)
+        EVP_Copy_Pad(&md_ctx,opad);
+#endif
 	EVP_DigestUpdate(&md_ctx,md,md_size);
 	EVP_DigestFinal_ex( &md_ctx,md,&md_size);
 
diff -Naur openssl-0.9.8j/ssl/s3_lib.c TurboSSL-0.9.8j/ssl/s3_lib.c
--- openssl-0.9.8j/ssl/s3_lib.c	2008-06-16 18:56:41.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s3_lib.c	2010-05-31 12:13:09.000000000 +0200
@@ -131,6 +131,18 @@
 #include <openssl/dh.h>
 #endif
 #include <openssl/pq_compat.h>
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#else
+#include "cavium_common.h"
+#endif
+#ifdef linux
+#include <sys/mman.h>
+#endif
+
+#include "openssl/cav_debug.h"
+#endif
 
 const char ssl3_version_str[]="SSLv3" OPENSSL_VERSION_PTEXT;
 
@@ -1680,9 +1692,37 @@
 
 	ssl3_cleanup_key_block(s);
 	if (s->s3->rbuf.buf != NULL)
+#ifdef CAVIUM_SSL
+#if !defined (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+	{
+        munmap(s->s3->o_rbuf_buf, (5*4096));
+        cav_fprintf(cav_nb_fp, "ssl3_free(): %s %p\n",
+                               "unmapping s->s3->o_rbuf_buf = ", s->s3->o_rbuf_buf);
+        s->s3->o_rbuf_buf=NULL;
+        s->s3->rbuf.buf = NULL;
+	}
+#else
 		OPENSSL_free(s->s3->rbuf.buf);
+#endif // CAVIUM_NO_MMAP
+#else
+		OPENSSL_free(s->s3->rbuf.buf);
+#endif		
 	if (s->s3->wbuf.buf != NULL)
+#ifdef CAVIUM_SSL
+#if !defined (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+	{
+        munmap(s->s3->o_wbuf_buf, (5*4096));
+        cav_fprintf(cav_nb_fp, "ssl3_free(): %s %p\n",
+                               "unmapping s->s3->o_wbuf_buf = ", s->s3->o_wbuf_buf);
+        s->s3->o_wbuf_buf=NULL;
+        s->s3->wbuf.buf=NULL;
+	}
+#else
 		OPENSSL_free(s->s3->wbuf.buf);
+#endif // CAVIUM_NO_MMAP
+#else
+		OPENSSL_free(s->s3->wbuf.buf);
+#endif
 	if (s->s3->rrec.comp != NULL)
 		OPENSSL_free(s->s3->rrec.comp);
 #ifndef OPENSSL_NO_DH
@@ -1710,6 +1750,12 @@
 	{
 	unsigned char *rp,*wp;
 	size_t rlen, wlen;
+#ifdef CAVIUM_SSL
+#if !defined  (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+    unsigned char *o_rbuf_buf = NULL;
+    unsigned char *o_wbuf_buf = NULL;
+#endif
+#endif
 
 	ssl3_cleanup_key_block(s);
 	if (s->s3->tmp.ca_names != NULL)
@@ -1736,12 +1782,45 @@
 
 	EVP_MD_CTX_cleanup(&s->s3->finish_dgst1);
 	EVP_MD_CTX_cleanup(&s->s3->finish_dgst2);
+#ifdef CAVIUM_SSL
+#if !defined  (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+    if (s->s3->rbuf.buf != NULL) {
+        cav_fprintf(cav_nb_fp, "ssl3_clear():saving o_rbuf_buf %p\n",
+                                s->s3->o_rbuf_buf);
+        o_rbuf_buf = s->s3->o_rbuf_buf;
+    }
+    if (s->s3->wbuf.buf != NULL) {
+        cav_fprintf(cav_nb_fp, "ssl3_clear():saving o_wbuf_buf %p\n",
+                                s->s3->o_wbuf_buf);
+        o_wbuf_buf = s->s3->o_wbuf_buf;
+    }
+#endif
+#endif // CAVIUM_SSL
+
 
 	memset(s->s3,0,sizeof *s->s3);
 	s->s3->rbuf.buf = rp;
 	s->s3->wbuf.buf = wp;
 	s->s3->rbuf.len = rlen;
  	s->s3->wbuf.len = wlen;
+#ifdef CAVIUM_SSL
+#if !defined  (CAVIUM_NO_MMAP) && !defined (CAVIUM_FIPS)
+    if ( o_rbuf_buf != NULL ) {
+        s->s3->o_rbuf_buf = o_rbuf_buf;
+        s->s3->rbuf.buf = o_rbuf_buf + 3;
+        s->s3->rbuf.buf[0] = 1;
+        cav_fprintf(cav_nb_fp, "ssl3_clear():restoring o_rbuf_buf %p\n",
+                                s->s3->o_rbuf_buf);
+    }
+    if ( o_wbuf_buf != NULL ) {
+        s->s3->o_wbuf_buf = o_wbuf_buf;
+        s->s3->wbuf.buf = o_wbuf_buf + 3;
+        s->s3->wbuf.buf[0] = 1;
+        cav_fprintf(cav_nb_fp, "ssl3_clear():restoring o_wbuf_buf %p\n",
+                                s->s3->o_wbuf_buf);
+    }
+#endif
+#endif
 
 	ssl_free_wbio_buffer(s);
 
@@ -2480,6 +2559,9 @@
 		{
 		/* resend it if not sent */
 #if 1
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"ssl3_shutdown \n");
+#endif
 		s->method->ssl_dispatch_alert(s);
 #endif
 		}
@@ -2491,14 +2573,27 @@
 
 	if ((s->shutdown == (SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN)) &&
 		!s->s3->alert_dispatch)
+        {
+#ifdef CAVIUM_SSL		
+		cav_fprintf(cav_nb_fp,"ssl3_shutdown returning 1 \n");
+#endif		
 		return(1);
+		}
 	else
+		{
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"ssl3_shutdown returning 0\n");
+#endif		
 		return(0);
+		}
 	}
 
 int ssl3_write(SSL *s, const void *buf, int len)
 	{
 	int ret,n;
+#ifdef CAVIUM_SSL		
+    cav_fprintf(cav_nb_fp,"ssl3_write(): entry\n");
+#endif	
 
 #if 0
 	if (s->shutdown & SSL_SEND_SHUTDOWN)
@@ -2541,9 +2636,24 @@
 		}
 	else
 		{
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"ssl3_write(): before ssl3_write_bytes()\n");
+#endif		
 		ret=s->method->ssl_write_bytes(s,SSL3_RT_APPLICATION_DATA,
 			buf,len);
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"ssl3_write(): after ssl3_write_bytes()\n");
+#endif		
 		if (ret <= 0) return(ret);
+		    {
+#ifdef CAVIUM_SSL		
+            cav_fprintf(cav_nb_fp,"ssl3_write(): ssl3_write_bytes() ret <= 0\n");
+#endif			
+			return (ret);
+			}
+#ifdef CAVIUM_SSL		
+            cav_fprintf(cav_nb_fp,"ssl3_write(): ssl3_write_bytes() ret=%d\n",ret);
+#endif			
 		}
 
 	return(ret);
@@ -2553,6 +2663,9 @@
 	{
 	int ret;
 	
+#ifdef CAVIUM_SSL		
+    cav_fprintf(cav_nb_fp,"ssl3_read_internal(): entry\n");
+#endif	
 	clear_sys_error();
 	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
 	s->s3->in_read_app_data=1;
diff -Naur openssl-0.9.8j/ssl/s3_pkt.c TurboSSL-0.9.8j/ssl/s3_pkt.c
--- openssl-0.9.8j/ssl/s3_pkt.c	2008-10-10 12:41:32.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/s3_pkt.c	2010-05-31 12:13:09.000000000 +0200
@@ -115,11 +115,25 @@
 #include "ssl_locl.h"
 #include <openssl/evp.h>
 #include <openssl/buffer.h>
+#ifdef CAVIUM_SSL
+#include "ssl_engine.h"
+#include "openssl/cav_debug.h"
+#ifndef CAVIUM_NOMMAP
+extern int CSP1_driver_handle;
+#endif
+#endif
+
 
 static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
 			 unsigned int len, int create_empty_fragment);
 static int ssl3_get_record(SSL *s);
 
+#ifdef CAVIUM_SSL
+#define CAV_MAX_VRFY_MSG_LEN 91
+extern int check_decrypt_completion(SSL *s);
+extern int check_encrypt_completion(SSL *s);
+#endif
+
 int ssl3_read_n(SSL *s, int n, int max, int extend)
 	{
 	/* If extend == 0, obtain new n-byte packet; if extend == 1, increase
@@ -131,6 +145,28 @@
 	 */
 	int i,off,newb;
 
+#ifdef CAVIUM_SSL
+    cav_fprintf(cav_nb_fp,
+            "ssl3_read_n(): entry, n = %d, max = %d, extend = %d\n",
+            n, max, extend);
+    //if ( s->cav_renego > 0 ) {
+    if ( s->cav_renego > 0 && s->cipher_support ) {
+        //if (( s->state == SSL3_ST_SR_CERT_A ) || (s->state == SSL3_ST_CR_SRVR_HELLO_A) || (s->state == SSL3_ST_CR_CERT_A)|| (s->state == SSL3_ST_CW_KEY_EXCH_A)|| (s->state == SSL3_ST_CR_KEY_EXCH_A))  {
+        if ( (s->cipher_type == NID_rc4 ||
+              s->cipher_type == NID_rc4_40)
+             &&
+             ((s->digest_type == NID_md5) || (s->digest_type == NID_sha1)))
+              {
+                  if ( max > n ) {
+                      max = n;
+                      cav_fprintf(cav_nb_fp,
+                          "ssl3_read_n(): resetting max to n = %d\n", n);
+                  }
+               }
+           //}
+            }
+#endif
+
 	if (!extend)
 		{
 		/* start with empty packet ... */
@@ -155,6 +191,10 @@
 		s->packet_length+=n;
 		s->s3->rbuf.left-=n;
 		s->s3->rbuf.offset+=n;
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,
+                       "ssl3_read_n(): returning from buf left to n = %d\n", n);
+#endif					   
 		return(n);
 		}
 
@@ -185,6 +225,10 @@
 		memmove(s->s3->rbuf.buf, s->packet, off+newb);
 		s->packet = s->s3->rbuf.buf;
 		}
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,
+                "ssl3_read_n(): before while newb= %d ,n= %d, max= %d , off= %d\n", newb , n, max, off);
+#endif				
 
 	while (newb < n)
 		{
@@ -206,8 +250,11 @@
 		if (i <= 0)
 			{
 			s->s3->rbuf.left = newb;
-			return(i);
-			}
+#ifdef CAVIUM_SSL			
+            cav_fprintf(cav_nb_fp,
+                    "ssl3_read_n(): returning from i = %d\n", i);
+#endif					
+			return(i);		}
 		newb+=i;
 		}
 
@@ -216,6 +263,10 @@
 	s->s3->rbuf.left = newb - n;
 	s->packet_length += n;
 	s->rwstate=SSL_NOTHING;
+#ifdef CAVIUM_SSL			
+    cav_fprintf(cav_nb_fp,
+            "ssl3_read_n(): returning from end = %d\n", n);
+#endif					
 	return(n);
 	}
 
@@ -240,11 +291,85 @@
 	unsigned int mac_size;
 	int clear=0;
 	size_t extra;
+#ifdef CAVIUM_SSL
+    int rlen;
+    int throw_zero_rrec = 0;
+#endif
 	int decryption_failed_or_bad_record_mac = 0;
 	unsigned char *mac = NULL;
 
 	rr= &(s->s3->rrec);
 	sess=s->session;
+    /*
+     * Check if this request was sent ealier, and
+     * that all we need to do is to check for it's
+     * completion.
+     */
+
+#ifdef CAVIUM_SSL
+    if ( s->cav_crypto_state == CAV_ST_IN_DECRYPT ) {
+
+        cav_fprintf(cav_nb_fp,"ssl3_get_record(): crypto_state CAV_ST_IN_DECRYPT\n");
+        // =====
+        if ( (rlen = check_decrypt_completion(s)) == 0 ) {
+            cav_fprintf(cav_nb_fp,"ssl3_get_record(): %s\n",
+                            "check_decrypt_completion() returned 0\n");
+        }
+        else if ( rlen == -1 ) {
+            cav_fprintf(cav_nb_fp,"ssl3_get_record(): %s\n",
+                                  "ERROR check_decrypt_completion() failed\n");
+        }
+        else {
+            if ((!s->server) && (s->cav_renego >0) && (s->cav_nb_mode == 1) && (s->state == SSL3_ST_CR_SRVR_HELLO_A)) {
+                rr->off=0;
+                rr->data = rr->input;
+            }
+
+            cav_fprintf(cav_nb_fp,"ssl3_get_record(): %s %d\n",
+                                "prior request has completed", rlen);
+        }
+        // =====
+
+                // FIX for 0 byte record!
+                /***
+                if ( rlen == 0 ) {
+                        return(0);
+                }
+                ***/
+        if ( rlen == 0 ) {
+            if ( s->cav_crypto_state == CAV_ST_IN_DECRYPT ) {
+                cav_fprintf(cav_nb_fp, "%s %s\n",
+                        "ssl3_get_record(): got 0 bytes from ",
+                        "check_decrypt_completion(), but it's non-blocking");
+                return(0);
+            }
+        	else {
+            	cav_fprintf(cav_nb_fp, "%s %s\n",
+                                "ssl3_get_record(): got 0 byte record",
+                                "from check_decrypt_completion");
+            	throw_zero_rrec = 1;    // do not return to app
+        	}
+    	}
+    	// ----------------------
+	    if(rlen < 0)
+    	 {
+        	 SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DIGEST_CHECK_FAILED);
+	         goto err;
+    	 }
+	     else
+    	 {
+        	 rr->length = rlen;
+	     }
+
+    	 if ( throw_zero_rrec == 1 )  {
+        	 cav_fprintf(cav_nb_fp,
+                 "ssl3_get_record(): throw away zero byte record that we received\n");
+     	}
+     	else {
+        	return(1);
+     	}
+    } // end if cav_crypto_state
+#endif
 
 	if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
 		extra=SSL3_RT_MAX_EXTRA;
@@ -264,6 +389,9 @@
 		(s->packet_length < SSL3_RT_HEADER_LENGTH)) 
 		{
 		n=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"ssl3_get_record(): after ssl3_read_n-1(), n = %d\n", n);
+#endif		
 		if (n <= 0) return(n); /* error or non-blocking */
 		s->rstate=SSL_ST_READ_BODY;
 
@@ -281,6 +409,11 @@
 			{
 			if (version != s->version)
 				{
+#ifdef CAVIUM_SSL				
+                cav_fprintf(cav_nb_fp,
+                              "ssl3_get_record(): wrong version, version = 0x%0x, s->version = 0x%0x\n",
+                               version, s->version);
+#endif
 				SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
 				/* Send back error using their
 				 * version number :-) */
@@ -292,12 +425,22 @@
 
 		if ((version>>8) != SSL3_VERSION_MAJOR)
 			{
+#ifdef CAVIUM_SSL				
+            cav_fprintf(cav_nb_fp,
+            "ssl3_get_record(): wrong major version, version>>8 = 0x%0x, SSL_VERSION_MAJOR = 0x%0x\n",
+            (version>>8), SSL3_VERSION_MAJOR);
+#endif
 			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);
 			goto err;
 			}
 
 		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)
 			{
+#ifdef CAVIUM_SSL				
+            cav_fprintf(cav_nb_fp,
+                    "ssl3_get_record(): wrong rr->length, rr->length = %d",
+                    rr->length);
+#endif					
 			al=SSL_AD_RECORD_OVERFLOW;
 			SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);
 			goto f_err;
@@ -307,12 +450,23 @@
 		}
 
 	/* s->rstate == SSL_ST_READ_BODY, get and decode the data */
+#ifdef CAVIUM_SSL				
+        cav_fprintf(cav_nb_fp,
+                        "ssl3_get_record(): before rr->length comparision\n");
+#endif
 
 	if (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)
 		{
 		/* now s->packet_length == SSL3_RT_HEADER_LENGTH */
 		i=rr->length;
+#ifdef CAVIUM_SSL				
+        cav_fprintf(cav_nb_fp,"ssl3_get_record(): before ssl3_read_n-2()\n");
+#endif		
 		n=ssl3_read_n(s,i,i,1);
+#ifdef CAVIUM_SSL				
+        cav_fprintf(cav_nb_fp,
+                "ssl3_get_record(): after ssl3_read_n-2(), rr->type = %d, n = %d\n", rr->type, n);
+#endif				
 		if (n <= 0) return(n); /* error or non-blocking io */
 		/* now n == rr->length,
 		 * and s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length */
@@ -345,6 +499,78 @@
 
 	/* decrypt in place in 'rr->input' */
 	rr->data=rr->input;
+#ifdef CAVIUM_SSL
+	if(s->cipher_support)
+	{
+
+		if(!s->read_cipher_active) {
+/* renegotiation fix for client authentication */
+	
+		 	if ((s->cav_renego > 0) && ((s->state == SSL3_ST_SR_CERT_VRFY_A) || (s->state == SSL3_ST_CW_CERT_VRFY_A)))
+			{
+				clear = 0 ;
+			}
+			else
+			{
+				clear=1;
+			}
+			
+		}
+		/* first check if it is message is plain*/
+		if(clear)
+		{
+			memcpy(rr->data,rr->input,rr->length);
+			rr->input=rr->data;
+		}
+		else
+		{
+			if (s->cav_renego == 5) {
+				/* to decrypt data after reneg in non block */
+				if ((!s->server ) && (s->state == SSL_ST_OK) && (s->cav_renego > 0))
+					goto tryf ;
+				cav_fprintf(cav_nb_fp,
+					"ssl3_read_bytes(): s->cav_renego = 5\n");
+			}
+			else if (s->s3->rrec.type == SSL3_RT_CHANGE_CIPHER_SPEC )  {
+				cav_fprintf(cav_nb_fp,
+				"ssl3_read_bytes(): change cipher spec msg type\n");
+				s->cav_renego = 5;
+			}
+			else
+			{
+tryf:			rlen = pkp_decrypt_record(s);
+			cav_fprintf(cav_nb_fp,
+				"ssl3_get_record(): pkp_decrypt_record-2() rlen = %d\n",rlen);
+			// Fix for 0 byte record
+			if ( rlen == 0 ) {
+				if ( s->cav_crypto_state == CAV_ST_IN_DECRYPT ) {
+					cav_fprintf(cav_nb_fp, "%s %s\n",
+						"ssl3_get_record(): got 0 bytes from ",
+						"pkp_decrypt_record(), but it's non-blocking");
+					return(0);
+				}
+				else {
+					cav_fprintf(cav_nb_fp, 
+						"ssl3_get_record(): got 0 bytes record\n");
+				}
+			}
+			// -----
+
+			if(rlen < 0)
+			{
+				SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DIGEST_CHECK_FAILED);
+				goto err;
+			}
+			else
+			{
+				rr->length = rlen;
+			}
+		   }
+	      }
+	}/* cipher support */
+	else
+        {
+#endif /* CAVIUM_SSL */
 
 	enc_err = s->method->ssl3_enc->enc(s,0);
 	if (enc_err <= 0)
@@ -422,6 +648,10 @@
 		SSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
 		goto f_err;
 		}
+#ifdef CAVIUM_SSL
+	}/* cipher support */
+	 cav_fprintf(cav_nb_fp,"ssl3_get_record(): before s->expand\n");
+#endif /* CAVIUM_SSL */
 
 	/* r->length is now just compressed */
 	if (s->expand != NULL)
@@ -567,20 +797,84 @@
 			 unsigned int len, int create_empty_fragment)
 	{
 	unsigned char *p,*plen;
-	int i,mac_size,clear=0;
+	int i,mac_size=0,clear=0;
 	int prefix_len = 0;
 	SSL3_RECORD *wr;
 	SSL3_BUFFER *wb;
 	SSL_SESSION *sess;
+#ifdef CAVIUM_SSL
+    int wlen;
+    int nav_bytes_written;
+
+    /*
+     * Check if this request was sent ealier, and
+     * that all we need to do is to check for it's
+     * completion.
+     */
+    if ( s->cav_crypto_state == CAV_ST_IN_ENCRYPT) {
+
+        //s->cav_crypto_state = 0;
+
+        plen = (unsigned char *)s->cav_plen;
+        prefix_len = s->cav_prefix_len;
+        wr = &(s->s3->wrec);
+        wb= &(s->s3->wbuf);
+        sess=s->session;
+
+        cav_fprintf(cav_nb_fp,"do_ssl3_write(): plen = %p, prefix_len = %d, wr->length = %d, wr->data = %p\n",
+        plen, prefix_len, wr->length, wr->data);
+
+        if ( (wlen = check_encrypt_completion(s)) == 0 ) {
+            cav_fprintf(cav_nb_fp,"do_ssl3_write(): %s\n",
+                        "prior request has not completed");
+        }
+        else if ( wlen == -1 ) {
+            cav_fprintf(cav_nb_fp,"do_ssl3_write(): %s\n",
+                        "ERROR check_encrypt_completion() failed\n");
+        }
+        else {
+            cav_fprintf(cav_nb_fp,"do_ssl3_write(): %s\n",
+                        "prior request has completed");
+        }
+        if ( wlen == 0 ) {
+            cav_fprintf(cav_nb_fp,"do_ssl3_write(): returning 0\n");
+            return(0);
+        }
+
+        if(wlen < 0 ) {
+            cav_fprintf(cav_nb_fp,"do_ssl3_write(): wlen < 0\n");
+                SSLerr(SSL_F_DO_SSL3_WRITE,SSL_R_DIGEST_CHECK_FAILED);
+            goto err;
+        }
+        else {
+            wr->length = wlen;
+        }
 
+        goto AFTER_CRYPTO_DONE;
+
+    } // end CAV_ST_IN_ENCRYPT
+#endif /* CAVIUM_SSL*/
 	/* first check if there is a SSL3_BUFFER still being written
 	 * out.  This will happen with non blocking IO */
 	if (s->s3->wbuf.left != 0)
+#ifdef CAVIUM_SSL
+    {
+        cav_fprintf(cav_nb_fp,"do_ssl3_write(): before ssl3_write_pending()-1\n");
+        nav_bytes_written = ssl3_write_pending(s,type,buf,len);
+        cav_fprintf(cav_nb_fp,"do_ssl3_write(): ssl3_write_pending()-1 wrote %d bytes\n",
+                nav_bytes_written);
+        return(nav_bytes_written);
+    }
+#else
 		return(ssl3_write_pending(s,type,buf,len));
+#endif		
 
 	/* If we have an alert to send, lets send it */
 	if (s->s3->alert_dispatch)
 		{
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"do_ssl3_write(): calling dispatch alert\n");
+#endif		
 		i=s->method->ssl_dispatch_alert(s);
 		if (i <= 0)
 			return(i);
@@ -594,6 +888,24 @@
 	wb= &(s->s3->wbuf);
 	sess=s->session;
 
+#ifdef CAVIUM_SSL
+    if(s->cipher_support)
+    {
+        if(!s->write_cipher_active){
+                 clear =1;
+        }
+
+        /*if (clear)
+        mac_size=0;
+        else
+        mac_size=EVP_MD_size(s->write_hash);
+        */
+
+    }/* cipher_support */
+    else
+    {
+#endif
+
 	if (	(sess == NULL) ||
 		(s->enc_write_ctx == NULL) ||
 		(s->write_hash == NULL))
@@ -616,6 +928,10 @@
 			 * this prepares and buffers the data for an empty fragment
 			 * (these 'prefix_len' bytes are sent out later
 			 * together with the actual payload) */
+#ifdef CAVIUM_SSL			 
+             cav_fprintf(cav_nb_fp,
+                               "do_ssl3_write(): before do_ssl3_write()-2\n");
+#endif							   
 			prefix_len = do_ssl3_write(s, type, buf, 0, 1);
 			if (prefix_len <= 0)
 				goto err;
@@ -630,6 +946,9 @@
 		
 		s->s3->empty_fragment_done = 1;
 		}
+#ifdef CAVIUM_SSL
+	}/* cipher support*/
+#endif /* CAVIUM_SSL */
 
 	p = wb->buf + prefix_len;
 
@@ -664,13 +983,81 @@
 		}
 	else
 		{
+#ifdef CAVIUM_SSL
+        cav_fprintf(cav_nb_fp,"+++++++++++do_ssl3_write(): %s\n",
+                            "memcpy(wr->data,wr->input,wr->length)");
+#endif
 		memcpy(wr->data,wr->input,wr->length);
 		wr->input=wr->data;
+#ifdef CAVIUM_SSL
+        cav_fprintf(cav_nb_fp,"do_ssl3_write(): after memcpy\n");
+#endif
 		}
+#ifdef CAVIUM_SSL
+
+        /* wrec->data is where we should get the encrypted record
+        wrec->input is the source
+        wrec->length is the length of source
+        wrec->type has the content type
+        */
+        if(s->cipher_support)
+        {
+            /* check if it is clear text*/
+            if(!clear)
+            {
+                wlen = pkp_encrypt_record(s);
+                if ( wlen == 0 ) {
+                    if ( s->cav_crypto_state == CAV_ST_IN_ENCRYPT ) {
+                        cav_fprintf(cav_nb_fp, "%s %s\n",
+                                "ssl3_get_record(): got 0 bytes from ",
+                                "pkp_encrypt_record(), but it's non-blocking");
+                                cav_print_state(s, "s3_pkt(): ");
+                        //return(0);
+                        s->cav_plen = (int *)plen;
+                        s->cav_prefix_len = prefix_len;
+                        cav_fprintf(cav_nb_fp,"do_ssl3_write(): returning 0. plen = %p, prefix_len = %d, wr->length = %d, wr->data = %p\n",
+                                plen, prefix_len, wr->length, wr->data);
+                        return(0);
+                    }
+                }
+
+                if(wlen < 0 )
+                {
+                    SSLerr(SSL_F_DO_SSL3_WRITE,SSL_R_DIGEST_CHECK_FAILED);
+                    goto err;
+                }
+                /*
+                if(wlen == 0)
+                {
+
+                    if (mac_size != 0)
+                    {
+                        s->method->ssl3_enc->mac(s,&(p[wr->length]),1);
+                        wr->length+=mac_size;
+                        wr->input=p;
+                        wr->data=p;
+                    }
+
+                    s->method->ssl3_enc->enc(s,1);
+                }
+                */
+
+                else
+                {
+                    wr->length = wlen;
+                }
+            }
+        }/* cipher_support */
+        else
+	{
+#endif /* CAVIUM_SSL */
 
 	/* we should still have the output to wr->data and the input
 	 * from wr->input.  Length should be wr->length.
 	 * wr->data still points in the wb->buf */
+#ifdef CAVIUM_SSL
+    cav_fprintf(cav_nb_fp,"do_ssl3_write(): before mac_size != 0\n");
+#endif /* CAVIUM_SSL */
 
 	if (mac_size != 0)
 		{
@@ -683,6 +1070,15 @@
 	/* ssl3_enc can only have an error on read */
 	s->method->ssl3_enc->enc(s,1);
 
+#ifdef CAVIUM_SSL
+	}/* !cipher_support */
+
+AFTER_CRYPTO_DONE:
+
+    cav_fprintf(cav_nb_fp,"do_ssl3_write(): before s2n()\n");
+
+#endif /* CAVIUM_SSL */
+
 	/* record length after mac and block padding */
 	s2n(wr->length,plen);
 
@@ -711,7 +1107,19 @@
 	s->s3->wpend_ret=len;
 
 	/* we now just need to write the buffer */
+#ifdef CAVIUM_SSL
+    cav_fprintf(cav_nb_fp,"do_ssl3_write(): before ssl3_write_pending, len = %d, wr->length = %d\n",
+            len, wr->length);
+
+    nav_bytes_written =  ssl3_write_pending(s,type,buf,len);
+
+    cav_fprintf(cav_nb_fp,"do_ssl3_write(): ssl3_write_pending() wrote %d bytes\n",
+    nav_bytes_written);
+
+    return (nav_bytes_written);
+#else
 	return ssl3_write_pending(s,type,buf,len);
+#endif	
 err:
 	return -1;
 	}
@@ -800,10 +1208,23 @@
 	unsigned int n;
 	SSL3_RECORD *rr;
 	void (*cb)(const SSL *ssl,int type2,int val)=NULL;
+#ifdef CAVIUM_SSL
+    cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): entry\n");
+#endif
 
 	if (s->s3->rbuf.buf == NULL) /* Not initialized yet */
+	{
+#ifdef CAVIUM_SSL
+        cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): in s->s3->rbuf.buf == NULL\n");
+#endif
 		if (!ssl3_setup_buffers(s))
+		{
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): in !ssl3_setup_buffers(s) returing -1\n");
+#endif
 			return(-1);
+		}
+	}
 
 	if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||
 	    (peek && (type != SSL3_RT_APPLICATION_DATA)))
@@ -856,10 +1277,21 @@
 	rr = &(s->s3->rrec);
 
 	/* get new packet if necessary */
-	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))
+#ifdef CAVIUM_SSL
+    cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): rr->length = %d, rstate = %d, crypto_state = %d\n",
+                rr->length, s->rstate, s->cav_crypto_state);
+#endif
+	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY)
+#ifdef CAVIUM_SSL
+                          || (s->cav_crypto_state == CAV_ST_IN_DECRYPT)
+#endif
+						)
 		{
 		ret=ssl3_get_record(s);
 		if (ret <= 0) return(ret);
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): ssl3_get_record() ret %d\n", ret);
+#endif
 		}
 
 	/* we now have a packet which can be read and processed */
@@ -877,6 +1309,10 @@
 	 * (even in 'peek' mode) */
 	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
 		{
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp,
+                        "ssl3_read_bytes(): if s->shutdown ...\n");
+#endif
 		rr->length=0;
 		s->rwstate=SSL_NOTHING;
 		return(0);
@@ -890,17 +1326,87 @@
 		if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
 			(s->enc_read_ctx == NULL))
 			{
+#ifdef CAVIUM_SSL
+                cav_fprintf(cav_nb_fp,
+                            "ssl3_read_bytes(): if s->enc_read_ctx\n");
+#endif
 			al=SSL_AD_UNEXPECTED_MESSAGE;
 			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
 			goto f_err;
 			}
 
-		if (len <= 0) return(len);
+		if (len <= 0) 
+		{
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp, "ssl3_read_bytes(): if len <= 0\n");
+#endif
+			return (len);
+		}
 
 		if ((unsigned int)len > rr->length)
 			n = rr->length;
 		else
 			n = (unsigned int)len;
+#ifdef CAVIUM_SSL
+        if(s->cipher_support)
+        {
+            cav_fprintf(cav_nb_fp,
+                    "ssl3_read_bytes(): if s->cipher_support\n");
+            if( ((s->state == SSL3_ST_SR_CERT_VRFY_A) && !(SSL_get_verify_mode
+            (s) & SSL_VERIFY_PEER))
+            ||
+            (s->state == SSL3_ST_SR_FINISHED_A)
+            ||
+            (s->state == SSL3_ST_CR_FINISHED_A)
+            ||
+            // for 0 cert
+        (
+            (s->state == SSL3_ST_SR_CERT_VRFY_A) &&
+            (SSL_get_verify_mode(s) & SSL_VERIFY_PEER ) &&
+            ((SSL_get_verify_mode(s) & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)==0)
+            && s->client_cert_verify_msg_offset == s->client_finish_msg_offset
+            && s->client_finish_msg_offset != 0
+            ) )
+
+            {
+			/* replace first four bytes with plain data. This 
+			   is necessary to avoid OpenSSL trying 
+			   to decrypt it.*/
+
+                buf[rr->off] = 20;  /* finish message type */
+                buf[rr->off+1] = 0;
+                buf[rr->off+2] = 0;
+                /*buf[rr->off+3] = 60;*/
+                buf[rr->off+3] = rr->length -n;
+
+			/* copy the original first four encrypted bytes. 
+			   This will be replaced by the four plain bytes 
+			   which we replaced above when TurboSSL handshake 
+			   function is called.*/
+                memcpy(s->peer_finish_first_four,&(rr->data[rr->off]),4);
+
+                rr->length-=n;
+                rr->off+=n;
+            }
+            else
+            {
+                memcpy(buf,&(rr->data[rr->off]),n);
+                if (!peek)
+                {
+                    rr->length-=n;
+                    rr->off+=n;
+                    if (rr->length == 0)
+                    {
+                        s->rstate=SSL_ST_READ_HEADER;
+                        rr->off=0;
+                    }
+                }
+            }
+            cav_fprintf(cav_nb_fp,"ssl3_read_bytes(): returning n-3 = %d\n", n);
+            return(n);
+        }/* Cipher_support */
+	else {
+#endif /* CAVIUM_SSL */
 
 		memcpy(buf,&(rr->data[rr->off]),n);
 		if (!peek)
@@ -915,7 +1421,9 @@
 			}
 		return(n);
 		}
-
+#ifdef CAVIUM_SSL
+		} /* Cipher_support */
+#endif /* CAVIUM_SSL */
 
 	/* If we get here, then type != rr->type; if we have a handshake
 	 * message, then it was unexpected (Hello Request or Client Hello). */
@@ -943,6 +1451,10 @@
 
 		if (dest_maxlen > 0)
 			{
+#ifdef CAVIUM_SSL
+                cav_fprintf(cav_nb_fp,
+                        "ssl3_read_bytes(): dest_maxlen > 0\n");
+#endif 
 			n = dest_maxlen - *dest_len; /* available space in 'dest' */
 			if (rr->length < n)
 				n = rr->length; /* available bytes */
@@ -1083,14 +1595,31 @@
 
 	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
 		{
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp,
+                       "ssl3_read_bytes(): SSL3_RT_CHANGE_CIPHER_SPEC\n");
+#endif 
 		/* 'Change Cipher Spec' is just a single byte, so we know
 		 * exactly what the record payload has to look like */
 		if (	(rr->length != 1) || (rr->off != 0) ||
 			(rr->data[0] != SSL3_MT_CCS))
 			{
+#ifdef CAVIUM_SSL
+                cav_fprintf(cav_nb_fp,
+                        "ssl3_read_bytes(): SSL3_MT_CCS\n");
+                if ( s->cav_renego ) {
+                        ;
+                }
+                else {
+                    al=SSL_AD_ILLEGAL_PARAMETER;
+                    SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
+                    goto f_err;
+                }
+#else
 			al=SSL_AD_ILLEGAL_PARAMETER;
 			SSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
 			goto f_err;
+#endif
 			}
 
 		/* Check we have a cipher to change to */
@@ -1107,11 +1636,20 @@
 			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);
 
 		s->s3->change_cipher_spec=1;
+#ifdef CAVIUM_SSL
+        cav_fprintf(cav_nb_fp,
+                        "ssl3_read_bytes(): before do_change_cipher_spec()\n");
+#endif
 		if (!ssl3_do_change_cipher_spec(s))
 			goto err;
 		else
+		{
+#ifdef CAVIUM_SSL
+            cav_fprintf(cav_nb_fp, "ssl3_read_bytes(): goto start 4\n");
+#endif
 			goto start;
 		}
+		}
 
 	/* Unexpected handshake message (Client Hello, or protocol violation) */
 	if ((s->s3->handshake_fragment_len >= 4) &&	!s->in_handshake)
@@ -1130,6 +1668,27 @@
 #endif
 			s->new_session=1;
 			}
+#ifdef CAVIUM_SSL
+        /*
+         * Renegotiation fix
+         */
+
+
+        if ( s->cipher_support || s->handshake_support) 
+		    {
+            cav_fprintf(cav_nb_fp,
+            		"ssl3_read_bytes(): setting cav_renego = 1\n");
+            s->cav_renego = 1;
+            if(s->handshake_support && pkp_write_updated_ssl_session_context(s)) 
+			    {
+                s->cipher_support = 1;
+                s->handshake_support = 0;
+                }
+            if(s->record_process && pkp_read_updated_ssl_session_context(s))
+                s->cipher_support = 0;
+            }
+#endif
+
 		i=s->handshake_func(s);
 		if (i < 0) return(i);
 		if (i == 0)
@@ -1225,6 +1784,38 @@
 	const char *sender;
 	int slen;
 
+#ifdef CAVIUM_SSL
+    if(s->cipher_support)
+    {
+        /* peer finish message starts here */
+        if(s->server)
+            s->client_finish_msg_offset = s->hs_msgs_len;
+        else
+            s->server_finish_msg_offset = s->hs_msgs_len;
+        if(s->hit)
+        {
+            cav_fprintf(cav_nb_fp,"do_change_cipher_spec():entering the hit condition \n");
+
+            if (s->state & SSL_ST_ACCEPT)
+                i=SSL3_CHANGE_CIPHER_SERVER_READ;
+            else
+                i=SSL3_CHANGE_CIPHER_CLIENT_READ;
+
+            if (s->s3->tmp.key_block == NULL)
+            {
+                s->session->cipher=s->s3->tmp.new_cipher;
+                if (!s->method->ssl3_enc->setup_key_block(s)) return(0);
+            }
+
+            /* Since it is a hit. So activate ciphers here */
+            if (!s->method->ssl3_enc->change_cipher_state(s,i))
+                return(0);
+        }
+    }
+    else
+    {
+#endif
+
 	if (s->state & SSL_ST_ACCEPT)
 		i=SSL3_CHANGE_CIPHER_SERVER_READ;
 	else
@@ -1265,6 +1856,12 @@
 		&(s->s3->finish_dgst2),
 		sender,slen,s->s3->tmp.peer_finish_md);
 
+#ifdef CAVIUM_SSL
+    }/* cipher support */
+    cav_fprintf(cav_nb_fp,
+            "ssl3_read_bytes(): returning  do_change_cipher_spec()\n");
+#endif /* CAVIUM_SSL*/
+
 	return(1);
 	}
 
@@ -1283,7 +1880,14 @@
 	s->s3->send_alert[0]=level;
 	s->s3->send_alert[1]=desc;
 	if (s->s3->wbuf.left == 0) /* data still being written out? */
+	{
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"s3_pkt.c ....ssl3 send alert \n");
+        ssl3_dispatch_alert(s);
+#else		
 		s->method->ssl_dispatch_alert(s);
+#endif		
+	}
 	/* else data is still being written out, we will get written
 	 * some time in the future */
 	}
@@ -1294,9 +1898,16 @@
 	void (*cb)(const SSL *ssl,int type,int val)=NULL;
 
 	s->s3->alert_dispatch=0;
+#ifdef CAVIUM_SSL		
+    cav_fprintf(cav_nb_fp,"s3_pkt.c ....ssl3 dispatch alert \n");
+#endif	
+
 	i = do_ssl3_write(s, SSL3_RT_ALERT, &s->s3->send_alert[0], 2, 0);
 	if (i <= 0)
 		{
+#ifdef CAVIUM_SSL		
+        cav_fprintf(cav_nb_fp,"s3_pkt.c ....setting the alert dispatch \n");
+#endif	
 		s->s3->alert_dispatch=1;
 		}
 	else
diff -Naur openssl-0.9.8j/ssl/s3_srvr.c TurboSSL-0.9.8j/ssl/s3_srvr.c
--- openssl-0.9.8j/ssl/s3_srvr.c	2009-01-07 11:48:23.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/s3_srvr.c	2010-05-31 12:14:16.000000000 +0200
@@ -143,1965 +143,2401 @@
 #endif
 #include <openssl/md5.h>
 
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include <openssl/cav_crypto_engine.h>
+#include "ssl_engine.h"
+#include "openssl/cav_debug.h"
+#endif
+
 static SSL_METHOD *ssl3_get_server_method(int ver);
 #ifndef OPENSSL_NO_ECDH
 static int nid2curve_id(int nid);
 #endif
 
 static SSL_METHOD *ssl3_get_server_method(int ver)
-	{
-	if (ver == SSL3_VERSION)
-		return(SSLv3_server_method());
-	else
-		return(NULL);
-	}
+    {
+    if (ver == SSL3_VERSION)
+        return(SSLv3_server_method());
+    else
+        return(NULL);
+    }
 
 IMPLEMENT_ssl3_meth_func(SSLv3_server_method,
-			ssl3_accept,
-			ssl_undefined_function,
-			ssl3_get_server_method)
+            ssl3_accept,
+            ssl_undefined_function,
+            ssl3_get_server_method)
 
 int ssl3_accept(SSL *s)
-	{
-	BUF_MEM *buf;
-	unsigned long l,Time=(unsigned long)time(NULL);
-	void (*cb)(const SSL *ssl,int type,int val)=NULL;
-	long num1;
-	int ret= -1;
-	int new_state,state,skip=0;
-
-	RAND_add(&Time,sizeof(Time),0);
-	ERR_clear_error();
-	clear_sys_error();
-
-	if (s->info_callback != NULL)
-		cb=s->info_callback;
-	else if (s->ctx->info_callback != NULL)
-		cb=s->ctx->info_callback;
-
-	/* init things to blank */
-	s->in_handshake++;
-	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
-
-	if (s->cert == NULL)
-		{
-		SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
-		return(-1);
-		}
-
-	for (;;)
-		{
-		state=s->state;
-
-		switch (s->state)
-			{
-		case SSL_ST_RENEGOTIATE:
-			s->new_session=1;
-			/* s->state=SSL_ST_ACCEPT; */
-
-		case SSL_ST_BEFORE:
-		case SSL_ST_ACCEPT:
-		case SSL_ST_BEFORE|SSL_ST_ACCEPT:
-		case SSL_ST_OK|SSL_ST_ACCEPT:
-
-			s->server=1;
-			if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
-
-			if ((s->version>>8) != 3)
-				{
-				SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
-				return -1;
-				}
-			s->type=SSL_ST_ACCEPT;
-
-			if (s->init_buf == NULL)
-				{
-				if ((buf=BUF_MEM_new()) == NULL)
-					{
-					ret= -1;
-					goto end;
-					}
-				if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
-					{
-					ret= -1;
-					goto end;
-					}
-				s->init_buf=buf;
-				}
-
-			if (!ssl3_setup_buffers(s))
-				{
-				ret= -1;
-				goto end;
-				}
-
-			s->init_num=0;
-
-			if (s->state != SSL_ST_RENEGOTIATE)
-				{
-				/* Ok, we now need to push on a buffering BIO so that
-				 * the output is sent in a way that TCP likes :-)
-				 */
-				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
-				
-				ssl3_init_finished_mac(s);
-				s->state=SSL3_ST_SR_CLNT_HELLO_A;
-				s->ctx->stats.sess_accept++;
-				}
-			else
-				{
-				/* s->state == SSL_ST_RENEGOTIATE,
-				 * we will just send a HelloRequest */
-				s->ctx->stats.sess_accept_renegotiate++;
-				s->state=SSL3_ST_SW_HELLO_REQ_A;
-				}
-			break;
-
-		case SSL3_ST_SW_HELLO_REQ_A:
-		case SSL3_ST_SW_HELLO_REQ_B:
-
-			s->shutdown=0;
-			ret=ssl3_send_hello_request(s);
-			if (ret <= 0) goto end;
-			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
-			s->state=SSL3_ST_SW_FLUSH;
-			s->init_num=0;
-
-			ssl3_init_finished_mac(s);
-			break;
-
-		case SSL3_ST_SW_HELLO_REQ_C:
-			s->state=SSL_ST_OK;
-			break;
-
-		case SSL3_ST_SR_CLNT_HELLO_A:
-		case SSL3_ST_SR_CLNT_HELLO_B:
-		case SSL3_ST_SR_CLNT_HELLO_C:
-
-			s->shutdown=0;
-			ret=ssl3_get_client_hello(s);
-			if (ret <= 0) goto end;
-			s->new_session = 2;
-			s->state=SSL3_ST_SW_SRVR_HELLO_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SW_SRVR_HELLO_A:
-		case SSL3_ST_SW_SRVR_HELLO_B:
-			ret=ssl3_send_server_hello(s);
-			if (ret <= 0) goto end;
+    {
+    BUF_MEM *buf;
+#ifndef CAVIUM_SSL
+    unsigned long l,Time=(unsigned long)time(NULL);
+#else
+    unsigned long l;
+#endif
+    void (*cb)(const SSL *ssl,int type,int val)=NULL;
+    long num1;
+    int ret= -1;
+    int new_state,state,skip=0;
+#ifdef CAVIUM_SSL
+    Uint32 key_size = 0;
+#endif
+#ifndef CAVIUM_SSL
+    RAND_add(&Time,sizeof(Time),0);
+#endif
+    ERR_clear_error();
+    clear_sys_error();
+
+    if (s->info_callback != NULL)
+        cb=s->info_callback;
+    else if (s->ctx->info_callback != NULL)
+        cb=s->ctx->info_callback;
+
+    /* init things to blank */
+    s->in_handshake++;
+#ifdef CAVIUM_NB_CRYPTO
+    if (!SSL_in_init(s) || SSL_in_before(s)) {
+        cav_print_state(s, "ssl3_accept(): ");
+        if ( s->cav_crypto_state == 0 ) {
+            cav_fprintf(cav_nb_fp,"ssl3_accept(): will call SSL_clear()\n");
+            SSL_clear(s);
+        }
+        else {
+            cav_fprintf(cav_nb_fp,"ssl3_accept(): will skip SSL_clear()\n");
+        }
+    }
+#else
+    if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
+#endif
+
+    if (s->cert == NULL)
+        {
+        SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);
+        return(-1);
+        }
+#ifdef CAVIUM_SSL
+    init_supported_cipher_list(s);
+#endif
+
+    for (;;)
+        {
+#ifdef CAVIUM_SSL
+           cav_fprintf(cav_nb_fp, "ssl3_accept(): within for loop\n");
+#endif
+           state=s->state;
+#ifdef CAVIUM_SSL
+           cav_print_state(s, "ssl3_accept(): ");
+           cav_fprintf(cav_nb_fp, "ssl3_accept(): s->verify_mode = 0x%0x\n",
+                                       s->verify_mode);
+#endif
+
+        switch (s->state)
+            {
+        case SSL_ST_RENEGOTIATE:
+            s->new_session=1;
+            /* s->state=SSL_ST_ACCEPT; */
+#ifdef CAVIUM_SSL
+            s->cav_renego = 1;
+
+            if(s->handshake_support && pkp_write_updated_ssl_session_context(s))
+                {
+                s->cipher_support = 1;
+                s->handshake_support = 0;
+                }
+            else if(s->record_process && pkp_read_updated_ssl_session_context(s))
+                s->cipher_support = 0;
+
+            SSL_set_verify(s,s->verify_mode,NULL);
+#endif
+
+        case SSL_ST_BEFORE:
+        case SSL_ST_ACCEPT:
+        case SSL_ST_BEFORE|SSL_ST_ACCEPT:
+        case SSL_ST_OK|SSL_ST_ACCEPT:
+
+            s->server=1;
+            if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);
+
+            if ((s->version>>8) != 3)
+                {
+                SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);
+                return -1;
+                }
+            s->type=SSL_ST_ACCEPT;
+
+            if (s->init_buf == NULL)
+                {
+                if ((buf=BUF_MEM_new()) == NULL)
+                    {
+                    ret= -1;
+                    goto end;
+                    }
+                if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))
+                    {
+                    ret= -1;
+                    goto end;
+                    }
+                s->init_buf=buf;
+                }
+
+            if (!ssl3_setup_buffers(s))
+                {
+                ret= -1;
+                goto end;
+                }
+
+            s->init_num=0;
+
+            if (s->state != SSL_ST_RENEGOTIATE)
+                {
+                /* Ok, we now need to push on a buffering BIO so that
+                 * the output is sent in a way that TCP likes :-)
+                 */
+                if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
+
+                ssl3_init_finished_mac(s);
+                s->state=SSL3_ST_SR_CLNT_HELLO_A;
+                s->ctx->stats.sess_accept++;
+                }
+            else
+                {
+                /* s->state == SSL_ST_RENEGOTIATE,
+                 * we will just send a HelloRequest */
+                s->ctx->stats.sess_accept_renegotiate++;
+                s->state=SSL3_ST_SW_HELLO_REQ_A;
+                }
+            break;
+
+        case SSL3_ST_SW_HELLO_REQ_A:
+        case SSL3_ST_SW_HELLO_REQ_B:
+
+            s->shutdown=0;
+            ret=ssl3_send_hello_request(s);
+            if (ret <= 0) goto end;
+            s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
+            s->state=SSL3_ST_SW_FLUSH;
+            s->init_num=0;
+
+            ssl3_init_finished_mac(s);
+            break;
+
+        case SSL3_ST_SW_HELLO_REQ_C:
+            s->state=SSL_ST_OK;
+            break;
+
+        case SSL3_ST_SR_CLNT_HELLO_A:
+        case SSL3_ST_SR_CLNT_HELLO_B:
+        case SSL3_ST_SR_CLNT_HELLO_C:
+
+            s->shutdown=0;
+            ret=ssl3_get_client_hello(s);
+            if (ret <= 0) goto end;
+            s->new_session = 2;
+            s->state=SSL3_ST_SW_SRVR_HELLO_A;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_SRVR_HELLO_A:
+        case SSL3_ST_SW_SRVR_HELLO_B:
+            ret=ssl3_send_server_hello(s);
+            if (ret <= 0) goto end;
 #ifndef OPENSSL_NO_TLSEXT
-			if (s->hit)
-				{
-				if (s->tlsext_ticket_expected)
-					s->state=SSL3_ST_SW_SESSION_TICKET_A;
-				else
-					s->state=SSL3_ST_SW_CHANGE_A;
-				}
-#else
-			if (s->hit)
-					s->state=SSL3_ST_SW_CHANGE_A;
-#endif
-			else
-				s->state=SSL3_ST_SW_CERT_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SW_CERT_A:
-		case SSL3_ST_SW_CERT_B:
-			/* Check if it is anon DH or anon ECDH or KRB5 */
-			if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)
-				&& !(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
-				{
-				ret=ssl3_send_server_certificate(s);
-				if (ret <= 0) goto end;
+            if (s->hit)
+                {
+                if (s->tlsext_ticket_expected)
+                    s->state=SSL3_ST_SW_SESSION_TICKET_A;
+                else
+                    s->state=SSL3_ST_SW_CHANGE_A;
+                }
+#else
+            if (s->hit)
+                    {
+#ifdef CAVIUM_SSL
+                    cav_fprintf(cav_nb_fp,
+                                 "ssl3_accept(): GOT HIT AFTER SERVER DONE\n");
+#endif
+                    s->state=SSL3_ST_SW_CHANGE_A;
+                    }
+#endif
+            else
+                s->state=SSL3_ST_SW_CERT_A;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_CERT_A:
+        case SSL3_ST_SW_CERT_B:
+            /* Check if it is anon DH or anon ECDH or KRB5 */
+            if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)
+                && !(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
+                {
+                ret=ssl3_send_server_certificate(s);
+                if (ret <= 0) goto end;
 #ifndef OPENSSL_NO_TLSEXT
-				if (s->tlsext_status_expected)
-					s->state=SSL3_ST_SW_CERT_STATUS_A;
-				else
-					s->state=SSL3_ST_SW_KEY_EXCH_A;
-				}
-			else
-				{
-				skip = 1;
-				s->state=SSL3_ST_SW_KEY_EXCH_A;
-				}
-#else
-				}
-			else
-				skip=1;
-
-			s->state=SSL3_ST_SW_KEY_EXCH_A;
-#endif
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SW_KEY_EXCH_A:
-		case SSL3_ST_SW_KEY_EXCH_B:
-			l=s->s3->tmp.new_cipher->algorithms;
-
-			/* clear this, it may get reset by
-			 * send_server_key_exchange */
-			if ((s->options & SSL_OP_EPHEMERAL_RSA)
+                if (s->tlsext_status_expected)
+                    s->state=SSL3_ST_SW_CERT_STATUS_A;
+                else
+                    s->state=SSL3_ST_SW_KEY_EXCH_A;
+                }
+            else
+                {
+                skip = 1;
+                s->state=SSL3_ST_SW_KEY_EXCH_A;
+                }
+#else
+                }
+            else
+                skip=1;
+
+            s->state=SSL3_ST_SW_KEY_EXCH_A;
+#endif
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_KEY_EXCH_A:
+        case SSL3_ST_SW_KEY_EXCH_B:
+            l=s->s3->tmp.new_cipher->algorithms;
+
+            /* clear this, it may get reset by
+             * send_server_key_exchange */
+            if ((s->options & SSL_OP_EPHEMERAL_RSA)
 #ifndef OPENSSL_NO_KRB5
-				&& !(l & SSL_KRB5)
+                && !(l & SSL_KRB5)
 #endif /* OPENSSL_NO_KRB5 */
-				)
-				/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
-				 * even when forbidden by protocol specs
-				 * (handshake may fail as clients are not required to
-				 * be able to handle this) */
-				s->s3->tmp.use_rsa_tmp=1;
-			else
-				s->s3->tmp.use_rsa_tmp=0;
-
-
-			/* only send if a DH key exchange, fortezza or
-			 * RSA but we have a sign only certificate
-			 *
-			 * For ECC ciphersuites, we send a serverKeyExchange
-			 * message only if the cipher suite is either
-			 * ECDH-anon or ECDHE. In other cases, the
-			 * server certificate contains the server's 
-			 * public key for key exchange.
-			 */
-			if (s->s3->tmp.use_rsa_tmp
-			    || (l & SSL_kECDHE)
-			    || (l & (SSL_DH|SSL_kFZA))
-			    || ((l & SSL_kRSA)
-				&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
-				    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
-					&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
-					)
-				    )
-				)
-			    )
-				{
-				ret=ssl3_send_server_key_exchange(s);
-				if (ret <= 0) goto end;
-				}
-			else
-				skip=1;
-
-			s->state=SSL3_ST_SW_CERT_REQ_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SW_CERT_REQ_A:
-		case SSL3_ST_SW_CERT_REQ_B:
-			if (/* don't request cert unless asked for it: */
-				!(s->verify_mode & SSL_VERIFY_PEER) ||
-				/* if SSL_VERIFY_CLIENT_ONCE is set,
-				 * don't request cert during re-negotiation: */
-				((s->session->peer != NULL) &&
-				 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
-				/* never request cert in anonymous ciphersuites
-				 * (see section "Certificate request" in SSL 3 drafts
-				 * and in RFC 2246): */
-				((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&
-				 /* ... except when the application insists on verification
-				  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
-				 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
+                )
+                /* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key
+                 * even when forbidden by protocol specs
+                 * (handshake may fail as clients are not required to
+                 * be able to handle this) */
+                s->s3->tmp.use_rsa_tmp=1;
+            else
+                s->s3->tmp.use_rsa_tmp=0;
+
+
+            /* only send if a DH key exchange, fortezza or
+             * RSA but we have a sign only certificate
+             *
+             * For ECC ciphersuites, we send a serverKeyExchange
+             * message only if the cipher suite is either
+             * ECDH-anon or ECDHE. In other cases, the
+             * server certificate contains the server's
+             * public key for key exchange.
+             */
+#ifdef CAVIUM_SSL
+#ifndef CAVIUM_FIPS
+            key_size = EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey);
+#else
+            key_size = s->ctx->pkey_info.size;
+#endif /* CAVIUM_FIPS */
+#endif /* CAVIUM_SSL */
+
+            if (s->s3->tmp.use_rsa_tmp
+                || (l & SSL_kECDHE)
+                || (l & (SSL_DH|SSL_kFZA))
+                || ((l & SSL_kRSA)
+                && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL
+                    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)
+#ifdef CAVIUM_SSL
+                    && (key_size*8) > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
+#else
+                    && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)
+#endif
+                    )
+                    )
+                )
+                )
+                {
+                ret=ssl3_send_server_key_exchange(s);
+                if (ret <= 0) goto end;
+                }
+            else
+                skip=1;
+
+            s->state=SSL3_ST_SW_CERT_REQ_A;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_CERT_REQ_A:
+        case SSL3_ST_SW_CERT_REQ_B:
+#ifdef CAVIUM_SSL
+            s->flag = 0;
+#endif
+            if (/* don't request cert unless asked for it: */
+                !(s->verify_mode & SSL_VERIFY_PEER) ||
+                /* if SSL_VERIFY_CLIENT_ONCE is set,
+                 * don't request cert during re-negotiation: */
+                ((s->session->peer != NULL) &&
+                 (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||
+                /* never request cert in anonymous ciphersuites
+                 * (see section "Certificate request" in SSL 3 drafts
+                 * and in RFC 2246): */
+                ((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&
+                 /* ... except when the application insists on verification
+                  * (against the specs, but s3_clnt.c accepts this for SSL 3) */
+                 !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||
                                  /* never request cert in Kerberos ciphersuites */
                                 (s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))
-				{
-				/* no cert request */
-				skip=1;
-				s->s3->tmp.cert_request=0;
-				s->state=SSL3_ST_SW_SRVR_DONE_A;
-				}
-			else
-				{
-				s->s3->tmp.cert_request=1;
-				ret=ssl3_send_certificate_request(s);
-				if (ret <= 0) goto end;
+                {
+                /* no cert request */
+                skip=1;
+                s->s3->tmp.cert_request=0;
+                s->state=SSL3_ST_SW_SRVR_DONE_A;
+                }
+            else
+                {
+                s->s3->tmp.cert_request=1;
+                ret=ssl3_send_certificate_request(s);
+                if (ret <= 0) goto end;
 #ifndef NETSCAPE_HANG_BUG
-				s->state=SSL3_ST_SW_SRVR_DONE_A;
+                s->state=SSL3_ST_SW_SRVR_DONE_A;
 #else
-				s->state=SSL3_ST_SW_FLUSH;
-				s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
+                s->state=SSL3_ST_SW_FLUSH;
+                s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
 #endif
-				s->init_num=0;
-				}
-			break;
-
-		case SSL3_ST_SW_SRVR_DONE_A:
-		case SSL3_ST_SW_SRVR_DONE_B:
-			ret=ssl3_send_server_done(s);
-			if (ret <= 0) goto end;
-			s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
-			s->state=SSL3_ST_SW_FLUSH;
-			s->init_num=0;
-			break;
-		
-		case SSL3_ST_SW_FLUSH:
-			/* number of bytes to be flushed */
-			num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
-			if (num1 > 0)
-				{
-				s->rwstate=SSL_WRITING;
-				num1=BIO_flush(s->wbio);
-				if (num1 <= 0) { ret= -1; goto end; }
-				s->rwstate=SSL_NOTHING;
-				}
-
-			s->state=s->s3->tmp.next_state;
-			break;
-
-		case SSL3_ST_SR_CERT_A:
-		case SSL3_ST_SR_CERT_B:
-			/* Check for second client hello (MS SGC) */
-			ret = ssl3_check_client_hello(s);
-			if (ret <= 0)
-				goto end;
-			if (ret == 2)
-				s->state = SSL3_ST_SR_CLNT_HELLO_C;
-			else {
-				if (s->s3->tmp.cert_request)
-					{
-					ret=ssl3_get_client_certificate(s);
-					if (ret <= 0) goto end;
-					}
-				s->init_num=0;
-				s->state=SSL3_ST_SR_KEY_EXCH_A;
-			}
-			break;
-
-		case SSL3_ST_SR_KEY_EXCH_A:
-		case SSL3_ST_SR_KEY_EXCH_B:
-			ret=ssl3_get_client_key_exchange(s);
-			if (ret <= 0) 
-				goto end;
-			if (ret == 2)
-				{
-				/* For the ECDH ciphersuites when
-				 * the client sends its ECDH pub key in
-				 * a certificate, the CertificateVerify
-				 * message is not sent.
-				 */
-				s->state=SSL3_ST_SR_FINISHED_A;
-				s->init_num = 0;
-				}
-			else   
-				{
-				s->state=SSL3_ST_SR_CERT_VRFY_A;
-				s->init_num=0;
-
-				/* We need to get hashes here so if there is
-				 * a client cert, it can be verified
-				 */ 
-				s->method->ssl3_enc->cert_verify_mac(s,
-				    &(s->s3->finish_dgst1),
-				    &(s->s3->tmp.cert_verify_md[0]));
-				s->method->ssl3_enc->cert_verify_mac(s,
-				    &(s->s3->finish_dgst2),
-				    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
-				}
-			break;
-
-		case SSL3_ST_SR_CERT_VRFY_A:
-		case SSL3_ST_SR_CERT_VRFY_B:
-
-			/* we should decide if we expected this one */
-			ret=ssl3_get_cert_verify(s);
-			if (ret <= 0) goto end;
-
-			s->state=SSL3_ST_SR_FINISHED_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SR_FINISHED_A:
-		case SSL3_ST_SR_FINISHED_B:
-			ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
-				SSL3_ST_SR_FINISHED_B);
-			if (ret <= 0) goto end;
-			if (s->hit)
-				s->state=SSL_ST_OK;
+                s->init_num=0;
+                }
+            break;
+
+        case SSL3_ST_SW_SRVR_DONE_A:
+        case SSL3_ST_SW_SRVR_DONE_B:
+            ret=ssl3_send_server_done(s);
+            if (ret <= 0) goto end;
+            s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
+            s->state=SSL3_ST_SW_FLUSH;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_FLUSH:
+            /* number of bytes to be flushed */
+            num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);
+            if (num1 > 0)
+                {
+                s->rwstate=SSL_WRITING;
+                num1=BIO_flush(s->wbio);
+                if (num1 <= 0) { ret= -1; goto end; }
+                s->rwstate=SSL_NOTHING;
+                }
+
+            s->state=s->s3->tmp.next_state;
+            break;
+
+        case SSL3_ST_SR_CERT_A:
+        case SSL3_ST_SR_CERT_B:
+            /* Check for second client hello (MS SGC) */
+            ret = ssl3_check_client_hello(s);
+            if (ret <= 0)
+                goto end;
+            if (ret == 2)
+                s->state = SSL3_ST_SR_CLNT_HELLO_C;
+            else {
+                if (s->s3->tmp.cert_request)
+                    {
+                    ret=ssl3_get_client_certificate(s);
+                    if (ret <= 0) goto end;
+                    }
+                s->init_num=0;
+                s->state=SSL3_ST_SR_KEY_EXCH_A;
+            }
+            break;
+
+        case SSL3_ST_SR_KEY_EXCH_A:
+        case SSL3_ST_SR_KEY_EXCH_B:
+            ret=ssl3_get_client_key_exchange(s);
+            if (ret <= 0)
+                goto end;
+            if (ret == 2)
+                {
+                /* For the ECDH ciphersuites when
+                 * the client sends its ECDH pub key in
+                 * a certificate, the CertificateVerify
+                 * message is not sent.
+                 */
+                s->state=SSL3_ST_SR_FINISHED_A;
+                s->init_num = 0;
+                }
+            else
+                {
+                s->state=SSL3_ST_SR_CERT_VRFY_A;
+                s->init_num=0;
+#ifdef CAVIUM_SSL
+                if(!s->cipher_support)
+                {
+#endif
+                /* We need to get hashes here so if there is
+                 * a client cert, it can be verified
+                 */
+                s->method->ssl3_enc->cert_verify_mac(s,
+                    &(s->s3->finish_dgst1),
+                    &(s->s3->tmp.cert_verify_md[0]));
+                s->method->ssl3_enc->cert_verify_mac(s,
+                    &(s->s3->finish_dgst2),
+                    &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));
+                }
+#ifdef CAVIUM_SSL
+                else
+                {
+                    if( SSL_get_verify_mode(s) & SSL_VERIFY_PEER)
+                    {
+                        /* create certificate verify hash here*/
+                        ret = pkp_cert_verify_mac(s);
+                        cav_fprintf(cav_nb_fp,
+                                "ssl3_accept():AFTER PKP_CERT_VERIFY_MAC \n");
+                        if (ret <= 0) goto end;
+
+                    }
+                }
+                } /* else (ret == 2) */
+#endif
+            break;
+
+        case SSL3_ST_SR_CERT_VRFY_A:
+        case SSL3_ST_SR_CERT_VRFY_B:
+#ifdef CAVIUM_SSL
+            s->client_cert_verify_msg_offset = s->hs_msgs_len;
+            cav_fprintf(cav_nb_fp, "%s %s %d\n",
+                    "ssl3_accept(): calling ssl3_get_cert_verify()",
+                    ", s->cav_reneo = ", s->cav_renego);
+
+            if ( s->cav_renego > 0 ) {
+                s->read_cipher_active = 0;
+                cav_fprintf(cav_nb_fp,
+                            "ssl3_accept(): set read_cipher_active = 0\n");
+            }
+#endif
+
+            /* we should decide if we expected this one */
+            ret=ssl3_get_cert_verify(s);
+            if (ret <= 0) goto end;
+
+            s->state=SSL3_ST_SR_FINISHED_A;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SR_FINISHED_A:
+        case SSL3_ST_SR_FINISHED_B:
+            ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
+                SSL3_ST_SR_FINISHED_B);
+            if (ret <= 0) goto end;
+            if (s->hit)
+                s->state=SSL_ST_OK;
 #ifndef OPENSSL_NO_TLSEXT
-			else if (s->tlsext_ticket_expected)
-				s->state=SSL3_ST_SW_SESSION_TICKET_A;
+            else if (s->tlsext_ticket_expected)
+                s->state=SSL3_ST_SW_SESSION_TICKET_A;
 #endif
-			else
-				s->state=SSL3_ST_SW_CHANGE_A;
-			s->init_num=0;
-			break;
+            else
+                s->state=SSL3_ST_SW_CHANGE_A;
+            s->init_num=0;
+            break;
 
 #ifndef OPENSSL_NO_TLSEXT
-		case SSL3_ST_SW_SESSION_TICKET_A:
-		case SSL3_ST_SW_SESSION_TICKET_B:
-			ret=ssl3_send_newsession_ticket(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_SW_CHANGE_A;
-			s->init_num=0;
-			break;
-
-		case SSL3_ST_SW_CERT_STATUS_A:
-		case SSL3_ST_SW_CERT_STATUS_B:
-			ret=ssl3_send_cert_status(s);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_SW_KEY_EXCH_A;
-			s->init_num=0;
-			break;
-
-#endif
-
-		case SSL3_ST_SW_CHANGE_A:
-		case SSL3_ST_SW_CHANGE_B:
-
-			s->session->cipher=s->s3->tmp.new_cipher;
-			if (!s->method->ssl3_enc->setup_key_block(s))
-				{ ret= -1; goto end; }
-
-			ret=ssl3_send_change_cipher_spec(s,
-				SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);
-
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_SW_FINISHED_A;
-			s->init_num=0;
-
-			if (!s->method->ssl3_enc->change_cipher_state(s,
-				SSL3_CHANGE_CIPHER_SERVER_WRITE))
-				{
-				ret= -1;
-				goto end;
-				}
-
-			break;
-
-		case SSL3_ST_SW_FINISHED_A:
-		case SSL3_ST_SW_FINISHED_B:
-			ret=ssl3_send_finished(s,
-				SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
-				s->method->ssl3_enc->server_finished_label,
-				s->method->ssl3_enc->server_finished_label_len);
-			if (ret <= 0) goto end;
-			s->state=SSL3_ST_SW_FLUSH;
-			if (s->hit)
-				s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
-			else
-				s->s3->tmp.next_state=SSL_ST_OK;
-			s->init_num=0;
-			break;
-
-		case SSL_ST_OK:
-			/* clean a few things up */
-			ssl3_cleanup_key_block(s);
-
-			BUF_MEM_free(s->init_buf);
-			s->init_buf=NULL;
-
-			/* remove buffering on output */
-			ssl_free_wbio_buffer(s);
-
-			s->init_num=0;
-
-			if (s->new_session == 2) /* skipped if we just sent a HelloRequest */
-				{
-				/* actually not necessarily a 'new' session unless
-				 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
-				
-				s->new_session=0;
-				
-				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
-				
-				s->ctx->stats.sess_accept_good++;
-				/* s->server=1; */
-				s->handshake_func=ssl3_accept;
-
-				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
-				}
-			
-			ret = 1;
-			goto end;
-			/* break; */
-
-		default:
-			SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
-			ret= -1;
-			goto end;
-			/* break; */
-			}
-		
-		if (!s->s3->tmp.reuse_message && !skip)
-			{
-			if (s->debug)
-				{
-				if ((ret=BIO_flush(s->wbio)) <= 0)
-					goto end;
-				}
-
-
-			if ((cb != NULL) && (s->state != state))
-				{
-				new_state=s->state;
-				s->state=state;
-				cb(s,SSL_CB_ACCEPT_LOOP,1);
-				s->state=new_state;
-				}
-			}
-		skip=0;
-		}
+        case SSL3_ST_SW_SESSION_TICKET_A:
+        case SSL3_ST_SW_SESSION_TICKET_B:
+            ret=ssl3_send_newsession_ticket(s);
+            if (ret <= 0) goto end;
+            s->state=SSL3_ST_SW_CHANGE_A;
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_SW_CERT_STATUS_A:
+        case SSL3_ST_SW_CERT_STATUS_B:
+            ret=ssl3_send_cert_status(s);
+            if (ret <= 0) goto end;
+            s->state=SSL3_ST_SW_KEY_EXCH_A;
+            s->init_num=0;
+            break;
+
+#endif
+
+        case SSL3_ST_SW_CHANGE_A:
+        case SSL3_ST_SW_CHANGE_B:
+#ifdef CAVIUM_SSL
+            if(s->cipher_support)
+            {
+                if(!s->hit)
+                {
+                    s->state=SSL3_ST_SW_FLUSH;
+                    s->s3->tmp.next_state=SSL_ST_OK;
+                    s->init_num=0;
+                }
+                else
+                {
+                    cav_fprintf(cav_nb_fp,
+                            "ssl3_accept():BEFORE PKP RESUME \n");
+                    ret = pkp_resume_handshake(s);
+                    if (ret <= 0) goto end;
+                }
+            }
+            else
+            {
+#endif /* CAVIUM_SSL */
+
+            s->session->cipher=s->s3->tmp.new_cipher;
+            if (!s->method->ssl3_enc->setup_key_block(s))
+                { ret= -1; goto end; }
+
+            ret=ssl3_send_change_cipher_spec(s,
+                SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);
+
+            if (ret <= 0) goto end;
+            s->state=SSL3_ST_SW_FINISHED_A;
+            s->init_num=0;
+
+            if (!s->method->ssl3_enc->change_cipher_state(s,
+                SSL3_CHANGE_CIPHER_SERVER_WRITE))
+                {
+                ret= -1;
+                goto end;
+                }
+#ifdef CAVIUM_SSL
+            } /* !(s->cipher_support) */
+#endif
+            break;
+
+        case SSL3_ST_SW_FINISHED_A:
+        case SSL3_ST_SW_FINISHED_B:
+#ifdef CAVIUM_SSL
+            if(s->cipher_support)
+            {
+                /* we can reach here only in case of session resumption.
+                There are no other possible way to get into this state*/
+
+                s->state=SSL3_ST_SW_FLUSH;
+                s->init_num=0;
+                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
+            }
+            else
+            {
+#endif /* CAVIUM_SSL */
+            ret=ssl3_send_finished(s,
+                SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,
+                s->method->ssl3_enc->server_finished_label,
+                s->method->ssl3_enc->server_finished_label_len);
+            if (ret <= 0) goto end;
+            s->state=SSL3_ST_SW_FLUSH;
+            if (s->hit)
+                s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;
+            else
+                s->s3->tmp.next_state=SSL_ST_OK;
+            s->init_num=0;
+#ifdef CAVIUM_SSL
+            } /* !(s->cipher_support) */
+#endif /* CAVIUM_SSL */
+            break;
+
+        case SSL_ST_OK:
+            /* clean a few things up */
+#ifdef CAVIUM_SSL
+            if(s->hs_msgs != NULL)
+            {
+                OPENSSL_free(s->hs_msgs);
+                s->hs_msgs=NULL;
+            }
+#endif
+            ssl3_cleanup_key_block(s);
+
+            BUF_MEM_free(s->init_buf);
+            s->init_buf=NULL;
+
+            /* remove buffering on output */
+            ssl_free_wbio_buffer(s);
+
+            s->init_num=0;
+
+            if (s->new_session == 2) /* skipped if we just sent a HelloRequest */
+                {
+                /* actually not necessarily a 'new' session unless
+                 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
+
+                s->new_session=0;
+#ifdef CAVIUM_SSL
+#ifndef NO_SESSION_CACHE
+                ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
+#endif
+#else
+                ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
+#endif
+
+                s->ctx->stats.sess_accept_good++;
+#ifdef CAVIUM_SSL
+#if !defined(RECORD_PROCESS_OFFLOAD) && defined(HANDSHAKE_OFFLOAD)
+                if(s->cipher_support && pkp_read_ssl_session_context(s))
+                    {
+                    s->handshake_support = 1;
+                    s->cipher_support = 0;
+                    }
+#endif
+                if(s->record_process && pkp_write_ssl_session_context(s))
+                    s->cipher_support = 1;
+#endif
+                /* s->server=1; */
+                s->handshake_func=ssl3_accept;
+
+                if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
+                }
+
+            ret = 1;
+            goto end;
+            /* break; */
+
+#ifdef CAVIUM_NB_CRYPTO
+
+        case CAV_ST_IN_PRE_MASTER_KEY:
+            ret = ssl3_get_cert_verify(s);
+            if ( ret <= 0 ) {
+                goto end;
+            }
+            s->state=SSL3_ST_SR_FINISHED_A;
+            s->init_num=0;
+            break;
+
+        case CAV_ST_IN_RESUME_HANDSHAKE:
+            if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER_2) {
+                ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,
+                                         SSL3_ST_SR_FINISHED_B);
+                if (ret <= 0) {
+                    goto end;
+                }
+                if (s->hit)
+                {
+                    s->state=SSL_ST_OK;
+                }
+                else
+                {
+                    s->state=SSL3_ST_SW_CHANGE_A;
+                }
+                s->init_num=0;
+            }
+            else {
+                ret = pkp_resume_handshake(s);
+                if ( ret <= 0 ) {
+                    goto end;
+                }
+            }
+            break;
+
+        case CAV_ST_IN_VRFY_CERT:
+            if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY ||
+                 s->cav_crypto_state == CAV_ST_IN_WRITE_CONTEXT ||
+                 s->cav_crypto_state == CAV_ST_IN_VRFY_CERT) {
+
+                ret = pkp_cert_verify_mac(s);
+                if ( ret <= 0 ) {
+                    goto end;
+                }
+                s->state=SSL3_ST_SR_CERT_VRFY_A;
+                s->init_num=0;
+                break;
+            }
+
+        case CAV_ST_IN_HANDSHAKE:
+            if( SSL_get_verify_mode(s) & SSL_VERIFY_PEER){
+                ret = pkp_handshake_client_auth(s);
+                cav_fprintf(cav_nb_fp,
+                        "ssl3_accept(): pkp_handshake_client_auth, ret = %d\n", ret);
+            }
+            else if(s->s3->tmp.use_rsa_tmp){
+                ret = pkp_ephemeral_handshake(s);
+                cav_fprintf(cav_nb_fp,
+                        "ssl3_accept(): pkp_ephemeral_handshake, ret = %d\n", ret);
+            }
+
+            else {
+                ret = pkp_handshake(s);
+                cav_fprintf(cav_nb_fp,
+                        "ssl3_accept(): pkp_handshake, ret = %d\n", ret);
+            }
+            if ( ret <= 0 ) {
+                goto end;
+            }
+
+            if (s->hit) {
+                s->state=SSL_ST_OK;
+            }
+            else {
+                s->state=SSL3_ST_SW_CHANGE_A;
+            }
+
+            s->init_num=0;
+            break;
+
+        case SSL3_ST_CW_CLNT_HELLO_B:
+            if ( s->cav_renego > 0 ) {
+                ret = ssl3_do_write(s,SSL3_RT_HANDSHAKE);
+                if (ret <= 0) goto end;
+                if (s->hit)
+                    s->state=SSL3_ST_SW_CHANGE_A;
+                else
+                    s->state=SSL3_ST_SW_CERT_A;
+                s->rwstate = SSL_NOTHING;
+                s->init_num=0;
+            }
+            break;
+#endif
+
+        default:
+            SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);
+            ret= -1;
+            goto end;
+            /* break; */
+            }
+
+        if (!s->s3->tmp.reuse_message && !skip)
+            {
+            if (s->debug)
+                {
+                if ((ret=BIO_flush(s->wbio)) <= 0)
+                    goto end;
+                }
+
+
+            if ((cb != NULL) && (s->state != state))
+                {
+                new_state=s->state;
+                s->state=state;
+                cb(s,SSL_CB_ACCEPT_LOOP,1);
+                s->state=new_state;
+                }
+            }
+        skip=0;
+        }
 end:
-	/* BIO_flush(s->wbio); */
+    /* BIO_flush(s->wbio); */
 
-	s->in_handshake--;
-	if (cb != NULL)
-		cb(s,SSL_CB_ACCEPT_EXIT,ret);
-	return(ret);
-	}
+    s->in_handshake--;
+    if (cb != NULL)
+        cb(s,SSL_CB_ACCEPT_EXIT,ret);
+    return(ret);
+    }
 
 int ssl3_send_hello_request(SSL *s)
-	{
-	unsigned char *p;
+    {
+    unsigned char *p;
 
-	if (s->state == SSL3_ST_SW_HELLO_REQ_A)
-		{
-		p=(unsigned char *)s->init_buf->data;
-		*(p++)=SSL3_MT_HELLO_REQUEST;
-		*(p++)=0;
-		*(p++)=0;
-		*(p++)=0;
-
-		s->state=SSL3_ST_SW_HELLO_REQ_B;
-		/* number of bytes to write */
-		s->init_num=4;
-		s->init_off=0;
-		}
-
-	/* SSL3_ST_SW_HELLO_REQ_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+    if (s->state == SSL3_ST_SW_HELLO_REQ_A)
+        {
+        p=(unsigned char *)s->init_buf->data;
+        *(p++)=SSL3_MT_HELLO_REQUEST;
+        *(p++)=0;
+        *(p++)=0;
+        *(p++)=0;
+
+        s->state=SSL3_ST_SW_HELLO_REQ_B;
+        /* number of bytes to write */
+        s->init_num=4;
+        s->init_off=0;
+        }
+
+    /* SSL3_ST_SW_HELLO_REQ_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+    }
 
 int ssl3_check_client_hello(SSL *s)
-	{
-	int ok;
-	long n;
-
-	/* this function is called when we really expect a Certificate message,
-	 * so permit appropriate message length */
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_CERT_A,
-		SSL3_ST_SR_CERT_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-	if (!ok) return((int)n);
-	s->s3->tmp.reuse_message = 1;
-	if (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO)
-		{
-		/* Throw away what we have done so far in the current handshake,
-		 * which will now be aborted. (A full SSL_clear would be too much.)
-		 * I hope that tmp.dh is the only thing that may need to be cleared
-		 * when a handshake is not completed ... */
+    {
+    int ok;
+    long n;
+
+    /* this function is called when we really expect a Certificate message,
+     * so permit appropriate message length */
+    n=s->method->ssl_get_message(s,
+        SSL3_ST_SR_CERT_A,
+        SSL3_ST_SR_CERT_B,
+        -1,
+        s->max_cert_list,
+        &ok);
+    if (!ok) return((int)n);
+    s->s3->tmp.reuse_message = 1;
+    if (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO)
+        {
+        /* Throw away what we have done so far in the current handshake,
+         * which will now be aborted. (A full SSL_clear would be too much.)
+         * I hope that tmp.dh is the only thing that may need to be cleared
+         * when a handshake is not completed ... */
 #ifndef OPENSSL_NO_DH
-		if (s->s3->tmp.dh != NULL)
-			{
-			DH_free(s->s3->tmp.dh);
-			s->s3->tmp.dh = NULL;
-			}
-#endif
-		return 2;
-		}
-	return 1;
+        if (s->s3->tmp.dh != NULL)
+            {
+            DH_free(s->s3->tmp.dh);
+            s->s3->tmp.dh = NULL;
+            }
+#endif
+        return 2;
+        }
+    return 1;
 }
 
 int ssl3_get_client_hello(SSL *s)
-	{
-	int i,j,ok,al,ret= -1;
-	unsigned int cookie_len;
-	long n;
-	unsigned long id;
-	unsigned char *p,*d,*q;
-	SSL_CIPHER *c;
+    {
+    int i,j,ok,al,ret= -1;
+    unsigned int cookie_len;
+    long n;
+    unsigned long id;
+    unsigned char *p,*d,*q;
+    SSL_CIPHER *c;
 #ifndef OPENSSL_NO_COMP
-	SSL_COMP *comp=NULL;
+    SSL_COMP *comp=NULL;
 #endif
-	STACK_OF(SSL_CIPHER) *ciphers=NULL;
+    STACK_OF(SSL_CIPHER) *ciphers=NULL;
 
-	/* We do this so that we will respond with our native type.
-	 * If we are TLSv1 and we get SSLv3, we will respond with TLSv1,
-	 * This down switching should be handled by a different method.
-	 * If we are SSLv3, we will respond with SSLv3, even if prompted with
-	 * TLSv1.
-	 */
-	if (s->state == SSL3_ST_SR_CLNT_HELLO_A)
-		{
-		s->state=SSL3_ST_SR_CLNT_HELLO_B;
-		}
-	s->first_packet=1;
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_CLNT_HELLO_B,
-		SSL3_ST_SR_CLNT_HELLO_C,
-		SSL3_MT_CLIENT_HELLO,
-		SSL3_RT_MAX_PLAIN_LENGTH,
-		&ok);
-
-	if (!ok) return((int)n);
-	s->first_packet=0;
-	d=p=(unsigned char *)s->init_msg;
-
-	/* use version from inside client hello, not from record header
-	 * (may differ: see RFC 2246, Appendix E, second paragraph) */
-	s->client_version=(((int)p[0])<<8)|(int)p[1];
-	p+=2;
-
-	if ((s->version == DTLS1_VERSION && s->client_version > s->version) ||
-	    (s->version != DTLS1_VERSION && s->client_version < s->version))
-		{
-		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);
-		if ((s->client_version>>8) == SSL3_VERSION_MAJOR) 
-			{
-			/* similar to ssl3_get_record, send alert using remote version number */
-			s->version = s->client_version;
-			}
-		al = SSL_AD_PROTOCOL_VERSION;
-		goto f_err;
-		}
-
-	/* load the client random */
-	memcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);
-	p+=SSL3_RANDOM_SIZE;
-
-	/* get the session-id */
-	j= *(p++);
-
-	s->hit=0;
-	/* Versions before 0.9.7 always allow session reuse during renegotiation
-	 * (i.e. when s->new_session is true), option
-	 * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is new with 0.9.7.
-	 * Maybe this optional behaviour should always have been the default,
-	 * but we cannot safely change the default behaviour (or new applications
-	 * might be written that become totally unsecure when compiled with
-	 * an earlier library version)
-	 */
-	if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
-		{
-		if (!ssl_get_new_session(s,1))
-			goto err;
-		}
-	else
-		{
-		i=ssl_get_prev_session(s, p, j, d + n);
-		if (i == 1)
-			{ /* previous session */
-			s->hit=1;
-			}
-		else if (i == -1)
-			goto err;
-		else /* i == 0 */
-			{
-			if (!ssl_get_new_session(s,1))
-				goto err;
-			}
-		}
-
-	p+=j;
-
-	if (s->version == DTLS1_VERSION)
-		{
-		/* cookie stuff */
-		cookie_len = *(p++);
-
-		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
-			s->d1->send_cookie == 0)
-			{
-			/* HelloVerifyMessage has already been sent */
-			if ( cookie_len != s->d1->cookie_len)
-				{
-				al = SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
-				goto f_err;
-				}
-			}
-
-		/* 
-		 * The ClientHello may contain a cookie even if the
-		 * HelloVerify message has not been sent--make sure that it
-		 * does not cause an overflow.
-		 */
-		if ( cookie_len > sizeof(s->d1->rcvd_cookie))
-			{
-			/* too much data */
-			al = SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
-			goto f_err;
-			}
-
-		/* verify the cookie if appropriate option is set. */
-		if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
-			cookie_len > 0)
-			{
-			memcpy(s->d1->rcvd_cookie, p, cookie_len);
-
-			if ( s->ctx->app_verify_cookie_cb != NULL)
-				{
-				if ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
-					cookie_len) == 0)
-					{
-					al=SSL_AD_HANDSHAKE_FAILURE;
-					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
-						SSL_R_COOKIE_MISMATCH);
-					goto f_err;
-					}
-				/* else cookie verification succeeded */
-				}
-			else if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie, 
-						  s->d1->cookie_len) != 0) /* default verification */
-				{
-					al=SSL_AD_HANDSHAKE_FAILURE;
-					SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
-						SSL_R_COOKIE_MISMATCH);
-					goto f_err;
-				}
-			}
-
-		p += cookie_len;
-		}
-
-	n2s(p,i);
-	if ((i == 0) && (j != 0))
-		{
-		/* we need a cipher if we are not resuming a session */
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);
-		goto f_err;
-		}
-	if ((p+i) >= (d+n))
-		{
-		/* not enough data */
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	if ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))
-		== NULL))
-		{
-		goto err;
-		}
-	p+=i;
-
-	/* If it is a hit, check that the cipher is in the list */
-	if ((s->hit) && (i > 0))
-		{
-		j=0;
-		id=s->session->cipher->id;
+    /* We do this so that we will respond with our native type.
+     * If we are TLSv1 and we get SSLv3, we will respond with TLSv1,
+     * This down switching should be handled by a different method.
+     * If we are SSLv3, we will respond with SSLv3, even if prompted with
+     * TLSv1.
+     */
+    if (s->state == SSL3_ST_SR_CLNT_HELLO_A)
+        {
+        s->state=SSL3_ST_SR_CLNT_HELLO_B;
+        }
+    s->first_packet=1;
+    n=s->method->ssl_get_message(s,
+        SSL3_ST_SR_CLNT_HELLO_B,
+        SSL3_ST_SR_CLNT_HELLO_C,
+        SSL3_MT_CLIENT_HELLO,
+        SSL3_RT_MAX_PLAIN_LENGTH,
+        &ok);
+
+    if (!ok) return((int)n);
+    s->first_packet=0;
+    d=p=(unsigned char *)s->init_msg;
+
+    /* use version from inside client hello, not from record header
+     * (may differ: see RFC 2246, Appendix E, second paragraph) */
+    s->client_version=(((int)p[0])<<8)|(int)p[1];
+    p+=2;
+
+    if ((s->version == DTLS1_VERSION && s->client_version > s->version) ||
+        (s->version != DTLS1_VERSION && s->client_version < s->version))
+        {
+        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, 
+           SSL_R_WRONG_VERSION_NUMBER);
+        if ((s->client_version>>8) == SSL3_VERSION_MAJOR)
+            {
+            /* similar to ssl3_get_record, send alert using remote version number */
+            s->version = s->client_version;
+            }
+        al = SSL_AD_PROTOCOL_VERSION;
+        goto f_err;
+        }
+
+    /* load the client random */
+    memcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);
+    p+=SSL3_RANDOM_SIZE;
+
+    /* get the session-id */
+    j= *(p++);
+
+    s->hit=0;
+    /* Versions before 0.9.7 always allow session reuse during renegotiation
+     * (i.e. when s->new_session is true), option
+     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is new with 0.9.7.
+     * Maybe this optional behaviour should always have been the default,
+     * but we cannot safely change the default behaviour (or new applications
+     * might be written that become totally unsecure when compiled with
+     * an earlier library version)
+     */
+#ifdef CAVIUM_SSL
+#ifndef NO_SESSION_CACHE
+    if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
+#else
+    if (1)
+#endif
+
+#else /*!CAVIUM_SSL*/
+    if ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))
+#endif
+        {
+        if (!ssl_get_new_session(s,1))
+            goto err;
+        }
+    else
+        {
+        i=ssl_get_prev_session(s, p, j, d + n);
+        if (i == 1)
+            { /* previous session */
+#ifdef CAVIUM_SSL
+                unsigned char temp_buf[48];
+                memset(temp_buf, 0, 48);
+                s->hit=1;
+                if(memcmp(s->session->master_key, temp_buf,48) == 0)
+                {
+                    s->hit=0;
+                    if (!ssl_get_new_session(s,1))
+                    {
+                        goto err;
+                    }
+                }
+#else
+            s->hit=1;
+#endif
+            }
+        else if (i == -1)
+            goto err;
+        else /* i == 0 */
+            {
+            if (!ssl_get_new_session(s,1))
+                goto err;
+            }
+        }
+
+    p+=j;
+
+    if (s->version == DTLS1_VERSION)
+        {
+        /* cookie stuff */
+        cookie_len = *(p++);
+
+        if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
+            s->d1->send_cookie == 0)
+            {
+            /* HelloVerifyMessage has already been sent */
+            if ( cookie_len != s->d1->cookie_len)
+                {
+                al = SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
+                goto f_err;
+                }
+            }
+
+        /*
+         * The ClientHello may contain a cookie even if the
+         * HelloVerify message has not been sent--make sure that it
+         * does not cause an overflow.
+         */
+        if ( cookie_len > sizeof(s->d1->rcvd_cookie))
+            {
+            /* too much data */
+            al = SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);
+            goto f_err;
+            }
+
+        /* verify the cookie if appropriate option is set. */
+        if ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&
+            cookie_len > 0)
+            {
+            memcpy(s->d1->rcvd_cookie, p, cookie_len);
+
+            if ( s->ctx->app_verify_cookie_cb != NULL)
+                {
+                if ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,
+                    cookie_len) == 0)
+                    {
+                    al=SSL_AD_HANDSHAKE_FAILURE;
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+                        SSL_R_COOKIE_MISMATCH);
+                    goto f_err;
+                    }
+                /* else cookie verification succeeded */
+                }
+            else if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie,
+                          s->d1->cookie_len) != 0) /* default verification */
+                {
+                    al=SSL_AD_HANDSHAKE_FAILURE;
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+                        SSL_R_COOKIE_MISMATCH);
+                    goto f_err;
+                }
+            }
+
+        p += cookie_len;
+        }
+
+    n2s(p,i);
+    if ((i == 0) && (j != 0))
+        {
+        /* we need a cipher if we are not resuming a session */
+        al=SSL_AD_ILLEGAL_PARAMETER;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);
+        goto f_err;
+        }
+    if ((p+i) >= (d+n))
+        {
+        /* not enough data */
+        al=SSL_AD_DECODE_ERROR;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+           SSL_R_LENGTH_MISMATCH);
+        goto f_err;
+        }
+    if ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))
+        == NULL))
+        {
+        goto err;
+        }
+    p+=i;
+
+    /* If it is a hit, check that the cipher is in the list */
+    if ((s->hit) && (i > 0))
+        {
+        j=0;
+        id=s->session->cipher->id;
 
 #ifdef CIPHER_DEBUG
-		printf("client sent %d ciphers\n",sk_num(ciphers));
+        printf("client sent %d ciphers\n",sk_num(ciphers));
 #endif
-		for (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)
-			{
-			c=sk_SSL_CIPHER_value(ciphers,i);
+        for (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)
+            {
+            c=sk_SSL_CIPHER_value(ciphers,i);
 #ifdef CIPHER_DEBUG
-			printf("client [%2d of %2d]:%s\n",
-				i,sk_num(ciphers),SSL_CIPHER_get_name(c));
+            printf("client [%2d of %2d]:%s\n",
+                i,sk_num(ciphers),SSL_CIPHER_get_name(c));
 #endif
-			if (c->id == id)
-				{
-				j=1;
-				break;
-				}
-			}
-		if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
-			{
-			/* Special case as client bug workaround: the previously used cipher may
-			 * not be in the current list, the client instead might be trying to
-			 * continue using a cipher that before wasn't chosen due to server
-			 * preferences.  We'll have to reject the connection if the cipher is not
-			 * enabled, though. */
-			c = sk_SSL_CIPHER_value(ciphers, 0);
-			if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0)
-				{
-				s->session->cipher = c;
-				j = 1;
-				}
-			}
-		if (j == 0)
-			{
-			/* we need to have the cipher in the cipher
-			 * list if we are asked to reuse it */
-			al=SSL_AD_ILLEGAL_PARAMETER;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);
-			goto f_err;
-			}
-		}
-
-	/* compression */
-	i= *(p++);
-	if ((p+i) > (d+n))
-		{
-		/* not enough data */
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	q=p;
-	for (j=0; j<i; j++)
-		{
-		if (p[j] == 0) break;
-		}
-
-	p+=i;
-	if (j >= i)
-		{
-		/* no compress */
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_COMPRESSION_SPECIFIED);
-		goto f_err;
-		}
+            if (c->id == id)
+                {
+                j=1;
+                break;
+                }
+            }
+        if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))
+            {
+            /* Special case as client bug workaround: the previously used
+             * cipher may not be in the current list, the client instead
+             * might be trying to continue using a cipher that before wasn't
+             * chosen due to server preferences.  We'll have to reject the
+             * connection if the cipher is not enabled, though.
+             */
+            c = sk_SSL_CIPHER_value(ciphers, 0);
+            if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0)
+                {
+                s->session->cipher = c;
+                j = 1;
+                }
+            }
+        if (j == 0)
+            {
+            /* we need to have the cipher in the cipher
+             * list if we are asked to reuse it */
+            al=SSL_AD_ILLEGAL_PARAMETER;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+               SSL_R_REQUIRED_CIPHER_MISSING);
+            goto f_err;
+            }
+        }
+
+    /* compression */
+    i= *(p++);
+    if ((p+i) > (d+n))
+        {
+        /* not enough data */
+        al=SSL_AD_DECODE_ERROR;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+           SSL_R_LENGTH_MISMATCH);
+        goto f_err;
+        }
+    q=p;
+    for (j=0; j<i; j++)
+        {
+        if (p[j] == 0) break;
+        }
+
+    p+=i;
+    if (j >= i)
+        {
+        /* no compress */
+        al=SSL_AD_DECODE_ERROR;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+           SSL_R_NO_COMPRESSION_SPECIFIED);
+        goto f_err;
+        }
 
 #ifndef OPENSSL_NO_TLSEXT
-	/* TLS extensions*/
-	if (s->version > SSL3_VERSION)
-		{
-		if (!ssl_parse_clienthello_tlsext(s,&p,d,n, &al))
-			{
-			/* 'al' set by ssl_parse_clienthello_tlsext */
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PARSE_TLSEXT);
-			goto f_err;
-			}
-		}
-		if (ssl_check_clienthello_tlsext(s) <= 0) {
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_CLIENTHELLO_TLSEXT);
-			goto err;
-		}
-#endif
-	/* Worst case, we will use the NULL compression, but if we have other
-	 * options, we will now look for them.  We have i-1 compression
-	 * algorithms from the client, starting at q. */
-	s->s3->tmp.new_compression=NULL;
+    /* TLS extensions*/
+    if (s->version > SSL3_VERSION)
+        {
+        if (!ssl_parse_clienthello_tlsext(s,&p,d,n, &al))
+            {
+            /* 'al' set by ssl_parse_clienthello_tlsext */
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+               SSL_R_PARSE_TLSEXT);
+            goto f_err;
+            }
+        }
+        if (ssl_check_clienthello_tlsext(s) <= 0) {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+               SSL_R_CLIENTHELLO_TLSEXT);
+            goto err;
+        }
+#endif
+    /* Worst case, we will use the NULL compression, but if we have other
+     * options, we will now look for them.  We have i-1 compression
+     * algorithms from the client, starting at q. */
+    s->s3->tmp.new_compression=NULL;
 #ifndef OPENSSL_NO_COMP
-	if (s->ctx->comp_methods != NULL)
-		{ /* See if we have a match */
-		int m,nn,o,v,done=0;
-
-		nn=sk_SSL_COMP_num(s->ctx->comp_methods);
-		for (m=0; m<nn; m++)
-			{
-			comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
-			v=comp->id;
-			for (o=0; o<i; o++)
-				{
-				if (v == q[o])
-					{
-					done=1;
-					break;
-					}
-				}
-			if (done) break;
-			}
-		if (done)
-			s->s3->tmp.new_compression=comp;
-		else
-			comp=NULL;
-		}
+    if (s->ctx->comp_methods != NULL)
+        { /* See if we have a match */
+        int m,nn,o,v,done=0;
+
+        nn=sk_SSL_COMP_num(s->ctx->comp_methods);
+        for (m=0; m<nn; m++)
+            {
+            comp=sk_SSL_COMP_value(s->ctx->comp_methods,m);
+            v=comp->id;
+            for (o=0; o<i; o++)
+                {
+                if (v == q[o])
+                    {
+                    done=1;
+                    break;
+                    }
+                }
+            if (done) break;
+            }
+        if (done)
+            s->s3->tmp.new_compression=comp;
+        else
+            comp=NULL;
+        }
 #endif
 
-	/* TLS does not mind if there is extra stuff */
+    /* TLS does not mind if there is extra stuff */
 #if 0   /* SSL 3.0 does not mind either, so we should disable this test
          * (was enabled in 0.9.6d through 0.9.6j and 0.9.7 through 0.9.7b,
-         * in earlier SSLeay/OpenSSL releases this test existed but was buggy) */
-	if (s->version == SSL3_VERSION)
-		{
-		if (p < (d+n))
-			{
-			/* wrong number of bytes,
-			 * there could be more to follow */
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
-			goto f_err;
-			}
-		}
+         * in earlier SSLeay/OpenSSL releases this test existed but was buggy)
+         */
+    if (s->version == SSL3_VERSION)
+        {
+        if (p < (d+n))
+            {
+            /* wrong number of bytes,
+             * there could be more to follow */
+            al=SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);
+            goto f_err;
+            }
+        }
 #endif
 
-	/* Given s->session->ciphers and SSL_get_ciphers, we must
-	 * pick a cipher */
+    /* Given s->session->ciphers and SSL_get_ciphers, we must
+     * pick a cipher */
 
-	if (!s->hit)
-		{
+    if (!s->hit)
+        {
 #ifdef OPENSSL_NO_COMP
-		s->session->compress_meth=0;
+        s->session->compress_meth=0;
 #else
-		s->session->compress_meth=(comp == NULL)?0:comp->id;
+        s->session->compress_meth=(comp == NULL)?0:comp->id;
+#endif
+        if (s->session->ciphers != NULL)
+            sk_SSL_CIPHER_free(s->session->ciphers);
+        s->session->ciphers=ciphers;
+        if (ciphers == NULL)
+            {
+            al=SSL_AD_ILLEGAL_PARAMETER;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+               SSL_R_NO_CIPHERS_PASSED);
+            goto f_err;
+            }
+        ciphers=NULL;
+        c=ssl3_choose_cipher(s,s->session->ciphers,
+                     SSL_get_ciphers(s));
+
+        if (c == NULL)
+            {
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,
+               SSL_R_NO_SHARED_CIPHER);
+            goto f_err;
+            }
+        s->s3->tmp.new_cipher=c;
+#ifdef CAVIUM_SSL
+        s->cipher_support = find_cipher(s, c->id);
+#if defined(RECORD_PROCESS_OFFLOAD) && !defined(HANDSHAKE_OFFLOAD)
+                if(s->cipher_support) {
+                     s->record_process = 1;
+                     s->cipher_support = 0;
+                }
 #endif
-		if (s->session->ciphers != NULL)
-			sk_SSL_CIPHER_free(s->session->ciphers);
-		s->session->ciphers=ciphers;
-		if (ciphers == NULL)
-			{
-			al=SSL_AD_ILLEGAL_PARAMETER;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_PASSED);
-			goto f_err;
-			}
-		ciphers=NULL;
-		c=ssl3_choose_cipher(s,s->session->ciphers,
-				     SSL_get_ciphers(s));
-
-		if (c == NULL)
-			{
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);
-			goto f_err;
-			}
-		s->s3->tmp.new_cipher=c;
-		}
-	else
-		{
-		/* Session-id reuse */
+#endif
+        }
+    else
+        {
+        /* Session-id reuse */
 #ifdef REUSE_CIPHER_BUG
-		STACK_OF(SSL_CIPHER) *sk;
-		SSL_CIPHER *nc=NULL;
-		SSL_CIPHER *ec=NULL;
-
-		if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)
-			{
-			sk=s->session->ciphers;
-			for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
-				{
-				c=sk_SSL_CIPHER_value(sk,i);
-				if (c->algorithms & SSL_eNULL)
-					nc=c;
-				if (SSL_C_IS_EXPORT(c))
-					ec=c;
-				}
-			if (nc != NULL)
-				s->s3->tmp.new_cipher=nc;
-			else if (ec != NULL)
-				s->s3->tmp.new_cipher=ec;
-			else
-				s->s3->tmp.new_cipher=s->session->cipher;
-			}
-		else
-#endif
-		s->s3->tmp.new_cipher=s->session->cipher;
-		}
-	
-	/* we now have the following setup. 
-	 * client_random
-	 * cipher_list 		- our prefered list of ciphers
-	 * ciphers 		- the clients prefered list of ciphers
-	 * compression		- basically ignored right now
-	 * ssl version is set	- sslv3
-	 * s->session		- The ssl session has been setup.
-	 * s->hit		- session reuse flag
-	 * s->tmp.new_cipher	- the new cipher to use.
-	 */
-
-	ret=1;
-	if (0)
-		{
+        STACK_OF(SSL_CIPHER) *sk;
+        SSL_CIPHER *nc=NULL;
+        SSL_CIPHER *ec=NULL;
+
+        if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)
+            {
+            sk=s->session->ciphers;
+            for (i=0; i<sk_SSL_CIPHER_num(sk); i++)
+                {
+                c=sk_SSL_CIPHER_value(sk,i);
+                if (c->algorithms & SSL_eNULL)
+                    nc=c;
+                if (SSL_C_IS_EXPORT(c))
+                    ec=c;
+                }
+            if (nc != NULL)
+                s->s3->tmp.new_cipher=nc;
+            else if (ec != NULL)
+                s->s3->tmp.new_cipher=ec;
+            else
+                s->s3->tmp.new_cipher=s->session->cipher;
+            }
+        else
+#endif
+        s->s3->tmp.new_cipher=s->session->cipher;
+#ifdef CAVIUM_SSL
+        s->cipher_support = find_cipher(s, s->session->cipher->id);
+#if defined(RECORD_PROCESS_OFFLOAD) && !defined(HANDSHAKE_OFFLOAD)
+        if(s->cipher_support)
+            {
+            s->cipher_support = 0;
+            s->record_process = 1;
+            }
+#endif
+#endif
+        }
+
+    /* we now have the following setup.
+     * client_random
+     * cipher_list         - our prefered list of ciphers
+     * ciphers             - the clients prefered list of ciphers
+     * compression         - basically ignored right now
+     * ssl version is set  - sslv3
+     * s->session          - The ssl session has been setup.
+     * s->hit              - session reuse flag
+     * s->tmp.new_cipher   - the new cipher to use.
+     */
+
+    ret=1;
+    if (0)
+        {
 f_err:
-		ssl3_send_alert(s,SSL3_AL_FATAL,al);
-		}
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        }
 err:
-	if (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);
-	return(ret);
-	}
+    if (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);
+    return(ret);
+    }
 
 int ssl3_send_server_hello(SSL *s)
-	{
-	unsigned char *buf;
-	unsigned char *p,*d;
-	int i,sl;
-	unsigned long l,Time;
-
-	if (s->state == SSL3_ST_SW_SRVR_HELLO_A)
-		{
-		buf=(unsigned char *)s->init_buf->data;
-		p=s->s3->server_random;
-		Time=(unsigned long)time(NULL);			/* Time */
-		l2n(Time,p);
-		if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
-			return -1;
-		/* Do the message type and length last */
-		d=p= &(buf[4]);
-
-		*(p++)=s->version>>8;
-		*(p++)=s->version&0xff;
-
-		/* Random stuff */
-		memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
-		p+=SSL3_RANDOM_SIZE;
-
-		/* now in theory we have 3 options to sending back the
-		 * session id.  If it is a re-use, we send back the
-		 * old session-id, if it is a new session, we send
-		 * back the new session-id or we send back a 0 length
-		 * session-id if we want it to be single use.
-		 * Currently I will not implement the '0' length session-id
-		 * 12-Jan-98 - I'll now support the '0' length stuff.
-		 *
-		 * We also have an additional case where stateless session
-		 * resumption is successful: we always send back the old
-		 * session id. In this case s->hit is non zero: this can
-		 * only happen if stateless session resumption is succesful
-		 * if session caching is disabled so existing functionality
-		 * is unaffected.
-		 */
-		if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
-			&& !s->hit)
-			s->session->session_id_length=0;
-
-		sl=s->session->session_id_length;
-		if (sl > (int)sizeof(s->session->session_id))
-			{
-			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
-			return -1;
-			}
-		*(p++)=sl;
-		memcpy(p,s->session->session_id,sl);
-		p+=sl;
-
-		/* put the cipher */
-		i=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);
-		p+=i;
+    {
+    unsigned char *buf;
+    unsigned char *p,*d;
+    int i,sl;
+    unsigned long l,Time;
+
+    if (s->state == SSL3_ST_SW_SRVR_HELLO_A)
+        {
+        buf=(unsigned char *)s->init_buf->data;
+        p=s->s3->server_random;
+#ifndef CAVIUM_SSL
+
+#ifndef NO_SESSION_CACHE
+        {
+        //unsigned long Time;
+        Time=(unsigned long)time(NULL);            /* Time */
+        l2n(Time,p);
+
+        if(!pkp_get_random((char *)p, SSL3_RANDOM_SIZE-sizeof(Time), s))
+            return (0);
+        }
+#else
+        if(!pkp_get_random(p, SSL3_RANDOM_SIZE, s))
+            return (0);
+#endif
 
-		/* put the compression method */
+#else
+        Time=(unsigned long)time(NULL);            /* Time */
+        l2n(Time,p);
+        if (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)
+            return -1;
+#endif
+        /* Do the message type and length last */
+        d=p= &(buf[4]);
+
+        *(p++)=s->version>>8;
+        *(p++)=s->version&0xff;
+
+        /* Random stuff */
+        memcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);
+        p+=SSL3_RANDOM_SIZE;
+
+        /* now in theory we have 3 options to sending back the
+         * session id.  If it is a re-use, we send back the
+         * old session-id, if it is a new session, we send
+         * back the new session-id or we send back a 0 length
+         * session-id if we want it to be single use.
+         * Currently I will not implement the '0' length session-id
+         * 12-Jan-98 - I'll now support the '0' length stuff.
+         *
+         * We also have an additional case where stateless session
+         * resumption is successful: we always send back the old
+         * session id. In this case s->hit is non zero: this can
+         * only happen if stateless session resumption is succesful
+         * if session caching is disabled so existing functionality
+         * is unaffected.
+         */
+        if (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER)
+            && !s->hit)
+            s->session->session_id_length=0;
+
+        sl=s->session->session_id_length;
+        if (sl > (int)sizeof(s->session->session_id))
+            {
+            SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, 
+               ERR_R_INTERNAL_ERROR);
+            return -1;
+            }
+        *(p++)=sl;
+        memcpy(p,s->session->session_id,sl);
+        p+=sl;
+
+        /* put the cipher */
+        i=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);
+        p+=i;
+
+        /* put the compression method */
 #ifdef OPENSSL_NO_COMP
-			*(p++)=0;
+            *(p++)=0;
 #else
-		if (s->s3->tmp.new_compression == NULL)
-			*(p++)=0;
-		else
-			*(p++)=s->s3->tmp.new_compression->id;
+        if (s->s3->tmp.new_compression == NULL)
+            *(p++)=0;
+        else
+            *(p++)=s->s3->tmp.new_compression->id;
 #endif
 #ifndef OPENSSL_NO_TLSEXT
-		if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,ERR_R_INTERNAL_ERROR);
-			return -1;
-			}
-#endif
-		/* do the header */
-		l=(p-d);
-		d=buf;
-		*(d++)=SSL3_MT_SERVER_HELLO;
-		l2n3(l,d);
-
-		s->state=SSL3_ST_SW_SRVR_HELLO_B;
-		/* number of bytes to write */
-		s->init_num=p-buf;
-		s->init_off=0;
-		}
-
-	/* SSL3_ST_SW_SRVR_HELLO_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+        if ((p = ssl_add_serverhello_tlsext(s, p, buf+SSL3_RT_MAX_PLAIN_LENGTH)) == NULL)
+            {
+            SSLerr(SSL_F_SSL3_SEND_SERVER_HELLO,
+               ERR_R_INTERNAL_ERROR);
+            return -1;
+            }
+#endif
+        /* do the header */
+        l=(p-d);
+        d=buf;
+        *(d++)=SSL3_MT_SERVER_HELLO;
+        l2n3(l,d);
+
+        s->state=SSL3_ST_SW_SRVR_HELLO_B;
+        /* number of bytes to write */
+        s->init_num=p-buf;
+        s->init_off=0;
+        }
+
+    /* SSL3_ST_SW_SRVR_HELLO_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+    }
 
 int ssl3_send_server_done(SSL *s)
-	{
-	unsigned char *p;
-
-	if (s->state == SSL3_ST_SW_SRVR_DONE_A)
-		{
-		p=(unsigned char *)s->init_buf->data;
-
-		/* do the header */
-		*(p++)=SSL3_MT_SERVER_DONE;
-		*(p++)=0;
-		*(p++)=0;
-		*(p++)=0;
-
-		s->state=SSL3_ST_SW_SRVR_DONE_B;
-		/* number of bytes to write */
-		s->init_num=4;
-		s->init_off=0;
-		}
-
-	/* SSL3_ST_SW_SRVR_DONE_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+    {
+    unsigned char *p;
+#ifdef CAVIUM_SSL
+    int i;
+#endif
+
+    if (s->state == SSL3_ST_SW_SRVR_DONE_A)
+        {
+        p=(unsigned char *)s->init_buf->data;
+
+        /* do the header */
+        *(p++)=SSL3_MT_SERVER_DONE;
+        *(p++)=0;
+        *(p++)=0;
+        *(p++)=0;
+
+        s->state=SSL3_ST_SW_SRVR_DONE_B;
+        /* number of bytes to write */
+        s->init_num=4;
+        s->init_off=0;
+        }
+
+    /* SSL3_ST_SW_SRVR_DONE_B */
+#ifndef CAVIUM_SSL
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+#else
+    i = ssl3_do_write(s,SSL3_RT_HANDSHAKE);
+        /* here store the client key_exchange message offset */
+    if(!(SSL_get_verify_mode(s) & SSL_VERIFY_PEER))
+        s->client_key_exch_msg_offset = s->hs_msgs_len;
+    else
+        s->client_cert_msg_offset = s->hs_msgs_len;
+    return i;
+#endif
+    }
 
 int ssl3_send_server_key_exchange(SSL *s)
-	{
+    {
 #ifndef OPENSSL_NO_RSA
-	unsigned char *q;
-	int j,num;
-	RSA *rsa;
-	unsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
-	unsigned int u;
+    unsigned char *q;
+    int j,num;
+    RSA *rsa;
+    unsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
+    unsigned int u;
 #endif
 #ifndef OPENSSL_NO_DH
-	DH *dh=NULL,*dhp;
+    DH *dh=NULL,*dhp;
 #endif
 #ifndef OPENSSL_NO_ECDH
-	EC_KEY *ecdh=NULL, *ecdhp;
-	unsigned char *encodedPoint = NULL;
-	int encodedlen = 0;
-	int curve_id = 0;
-	BN_CTX *bn_ctx = NULL; 
-#endif
-	EVP_PKEY *pkey;
-	unsigned char *p,*d;
-	int al,i;
-	unsigned long type;
-	int n;
-	CERT *cert;
-	BIGNUM *r[4];
-	int nr[4],kn;
-	BUF_MEM *buf;
-	EVP_MD_CTX md_ctx;
-
-	EVP_MD_CTX_init(&md_ctx);
-	if (s->state == SSL3_ST_SW_KEY_EXCH_A)
-		{
-		type=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;
-		cert=s->cert;
+    EC_KEY *ecdh=NULL, *ecdhp;
+    unsigned char *encodedPoint = NULL;
+    int encodedlen = 0;
+    int curve_id = 0;
+    BN_CTX *bn_ctx = NULL;
+#endif
+    EVP_PKEY *pkey;
+    unsigned char *p,*d;
+    int al,i;
+    unsigned long type;
+    int key_type;
+    int n;
+    CERT *cert;
+    BIGNUM *r[4];
+    int nr[4],kn;
+    BUF_MEM *buf;
+    EVP_MD_CTX md_ctx;
+
+    EVP_MD_CTX_init(&md_ctx);
+    if (s->state == SSL3_ST_SW_KEY_EXCH_A)
+        {
+        type=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;
+        cert=s->cert;
 
-		buf=s->init_buf;
+        buf=s->init_buf;
 
-		r[0]=r[1]=r[2]=r[3]=NULL;
-		n=0;
+        r[0]=r[1]=r[2]=r[3]=NULL;
+        n=0;
 #ifndef OPENSSL_NO_RSA
-		if (type & SSL_kRSA)
-			{
-			rsa=cert->rsa_tmp;
-			if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))
-				{
-				rsa=s->cert->rsa_tmp_cb(s,
-				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
-				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
-				if(rsa == NULL)
-				{
-					al=SSL_AD_HANDSHAKE_FAILURE;
-					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
-					goto f_err;
-				}
-				RSA_up_ref(rsa);
-				cert->rsa_tmp=rsa;
-				}
-			if (rsa == NULL)
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);
-				goto f_err;
-				}
-			r[0]=rsa->n;
-			r[1]=rsa->e;
-			s->s3->tmp.use_rsa_tmp=1;
-			}
-		else
+        if (type & SSL_kRSA)
+            {
+            rsa=cert->rsa_tmp;
+            if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))
+                {
+                rsa=s->cert->rsa_tmp_cb(s,
+                      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
+                      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
+                if(rsa == NULL)
+                {
+                    al=SSL_AD_HANDSHAKE_FAILURE;
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                       SSL_R_ERROR_GENERATING_TMP_RSA_KEY);
+                    goto f_err;
+                }
+                RSA_up_ref(rsa);
+                cert->rsa_tmp=rsa;
+                }
+            if (rsa == NULL)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_MISSING_TMP_RSA_KEY);
+                goto f_err;
+                }
+            r[0]=rsa->n;
+            r[1]=rsa->e;
+            s->s3->tmp.use_rsa_tmp=1;
+#ifdef CAVIUM_SSL
+            s->flag=1;
+#endif
+            }
+        else
 #endif
 #ifndef OPENSSL_NO_DH
-			if (type & SSL_kEDH)
-			{
-			dhp=cert->dh_tmp;
-			if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))
-				dhp=s->cert->dh_tmp_cb(s,
-				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
-				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
-			if (dhp == NULL)
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);
-				goto f_err;
-				}
-
-			if (s->s3->tmp.dh != NULL)
-				{
-				DH_free(dh);
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
-				goto err;
-				}
-
-			if ((dh=DHparams_dup(dhp)) == NULL)
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
-				goto err;
-				}
-
-			s->s3->tmp.dh=dh;
-			if ((dhp->pub_key == NULL ||
-			     dhp->priv_key == NULL ||
-			     (s->options & SSL_OP_SINGLE_DH_USE)))
-				{
-				if(!DH_generate_key(dh))
-				    {
-				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
-					   ERR_R_DH_LIB);
-				    goto err;
-				    }
-				}
-			else
-				{
-				dh->pub_key=BN_dup(dhp->pub_key);
-				dh->priv_key=BN_dup(dhp->priv_key);
-				if ((dh->pub_key == NULL) ||
-					(dh->priv_key == NULL))
-					{
-					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
-					goto err;
-					}
-				}
-			r[0]=dh->p;
-			r[1]=dh->g;
-			r[2]=dh->pub_key;
-			}
-		else 
+            if (type & SSL_kEDH)
+            {
+            dhp=cert->dh_tmp;
+            if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))
+                dhp=s->cert->dh_tmp_cb(s,
+                      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
+                      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
+            if (dhp == NULL)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_MISSING_TMP_DH_KEY);
+                goto f_err;
+                }
+
+            if (s->s3->tmp.dh != NULL)
+                {
+                DH_free(dh);
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, 
+                   ERR_R_INTERNAL_ERROR);
+                goto err;
+                }
+
+            if ((dh=DHparams_dup(dhp)) == NULL)
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   ERR_R_DH_LIB);
+                goto err;
+                }
+
+            s->s3->tmp.dh=dh;
+            if ((dhp->pub_key == NULL ||
+                 dhp->priv_key == NULL ||
+                 (s->options & SSL_OP_SINGLE_DH_USE)))
+                {
+                if(!DH_generate_key(dh))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                       ERR_R_DH_LIB);
+                    goto err;
+                    }
+                }
+            else
+                {
+                dh->pub_key=BN_dup(dhp->pub_key);
+                dh->priv_key=BN_dup(dhp->priv_key);
+                if ((dh->pub_key == NULL) ||
+                    (dh->priv_key == NULL))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);
+                    goto err;
+                    }
+                }
+            r[0]=dh->p;
+            r[1]=dh->g;
+            r[2]=dh->pub_key;
+            }
+        else
 #endif
 #ifndef OPENSSL_NO_ECDH
-			if (type & SSL_kECDHE)
-			{
-			const EC_GROUP *group;
-
-			ecdhp=cert->ecdh_tmp;
-			if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
-				{
-				ecdhp=s->cert->ecdh_tmp_cb(s,
-				      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
-				      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
-				}
-			if (ecdhp == NULL)
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
-				goto f_err;
-				}
-
-			if (s->s3->tmp.ecdh != NULL)
-				{
-				EC_KEY_free(s->s3->tmp.ecdh); 
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);
-				goto err;
-				}
-
-			/* Duplicate the ECDH structure. */
-			if (ecdhp == NULL)
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
-				goto err;
-				}
-			if (!EC_KEY_up_ref(ecdhp))
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
-				goto err;
-				}
-			ecdh = ecdhp;
-
-			s->s3->tmp.ecdh=ecdh;
-			if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
-			    (EC_KEY_get0_private_key(ecdh) == NULL) ||
-			    (s->options & SSL_OP_SINGLE_ECDH_USE))
-				{
-				if(!EC_KEY_generate_key(ecdh))
-				    {
-				    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
-				    goto err;
-				    }
-				}
-
-			if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
-			    (EC_KEY_get0_public_key(ecdh)  == NULL) ||
-			    (EC_KEY_get0_private_key(ecdh) == NULL))
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
-				goto err;
-				}
-
-			if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
-			    (EC_GROUP_get_degree(group) > 163)) 
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
-				goto err;
-				}
-
-			/* XXX: For now, we only support ephemeral ECDH
-			 * keys over named (not generic) curves. For 
-			 * supported named curves, curve_id is non-zero.
-			 */
-			if ((curve_id = 
-			    nid2curve_id(EC_GROUP_get_curve_name(group)))
-			    == 0)
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
-				goto err;
-				}
-
-			/* Encode the public key.
-			 * First check the size of encoding and
-			 * allocate memory accordingly.
-			 */
-			encodedlen = EC_POINT_point2oct(group, 
-			    EC_KEY_get0_public_key(ecdh),
-			    POINT_CONVERSION_UNCOMPRESSED, 
-			    NULL, 0, NULL);
-
-			encodedPoint = (unsigned char *) 
-			    OPENSSL_malloc(encodedlen*sizeof(unsigned char)); 
-			bn_ctx = BN_CTX_new();
-			if ((encodedPoint == NULL) || (bn_ctx == NULL))
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);
-				goto err;
-				}
-
-
-			encodedlen = EC_POINT_point2oct(group, 
-			    EC_KEY_get0_public_key(ecdh), 
-			    POINT_CONVERSION_UNCOMPRESSED, 
-			    encodedPoint, encodedlen, bn_ctx);
-
-			if (encodedlen == 0) 
-				{
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
-				goto err;
-				}
-
-			BN_CTX_free(bn_ctx);  bn_ctx=NULL;
-
-			/* XXX: For now, we only support named (not 
-			 * generic) curves in ECDH ephemeral key exchanges.
-			 * In this situation, we need four additional bytes
-			 * to encode the entire ServerECDHParams
-			 * structure. 
-			 */
-			n = 4 + encodedlen;
-
-			/* We'll generate the serverKeyExchange message
-			 * explicitly so we can set these to NULLs
-			 */
-			r[0]=NULL;
-			r[1]=NULL;
-			r[2]=NULL;
-			r[3]=NULL;
-			}
-		else 
+            if (type & SSL_kECDHE)
+            {
+            const EC_GROUP *group;
+
+            ecdhp=cert->ecdh_tmp;
+            if ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))
+                {
+                ecdhp=s->cert->ecdh_tmp_cb(s,
+                      SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),
+                      SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));
+                }
+            if (ecdhp == NULL)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_MISSING_TMP_ECDH_KEY);
+                goto f_err;
+                }
+
+            if (s->s3->tmp.ecdh != NULL)
+                {
+                EC_KEY_free(s->s3->tmp.ecdh);
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, 
+                   ERR_R_INTERNAL_ERROR);
+                goto err;
+                }
+
+            /* Duplicate the ECDH structure. */
+            if (ecdhp == NULL)
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   ERR_R_ECDH_LIB);
+                goto err;
+                }
+            if (!EC_KEY_up_ref(ecdhp))
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   ERR_R_ECDH_LIB);
+                goto err;
+                }
+            ecdh = ecdhp;
+
+            s->s3->tmp.ecdh=ecdh;
+            if ((EC_KEY_get0_public_key(ecdh) == NULL) ||
+                (EC_KEY_get0_private_key(ecdh) == NULL) ||
+                (s->options & SSL_OP_SINGLE_ECDH_USE))
+                {
+                if(!EC_KEY_generate_key(ecdh))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
+                    goto err;
+                    }
+                }
+
+            if (((group = EC_KEY_get0_group(ecdh)) == NULL) ||
+                (EC_KEY_get0_public_key(ecdh)  == NULL) ||
+                (EC_KEY_get0_private_key(ecdh) == NULL))
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);
+                goto err;
+                }
+
+            if (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&
+                (EC_GROUP_get_degree(group) > 163))
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);
+                goto err;
+                }
+
+            /* XXX: For now, we only support ephemeral ECDH
+             * keys over named (not generic) curves. For
+             * supported named curves, curve_id is non-zero.
+             */
+            if ((curve_id =
+                nid2curve_id(EC_GROUP_get_curve_name(group)))
+                == 0)
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);
+                goto err;
+                }
+
+            /* Encode the public key.
+             * First check the size of encoding and
+             * allocate memory accordingly.
+             */
+            encodedlen = EC_POINT_point2oct(group,
+                EC_KEY_get0_public_key(ecdh),
+                POINT_CONVERSION_UNCOMPRESSED,
+                NULL, 0, NULL);
+
+            encodedPoint = (unsigned char *)
+                OPENSSL_malloc(encodedlen*sizeof(unsigned char));
+            bn_ctx = BN_CTX_new();
+            if ((encodedPoint == NULL) || (bn_ctx == NULL))
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+
+
+            encodedlen = EC_POINT_point2oct(group,
+                EC_KEY_get0_public_key(ecdh),
+                POINT_CONVERSION_UNCOMPRESSED,
+                encodedPoint, encodedlen, bn_ctx);
+
+            if (encodedlen == 0)
+                {
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   ERR_R_ECDH_LIB);
+                goto err;
+                }
+
+            BN_CTX_free(bn_ctx);  bn_ctx=NULL;
+
+            /* XXX: For now, we only support named (not
+             * generic) curves in ECDH ephemeral key exchanges.
+             * In this situation, we need four additional bytes
+             * to encode the entire ServerECDHParams
+             * structure.
+             */
+            n = 4 + encodedlen;
+
+            /* We'll generate the serverKeyExchange message
+             * explicitly so we can set these to NULLs
+             */
+            r[0]=NULL;
+            r[1]=NULL;
+            r[2]=NULL;
+            r[3]=NULL;
+            }
+        else
 #endif /* !OPENSSL_NO_ECDH */
-			{
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
-			goto f_err;
-			}
-		for (i=0; r[i] != NULL; i++)
-			{
-			nr[i]=BN_num_bytes(r[i]);
-			n+=2+nr[i];
-			}
-
-		if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
-			{
-			if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))
-				== NULL)
-				{
-				al=SSL_AD_DECODE_ERROR;
-				goto f_err;
-				}
-			kn=EVP_PKEY_size(pkey);
-			}
-		else
-			{
-			pkey=NULL;
-			kn=0;
-			}
-
-		if (!BUF_MEM_grow_clean(buf,n+4+kn))
-			{
-			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);
-			goto err;
-			}
-		d=(unsigned char *)s->init_buf->data;
-		p= &(d[4]);
-
-		for (i=0; r[i] != NULL; i++)
-			{
-			s2n(nr[i],p);
-			BN_bn2bin(r[i],p);
-			p+=nr[i];
-			}
+            {
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+               SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
+            goto f_err;
+            }
+        for (i=0; r[i] != NULL; i++)
+            {
+            nr[i]=BN_num_bytes(r[i]);
+            n+=2+nr[i];
+            }
+
+        if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))
+            {
+            if ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))
+                == NULL)
+                {
+                al=SSL_AD_DECODE_ERROR;
+                goto f_err;
+                }
+#ifdef CAVIUM_FIPS
+            kn = s->ctx->pkey_info.size;
+#else
+            kn = EVP_PKEY_size(pkey);
+#endif
+            }
+        else
+            {
+            pkey=NULL;
+            kn=0;
+            }
+
+        if (!BUF_MEM_grow_clean(buf,n+4+kn))
+            {
+            SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+               ERR_LIB_BUF);
+            goto err;
+            }
+        d=(unsigned char *)s->init_buf->data;
+        p= &(d[4]);
+
+        for (i=0; r[i] != NULL; i++)
+            {
+            s2n(nr[i],p);
+            BN_bn2bin(r[i],p);
+            p+=nr[i];
+            }
 
 #ifndef OPENSSL_NO_ECDH
-		if (type & SSL_kECDHE) 
-			{
-			/* XXX: For now, we only support named (not generic) curves.
-			 * In this situation, the serverKeyExchange message has:
-			 * [1 byte CurveType], [2 byte CurveName]
-			 * [1 byte length of encoded point], followed by
-			 * the actual encoded point itself
-			 */
-			*p = NAMED_CURVE_TYPE;
-			p += 1;
-			*p = 0;
-			p += 1;
-			*p = curve_id;
-			p += 1;
-			*p = encodedlen;
-			p += 1;
-			memcpy((unsigned char*)p, 
-			    (unsigned char *)encodedPoint, 
-			    encodedlen);
-			OPENSSL_free(encodedPoint);
-			p += encodedlen;
-			}
-#endif
-
-		/* not anonymous */
-		if (pkey != NULL)
-			{
-			/* n is the length of the params, they start at &(d[4])
-			 * and p points to the space at the end. */
+        if (type & SSL_kECDHE)
+            {
+            /* XXX: For now, we only support named (not generic) curves.
+             * In this situation, the serverKeyExchange message has:
+             * [1 byte CurveType], [2 byte CurveName]
+             * [1 byte length of encoded point], followed by
+             * the actual encoded point itself
+             */
+            *p = NAMED_CURVE_TYPE;
+            p += 1;
+            *p = 0;
+            p += 1;
+            *p = curve_id;
+            p += 1;
+            *p = encodedlen;
+            p += 1;
+            memcpy((unsigned char*)p,
+                (unsigned char *)encodedPoint,
+                encodedlen);
+            OPENSSL_free(encodedPoint);
+            p += encodedlen;
+            }
+#endif
+
+        /* not anonymous */
+        if (pkey != NULL)
+            {
+            /* n is the length of the params, they start at &(d[4])
+             * and p points to the space at the end. */
 #ifndef OPENSSL_NO_RSA
-			if (pkey->type == EVP_PKEY_RSA)
-				{
-				q=md_buf;
-				j=0;
-				for (num=2; num > 0; num--)
-					{
-					EVP_MD_CTX_set_flags(&md_ctx,
-						EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
-					EVP_DigestInit_ex(&md_ctx,(num == 2)
-						?s->ctx->md5:s->ctx->sha1, NULL);
-					EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-					EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-					EVP_DigestUpdate(&md_ctx,&(d[4]),n);
-					EVP_DigestFinal_ex(&md_ctx,q,
-						(unsigned int *)&i);
-					q+=i;
-					j+=i;
-					}
-				if (RSA_sign(NID_md5_sha1, md_buf, j,
-					&(p[2]), &u, pkey->pkey.rsa) <= 0)
-					{
-					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);
-					goto err;
-					}
-				s2n(u,p);
-				n+=u+2;
-				}
-			else
+#ifdef CAVIUM_FIPS
+            key_type = s->ctx->pkey_info.type;
+#else
+            key_type = pkey->type;
+#endif
+            if (key_type == EVP_PKEY_RSA)
+                {
+                q=md_buf;
+                j=0;
+                for (num=2; num > 0; num--)
+                    {
+                    EVP_MD_CTX_set_flags(&md_ctx,
+                        EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
+                    EVP_DigestInit_ex(&md_ctx,(num == 2)
+                        ?s->ctx->md5:s->ctx->sha1, NULL);
+                    EVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                    EVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                    EVP_DigestUpdate(&md_ctx,&(d[4]),n);
+                    EVP_DigestFinal_ex(&md_ctx,q,
+                        (unsigned int *)&i);
+                    q+=i;
+                    j+=i;
+                    }
+#if defined (CAVIUM_SSL) && defined(CAVIUM_FIPS)
+                if(pkp_rsa_private_encrypt(j, md_buf, &p[2], (RSA *)s, 1) == 0)
+                {
+                   SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                      ERR_LIB_RSA);
+                   goto err;
+                }
+                u = s->ctx->pkey_info.size;
+#else
+                if (RSA_sign(NID_md5_sha1, md_buf, j,
+                    &(p[2]), &u, pkey->pkey.rsa) <= 0)
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                       ERR_LIB_RSA);
+                    goto err;
+                    }
+#endif
+                s2n(u,p);
+                n+=u+2;
+                }
+            else
 #endif
 #if !defined(OPENSSL_NO_DSA)
-				if (pkey->type == EVP_PKEY_DSA)
-				{
-				/* lets do DSS */
-				EVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);
-				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-				EVP_SignUpdate(&md_ctx,&(d[4]),n);
-				if (!EVP_SignFinal(&md_ctx,&(p[2]),
-					(unsigned int *)&i,pkey))
-					{
-					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);
-					goto err;
-					}
-				s2n(i,p);
-				n+=i+2;
-				}
-			else
+                if (pkey->type == EVP_PKEY_DSA)
+                {
+                /* lets do DSS */
+                EVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);
+                EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                EVP_SignUpdate(&md_ctx,&(d[4]),n);
+                if (!EVP_SignFinal(&md_ctx,&(p[2]),
+                    (unsigned int *)&i,pkey))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                       ERR_LIB_DSA);
+                    goto err;
+                    }
+                s2n(i,p);
+                n+=i+2;
+                }
+            else
 #endif
 #if !defined(OPENSSL_NO_ECDSA)
-				if (pkey->type == EVP_PKEY_EC)
-				{
-				/* let's do ECDSA */
-				EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
-				EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
-				EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
-				EVP_SignUpdate(&md_ctx,&(d[4]),n);
-				if (!EVP_SignFinal(&md_ctx,&(p[2]),
-					(unsigned int *)&i,pkey))
-					{
-					SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);
-					goto err;
-					}
-				s2n(i,p);
-				n+=i+2;
-				}
-			else
-#endif
-				{
-				/* Is this error check actually needed? */
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);
-				goto f_err;
-				}
-			}
-
-		*(d++)=SSL3_MT_SERVER_KEY_EXCHANGE;
-		l2n3(n,d);
-
-		/* we should now have things packed up, so lets send
-		 * it off */
-		s->init_num=n+4;
-		s->init_off=0;
-		}
-
-	s->state = SSL3_ST_SW_KEY_EXCH_B;
-	EVP_MD_CTX_cleanup(&md_ctx);
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+                if (pkey->type == EVP_PKEY_EC)
+                {
+                /* let's do ECDSA */
+                EVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);
+                EVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);
+                EVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);
+                EVP_SignUpdate(&md_ctx,&(d[4]),n);
+                if (!EVP_SignFinal(&md_ctx,&(p[2]),
+                    (unsigned int *)&i,pkey))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                       ERR_LIB_ECDSA);
+                    goto err;
+                    }
+                s2n(i,p);
+                n+=i+2;
+                }
+            else
+#endif
+                {
+                /* Is this error check actually needed? */
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
+                   SSL_R_UNKNOWN_PKEY_TYPE);
+                goto f_err;
+                }
+            }
+
+        *(d++)=SSL3_MT_SERVER_KEY_EXCHANGE;
+        l2n3(n,d);
+
+        /* we should now have things packed up, so lets send
+         * it off */
+        s->init_num=n+4;
+        s->init_off=0;
+        }
+
+    s->state = SSL3_ST_SW_KEY_EXCH_B;
+    EVP_MD_CTX_cleanup(&md_ctx);
+#ifdef CAVIUM_SSL
+    if (s->flag == 1) {
+        s->s3->tmp.use_rsa_tmp=1;
+    }
+#endif
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
+    ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
 #ifndef OPENSSL_NO_ECDH
-	if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
-	BN_CTX_free(bn_ctx);
+    if (encodedPoint != NULL) OPENSSL_free(encodedPoint);
+    BN_CTX_free(bn_ctx);
 #endif
-	EVP_MD_CTX_cleanup(&md_ctx);
-	return(-1);
-	}
+    EVP_MD_CTX_cleanup(&md_ctx);
+    return(-1);
+    }
 
 int ssl3_send_certificate_request(SSL *s)
-	{
-	unsigned char *p,*d;
-	int i,j,nl,off,n;
-	STACK_OF(X509_NAME) *sk=NULL;
-	X509_NAME *name;
-	BUF_MEM *buf;
-
-	if (s->state == SSL3_ST_SW_CERT_REQ_A)
-		{
-		buf=s->init_buf;
-
-		d=p=(unsigned char *)&(buf->data[4]);
-
-		/* get the list of acceptable cert types */
-		p++;
-		n=ssl3_get_req_cert_type(s,p);
-		d[0]=n;
-		p+=n;
-		n++;
-
-		off=n;
-		p+=2;
-		n+=2;
-
-		sk=SSL_get_client_CA_list(s);
-		nl=0;
-		if (sk != NULL)
-			{
-			for (i=0; i<sk_X509_NAME_num(sk); i++)
-				{
-				name=sk_X509_NAME_value(sk,i);
-				j=i2d_X509_NAME(name,NULL);
-				if (!BUF_MEM_grow_clean(buf,4+n+j+2))
-					{
-					SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);
-					goto err;
-					}
-				p=(unsigned char *)&(buf->data[4+n]);
-				if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
-					{
-					s2n(j,p);
-					i2d_X509_NAME(name,&p);
-					n+=2+j;
-					nl+=2+j;
-					}
-				else
-					{
-					d=p;
-					i2d_X509_NAME(name,&p);
-					j-=2; s2n(j,d); j+=2;
-					n+=j;
-					nl+=j;
-					}
-				}
-			}
-		/* else no CA names */
-		p=(unsigned char *)&(buf->data[4+off]);
-		s2n(nl,p);
-
-		d=(unsigned char *)buf->data;
-		*(d++)=SSL3_MT_CERTIFICATE_REQUEST;
-		l2n3(n,d);
+    {
+    unsigned char *p,*d;
+    int i,j,nl,off,n;
+    STACK_OF(X509_NAME) *sk=NULL;
+    X509_NAME *name;
+    BUF_MEM *buf;
+
+    if (s->state == SSL3_ST_SW_CERT_REQ_A)
+        {
+        buf=s->init_buf;
+
+        d=p=(unsigned char *)&(buf->data[4]);
+
+        /* get the list of acceptable cert types */
+        p++;
+        n=ssl3_get_req_cert_type(s,p);
+        d[0]=n;
+        p+=n;
+        n++;
+
+        off=n;
+        p+=2;
+        n+=2;
+
+        sk=SSL_get_client_CA_list(s);
+        nl=0;
+        if (sk != NULL)
+            {
+            for (i=0; i<sk_X509_NAME_num(sk); i++)
+                {
+                name=sk_X509_NAME_value(sk,i);
+                j=i2d_X509_NAME(name,NULL);
+                if (!BUF_MEM_grow_clean(buf,4+n+j+2))
+                    {
+                    SSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,
+                       ERR_R_BUF_LIB);
+                    goto err;
+                    }
+                p=(unsigned char *)&(buf->data[4+n]);
+                if (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))
+                    {
+                    s2n(j,p);
+                    i2d_X509_NAME(name,&p);
+                    n+=2+j;
+                    nl+=2+j;
+                    }
+                else
+                    {
+                    d=p;
+                    i2d_X509_NAME(name,&p);
+                    j-=2; s2n(j,d); j+=2;
+                    n+=j;
+                    nl+=j;
+                    }
+                }
+            }
+        /* else no CA names */
+        p=(unsigned char *)&(buf->data[4+off]);
+        s2n(nl,p);
+
+        d=(unsigned char *)buf->data;
+        *(d++)=SSL3_MT_CERTIFICATE_REQUEST;
+        l2n3(n,d);
 
-		/* we should now have things packed up, so lets send
-		 * it off */
+        /* we should now have things packed up, so lets send
+         * it off */
 
-		s->init_num=n+4;
-		s->init_off=0;
+        s->init_num=n+4;
+        s->init_off=0;
 #ifdef NETSCAPE_HANG_BUG
-		p=(unsigned char *)s->init_buf->data + s->init_num;
+        p=(unsigned char *)s->init_buf->data + s->init_num;
 
-		/* do the header */
-		*(p++)=SSL3_MT_SERVER_DONE;
-		*(p++)=0;
-		*(p++)=0;
-		*(p++)=0;
-		s->init_num += 4;
+        /* do the header */
+        *(p++)=SSL3_MT_SERVER_DONE;
+        *(p++)=0;
+        *(p++)=0;
+        *(p++)=0;
+        s->init_num += 4;
 #endif
 
-		s->state = SSL3_ST_SW_CERT_REQ_B;
-		}
+        s->state = SSL3_ST_SW_CERT_REQ_B;
+        }
 
-	/* SSL3_ST_SW_CERT_REQ_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+    /* SSL3_ST_SW_CERT_REQ_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
 err:
-	return(-1);
-	}
+    return(-1);
+    }
 
 int ssl3_get_client_key_exchange(SSL *s)
-	{
-	int i,al,ok;
-	long n;
-	unsigned long l;
-	unsigned char *p;
+    {
+    int i,al,ok;
+    long n;
+    unsigned long l;
+    unsigned char *p;
 #ifndef OPENSSL_NO_RSA
-	RSA *rsa=NULL;
-	EVP_PKEY *pkey=NULL;
+    RSA *rsa=NULL;
+    EVP_PKEY *pkey=NULL;
 #endif
 #ifndef OPENSSL_NO_DH
-	BIGNUM *pub=NULL;
-	DH *dh_srvr;
+    BIGNUM *pub=NULL;
+    DH *dh_srvr;
 #endif
 #ifndef OPENSSL_NO_KRB5
-        KSSL_ERR kssl_err;
+    KSSL_ERR kssl_err;
 #endif /* OPENSSL_NO_KRB5 */
 
 #ifndef OPENSSL_NO_ECDH
-	EC_KEY *srvr_ecdh = NULL;
-	EVP_PKEY *clnt_pub_pkey = NULL;
-	EC_POINT *clnt_ecpoint = NULL;
-	BN_CTX *bn_ctx = NULL; 
-#endif
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_KEY_EXCH_A,
-		SSL3_ST_SR_KEY_EXCH_B,
-		SSL3_MT_CLIENT_KEY_EXCHANGE,
-		2048, /* ??? */
-		&ok);
-
-	if (!ok) return((int)n);
-	p=(unsigned char *)s->init_msg;
+    EC_KEY *srvr_ecdh = NULL;
+    EVP_PKEY *clnt_pub_pkey = NULL;
+    EC_POINT *clnt_ecpoint = NULL;
+    BN_CTX *bn_ctx = NULL;
+#endif
+
+    n=s->method->ssl_get_message(s,
+        SSL3_ST_SR_KEY_EXCH_A,
+        SSL3_ST_SR_KEY_EXCH_B,
+        SSL3_MT_CLIENT_KEY_EXCHANGE,
+        2048, /* ??? */
+        &ok);
+
+    if (!ok) return((int)n);
+#ifdef CAVIUM_SSL
+    /* Donot do any rsa operation and master key generation
+     * when CAVIUM_SSL is defined. These are the part of TurboSSL
+     * and will be done after receiving client finish message */
+    if(s->cipher_support)
+    {
+        /* Added by Tarun for Session Resumption
+         * Apache uses master_key_length to get teh length
+         * and store that many bytes of master secret in
+         * its cache
+         */
+        s->session->master_key_length = SSL_MAX_MASTER_KEY_LENGTH;
+        return 1;
+    } /* if cipher_support */
+    else
+    {
+#endif /* CAVIUM_SSL */
+    p=(unsigned char *)s->init_msg;
 
-	l=s->s3->tmp.new_cipher->algorithms;
+    l=s->s3->tmp.new_cipher->algorithms;
 
 #ifndef OPENSSL_NO_RSA
-	if (l & SSL_kRSA)
-		{
-		/* FIX THIS UP EAY EAY EAY EAY */
-		if (s->s3->tmp.use_rsa_tmp)
-			{
-			if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
-				rsa=s->cert->rsa_tmp;
-			/* Don't do a callback because rsa_tmp should
-			 * be sent already */
-			if (rsa == NULL)
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);
-				goto f_err;
-
-				}
-			}
-		else
-			{
-			pkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
-			if (	(pkey == NULL) ||
-				(pkey->type != EVP_PKEY_RSA) ||
-				(pkey->pkey.rsa == NULL))
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);
-				goto f_err;
-				}
-			rsa=pkey->pkey.rsa;
-			}
-
-		/* TLS and [incidentally] DTLS, including pre-0.9.8f */
-		if (s->version > SSL3_VERSION &&
-		    s->client_version != DTLS1_BAD_VER)
-			{
-			n2s(p,i);
-			if (n != i+2)
-				{
-				if (!(s->options & SSL_OP_TLS_D5_BUG))
-					{
-					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
-					goto err;
-					}
-				else
-					p-=2;
-				}
-			else
-				n=i;
-			}
-
-		i=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);
-
-		al = -1;
-		
-		if (i != SSL_MAX_MASTER_KEY_LENGTH)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
-			}
-
-		if ((al == -1) && !((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))
-			{
-			/* The premaster secret must contain the same version number as the
-			 * ClientHello to detect version rollback attacks (strangely, the
-			 * protocol does not offer such protection for DH ciphersuites).
-			 * However, buggy clients exist that send the negotiated protocol
-			 * version instead if the server does not support the requested
-			 * protocol version.
-			 * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. */
-			if (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&
-				(p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))
-				{
-				al=SSL_AD_DECODE_ERROR;
-				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */
-
-				/* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
-				 * (http://eprint.iacr.org/2003/052/) exploits the version
-				 * number check as a "bad version oracle" -- an alert would
-				 * reveal that the plaintext corresponding to some ciphertext
-				 * made up by the adversary is properly formatted except
-				 * that the version number is wrong.  To avoid such attacks,
-				 * we should treat this just like any other decryption error. */
-				}
-			}
-
-		if (al != -1)
-			{
-			/* Some decryption failure -- use random value instead as countermeasure
-			 * against Bleichenbacher's attack on PKCS #1 v1.5 RSA padding
-			 * (see RFC 2246, section 7.4.7.1). */
-			ERR_clear_error();
-			i = SSL_MAX_MASTER_KEY_LENGTH;
-			p[0] = s->client_version >> 8;
-			p[1] = s->client_version & 0xff;
-			if (RAND_pseudo_bytes(p+2, i-2) <= 0) /* should be RAND_bytes, but we cannot work around a failure */
-				goto err;
-			}
-	
-		s->session->master_key_length=
-			s->method->ssl3_enc->generate_master_secret(s,
-				s->session->master_key,
-				p,i);
-		OPENSSL_cleanse(p,i);
-		}
-	else
+    if (l & SSL_kRSA)
+    {
+        /* FIX THIS UP EAY EAY EAY EAY */
+        if (s->s3->tmp.use_rsa_tmp)
+        {
+            if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
+                rsa=s->cert->rsa_tmp;
+            /* Don't do a callback because rsa_tmp should
+             * be sent already */
+            if (rsa == NULL)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_R_MISSING_TMP_RSA_PKEY);
+                goto f_err;
+
+                }
+        }
+        else
+        {
+            pkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
+            if ((pkey == NULL) ||
+#ifdef CAVIUM_FIPS
+                (s->ctx->pkey_info.type != EVP_PKEY_RSA) ||
+                (s->ctx->key_handle == 0)
+#else
+                (pkey->type != EVP_PKEY_RSA) ||
+                (pkey->pkey.rsa == NULL)
+#endif
+                )
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_R_MISSING_RSA_CERTIFICATE);
+                goto f_err;
+                }
+#ifdef CAVIUM_FIPS
+            rsa=(RSA *)s;
+#else
+            rsa=pkey->pkey.rsa;
+#endif
+        }
+
+        /* TLS and [incidentally] DTLS, including pre-0.9.8f */
+        if (s->version > SSL3_VERSION &&
+            s->client_version != DTLS1_BAD_VER)
+        {
+            n2s(p,i);
+            if (n != i+2)
+                {
+                if (!(s->options & SSL_OP_TLS_D5_BUG))
+                    {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                       SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
+                    goto err;
+                    }
+                else
+                    p-=2;
+                }
+            else
+                n=i;
+        }
+#if defined(CAVIUM_SSL) && defined(CAVIUM_FIPS)
+        if (s->s3->tmp.use_rsa_tmp)
+            i=pkp_rsa_private_decrypt((int)n,p,p,rsa,0);
+        else
+#endif
+            i=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);
+
+        al = -1;
+
+        if (i != SSL_MAX_MASTER_KEY_LENGTH)
+            {
+            al=SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+               SSL_R_BAD_RSA_DECRYPT);
+            }
+
+        if ((al == -1) && !((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))
+            {
+            /* The premaster secret must contain the same version number as the
+             * ClientHello to detect version rollback attacks (strangely, the
+             * protocol does not offer such protection for DH ciphersuites).
+             * However, buggy clients exist that send the negotiated protocol
+             * version instead if the server does not support the requested
+             * protocol version.
+             * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. */
+            if (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&
+                (p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))
+                {
+                al=SSL_AD_DECODE_ERROR;
+                /* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */
+
+                /* The Klima-Pokorny-Rosa extension of Bleichenbacher's attack
+                 * (http://eprint.iacr.org/2003/052/) exploits the version
+                 * number check as a "bad version oracle" -- an alert would
+                 * reveal that the plaintext corresponding to some ciphertext
+                 * made up by the adversary is properly formatted except
+                 * that the version number is wrong.  To avoid such attacks,
+                 * we should treat this just like any other decryption error. */
+                }
+            }
+
+        if (al != -1)
+            {
+      /* Some decryption failure -- use random value instead as countermeasure
+       * against Bleichenbacher's attack on PKCS #1 v1.5 RSA padding
+       * (see RFC 2246, section 7.4.7.1). */
+            ERR_clear_error();
+            i = SSL_MAX_MASTER_KEY_LENGTH;
+            p[0] = s->client_version >> 8;
+            p[1] = s->client_version & 0xff;
+            if (RAND_pseudo_bytes(p+2, i-2) <= 0) /* should be RAND_bytes, but we cannot work around a failure */
+                goto err;
+            }
+
+        s->session->master_key_length=
+            s->method->ssl3_enc->generate_master_secret(s,
+                s->session->master_key,
+                p,i);
+        OPENSSL_cleanse(p,i);
+    }
+    else
 #endif
 #ifndef OPENSSL_NO_DH
-		if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
-		{
-		n2s(p,i);
-		if (n != i+2)
-			{
-			if (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG))
-				{
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
-				goto err;
-				}
-			else
-				{
-				p-=2;
-				i=(int)n;
-				}
-			}
-
-		if (n == 0L) /* the parameters are in the cert */
-			{
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_DECODE_DH_CERTS);
-			goto f_err;
-			}
-		else
-			{
-			if (s->s3->tmp.dh == NULL)
-				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);
-				goto f_err;
-				}
-			else
-				dh_srvr=s->s3->tmp.dh;
-			}
-
-		pub=BN_bin2bn(p,i,NULL);
-		if (pub == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BN_LIB);
-			goto err;
-			}
-
-		i=DH_compute_key(p,pub,dh_srvr);
-
-		if (i <= 0)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
-			goto err;
-			}
-
-		DH_free(s->s3->tmp.dh);
-		s->s3->tmp.dh=NULL;
-
-		BN_clear_free(pub);
-		pub=NULL;
-		s->session->master_key_length=
-			s->method->ssl3_enc->generate_master_secret(s,
-				s->session->master_key,p,i);
-		OPENSSL_cleanse(p,i);
-		}
-	else
+    if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
+    {
+        n2s(p,i);
+        if (n != i+2)
+        {
+            if (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG))
+                {
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);
+                goto err;
+                }
+            else
+                {
+                p-=2;
+                i=(int)n;
+                }
+        }
+
+        if (n == 0L) /* the parameters are in the cert */
+            {
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+               SSL_R_UNABLE_TO_DECODE_DH_CERTS);
+            goto f_err;
+            }
+        else
+            {
+            if (s->s3->tmp.dh == NULL)
+                {
+                al=SSL_AD_HANDSHAKE_FAILURE;
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_R_MISSING_TMP_DH_KEY);
+                goto f_err;
+                }
+            else
+                dh_srvr=s->s3->tmp.dh;
+            }
+
+        pub=BN_bin2bn(p,i,NULL);
+        if (pub == NULL)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BN_LIB);
+            goto err;
+            }
+
+        i=DH_compute_key(p,pub,dh_srvr);
+
+        if (i <= 0)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);
+            goto err;
+            }
+
+        DH_free(s->s3->tmp.dh);
+        s->s3->tmp.dh=NULL;
+
+        BN_clear_free(pub);
+        pub=NULL;
+        s->session->master_key_length=
+            s->method->ssl3_enc->generate_master_secret(s,
+                s->session->master_key,p,i);
+        OPENSSL_cleanse(p,i);
+    }
+    else
 #endif
 #ifndef OPENSSL_NO_KRB5
-        if (l & SSL_kKRB5)
-                {
-                krb5_error_code		krb5rc;
-		krb5_data		enc_ticket;
-		krb5_data		authenticator;
-		krb5_data		enc_pms;
-                KSSL_CTX		*kssl_ctx = s->kssl_ctx;
-		EVP_CIPHER_CTX		ciph_ctx;
-		EVP_CIPHER		*enc = NULL;
-		unsigned char		iv[EVP_MAX_IV_LENGTH];
-		unsigned char		pms[SSL_MAX_MASTER_KEY_LENGTH
-                                               + EVP_MAX_BLOCK_LENGTH];
-		int                     padl, outl;
-		krb5_timestamp		authtime = 0;
-		krb5_ticket_times	ttimes;
-
-		EVP_CIPHER_CTX_init(&ciph_ctx);
-
-                if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();
-
-		n2s(p,i);
-		enc_ticket.length = i;
-
-		if (n < (int)enc_ticket.length + 6)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
-
-		enc_ticket.data = (char *)p;
-		p+=enc_ticket.length;
-
-		n2s(p,i);
-		authenticator.length = i;
-
-		if (n < (int)(enc_ticket.length + authenticator.length) + 6)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
-
-		authenticator.data = (char *)p;
-		p+=authenticator.length;
-
-		n2s(p,i);
-		enc_pms.length = i;
-		enc_pms.data = (char *)p;
-		p+=enc_pms.length;
-
-		/* Note that the length is checked again below,
-		** after decryption
-		*/
-		if(enc_pms.length > sizeof pms)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			       SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
-
-		if (n != (long)(enc_ticket.length + authenticator.length +
-						enc_pms.length + 6))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
+    if (l & SSL_kKRB5)
+    {
+        krb5_error_code  krb5rc;
+        krb5_data        enc_ticket;
+        krb5_data        authenticator;
+        krb5_data        enc_pms;
+        KSSL_CTX         *kssl_ctx = s->kssl_ctx;
+        EVP_CIPHER_CTX   ciph_ctx;
+        EVP_CIPHER       *enc = NULL;
+        unsigned char    iv[EVP_MAX_IV_LENGTH];
+        unsigned char    pms[SSL_MAX_MASTER_KEY_LENGTH + EVP_MAX_BLOCK_LENGTH];
+        int              padl, outl;
+        krb5_timestamp   authtime = 0;
+        krb5_ticket_times ttimes;
+
+        EVP_CIPHER_CTX_init(&ciph_ctx);
+
+       if (!kssl_ctx)  kssl_ctx = kssl_ctx_new();
+
+        n2s(p,i);
+        enc_ticket.length = i;
+
+        if (n < (int)enc_ticket.length + 6)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
+
+        enc_ticket.data = (char *)p;
+        p+=enc_ticket.length;
+
+        n2s(p,i);
+        authenticator.length = i;
+
+        if (n < (int)(enc_ticket.length + authenticator.length) + 6)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
+
+        authenticator.data = (char *)p;
+        p+=authenticator.length;
+
+        n2s(p,i);
+        enc_pms.length = i;
+        enc_pms.data = (char *)p;
+        p+=enc_pms.length;
+
+        /* Note that the length is checked again below,
+        ** after decryption
+        */
+        if(enc_pms.length > sizeof pms)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
+
+        if (n != (long)(enc_ticket.length + authenticator.length +
+                        enc_pms.length + 6))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
 
                 if ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,
-					&kssl_err)) != 0)
+                    &kssl_err)) != 0)
                         {
 #ifdef KSSL_DEBUG
                         printf("kssl_sget_tkt rtn %d [%d]\n",
                                 krb5rc, kssl_err.reason);
                         if (kssl_err.text)
                                 printf("kssl_err text= %s\n", kssl_err.text);
-#endif	/* KSSL_DEBUG */
+#endif    /* KSSL_DEBUG */
                         SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
                                 kssl_err.reason);
                         goto err;
                         }
 
-		/*  Note: no authenticator is not considered an error,
-		**  but will return authtime == 0.
-		*/
-		if ((krb5rc = kssl_check_authent(kssl_ctx, &authenticator,
-					&authtime, &kssl_err)) != 0)
-			{
+        /*  Note: no authenticator is not considered an error,
+        **  but will return authtime == 0.
+        */
+        if ((krb5rc = kssl_check_authent(kssl_ctx, &authenticator,
+                    &authtime, &kssl_err)) != 0)
+            {
 #ifdef KSSL_DEBUG
                         printf("kssl_check_authent rtn %d [%d]\n",
                                 krb5rc, kssl_err.reason);
                         if (kssl_err.text)
                                 printf("kssl_err text= %s\n", kssl_err.text);
-#endif	/* KSSL_DEBUG */
+#endif    /* KSSL_DEBUG */
                         SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
                                 kssl_err.reason);
                         goto err;
-			}
+            }
 
-		if ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, krb5rc);
+        if ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, krb5rc);
                         goto err;
-			}
+            }
 
 #ifdef KSSL_DEBUG
                 kssl_ctx_show(kssl_ctx);
-#endif	/* KSSL_DEBUG */
+#endif    /* KSSL_DEBUG */
 
-		enc = kssl_map_enc(kssl_ctx->enctype);
+        enc = kssl_map_enc(kssl_ctx->enctype);
                 if (enc == NULL)
                     goto err;
 
-		memset(iv, 0, sizeof iv);	/* per RFC 1510 */
+        memset(iv, 0, sizeof iv);    /* per RFC 1510 */
 
-		if (!EVP_DecryptInit_ex(&ciph_ctx,enc,NULL,kssl_ctx->key,iv))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DECRYPTION_FAILED);
-			goto err;
-			}
-		if (!EVP_DecryptUpdate(&ciph_ctx, pms,&outl,
-					(unsigned char *)enc_pms.data, enc_pms.length))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DECRYPTION_FAILED);
-			goto err;
-			}
-		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
-		if (!EVP_DecryptFinal_ex(&ciph_ctx,&(pms[outl]),&padl))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DECRYPTION_FAILED);
-			goto err;
-			}
-		outl += padl;
-		if (outl > SSL_MAX_MASTER_KEY_LENGTH)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_DATA_LENGTH_TOO_LONG);
-			goto err;
-			}
-		if (!((pms[0] == (s->client_version>>8)) && (pms[1] == (s->client_version & 0xff))))
-		    {
-		    /* The premaster secret must contain the same version number as the
-		     * ClientHello to detect version rollback attacks (strangely, the
-		     * protocol does not offer such protection for DH ciphersuites).
-		     * However, buggy clients exist that send random bytes instead of
-		     * the protocol version.
-		     * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients. 
-		     * (Perhaps we should have a separate BUG value for the Kerberos cipher)
-		     */
-		    if (!(s->options & SSL_OP_TLS_ROLLBACK_BUG))
-		        {
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			       SSL_AD_DECODE_ERROR);
-			goto err;
-			}
-		    }
+        if (!EVP_DecryptInit_ex(&ciph_ctx,enc,NULL,kssl_ctx->key,iv))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DECRYPTION_FAILED);
+            goto err;
+            }
+        if (!EVP_DecryptUpdate(&ciph_ctx, pms,&outl,
+                    (unsigned char *)enc_pms.data, enc_pms.length))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DECRYPTION_FAILED);
+            goto err;
+            }
+        if (outl > SSL_MAX_MASTER_KEY_LENGTH)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
+        if (!EVP_DecryptFinal_ex(&ciph_ctx,&(pms[outl]),&padl))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DECRYPTION_FAILED);
+            goto err;
+            }
+        outl += padl;
+        if (outl > SSL_MAX_MASTER_KEY_LENGTH)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_DATA_LENGTH_TOO_LONG);
+            goto err;
+            }
+        if (!((pms[0] == (s->client_version>>8)) && (pms[1] == (s->client_version & 0xff))))
+            {
+            /* The premaster secret must contain the same version number as the
+             * ClientHello to detect version rollback attacks (strangely, the
+             * protocol does not offer such protection for DH ciphersuites).
+             * However, buggy clients exist that send random bytes instead of
+             * the protocol version.
+             * If SSL_OP_TLS_ROLLBACK_BUG is set, tolerate such clients.
+             * (Perhaps we should have a separate BUG value for the Kerberos cipher)
+             */
+            if (!(s->options & SSL_OP_TLS_ROLLBACK_BUG))
+                {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   SSL_AD_DECODE_ERROR);
+            goto err;
+            }
+            }
 
-		EVP_CIPHER_CTX_cleanup(&ciph_ctx);
+        EVP_CIPHER_CTX_cleanup(&ciph_ctx);
 
                 s->session->master_key_length=
                         s->method->ssl3_enc->generate_master_secret(s,
@@ -2110,7 +2546,7 @@
                 if (kssl_ctx->client_princ)
                         {
                         size_t len = strlen(kssl_ctx->client_princ);
-                        if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH ) 
+                        if ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH )
                                 {
                                 s->session->krb5_client_princ_len = len;
                                 memcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);
@@ -2119,727 +2555,781 @@
 
 
                 /*  Was doing kssl_ctx_free() here,
-		**  but it caused problems for apache.
+                **  but it caused problems for apache.
                 **  kssl_ctx = kssl_ctx_free(kssl_ctx);
                 **  if (s->kssl_ctx)  s->kssl_ctx = NULL;
                 */
-                }
-	else
-#endif	/* OPENSSL_NO_KRB5 */
+    }
+    else
+#endif    /* OPENSSL_NO_KRB5 */
 
 #ifndef OPENSSL_NO_ECDH
-		if ((l & SSL_kECDH) || (l & SSL_kECDHE))
-		{
-		int ret = 1;
-		int field_size = 0;
-		const EC_KEY   *tkey;
-		const EC_GROUP *group;
-		const BIGNUM *priv_key;
-
-                /* initialize structures for server's ECDH key pair */
-		if ((srvr_ecdh = EC_KEY_new()) == NULL) 
-			{
-                	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			    ERR_R_MALLOC_FAILURE);
-                	goto err;
-			}
-
-		/* Let's get server private key and group information */
-		if (l & SSL_kECDH) 
-			{ 
+    if ((l & SSL_kECDH) || (l & SSL_kECDHE))
+    {
+        int ret = 1;
+        int field_size = 0;
+        const EC_KEY   *tkey;
+        const EC_GROUP *group;
+        const BIGNUM *priv_key;
+
+        /* initialize structures for server's ECDH key pair */
+        if ((srvr_ecdh = EC_KEY_new()) == NULL)
+            {
+                    SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                ERR_R_MALLOC_FAILURE);
+                    goto err;
+            }
+
+        /* Let's get server private key and group information */
+        if (l & SSL_kECDH)
+            {
                         /* use the certificate */
-			tkey = s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec;
-			}
-		else
-			{
-			/* use the ephermeral values we saved when
-			 * generating the ServerKeyExchange msg.
-			 */
-			tkey = s->s3->tmp.ecdh;
-			}
-
-		group    = EC_KEY_get0_group(tkey);
-		priv_key = EC_KEY_get0_private_key(tkey);
-
-		if (!EC_KEY_set_group(srvr_ecdh, group) ||
-		    !EC_KEY_set_private_key(srvr_ecdh, priv_key))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			       ERR_R_EC_LIB);
-			goto err;
-			}
-
-		/* Let's get client's public key */
-		if ((clnt_ecpoint = EC_POINT_new(group)) == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			    ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
+            tkey = s->cert->pkeys[SSL_PKEY_ECC].privatekey->pkey.ec;
+            }
+        else
+            {
+            /* use the ephermeral values we saved when
+             * generating the ServerKeyExchange msg.
+             */
+            tkey = s->s3->tmp.ecdh;
+            }
+
+        group    = EC_KEY_get0_group(tkey);
+        priv_key = EC_KEY_get0_private_key(tkey);
+
+        if (!EC_KEY_set_group(srvr_ecdh, group) ||
+            !EC_KEY_set_private_key(srvr_ecdh, priv_key))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   ERR_R_EC_LIB);
+            goto err;
+            }
+
+        /* Let's get client's public key */
+        if ((clnt_ecpoint = EC_POINT_new(group)) == NULL)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                ERR_R_MALLOC_FAILURE);
+            goto err;
+            }
 
-                if (n == 0L) 
+                if (n == 0L)
                         {
-			/* Client Publickey was in Client Certificate */
+            /* Client Publickey was in Client Certificate */
 
-			 if (l & SSL_kECDHE) 
-				 {
-				 al=SSL_AD_HANDSHAKE_FAILURE;
-				 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
-				 goto f_err;
-				 }
+             if (l & SSL_kECDHE)
+                 {
+                 al=SSL_AD_HANDSHAKE_FAILURE;
+                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);
+                 goto f_err;
+                 }
                         if (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))
-			    == NULL) || 
-			    (clnt_pub_pkey->type != EVP_PKEY_EC))
-                        	{
-				/* XXX: For now, we do not support client
-				 * authentication using ECDH certificates
-				 * so this branch (n == 0L) of the code is
-				 * never executed. When that support is
-				 * added, we ought to ensure the key 
-				 * received in the certificate is 
-				 * authorized for key agreement.
-				 * ECDH_compute_key implicitly checks that
-				 * the two ECDH shares are for the same
-				 * group.
-				 */
-                           	al=SSL_AD_HANDSHAKE_FAILURE;
-                           	SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				    SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
-                           	goto f_err;
-                           	}
-
-			if (EC_POINT_copy(clnt_ecpoint,
-			    EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec)) == 0)
-				{
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-					ERR_R_EC_LIB);
-				goto err;
-				}
+                == NULL) ||
+                (clnt_pub_pkey->type != EVP_PKEY_EC))
+                            {
+                /* XXX: For now, we do not support client
+                 * authentication using ECDH certificates
+                 * so this branch (n == 0L) of the code is
+                 * never executed. When that support is
+                 * added, we ought to ensure the key
+                 * received in the certificate is
+                 * authorized for key agreement.
+                 * ECDH_compute_key implicitly checks that
+                 * the two ECDH shares are for the same
+                 * group.
+                 */
+                               al=SSL_AD_HANDSHAKE_FAILURE;
+                               SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    SSL_R_UNABLE_TO_DECODE_ECDH_CERTS);
+                               goto f_err;
+                               }
+
+            if (EC_POINT_copy(clnt_ecpoint,
+                EC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec)) == 0)
+                {
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    ERR_R_EC_LIB);
+                goto err;
+                }
                         ret = 2; /* Skip certificate verify processing */
                         }
                 else
                         {
-			/* Get client's public key from encoded point
-			 * in the ClientKeyExchange message.
-			 */
-			if ((bn_ctx = BN_CTX_new()) == NULL)
-				{
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				    ERR_R_MALLOC_FAILURE);
-				goto err;
-				}
-
-                        /* Get encoded point length */
-                        i = *p; 
-			p += 1;
-                        if (EC_POINT_oct2point(group, 
-			    clnt_ecpoint, p, i, bn_ctx) == 0)
-				{
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				    ERR_R_EC_LIB);
-				goto err;
-				}
+            /* Get client's public key from encoded point
+             * in the ClientKeyExchange message.
+             */
+            if ((bn_ctx = BN_CTX_new()) == NULL)
+                {
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+
+                /* Get encoded point length */
+                i = *p;
+                p += 1;
+                if (EC_POINT_oct2point(group, clnt_ecpoint, p, i, bn_ctx) == 0)
+                {
+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);
+                goto err;
+                }
                         /* p is pointing to somewhere in the buffer
-                         * currently, so set it to the start 
-                         */ 
+                         * currently, so set it to the start
+                         */
                         p=(unsigned char *)s->init_buf->data;
                         }
 
-		/* Compute the shared pre-master secret */
-		field_size = EC_GROUP_get_degree(group);
-		if (field_size <= 0)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, 
-			       ERR_R_ECDH_LIB);
-			goto err;
-			}
-		i = ECDH_compute_key(p, (field_size+7)/8, clnt_ecpoint, srvr_ecdh, NULL);
+        /* Compute the shared pre-master secret */
+        field_size = EC_GROUP_get_degree(group);
+        if (field_size <= 0)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                   ERR_R_ECDH_LIB);
+            goto err;
+            }
+    /* If field size is not more than 24 octets, then use SHA-1 hash of result;
+     * otherwise, use result (see section 4.8 of draft-ietf-tls-ecc-03.txt;
+     * this is new with this version of the Internet Draft).
+     */
+        i = ECDH_compute_key(p, (field_size+7)/8, clnt_ecpoint, srvr_ecdh, NULL);
                 if (i <= 0)
                         {
                         SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-			    ERR_R_ECDH_LIB);
+                ERR_R_ECDH_LIB);
                         goto err;
                         }
 
-		EVP_PKEY_free(clnt_pub_pkey);
-		EC_POINT_free(clnt_ecpoint);
-		if (srvr_ecdh != NULL) 
-			EC_KEY_free(srvr_ecdh);
-		BN_CTX_free(bn_ctx);
+        EVP_PKEY_free(clnt_pub_pkey);
+        EC_POINT_free(clnt_ecpoint);
+        if (srvr_ecdh != NULL)
+            EC_KEY_free(srvr_ecdh);
+        BN_CTX_free(bn_ctx);
 
-		/* Compute the master secret */
+        /* Compute the master secret */
                 s->session->master_key_length = s->method->ssl3_enc-> \
-		    generate_master_secret(s, s->session->master_key, p, i);
-		
+            generate_master_secret(s, s->session->master_key, p, i);
+
                 OPENSSL_cleanse(p, i);
                 return (ret);
-		}
-	else
+    }
+    else
 #endif
-		{
-		al=SSL_AD_HANDSHAKE_FAILURE;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
-				SSL_R_UNKNOWN_CIPHER_TYPE);
-		goto f_err;
-		}
+    {
+        al=SSL_AD_HANDSHAKE_FAILURE;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                SSL_R_UNKNOWN_CIPHER_TYPE);
+        goto f_err;
+    }
+#ifdef CAVIUM_SSL
+    } /* !cipher support*/
+#endif /* CAVIUM_SSL */
 
-	return(1);
+    return(1);
 f_err:
-	ssl3_send_alert(s,SSL3_AL_FATAL,al);
+    ssl3_send_alert(s,SSL3_AL_FATAL,al);
 #if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH)
 err:
 #endif
 #ifndef OPENSSL_NO_ECDH
-	EVP_PKEY_free(clnt_pub_pkey);
-	EC_POINT_free(clnt_ecpoint);
-	if (srvr_ecdh != NULL) 
-		EC_KEY_free(srvr_ecdh);
-	BN_CTX_free(bn_ctx);
+    EVP_PKEY_free(clnt_pub_pkey);
+    EC_POINT_free(clnt_ecpoint);
+    if (srvr_ecdh != NULL)
+        EC_KEY_free(srvr_ecdh);
+    BN_CTX_free(bn_ctx);
 #endif
-	return(-1);
-	}
+    return(-1);
+    }
 
 int ssl3_get_cert_verify(SSL *s)
-	{
-	EVP_PKEY *pkey=NULL;
-	unsigned char *p;
-	int al,ok,ret=0;
-	long n;
-	int type=0,i,j;
-	X509 *peer;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_CERT_VRFY_A,
-		SSL3_ST_SR_CERT_VRFY_B,
-		-1,
-		514, /* 514? */
-		&ok);
-
-	if (!ok) return((int)n);
-
-	if (s->session->peer != NULL)
-		{
-		peer=s->session->peer;
-		pkey=X509_get_pubkey(peer);
-		type=X509_certificate_type(peer,pkey);
-		}
-	else
-		{
-		peer=NULL;
-		pkey=NULL;
-		}
-
-	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
-		{
-		s->s3->tmp.reuse_message=1;
-		if ((peer != NULL) && (type | EVP_PKT_SIGN))
-			{
-			al=SSL_AD_UNEXPECTED_MESSAGE;
-			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
-			goto f_err;
-			}
-		ret=1;
-		goto end;
-		}
-
-	if (peer == NULL)
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		goto f_err;
-		}
-
-	if (!(type & EVP_PKT_SIGN))
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
-		al=SSL_AD_ILLEGAL_PARAMETER;
-		goto f_err;
-		}
-
-	if (s->s3->change_cipher_spec)
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		goto f_err;
-		}
-
-	/* we now have a signature that we need to verify */
-	p=(unsigned char *)s->init_msg;
-	n2s(p,i);
-	n-=2;
-	if (i > n)
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
-		al=SSL_AD_DECODE_ERROR;
-		goto f_err;
-		}
-
-	j=EVP_PKEY_size(pkey);
-	if ((i > j) || (n > j) || (n <= 0))
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
-		al=SSL_AD_DECODE_ERROR;
-		goto f_err;
-		}
-
-#ifndef OPENSSL_NO_RSA 
-	if (pkey->type == EVP_PKEY_RSA)
-		{
-		i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
-			MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, 
-							pkey->pkey.rsa);
-		if (i < 0)
-			{
-			al=SSL_AD_DECRYPT_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
-			goto f_err;
-			}
-		if (i == 0)
-			{
-			al=SSL_AD_DECRYPT_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
-			goto f_err;
-			}
-		}
-	else
+    {
+    EVP_PKEY *pkey=NULL;
+    unsigned char *p;
+    int al,ok,ret=0;
+    long n;
+    int type=0,i,j;
+    X509 *peer;
+#if defined (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+    if ( s->state == CAV_ST_IN_PRE_MASTER_KEY ) {
+        goto vrfy_cav;
+    }
+#endif
+
+    n=s->method->ssl_get_message(s,
+        SSL3_ST_SR_CERT_VRFY_A,
+        SSL3_ST_SR_CERT_VRFY_B,
+        -1,
+        514, /* 514? */
+        &ok);
+
+    if (!ok) return((int)n);
+
+    if (s->session->peer != NULL)
+        {
+        peer=s->session->peer;
+        pkey=X509_get_pubkey(peer);
+        type=X509_certificate_type(peer,pkey);
+        }
+    else
+        {
+        peer=NULL;
+        pkey=NULL;
+        }
+
+    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)
+        {
+        s->s3->tmp.reuse_message=1;
+        if ((peer != NULL) && (type | EVP_PKT_SIGN))
+            {
+            al=SSL_AD_UNEXPECTED_MESSAGE;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);
+            goto f_err;
+            }
+        ret=1;
+        goto end;
+        }
+
+    if (peer == NULL)
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);
+        al=SSL_AD_UNEXPECTED_MESSAGE;
+        goto f_err;
+        }
+
+    if (!(type & EVP_PKT_SIGN))
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);
+        al=SSL_AD_ILLEGAL_PARAMETER;
+        goto f_err;
+        }
+
+    if (s->s3->change_cipher_spec)
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);
+        al=SSL_AD_UNEXPECTED_MESSAGE;
+        goto f_err;
+        }
+
+    /* we now have a signature that we need to verify */
+    p=(unsigned char *)s->init_msg;
+    n2s(p,i);
+    n-=2;
+    if (i > n)
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
+        al=SSL_AD_DECODE_ERROR;
+        goto f_err;
+        }
+
+    j=EVP_PKEY_size(pkey);
+    if ((i > j) || (n > j) || (n <= 0))
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);
+        al=SSL_AD_DECODE_ERROR;
+        goto f_err;
+        }
+
+#ifndef OPENSSL_NO_RSA
+    if (pkey->type == EVP_PKEY_RSA)
+    {
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+    if (s->cipher_support)
+    {
+            s->pkey = pkey ;
+            s->p_vrfy_cert = p ;
+            s->vrfy_cert_i = i ;
+
+vrfy_cav:
+            i=RSA_verify_cav(s,NID_md5_sha1, s->s3->tmp.cert_verify_md,MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, s->p_vrfy_cert, s->vrfy_cert_i,s->pkey->pkey.rsa);
+            if (i == -EAGAIN)
+                return 0;
+            pkey = s->pkey ;
+            p = s->p_vrfy_cert ;
+        }
+        else
+#endif
+        i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,
+            MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i,
+                            pkey->pkey.rsa);
+        if (i < 0)
+            {
+            al=SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);
+            goto f_err;
+            }
+        if (i == 0)
+            {
+            al=SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);
+            goto f_err;
+            }
+        }
+    else
 #endif
 #ifndef OPENSSL_NO_DSA
-		if (pkey->type == EVP_PKEY_DSA)
-		{
-		j=DSA_verify(pkey->save_type,
-			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
-			SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
-		if (j <= 0)
-			{
-			/* bad signature */
-			al=SSL_AD_DECRYPT_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
-			goto f_err;
-			}
-		}
-	else
+        if (pkey->type == EVP_PKEY_DSA)
+        {
+        j=DSA_verify(pkey->save_type,
+            &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
+            SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);
+        if (j <= 0)
+            {
+            /* bad signature */
+            al=SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);
+            goto f_err;
+            }
+        }
+    else
 #endif
 #ifndef OPENSSL_NO_ECDSA
-		if (pkey->type == EVP_PKEY_EC)
-		{
-		j=ECDSA_verify(pkey->save_type,
-			&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
-			SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
-		if (j <= 0)
-			{
-			/* bad signature */
-			al=SSL_AD_DECRYPT_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
-			    SSL_R_BAD_ECDSA_SIGNATURE);
-			goto f_err;
-			}
-		}
-	else
-#endif
-		{
-		SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
-		al=SSL_AD_UNSUPPORTED_CERTIFICATE;
-		goto f_err;
-		}
-
-
-	ret=1;
-	if (0)
-		{
+        if (pkey->type == EVP_PKEY_EC)
+        {
+        j=ECDSA_verify(pkey->save_type,
+            &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
+            SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);
+        if (j <= 0)
+            {
+            /* bad signature */
+            al=SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
+                SSL_R_BAD_ECDSA_SIGNATURE);
+            goto f_err;
+            }
+        }
+    else
+#endif
+        {
+        SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);
+        al=SSL_AD_UNSUPPORTED_CERTIFICATE;
+        goto f_err;
+        }
+
+
+    ret=1;
+    if (0)
+        {
 f_err:
-		ssl3_send_alert(s,SSL3_AL_FATAL,al);
-		}
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        }
 end:
-	EVP_PKEY_free(pkey);
-	return(ret);
-	}
+    EVP_PKEY_free(pkey);
+    return(ret);
+    }
 
 int ssl3_get_client_certificate(SSL *s)
-	{
-	int i,ok,al,ret= -1;
-	X509 *x=NULL;
-	unsigned long l,nc,llen,n;
-	const unsigned char *p,*q;
-	unsigned char *d;
-	STACK_OF(X509) *sk=NULL;
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_CERT_A,
-		SSL3_ST_SR_CERT_B,
-		-1,
-		s->max_cert_list,
-		&ok);
-
-	if (!ok) return((int)n);
-
-	if	(s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE)
-		{
-		if (	(s->verify_mode & SSL_VERIFY_PEER) &&
-			(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			goto f_err;
-			}
-		/* If tls asked for a client cert, the client must return a 0 list */
-		if ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);
-			al=SSL_AD_UNEXPECTED_MESSAGE;
-			goto f_err;
-			}
-		s->s3->tmp.reuse_message=1;
-		return(1);
-		}
-
-	if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
-		{
-		al=SSL_AD_UNEXPECTED_MESSAGE;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_WRONG_MESSAGE_TYPE);
-		goto f_err;
-		}
-	p=d=(unsigned char *)s->init_msg;
-
-	if ((sk=sk_X509_new_null()) == NULL)
-		{
-		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-
-	n2l3(p,llen);
-	if (llen+3 != n)
-		{
-		al=SSL_AD_DECODE_ERROR;
-		SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
-		goto f_err;
-		}
-	for (nc=0; nc<llen; )
-		{
-		n2l3(p,l);
-		if ((l+nc+3) > llen)
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
-			goto f_err;
-			}
-
-		q=p;
-		x=d2i_X509(NULL,&p,l);
-		if (x == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_ASN1_LIB);
-			goto err;
-			}
-		if (p != (q+l))
-			{
-			al=SSL_AD_DECODE_ERROR;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);
-			goto f_err;
-			}
-		if (!sk_X509_push(sk,x))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		x=NULL;
-		nc+=l+3;
-		}
-
-	if (sk_X509_num(sk) <= 0)
-		{
-		/* TLS does not mind 0 certs returned */
-		if (s->version == SSL3_VERSION)
-			{
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATES_RETURNED);
-			goto f_err;
-			}
-		/* Fail for TLS only if we required a certificate */
-		else if ((s->verify_mode & SSL_VERIFY_PEER) &&
-			 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
-			al=SSL_AD_HANDSHAKE_FAILURE;
-			goto f_err;
-			}
-		}
-	else
-		{
-		i=ssl_verify_cert_chain(s,sk);
-		if (i <= 0)
-			{
-			al=ssl_verify_alarm_type(s->verify_result);
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATE_RETURNED);
-			goto f_err;
-			}
-		}
-
-	if (s->session->peer != NULL) /* This should not be needed */
-		X509_free(s->session->peer);
-	s->session->peer=sk_X509_shift(sk);
-	s->session->verify_result = s->verify_result;
-
-	/* With the current implementation, sess_cert will always be NULL
-	 * when we arrive here. */
-	if (s->session->sess_cert == NULL)
-		{
-		s->session->sess_cert = ssl_sess_cert_new();
-		if (s->session->sess_cert == NULL)
-			{
-			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		}
-	if (s->session->sess_cert->cert_chain != NULL)
-		sk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);
-	s->session->sess_cert->cert_chain=sk;
-	/* Inconsistency alert: cert_chain does *not* include the
-	 * peer's own certificate, while we do include it in s3_clnt.c */
-
-	sk=NULL;
-
-	ret=1;
-	if (0)
-		{
+    {
+    int i,ok,al,ret= -1;
+    X509 *x=NULL;
+    unsigned long l,nc,llen,n;
+    const unsigned char *p,*q;
+    unsigned char *d;
+    STACK_OF(X509) *sk=NULL;
+
+    n=s->method->ssl_get_message(s,
+        SSL3_ST_SR_CERT_A,
+        SSL3_ST_SR_CERT_B,
+        -1,
+        s->max_cert_list,
+        &ok);
+
+    if (!ok) return((int)n);
+
+    if    (s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE)
+        {
+        if (    (s->verify_mode & SSL_VERIFY_PEER) &&
+            (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            goto f_err;
+            }
+        /* If tls asked for a client cert, the client must return a 0 list */
+        if ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);
+            al=SSL_AD_UNEXPECTED_MESSAGE;
+            goto f_err;
+            }
+        s->s3->tmp.reuse_message=1;
+#ifdef CAVIUM_SSL
+        if( (SSL_get_verify_mode(s) & SSL_VERIFY_PEER) &&
+            ((s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) == 0) )
+        {
+            s->client_key_exch_msg_offset = s->hs_msgs_len - (n + 4);
+            cav_fprintf(cav_nb_fp,
+                    "ssl3_get_client_certificate(): %s %d\n",
+                    "setting s->client_key_exch_msg_offset = ",
+                    s->client_key_exch_msg_offset);
+        }
+#endif
+
+        return(1);
+        }
+
+    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)
+        {
+        al=SSL_AD_UNEXPECTED_MESSAGE;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+           SSL_R_WRONG_MESSAGE_TYPE);
+        goto f_err;
+        }
+    p=d=(unsigned char *)s->init_msg;
+
+    if ((sk=sk_X509_new_null()) == NULL)
+        {
+        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+           ERR_R_MALLOC_FAILURE);
+        goto err;
+        }
+
+    n2l3(p,llen);
+    if (llen+3 != n)
+        {
+        al=SSL_AD_DECODE_ERROR;
+        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_LENGTH_MISMATCH);
+        goto f_err;
+        }
+    for (nc=0; nc<llen; )
+        {
+        n2l3(p,l);
+        if ((l+nc+3) > llen)
+            {
+            al=SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_CERT_LENGTH_MISMATCH);
+            goto f_err;
+            }
+
+        q=p;
+        x=d2i_X509(NULL,&p,l);
+        if (x == NULL)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               ERR_R_ASN1_LIB);
+            goto err;
+            }
+        if (p != (q+l))
+            {
+            al=SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_CERT_LENGTH_MISMATCH);
+            goto f_err;
+            }
+        if (!sk_X509_push(sk,x))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               ERR_R_MALLOC_FAILURE);
+            goto err;
+            }
+        x=NULL;
+        nc+=l+3;
+        }
+
+    if (sk_X509_num(sk) <= 0)
+        {
+        /* TLS does not mind 0 certs returned */
+        if (s->version == SSL3_VERSION)
+            {
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_NO_CERTIFICATES_RETURNED);
+            goto f_err;
+            }
+        /* Fail for TLS only if we required a certificate */
+        else if ((s->verify_mode & SSL_VERIFY_PEER) &&
+             (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);
+            al=SSL_AD_HANDSHAKE_FAILURE;
+            goto f_err;
+            }
+        }
+    else
+        {
+        i=ssl_verify_cert_chain(s,sk);
+        if (i <= 0)
+            {
+            al=ssl_verify_alarm_type(s->verify_result);
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,
+               SSL_R_NO_CERTIFICATE_RETURNED);
+            goto f_err;
+            }
+        }
+
+    if (s->session->peer != NULL) /* This should not be needed */
+        X509_free(s->session->peer);
+    s->session->peer=sk_X509_shift(sk);
+    s->session->verify_result = s->verify_result;
+
+    /* With the current implementation, sess_cert will always be NULL
+     * when we arrive here. */
+    if (s->session->sess_cert == NULL)
+        {
+        s->session->sess_cert = ssl_sess_cert_new();
+        if (s->session->sess_cert == NULL)
+            {
+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, 
+               ERR_R_MALLOC_FAILURE);
+            goto err;
+            }
+        }
+    if (s->session->sess_cert->cert_chain != NULL)
+        sk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);
+    s->session->sess_cert->cert_chain=sk;
+    /* Inconsistency alert: cert_chain does *not* include the
+     * peer's own certificate, while we do include it in s3_clnt.c */
+
+    sk=NULL;
+#ifdef CAVIUM_SSL
+    if((SSL_get_verify_mode(s) & SSL_VERIFY_PEER))
+        s->client_key_exch_msg_offset = s->hs_msgs_len;
+#endif
+
+    ret=1;
+    if (0)
+        {
 f_err:
-		ssl3_send_alert(s,SSL3_AL_FATAL,al);
-		}
+        ssl3_send_alert(s,SSL3_AL_FATAL,al);
+        }
 err:
-	if (x != NULL) X509_free(x);
-	if (sk != NULL) sk_X509_pop_free(sk,X509_free);
-	return(ret);
-	}
+    if (x != NULL) X509_free(x);
+    if (sk != NULL) sk_X509_pop_free(sk,X509_free);
+    return(ret);
+    }
 
 int ssl3_send_server_certificate(SSL *s)
-	{
-	unsigned long l;
-	X509 *x;
-
-	if (s->state == SSL3_ST_SW_CERT_A)
-		{
-		x=ssl_get_server_send_cert(s);
-		if (x == NULL &&
+{
+    unsigned long l;
+    X509 *x;
+
+    if (s->state == SSL3_ST_SW_CERT_A)
+        {
+        x=ssl_get_server_send_cert(s);
+        if (x == NULL &&
                         /* VRS: allow null cert if auth == KRB5 */
                         (s->s3->tmp.new_cipher->algorithms
                                 & (SSL_MKEY_MASK|SSL_AUTH_MASK))
                         != (SSL_aKRB5|SSL_kKRB5))
-			{
-			SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);
-			return(0);
-			}
-
-		l=ssl3_output_cert_chain(s,x);
-		s->state=SSL3_ST_SW_CERT_B;
-		s->init_num=(int)l;
-		s->init_off=0;
-		}
-
-	/* SSL3_ST_SW_CERT_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+            {
+            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
+               ERR_R_INTERNAL_ERROR);
+            return(0);
+            }
+
+        l=ssl3_output_cert_chain(s,x);
+        s->state=SSL3_ST_SW_CERT_B;
+        s->init_num=(int)l;
+        s->init_off=0;
+        }
+
+    /* SSL3_ST_SW_CERT_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+}
 
 
 #ifndef OPENSSL_NO_ECDH
 /* This is the complement of curve_id2nid in s3_clnt.c. */
 static int nid2curve_id(int nid)
 {
-	/* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
-	 * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
-	switch (nid) {
-	case NID_sect163k1: /* sect163k1 (1) */
-		return 1;
-	case NID_sect163r1: /* sect163r1 (2) */
-		return 2;
-	case NID_sect163r2: /* sect163r2 (3) */
-		return 3;
-	case NID_sect193r1: /* sect193r1 (4) */ 
-		return 4;
-	case NID_sect193r2: /* sect193r2 (5) */ 
-		return 5;
-	case NID_sect233k1: /* sect233k1 (6) */
-		return 6;
-	case NID_sect233r1: /* sect233r1 (7) */ 
-		return 7;
-	case NID_sect239k1: /* sect239k1 (8) */ 
-		return 8;
-	case NID_sect283k1: /* sect283k1 (9) */
-		return 9;
-	case NID_sect283r1: /* sect283r1 (10) */ 
-		return 10;
-	case NID_sect409k1: /* sect409k1 (11) */ 
-		return 11;
-	case NID_sect409r1: /* sect409r1 (12) */
-		return 12;
-	case NID_sect571k1: /* sect571k1 (13) */ 
-		return 13;
-	case NID_sect571r1: /* sect571r1 (14) */ 
-		return 14;
-	case NID_secp160k1: /* secp160k1 (15) */
-		return 15;
-	case NID_secp160r1: /* secp160r1 (16) */ 
-		return 16;
-	case NID_secp160r2: /* secp160r2 (17) */ 
-		return 17;
-	case NID_secp192k1: /* secp192k1 (18) */
-		return 18;
-	case NID_X9_62_prime192v1: /* secp192r1 (19) */ 
-		return 19;
-	case NID_secp224k1: /* secp224k1 (20) */ 
-		return 20;
-	case NID_secp224r1: /* secp224r1 (21) */
-		return 21;
-	case NID_secp256k1: /* secp256k1 (22) */ 
-		return 22;
-	case NID_X9_62_prime256v1: /* secp256r1 (23) */ 
-		return 23;
-	case NID_secp384r1: /* secp384r1 (24) */
-		return 24;
-	case NID_secp521r1:  /* secp521r1 (25) */	
-		return 25;
-	default:
-		return 0;
-	}
+    /* ECC curves from draft-ietf-tls-ecc-01.txt (Mar 15, 2001)
+     * (no changes in draft-ietf-tls-ecc-03.txt [June 2003]) */
+    switch (nid) {
+    case NID_sect163k1: /* sect163k1 (1) */
+        return 1;
+    case NID_sect163r1: /* sect163r1 (2) */
+        return 2;
+    case NID_sect163r2: /* sect163r2 (3) */
+        return 3;
+    case NID_sect193r1: /* sect193r1 (4) */
+        return 4;
+    case NID_sect193r2: /* sect193r2 (5) */
+        return 5;
+    case NID_sect233k1: /* sect233k1 (6) */
+        return 6;
+    case NID_sect233r1: /* sect233r1 (7) */
+        return 7;
+    case NID_sect239k1: /* sect239k1 (8) */
+        return 8;
+    case NID_sect283k1: /* sect283k1 (9) */
+        return 9;
+    case NID_sect283r1: /* sect283r1 (10) */
+        return 10;
+    case NID_sect409k1: /* sect409k1 (11) */
+        return 11;
+    case NID_sect409r1: /* sect409r1 (12) */
+        return 12;
+    case NID_sect571k1: /* sect571k1 (13) */
+        return 13;
+    case NID_sect571r1: /* sect571r1 (14) */
+        return 14;
+    case NID_secp160k1: /* secp160k1 (15) */
+        return 15;
+    case NID_secp160r1: /* secp160r1 (16) */
+        return 16;
+    case NID_secp160r2: /* secp160r2 (17) */
+        return 17;
+    case NID_secp192k1: /* secp192k1 (18) */
+        return 18;
+    case NID_X9_62_prime192v1: /* secp192r1 (19) */
+        return 19;
+    case NID_secp224k1: /* secp224k1 (20) */
+        return 20;
+    case NID_secp224r1: /* secp224r1 (21) */
+        return 21;
+    case NID_secp256k1: /* secp256k1 (22) */
+        return 22;
+    case NID_X9_62_prime256v1: /* secp256r1 (23) */
+        return 23;
+    case NID_secp384r1: /* secp384r1 (24) */
+        return 24;
+    case NID_secp521r1:  /* secp521r1 (25) */
+        return 25;
+    default:
+        return 0;
+    }
 }
 #endif
 #ifndef OPENSSL_NO_TLSEXT
 int ssl3_send_newsession_ticket(SSL *s)
-	{
-	if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
-		{
-		unsigned char *p, *senc, *macstart;
-		int len, slen;
-		unsigned int hlen;
-		EVP_CIPHER_CTX ctx;
-		HMAC_CTX hctx;
-		unsigned char iv[EVP_MAX_IV_LENGTH];
-		unsigned char key_name[16];
-
-		/* get session encoding length */
-		slen = i2d_SSL_SESSION(s->session, NULL);
-		/* Some length values are 16 bits, so forget it if session is
- 		 * too long
- 		 */
-		if (slen > 0xFF00)
-			return -1;
-		/* Grow buffer if need be: the length calculation is as
- 		 * follows 1 (size of message name) + 3 (message length
- 		 * bytes) + 4 (ticket lifetime hint) + 2 (ticket length) +
- 		 * 16 (key name) + max_iv_len (iv length) +
- 		 * session_length + max_enc_block_size (max encrypted session
- 		 * length) + max_md_size (HMAC).
- 		 */
-		if (!BUF_MEM_grow(s->init_buf,
-			26 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
-			EVP_MAX_MD_SIZE + slen))
-			return -1;
-		senc = OPENSSL_malloc(slen);
-		if (!senc)
-			return -1;
-		p = senc;
-		i2d_SSL_SESSION(s->session, &p);
-
-		p=(unsigned char *)s->init_buf->data;
-		/* do the header */
-		*(p++)=SSL3_MT_NEWSESSION_TICKET;
-		/* Skip message length for now */
-		p += 3;
-		EVP_CIPHER_CTX_init(&ctx);
-		HMAC_CTX_init(&hctx);
-		/* Initialize HMAC and cipher contexts. If callback present
-		 * it does all the work otherwise use generated values
-		 * from parent ctx.
-		 */
-		if (s->ctx->tlsext_ticket_key_cb)
-			{
-			if (s->ctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
-							 &hctx, 1) < 0)
-				{
-				OPENSSL_free(senc);
-				return -1;
-				}
-			}
-		else
-			{
-			RAND_pseudo_bytes(iv, 16);
-			EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
-					s->ctx->tlsext_tick_aes_key, iv);
-			HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
-					tlsext_tick_md(), NULL);
-			memcpy(key_name, s->ctx->tlsext_tick_key_name, 16);
-			}
-		l2n(s->session->tlsext_tick_lifetime_hint, p);
-		/* Skip ticket length for now */
-		p += 2;
-		/* Output key name */
-		macstart = p;
-		memcpy(p, key_name, 16);
-		p += 16;
-		/* output IV */
-		memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
-		p += EVP_CIPHER_CTX_iv_length(&ctx);
-		/* Encrypt session data */
-		EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
-		p += len;
-		EVP_EncryptFinal(&ctx, p, &len);
-		p += len;
-		EVP_CIPHER_CTX_cleanup(&ctx);
-
-		HMAC_Update(&hctx, macstart, p - macstart);
-		HMAC_Final(&hctx, p, &hlen);
-		HMAC_CTX_cleanup(&hctx);
-
-		p += hlen;
-		/* Now write out lengths: p points to end of data written */
-		/* Total length */
-		len = p - (unsigned char *)s->init_buf->data;
-		p=(unsigned char *)s->init_buf->data + 1;
-		l2n3(len - 4, p); /* Message length */
-		p += 4;
-		s2n(len - 10, p);  /* Ticket length */
-
-		/* number of bytes to write */
-		s->init_num= len;
-		s->state=SSL3_ST_SW_SESSION_TICKET_B;
-		s->init_off=0;
-		OPENSSL_free(senc);
-		}
-
-	/* SSL3_ST_SW_SESSION_TICKET_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+{
+    if (s->state == SSL3_ST_SW_SESSION_TICKET_A)
+        {
+        unsigned char *p, *senc, *macstart;
+        int len, slen;
+        unsigned int hlen;
+        EVP_CIPHER_CTX ctx;
+        HMAC_CTX hctx;
+        unsigned char iv[EVP_MAX_IV_LENGTH];
+        unsigned char key_name[16];
+
+        /* get session encoding length */
+        slen = i2d_SSL_SESSION(s->session, NULL);
+        /* Some length values are 16 bits, so forget it if session is
+          * too long
+          */
+        if (slen > 0xFF00)
+            return -1;
+        /* Grow buffer if need be: the length calculation is as
+          * follows 1 (size of message name) + 3 (message length
+          * bytes) + 4 (ticket lifetime hint) + 2 (ticket length) +
+          * 16 (key name) + max_iv_len (iv length) +
+          * session_length + max_enc_block_size (max encrypted session
+          * length) + max_md_size (HMAC).
+          */
+        if (!BUF_MEM_grow(s->init_buf,
+            26 + EVP_MAX_IV_LENGTH + EVP_MAX_BLOCK_LENGTH +
+            EVP_MAX_MD_SIZE + slen))
+            return -1;
+        senc = OPENSSL_malloc(slen);
+        if (!senc)
+            return -1;
+        p = senc;
+        i2d_SSL_SESSION(s->session, &p);
+
+        p=(unsigned char *)s->init_buf->data;
+        /* do the header */
+        *(p++)=SSL3_MT_NEWSESSION_TICKET;
+        /* Skip message length for now */
+        p += 3;
+        EVP_CIPHER_CTX_init(&ctx);
+        HMAC_CTX_init(&hctx);
+        /* Initialize HMAC and cipher contexts. If callback present
+         * it does all the work otherwise use generated values
+         * from parent ctx.
+         */
+        if (s->ctx->tlsext_ticket_key_cb)
+            {
+            if (s->ctx->tlsext_ticket_key_cb(s, key_name, iv, &ctx,
+                             &hctx, 1) < 0)
+                {
+                OPENSSL_free(senc);
+                return -1;
+                }
+            }
+        else
+            {
+            RAND_pseudo_bytes(iv, 16);
+            EVP_EncryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,
+                    s->ctx->tlsext_tick_aes_key, iv);
+            HMAC_Init_ex(&hctx, s->ctx->tlsext_tick_hmac_key, 16,
+                    tlsext_tick_md(), NULL);
+            memcpy(key_name, s->ctx->tlsext_tick_key_name, 16);
+            }
+        l2n(s->session->tlsext_tick_lifetime_hint, p);
+        /* Skip ticket length for now */
+        p += 2;
+        /* Output key name */
+        macstart = p;
+        memcpy(p, key_name, 16);
+        p += 16;
+        /* output IV */
+        memcpy(p, iv, EVP_CIPHER_CTX_iv_length(&ctx));
+        p += EVP_CIPHER_CTX_iv_length(&ctx);
+        /* Encrypt session data */
+        EVP_EncryptUpdate(&ctx, p, &len, senc, slen);
+        p += len;
+        EVP_EncryptFinal(&ctx, p, &len);
+        p += len;
+        EVP_CIPHER_CTX_cleanup(&ctx);
+
+        HMAC_Update(&hctx, macstart, p - macstart);
+        HMAC_Final(&hctx, p, &hlen);
+        HMAC_CTX_cleanup(&hctx);
+
+        p += hlen;
+        /* Now write out lengths: p points to end of data written */
+        /* Total length */
+        len = p - (unsigned char *)s->init_buf->data;
+        p=(unsigned char *)s->init_buf->data + 1;
+        l2n3(len - 4, p); /* Message length */
+        p += 4;
+        s2n(len - 10, p);  /* Ticket length */
+
+        /* number of bytes to write */
+        s->init_num= len;
+        s->state=SSL3_ST_SW_SESSION_TICKET_B;
+        s->init_off=0;
+        OPENSSL_free(senc);
+        }
+
+    /* SSL3_ST_SW_SESSION_TICKET_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+}
 
 int ssl3_send_cert_status(SSL *s)
-	{
-	if (s->state == SSL3_ST_SW_CERT_STATUS_A)
-		{
-		unsigned char *p;
-		/* Grow buffer if need be: the length calculation is as
- 		 * follows 1 (message type) + 3 (message length) +
- 		 * 1 (ocsp response type) + 3 (ocsp response length)
- 		 * + (ocsp response)
- 		 */
-		if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen))
-			return -1;
-
-		p=(unsigned char *)s->init_buf->data;
-
-		/* do the header */
-		*(p++)=SSL3_MT_CERTIFICATE_STATUS;
-		/* message length */
-		l2n3(s->tlsext_ocsp_resplen + 4, p);
-		/* status type */
-		*(p++)= s->tlsext_status_type;
-		/* length of OCSP response */
-		l2n3(s->tlsext_ocsp_resplen, p);
-		/* actual response */
-		memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen);
-		/* number of bytes to write */
-		s->init_num = 8 + s->tlsext_ocsp_resplen;
-		s->state=SSL3_ST_SW_CERT_STATUS_B;
-		s->init_off = 0;
-		}
-
-	/* SSL3_ST_SW_CERT_STATUS_B */
-	return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
-	}
+{
+    if (s->state == SSL3_ST_SW_CERT_STATUS_A)
+        {
+        unsigned char *p;
+        /* Grow buffer if need be: the length calculation is as
+          * follows 1 (message type) + 3 (message length) +
+          * 1 (ocsp response type) + 3 (ocsp response length)
+          * + (ocsp response)
+          */
+        if (!BUF_MEM_grow(s->init_buf, 8 + s->tlsext_ocsp_resplen))
+            return -1;
+
+        p=(unsigned char *)s->init_buf->data;
+
+        /* do the header */
+        *(p++)=SSL3_MT_CERTIFICATE_STATUS;
+        /* message length */
+        l2n3(s->tlsext_ocsp_resplen + 4, p);
+        /* status type */
+        *(p++)= s->tlsext_status_type;
+        /* length of OCSP response */
+        l2n3(s->tlsext_ocsp_resplen, p);
+        /* actual response */
+        memcpy(p, s->tlsext_ocsp_resp, s->tlsext_ocsp_resplen);
+        /* number of bytes to write */
+        s->init_num = 8 + s->tlsext_ocsp_resplen;
+        s->state=SSL3_ST_SW_CERT_STATUS_B;
+        s->init_off = 0;
+        }
+
+    /* SSL3_ST_SW_CERT_STATUS_B */
+    return(ssl3_do_write(s,SSL3_RT_HANDSHAKE));
+}
 #endif
diff -Naur openssl-0.9.8j/ssl/ssl2.h TurboSSL-0.9.8j/ssl/ssl2.h
--- openssl-0.9.8j/ssl/ssl2.h	2001-11-10 02:16:28.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/ssl2.h	2010-05-31 12:13:09.000000000 +0200
@@ -216,6 +216,10 @@
 		unsigned int session_id_length;
 		unsigned int clen;
 		unsigned int rlen;
+#ifdef CAVIUM_SSL
+                int cavium_block_cipher;
+                int cavium_pad;
+#endif
 		} tmp;
 	} SSL2_STATE;
 
diff -Naur openssl-0.9.8j/ssl/ssl3.h TurboSSL-0.9.8j/ssl/ssl3.h
--- openssl-0.9.8j/ssl/ssl3.h	2007-10-12 02:00:30.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl3.h	2010-05-31 12:13:09.000000000 +0200
@@ -343,6 +343,14 @@
 
 	unsigned char server_random[SSL3_RANDOM_SIZE];
 	unsigned char client_random[SSL3_RANDOM_SIZE];
+#ifdef CAVIUM_SSL
+    unsigned char *o_rbuf_buf;
+    unsigned char *o_wbuf_buf;
+    unsigned char write_ipad_hash[20];
+    unsigned char read_ipad_hash[20];
+    unsigned char write_opad_hash[20];
+    unsigned char read_opad_hash[20]; 
+#endif
 
 	/* flags for countermeasure against known-IV weakness */
 	int need_empty_fragments;
@@ -438,6 +446,10 @@
 		char *new_compression;
 #endif
 		int cert_request;
+#ifdef CAVIUM_SSL
+        Uint64 ctx_ptr ;
+        Uint64 ctx_ptr1 ;
+#endif
 		} tmp;
 
 	} SSL3_STATE;
@@ -531,6 +543,10 @@
 #define SSL3_ST_SW_CERT_STATUS_A	(0x200|SSL_ST_ACCEPT)
 #define SSL3_ST_SW_CERT_STATUS_B	(0x201|SSL_ST_ACCEPT)
 
+#ifdef CAVIUM_SSL
+#define CAV_ST_IN_HANDSHAKE         (0x132|SSL_ST_ACCEPT)
+#endif
+
 #define SSL3_MT_HELLO_REQUEST			0
 #define SSL3_MT_CLIENT_HELLO			1
 #define SSL3_MT_SERVER_HELLO			2
diff -Naur openssl-0.9.8j/ssl/ssl_algs.c TurboSSL-0.9.8j/ssl/ssl_algs.c
--- openssl-0.9.8j/ssl/ssl_algs.c	2007-04-24 01:50:21.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl_algs.c	2010-05-31 12:13:09.000000000 +0200
@@ -60,9 +60,15 @@
 #include <openssl/objects.h>
 #include <openssl/lhash.h>
 #include "ssl_locl.h"
+#ifdef CAVIUM_SSL
+#include "ssl_engine.h"
+#endif
 
 int SSL_library_init(void)
 	{
+#ifdef CAVIUM_SSL
+        pkp_init();
+#endif
 
 #ifndef OPENSSL_NO_DES
 	EVP_add_cipher(EVP_des_cbc());
diff -Naur openssl-0.9.8j/ssl/ssl_cert.c TurboSSL-0.9.8j/ssl/ssl_cert.c
--- openssl-0.9.8j/ssl/ssl_cert.c	2007-09-06 14:43:54.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl_cert.c	2010-05-31 12:13:09.000000000 +0200
@@ -370,8 +370,10 @@
 		{
 		if (c->pkeys[i].x509 != NULL)
 			X509_free(c->pkeys[i].x509);
+#ifndef CAVIUM_FIPS
 		if (c->pkeys[i].privatekey != NULL)
 			EVP_PKEY_free(c->pkeys[i].privatekey);
+#endif			
 #if 0
 		if (c->pkeys[i].publickey != NULL)
 			EVP_PKEY_free(c->pkeys[i].publickey);
diff -Naur openssl-0.9.8j/ssl/ssl_engine.c TurboSSL-0.9.8j/ssl/ssl_engine.c
--- openssl-0.9.8j/ssl/ssl_engine.c	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/ssl_engine.c	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,8996 @@
+
+/* Copyright (c) 2003-2005 Cavium Networks (support@cavium.com) All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3. Cavium Networks name may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * This Software, including technical data, may be subject to U.S. export control laws,
+ * including the U.S. Export Administration Act and its associated regulations, and may be
+ * subject to export or import regulations in other countries. You warrant that You will comply
+ * strictly in all respects with all such regulations and acknowledge that you have the responsibility
+ * to obtain licenses to export, re-export or import the Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS
+ * AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
+ * FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT,
+ * QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE
+ * OF THE SOFTWARE LIES WITH YOU.
+ */
+
+
+/* ssl_engine.c */
+/*
+ *  Author  :   Imran Badr
+ *              Cavium Networks
+ */
+
+
+#include <openssl/buffer.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+
+#if defined(linux)
+#include <endian.h>
+#endif
+
+#include <netinet/in.h>
+
+#include "ssl_locl.h"
+#include "ssl_engine.h"
+
+#include "openssl/cav_debug.h"
+
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#include "luna_api.h"
+#include "cav_crypto_engine.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+Rc4Type get_Rc4_type (unsigned long id);
+DesType get_Des_type (unsigned long id);
+int generate_pre_master_secret (SSL * s, int modlength, unsigned char *p,
+    RSA * rsa);
+extern void print_hex (char *label, Uint8 * datap, int len);
+
+int check_vryf_mac_completion (SSL * s);
+/*
+   int check_dec_peer_completion(
+   SSL *s,
+   int *ip,
+   int *lenp,
+   int *md_sizep,
+   int *finish_sizep,
+   int *is_blockp,
+   unsigned short *peer_lenp,
+   char *dec_peer_client_finishedp);
+ */
+int check_handshake_completion (SSL * s,
+    int *ip,
+    int *lenp,
+    int *md_sizep,
+    int *finish_sizep,
+    int *is_blockp, char *client_finishedp, char *server_finishedp);
+
+#ifdef WIN32
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+//static unsigned int pkp_random_index;
+
+
+int pkp_device_present = 1;
+void
+pkp_init (void)
+{
+
+#ifdef CAV_DEBUG
+    char cav_nb_fname[100];
+#endif
+
+#ifdef CAVIUM_MULTICARD_API
+    int dev_id = 0;
+    Uint32 dev_cnt = 0;
+    Uint8 dev_mask = 0;
+#endif
+
+    cav_printf ("pkp_init(): entry\n");
+#if defined(CAVIUM_SCATTER_GATHER_MODE)
+    /* initialize the API layer */
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_MULTICARD_API
+    if (Csp1Initialize (CAVIUM_SCATTER_GATHER, CAVIUM_DEV_ID))    /* 500 ms */
+#else
+    if (Csp1Initialize (CAVIUM_SCATTER_GATHER))    /* 500 ms */
+#endif
+#else /*FIPS*/
+    if (Cfm1Initialize (500, SCATTER_GATHER))
+#endif
+
+    {
+        /*exit(-1); */
+        pkp_device_present = 0;
+    }
+#elif defined (CAVIUM_DIRECT_MODE)
+
+    /* initialize the API layer */
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_MULTICARD_API
+    if (Csp1Initialize (CAVIUM_DIRECT, CAVIUM_DEV_ID))    /* 500 ms */
+#else
+    if (Csp1Initialize (CAVIUM_DIRECT))    /* 500 ms */
+#endif
+#else /*FIPS*/
+    if (Cfm1Initialize (500, DIRECT))    /* 500 ms */
+#endif
+    {
+        cav_printf ("pkp_init(): Cps1Initialize() failed. exiting\n");
+        /*exit(-1); */
+        pkp_device_present = 0;
+    }
+#else
+
+    /* initialize the API layer */
+    //if(Csp1Initialize(5000,DIRECT))  /* 5000 ms */
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_MULTICARD_API
+    if (Csp1Initialize (CAVIUM_DIRECT, CAVIUM_DEV_ID))
+#else
+    if (Csp1Initialize (CAVIUM_DIRECT))
+#endif
+#else
+    if (Cfm1Initialize (500, DIRECT))
+#endif
+    {
+        cav_printf ("pkp_init(): Cps1Initialize() failed. exiting\n");
+        /*exit(-1); */
+        pkp_device_present = 0;
+    }
+#endif
+
+
+#ifdef CAVIUM_MULTICARD_API
+    Csp1GetDevCnt (&dev_cnt, &dev_mask);
+    for (dev_id = 0; dev_id < dev_cnt; dev_id++) {
+        if (Csp1Initialize (CAVIUM_DIRECT, dev_id))
+        {
+            printf ("pkp_init(): Cps1Initialize() failed for dev%d.\n",
+                dev_id);
+            //cav_printf("pkp_init(): Cps1Initialize() failed for dev%d.\n",dev_id);
+            exit (-1);
+        }
+
+    }
+#endif
+
+
+#ifdef CAV_DEBUG
+    if (cav_nb_fp == NULL) {
+        sprintf (cav_nb_fname, "cav_nb.log.%d", getpid ());
+        //sprintf(cav_nb_fname, "/tmp/cav_nb.log.%d",1);
+        if ((cav_nb_fp = fopen (cav_nb_fname, "w+")) == NULL) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_init(): fopen(%s) failed %s <%d>\n", cav_nb_fname,
+                sys_errlist[errno], errno);
+        }
+        setbuf (cav_nb_fp, NULL);
+    }
+#endif
+
+}            /* pkp_init */
+
+
+int
+pkp_get_random (char *out, int len, SSL * s)
+{
+    cav_fprintf (cav_nb_fp, "pkp_get_random(): entry\n");
+
+    if (!pkp_device_present)
+        return 1;
+
+    CRYPTO_r_lock (CRYPTO_LOCK_SSL);
+
+    if ((s->random_index + len) >= PKP_RANDOM_BUFFER_SIZE) {
+/* here I could have copied the bytes already in the buffer
+ * and after re-filling the buffer, get the remaining bytes.
+ * But that process involves two memcpy's which I want to avoid. :-) */
+
+/* refill the buffer */
+#ifdef CAVIUM_FIPS
+        if (Cfm1Random (OP_BLOCKING, PKP_RANDOM_BUFFER_SIZE,
+                s->random_buffer, &s->cav_req_id))
+#else
+#ifdef CAVIUM_MULTICARD_API
+        if (Csp1Random (CAVIUM_BLOCKING, PKP_RANDOM_BUFFER_SIZE,
+                s->random_buffer, &s->cav_req_id, s->dev_id))
+#else
+        if (Csp1Random (CAVIUM_BLOCKING, PKP_RANDOM_BUFFER_SIZE,
+                s->random_buffer, &s->cav_req_id))
+#endif
+#endif
+        {
+            CRYPTO_r_unlock (CRYPTO_LOCK_SSL);
+            cav_fprintf (cav_nb_fp, "pkp_get_random(): return 0\n");
+            return 0;
+        }
+
+        s->random_index = 0;
+
+    }
+
+    memcpy (out, &s->random_buffer[s->random_index], len);
+    s->random_index += len;
+
+    CRYPTO_r_unlock (CRYPTO_LOCK_SSL);
+    cav_fprintf (cav_nb_fp, "pkp_get_random(): return 0\n");
+    return 1;
+}
+
+
+/* wrec->data is where we should get the encrypted record
+   wrec->input is the source
+   wrec->length is the length of source
+   wrec->type has the content type
+ */
+
+void
+leftfill (unsigned char input[], int length, unsigned char output[],
+    int finallength)
+{
+    int i, j;
+    memset (output, 0, finallength);
+    j = finallength - 1;
+    for (i = length - 1; i >= 0; i--) {
+        output[j] = input[i];
+        j = j - 1;
+    }
+}
+
+void
+swap_word_openssl (unsigned char *d, unsigned char *s, int len)
+{
+    int i, j;
+#ifdef WIN32
+    unsigned __int64 *ps;
+    unsigned __int64 *pd;
+#else
+    unsigned long long *ps;
+    unsigned long long *pd;
+#endif
+
+    j = 0;
+
+#ifdef WIN32
+    ps = (unsigned __int64 *) s;
+    pd = (unsigned __int64 *) d;
+#else
+    ps = (unsigned long long *) s;
+    pd = (unsigned long long *) d;
+#endif
+
+    for (i = (len >> 3) - 1; i >= 0; i--) {
+        pd[j] = ps[i];
+        j++;
+    }
+
+}
+
+
+
+#ifdef CAVIUM_MULTICARD_API
+int
+store_pkey (EVP_PKEY * pkey, Uint64 * key_handle, Uint32 dev_id)
+#else
+int
+store_pkey (EVP_PKEY * pkey, Uint64 * key_handle)
+#endif
+{
+#ifndef CAVIUM_FIPS
+#ifdef CAVIUM_CRT_MOD_EX
+    int size_mod, size_q, size_eq, size_p, size_ep, size_iqmp, size_crt;
+    int ret = 1;
+    unsigned char *qb, *eqb, *pb, *epb, *iqmpb, *temp, *dummy;
+    BIGNUM *mod, *q, *eq, *p, *ep, *iqmp;
+
+    mod = pkey->pkey.rsa->n;
+
+    size_mod = BN_num_bytes (mod);
+    if ((size_mod < 8) || (size_mod > 2048))
+        return 0;
+
+    size_crt = size_mod / 2;
+
+    temp = alloca (size_crt + (size_mod * 2));
+    if (temp == NULL)
+        return 0;
+    memset (temp, 0, size_crt + (size_mod * 2));
+
+
+    /* Q */
+    q = pkey->pkey.rsa->q;
+
+    qb = alloca (size_crt);
+    if (qb == NULL)
+        return 0;
+    memset (qb, 0, size_crt);
+    BN_bn2bin (q, qb);
+
+    size_q = BN_num_bytes (q);
+    if (size_q < size_crt) {
+        leftfill (qb, size_q, temp, size_crt);
+        memcpy (qb, temp, size_crt);
+        memset (temp, 0, size_crt);
+    }
+
+    /* Eq */
+    eq = pkey->pkey.rsa->dmq1;
+    if (eq == NULL) {
+        cav_fprintf (cav_nb_fp,
+            "store_pkey(): eq = pkey->pkey.rsa->dmq1 is NULL\n");
+    }
+
+    eqb = alloca (size_crt);
+    if (eqb == NULL)
+        return 0;
+    memset (eqb, 0, size_crt);
+    BN_bn2bin (eq, eqb);
+
+    size_eq = BN_num_bytes (eq);
+    if (size_eq < size_crt) {
+        leftfill (eqb, size_eq, temp, size_crt);
+        memcpy (eqb, temp, size_crt);
+        memset (temp, 0, size_crt);
+    }
+
+
+    /* P */
+    p = pkey->pkey.rsa->p;
+
+    if (p == NULL) {
+        cav_fprintf (cav_nb_fp,
+            "store_pkey(): p = pkey->pkey.rsa->p is NULL\n");
+    }
+
+    pb = alloca (size_crt);
+    if (pb == NULL)
+        return 0;
+    memset (pb, 0, size_crt);
+    BN_bn2bin (p, pb);
+
+    size_p = BN_num_bytes (p);
+    if (size_p < size_crt) {
+        leftfill (pb, size_p, temp, size_crt);
+        memcpy (pb, temp, size_crt);
+        memset (temp, 0, size_crt);
+    }
+
+    /* Ep */
+    ep = pkey->pkey.rsa->dmp1;
+
+    epb = alloca (size_crt);
+    if (epb == NULL)
+        return 0;
+    memset (epb, 0, size_crt);
+    BN_bn2bin (ep, epb);
+
+    size_ep = BN_num_bytes (ep);
+    if (size_ep < size_crt) {
+        leftfill (epb, size_ep, temp, size_crt);
+        memcpy (epb, temp, size_crt);
+        memset (temp, 0, size_crt);
+    }
+
+
+    /* iqmp */
+    iqmp = pkey->pkey.rsa->iqmp;
+
+    iqmpb = alloca (size_crt);
+    if (iqmpb == NULL)
+        return 0;
+    memset (iqmpb, 0, size_crt);
+    BN_bn2bin (iqmp, iqmpb);
+
+    size_iqmp = BN_num_bytes (iqmp);
+    if (size_iqmp < size_crt) {
+        leftfill (iqmpb, size_iqmp, temp, size_crt);
+        memcpy (iqmpb, temp, size_crt);
+        memset (temp, 0, size_crt);
+    }
+
+    /* now convert all to Integer format */
+
+    dummy = temp;
+
+#ifdef MC2
+    memcpy (dummy, qb, size_crt);
+#else
+    swap_word_openssl (dummy, qb, size_crt);
+#endif
+
+    dummy += size_crt;
+
+#ifdef MC2
+    memcpy (dummy, eqb, size_crt);
+#else
+    swap_word_openssl (dummy, eqb, size_crt);
+#endif
+    dummy += size_crt;
+
+#ifdef MC2
+    memcpy (dummy, pb, size_crt);
+#else
+    swap_word_openssl (dummy, pb, size_crt);
+#endif
+    dummy += size_crt;
+
+#ifdef MC2
+    memcpy (dummy, epb, size_crt);
+#else
+    swap_word_openssl (dummy, epb, size_crt);
+#endif
+    dummy += size_crt;
+
+#ifdef MC2
+    memcpy (dummy, iqmpb, size_crt);
+#else
+    swap_word_openssl (dummy, iqmpb, size_crt);
+#endif
+
+#ifdef CAVIUM_MULTICARD_API
+    if (Csp1StoreKey (key_handle,
+            (unsigned short) (size_crt + (size_mod * 2)), temp, CRT_MOD_EX,
+            dev_id))
+#else
+    if (Csp1StoreKey (key_handle,
+            (unsigned short) (size_crt + (size_mod * 2)), temp,
+            CRT_MOD_EX))
+#endif
+    {
+        ret = 0;
+    }
+
+
+    memset (temp, 0, size_crt + (size_mod * 2));
+    return ret;
+
+
+#else                            /*presumably CAVIUM_NORMAL_MOD_EX */
+
+    int sizem, sizep, ret = 1;
+    unsigned char *mb, *pb, *temp;
+    BIGNUM *m, *p;
+
+    m = pkey->pkey.rsa->n;
+    p = pkey->pkey.rsa->d;
+
+    sizem = BN_num_bytes (m);
+    if ((sizem < 8) || (sizem > 2048))
+        return 0;
+    sizem = ((sizem + 7) / 8) * 8;
+    sizep = BN_num_bytes (p);
+
+    mb = alloca (sizem);
+    if (mb == NULL)
+        return 0;
+    memset (mb, 0, sizem);
+
+    pb = alloca (sizem);
+    if (pb == NULL)
+        return 0;
+    memset (pb, 0, sizem);
+
+    temp = alloca (sizem * 2);
+    if (temp == NULL)
+        return 0;
+    memset (temp, 0, sizem * 2);
+
+    BN_bn2bin (m, mb);
+
+    BN_bn2bin (p, pb);
+
+    if (sizep < sizem) {
+        leftfill (pb, sizep, temp, sizem);
+        memcpy (pb, temp, sizem);
+        memset (temp, 0, sizem);
+    }
+#ifdef MC2
+    memcpy (temp, mb, sizem);
+    memcpy (temp + sizem, pb, sizem);
+#else
+    swap_word_openssl (temp, mb, sizem);
+    swap_word_openssl (temp + sizem, pb, sizem);
+#endif
+
+#ifdef CAVIUM_MULTICARD_API
+    if (Csp1StoreKey (key_handle, (unsigned short) (sizem * 2), temp,
+            NORMAL_MOD_EX, dev_id))
+#else
+    if (Csp1StoreKey (key_handle, (unsigned short) (sizem * 2), temp,
+            NORMAL_MOD_EX))
+#endif
+    {
+        ret = 0;
+    }
+
+    memset (temp, 0, sizem * 2);
+    return (ret);
+
+#endif
+
+#else
+    return (0);
+#endif
+}
+
+
+int
+pkp_encrypt_record (SSL * s)
+{
+
+    int cipher_type, digest_type, md_size;
+    int err;
+    SslVersion version;
+    SslPartyType ssl_party;
+    AesType aes_type = 0;
+
+    version = s->ssl_version;
+    cipher_type = s->cipher_type;
+    digest_type = s->digest_type;
+    md_size = s->md_size;
+
+    if (cipher_type == NID_aes_256_cbc)
+        aes_type = AES_256;
+    else if (cipher_type == NID_aes_128_cbc)
+        aes_type = AES_128;
+
+    if (s->server)
+        ssl_party = SSL_SERVER;
+    else
+        ssl_party = SSL_CLIENT;
+
+    switch (cipher_type) {
+    case NID_rc4:
+    case NID_rc4_40:
+        switch (digest_type) {
+        case NID_md5:
+
+#ifdef CAVIUM_FIPS
+            err = Cfm1EncryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->wrec.type,
+                (unsigned short) (s->s3->wrec.length),
+                s->s3->wrec.input, s->s3->wrec.data, &s->cav_req_id);
+#else
+            err = Csp1EncryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->wrec.type,
+                (unsigned short) (s->s3->wrec.length),
+                s->s3->wrec.input, s->s3->wrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+            if (err == 0) {
+                s->cav_msg_len = s->s3->wrec.length + md_size;
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_encrypt_record(): %s\n",
+                    "Csp1EncryptRecordRc4() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_ENCRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 1;
+                s->cav_saved_state = s->state;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_encrypt_record(): ERROR return %d %s\n",
+                    err, "from Csp1EncryptRecordRc4()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+            break;
+
+        case NID_sha1:
+#ifdef CAVIUM_FIPS
+            err = Cfm1EncryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->wrec.type,
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input, s->s3->wrec.data, &s->cav_req_id);
+#else
+
+            err = Csp1EncryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->wrec.type,
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input, s->s3->wrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+            if (err == 0) {
+                s->cav_msg_len = s->s3->wrec.length + md_size;
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_encrypt_record(): %s\n",
+                    "Csp1EncryptRecordRc4() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_ENCRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 1;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_encrypt_record(): ERROR return %d %s\n", err,
+                    "from Csp1EncryptRecordRc4()");
+                // ------
+                return (-1);
+                // ------
+            }
+
+            break;
+
+        default:
+            return -1;
+        }
+        break;
+
+
+    case NID_des_ede3_cbc:
+    case NID_des_cbc:
+
+        switch (digest_type) {
+        case NID_md5:
+#ifdef CAVIUM_FIPS
+            err = Cfm1EncryptRecord3Des (s->cav_nb_mode, s->context_pointer,
+                MD5_TYPE, version, ssl_party,
+                s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input,
+                &s->cav_msg_len, s->s3->wrec.data, &s->cav_req_id);
+#else
+            err = Csp1EncryptRecord3Des (s->cav_nb_mode, s->context_pointer,
+                MD5_TYPE, version, ssl_party,
+                s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input, &s->cav_msg_len, s->s3->wrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_encrypt_record(): %s\n",
+                    "Csp1EncryptRecord3Des() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_ENCRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_encrypt_record(): ERROR return %d %s\n", err,
+                    "from Csp1EncryptRecord3Des()");
+                // -----
+                return (-1);
+                // ------
+            }
+
+            break;
+
+        case NID_sha1:
+#ifdef CAVIUM_FIPS
+            err = Cfm1EncryptRecord3Des (s->cav_nb_mode, s->context_pointer,
+                SHA1_TYPE, version, ssl_party,
+                s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input,
+                &s->cav_msg_len, s->s3->wrec.data, &s->cav_req_id);
+#else
+            err = Csp1EncryptRecord3Des (s->cav_nb_mode, s->context_pointer,
+                SHA1_TYPE, version, ssl_party,
+                s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input, &s->cav_msg_len, s->s3->wrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_encrypt_record(): %s\n",
+                    "Csp1DecryptRecord3Des() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_ENCRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_encrypt_record(): ERROR return %d %s\n",
+                    err, "from Csp1EncryptRecord3Des()");
+                // -----
+                return (-1);
+                // ------
+            }
+
+            break;
+
+        default:
+            return -1;
+        }
+        break;
+
+
+    case NID_aes_256_cbc:
+    case NID_aes_128_cbc:
+
+
+        if (aes_type == NID_aes_128_cbc)
+            cav_fprintf (cav_nb_fp,
+                "pkp_encrypt_record(): case NID_aes_128_cbc\n");
+        else
+            cav_fprintf (cav_nb_fp,
+                "pkp_encrypt_record(): case NID_aes_256_cbc\n");
+
+
+        switch (digest_type) {
+
+        case NID_sha1:
+#ifdef CAVIUM_FIPS
+            err = Cfm1EncryptRecordAes (s->cav_nb_mode, s->context_pointer,
+                SHA1_TYPE, version, ssl_party,
+                aes_type, s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input,
+                &s->cav_msg_len, s->s3->wrec.data, &s->cav_req_id);
+#else
+            err = Csp1EncryptRecordAes (s->cav_nb_mode, s->context_pointer,
+                SHA1_TYPE, version, ssl_party,
+                aes_type, s->s3->wrec.type, 0,    /* pad_length, */
+                (unsigned short) s->s3->wrec.length,
+                s->s3->wrec.input, &s->cav_msg_len, s->s3->wrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_encrypt_record(): %s\n",
+                    "Csp1DecryptRecordAes() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_ENCRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_encrypt_record(): ERROR return %d %s\n",
+                    err, "from Csp1EncryptRecordAes()");
+                // -----
+                return (-1);
+                // ------
+            }
+
+            break;
+
+        default:
+            cav_fprintf (cav_nb_fp, "%s %s %d\n",
+                "pkp_encrypt_record(): ",
+                "ERROR invalid default case for digest_type", digest_type);
+            return -1;
+
+        }                        // end aes cipher
+
+        break;
+
+
+    default:
+        /* do the software only encryption */
+        // -----
+        //return 0;
+        return (-1);
+        // ------
+    }
+
+    cav_fprintf (cav_nb_fp,
+        "pkp_encrypt_record(): end: returning s->msg_len = %d\n",
+        s->cav_msg_len);
+
+    return (int) s->cav_msg_len;
+
+}                                /* pkp_encrypt_record */
+
+
+/* rrec->data is where we should get the decrypted record
+   rrec->input is the source
+   rrec->length is the length of source
+   rrec->type has the content type
+   Returns:
+   - 0 if request has not completed.
+   - >0 # of bytes in the decrypted buffer if request has completed.
+ */
+int
+pkp_decrypt_record (SSL * s)
+{
+    int cipher_type, digest_type, md_size;
+    Uint32 err;
+    SslVersion version;
+    SslPartyType ssl_party;
+    AesType aes_type = 0;
+
+
+    cav_fprintf (cav_nb_fp, "%s %d\n",
+        "pkp_decrypt_record(): entry, s->crypto_state = ",
+        s->cav_crypto_state);
+
+    version = s->ssl_version;
+    md_size = s->md_size;
+    cipher_type = s->cipher_type;
+    digest_type = s->digest_type;
+
+    if (cipher_type == NID_aes_256_cbc)
+        aes_type = AES_256;
+    else if (cipher_type == NID_aes_128_cbc)
+        aes_type = AES_128;
+
+    if (s->server)
+        ssl_party = SSL_SERVER;
+    else
+        ssl_party = SSL_CLIENT;
+
+    if (s->s3->rrec.type == SSL3_RT_CHANGE_CIPHER_SPEC) {
+        cav_fprintf (cav_nb_fp,
+            "pkp_decrypt_record(): SSL3_RT_CHANGE_CIPHER_SPEC\n");
+        s->cav_renego = 5;
+    }
+
+    switch (cipher_type) {
+    case NID_rc4:
+    case NID_rc4_40:
+
+        switch (digest_type) {
+        case NID_md5:
+
+#ifdef CAVIUM_FIPS
+            err = Cfm1DecryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type & 0x3,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, s->s3->rrec.data, &s->cav_req_id);
+#else
+            err = Csp1DecryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, s->s3->rrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                s->cav_msg_len = s->s3->rrec.length - md_size;
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_decrypt_record(): %s\n",
+                    "Csp1DecryptRecordRc4() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_DECRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 1;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): ERROR return %ld %s\n", err,
+                    "from Csp1DecryptRecordRc4()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+        case NID_sha1:
+
+#ifdef CAVIUM_FIPS
+            err = Cfm1DecryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type & 0x3,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, s->s3->rrec.data, &s->cav_req_id);
+#else
+            err = Csp1DecryptRecordRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, s->s3->rrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                s->cav_msg_len = s->s3->rrec.length - md_size;
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_decrypt_record(): %s\n",
+                    "Csp1DecryptRecordRc4() EAGAIN");
+                s->cav_crypto_state = CAV_ST_IN_DECRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 1;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): ERROR return %ld %s\n",
+                    err, "from Csp1DecryptRecordRc4()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+        default:
+            return -1;
+        }
+        break;
+
+    case NID_des_ede3_cbc:
+    case NID_des_cbc:
+        switch (digest_type) {
+        case NID_md5:
+
+#ifdef CAVIUM_FIPS
+            err = Cfm1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type & 0x3,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input,
+                &s->cav_msg_len, s->s3->rrec.data, &s->cav_req_id);
+#else
+            err = Csp1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                MD5_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, &s->cav_msg_len, s->s3->rrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_decrypt_record(): %s\n",
+                    "Csp1DecryptRecord3Des() EAGAIN");
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                s->cav_crypto_state = CAV_ST_IN_DECRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): ERROR return %ld %s\n",
+                    err, "from Csp1DecryptRecord3Des()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+
+        case NID_sha1:
+
+#ifdef CAVIUM_FIPS
+            err = Cfm1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type & 0x3,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input,
+                &s->cav_msg_len, s->s3->rrec.data, &s->cav_req_id);
+#else
+            err = Csp1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                s->s3->rrec.type,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, &s->cav_msg_len, s->s3->rrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_decrypt_record(): %s\n",
+                    "Csp1DecryptRecord3Des() EAGAIN");
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                s->cav_crypto_state = CAV_ST_IN_DECRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): ERROR return %ld %s\n",
+                    err, "from Csp1DecryptRecord3Des()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+
+        default:
+            return -1;
+        }
+        break;
+
+
+    case NID_aes_256_cbc:
+    case NID_aes_128_cbc:
+
+
+        if (aes_type == NID_aes_128_cbc)
+            cav_fprintf (cav_nb_fp,
+                "pkp_decrypt_record(): case NID_aes_128_cbc\n");
+        else
+            cav_fprintf (cav_nb_fp,
+                "pkp_decrypt_record(): case NID_aes_256_cbc\n");
+
+        switch (digest_type) {
+
+        case NID_sha1:
+#ifdef CAVIUM_FIPS
+            err = Cfm1DecryptRecordAes (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                aes_type,
+                s->s3->rrec.type & 0x3,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input,
+                &s->cav_msg_len, s->s3->rrec.data, &s->cav_req_id);
+#else
+
+            err = Csp1DecryptRecordAes (s->cav_nb_mode,
+                s->context_pointer,
+                SHA1_TYPE,
+                version,
+                ssl_party,
+                aes_type,
+                s->s3->rrec.type,
+                (unsigned short) s->s3->rrec.length,
+                s->s3->rrec.input, &s->cav_msg_len, s->s3->rrec.data,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (err == 0) {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                break;
+            } else if (err == EAGAIN) {
+                cav_fprintf (cav_nb_fp, "pkp_decrypt_record(): %s\n",
+                    "Csp1DecryptRecordAes() EAGAIN");
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): cav_msg_len = %d\n",
+                    s->cav_msg_len);
+                s->cav_crypto_state = CAV_ST_IN_DECRYPT;
+                s->cav_req_id_check_done = 0;
+                s->cav_process_flag = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+                return (0);
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_decrypt_record(): ERROR return %ld, 0x%lx, %s\n",
+                    err, err, "from Csp1DecryptRecordAes()");
+                // -----
+                return (-1);
+                // -----
+            }
+
+
+        default:
+            cav_fprintf (cav_nb_fp, "%s %s %d\n",
+                "pkp_decrypt_record(): ",
+                "ERROR invalid default case for digest_type", digest_type);
+            return (-1);
+
+        }                        // end switch digest_type
+        break;
+
+
+    default:
+        /* do the software only decryption */
+        // -----
+        //return 0;
+        cav_fprintf (cav_nb_fp, "%s %s %d\n",
+            "pkp_decrypt_record(): ",
+            "ERROR invalid default case for cipher_type", cipher_type);
+        return (-1);
+        // -----
+    }
+
+    return (int) s->cav_msg_len;
+
+}                                /* pkp_decrypt_record */
+
+
+/*
+ * We have been storing all handshake messages to s->hs_msgs[] buffer.
+ * Offsets of Client finish, Client Key Exchange messages are also stored
+ * in the same structure. Now that we have received Client finish message,
+ * following operations have to be performed:
+
+   1. do RSA_private_decrypt for CKE msg
+   2. generate master secret
+   3. generate key material
+   4. decrypt client finish message
+   5. verify client finish msg
+   6. create handshake hash including client finish message
+   7. create server finish message
+   8. create final handshake hash
+ */
+
+int
+pkp_handshake (SSL * s)
+{
+    int i, ret = 0, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int modlength, handshake_len, md_size, len, finish_size;
+    unsigned short peer_len;
+    unsigned char *p;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char temp[512], dec_peer_client_finished[80];
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+    MasterSecretReturn master_secret_return;
+
+    cav_fprintf (cav_nb_fp,
+        "pkp_handshake(): entry, s->cav_crypto_state = %d\n",
+        s->cav_crypto_state);
+
+
+    if (s->cav_renego > 0 && s->reneg_flag == 0) {
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake(): building old change cipher spec msg\n");
+
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+        if (i <= 0) {
+            s->reneg_flag = 1;
+            s->state = SSL3_ST_SR_FINISHED_A;
+            ret = 0;
+            goto err;
+        }
+        s->write_cipher_active = 0;
+    }
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+
+#ifndef NO_SESSION_CACHE
+    if (SSL_CTX_get_session_cache_mode (s->ctx) == SSL_SESS_CACHE_OFF)
+        master_secret_return = NOT_RETURNED;
+    else
+        master_secret_return = RETURN_ENCRYPTED;
+#else
+    master_secret_return = NOT_RETURNED;
+#endif
+
+    /* make p point to the CKE message */
+    /* 4-byte handshake header */
+    p = (unsigned char *) &(s->hs_msgs[s->client_key_exch_msg_offset + 4]);
+
+    /* n1 has the length of the message */
+    /* 4 header bytes */
+    modlength =
+        s->client_finish_msg_offset - s->client_key_exch_msg_offset - 4;
+
+    if (ssl_version == VER_TLS) {
+        n2s (p, i);
+        if (modlength != i + 2) {
+            if (!(s->options & SSL_OP_TLS_D5_BUG)) {
+                SSLerr (SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
+                goto err;
+            } else
+                p -= 2;
+        } else
+            modlength = i;
+    }
+
+    if ((modlength % 8)) {
+        ret = 0;
+        goto err;
+    }
+#ifdef MC2
+    memcpy (temp, p, modlength);
+#else
+    swap_word_openssl (temp, p, modlength);
+#endif
+
+    handshake_len = s->client_finish_msg_offset;
+
+
+    /*
+     * Check if this is not the 1st call (i.e. that this
+     * call is to check for completion of a previously
+     * queued cmd).
+     */
+    if (s->state == CAV_ST_IN_HANDSHAKE) {
+
+        if (s->cav_crypto_state == CAV_ST_IN_HANDSHAKE) {
+
+            rc = check_handshake_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block,
+                (char *) client_finished, (char *) server_finished);
+            if (rc == 1) {
+                memcpy (s->server_finished, server_finished, 80);
+                memcpy (s->client_finished, client_finished, 80);
+            }
+        } else if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER) {
+
+            rc = check_dec_peer_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block, &peer_len, (char *) dec_peer_client_finished);
+            if (rc == 1) {
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s %d\n",
+                    "check_handshake_completion() completed, rc = ", rc);
+                goto dec_peer;
+            }
+        }
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+
+    }                            // end if .. CAV_ST_IN_HANDSHAKE
+
+    else {
+
+        // 1st time call - not in crypto state
+
+        if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+            || (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5))
+        {
+            // RC4
+            Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+
+            len = finish_size + md_size;
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake():before Csp1RsaServerFullRc4()\n");
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): finish_size = %d, md_size = %d, len = %d\n",
+                finish_size, md_size, len);
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): modlength = %d, handshake_len = %d\n",
+                modlength, handshake_len);
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1RsaServerFullRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                &s->key_handle,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) modlength,
+                temp, s->s3->client_random, s->s3->server_random,
+                /* length of meg buffer upto finished msg */
+                (unsigned short) handshake_len,
+                /* pointer to handshake_data */
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished,
+                s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1RsaServerFullRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                &s->key_handle,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) modlength,
+                temp, s->s3->client_random, s->s3->server_random,
+                /* length of meg buffer upto finished msg */
+                (unsigned short) handshake_len,
+                /* pointer to handshake_data */
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+#endif
+            if (i == 0) {
+                // completed
+                cav_fprintf (cav_nb_fp, "===>pkp_handshake(): %s\n",
+                    "Csp1RsaServerFullRc4() done");
+            } else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "Csp1RsaServerFullRc4() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+
+                /*
+                 * Save the actual state in cav_saved_state.
+                 * So we could navigate back to this
+                 * function thru openSSL.
+                 */
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake(): ERROR return %d %s\n", i,
+                    "from Csp1RsaServerFullRc4()");
+            }
+
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+
+        }                        // end if .. RC4
+
+        else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA)) {
+
+            // 3DES
+
+            DesType des_type = get_Des_type (s->session->cipher->id);
+
+            is_block = 1;
+
+            len = ((finish_size + md_size + 7) / 8) * 8;
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): finish_size = %d, md_size = %d, len = %d\n",
+                finish_size, md_size, len);
+
+            if (ssl_version == VER_TLS) {
+
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "before Csp1RsaServerFull3Des()");
+
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerFull3Des (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerFull3Des (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+
+            }                    // end if TLS
+            else {
+                // else ssl_version != VER_TLS
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "before NOT TLS Csp1RsaServerFull3Des()");
+
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerFull3Des (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerFull3Des (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+
+
+            }                    // end else
+
+            if (i == 0) {
+                // completed
+                cav_fprintf (cav_nb_fp, "===>pkp_handshake(): %s\n",
+                    "Csp1RsaServerFull3Des() done");
+            } else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "Csp1RsaServerFull3Des() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake(): ERROR return %d %s\n", i,
+                    "from Csp1RsaServerFull3Des()");
+            }
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+
+        }                        // end 3DES
+        else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+            || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+            ) {
+
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+            ClientFinishMessageOutput cfmo;
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): AES case\n");
+
+            is_block = 1;
+
+            len = ((finish_size + md_size + 15) / 16) * 16;
+
+            if (ssl_version == VER_TLS) {
+                cfmo = RETURN_CFM_ENCRYPTED;
+            } else {
+                // ssl3
+                cfmo = RETURN_CFM_UNENCRYPTED;
+            }
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): finish_size = %d, md_size = %d, len = %d\n",
+                finish_size, md_size, len);
+
+
+            if (ssl_version == VER_TLS || ssl_version == VER3_0) {
+
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "before TLS Csp1RsaServerFullAes()");
+
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerFullAes (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, aes_type,
+                    master_secret_return,
+                    cfmo,    //RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerFullAes (s->cav_nb_mode, s->context_pointer,
+                    &s->key_handle,
+                    hash_type, ssl_version, aes_type,
+                    master_secret_return,
+                    cfmo,    //RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+
+#endif
+                if (i == 0) {
+                    // completed
+                    cav_fprintf (cav_nb_fp, "===>pkp_handshake(): %s\n",
+                        "Csp1RsaServerFullAes() done");
+                } else if (i == EAGAIN) {
+
+                    cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                        "Csp1RsaServerFullAes() EAGAIN");
+
+                    s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                    s->cav_saved_state = s->state;
+                    s->state = CAV_ST_IN_HANDSHAKE;
+                    s->cav_req_id_check_done = 0;
+                    s->rwstate = SSL_NITROX_BUSY;
+
+                }                // end .. else i == EAGAIN
+                else {
+                    cav_fprintf (cav_nb_fp,
+                        "pkp_handshake(): ERROR return %d %s\n", i,
+                        "from Csp1RsaServerFullAes()");
+                }
+
+                if (i != 0) {
+                    ret = 0;
+                    goto err;
+                }
+
+            }                    // end if TLS
+            else {
+                cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                    "ERROR not tls1 or ssl3 and AES\n");
+                return (0);
+            }
+
+        }                        // end else if AES
+        else {
+            // not RC4 and not 3DES, so error
+            ret = 0;
+            goto err;
+        }
+
+    }                            // end .. else .. 1st time crypto call
+
+
+    cav_fprintf (cav_nb_fp, "pkp_handshake(): before memcpy()\n");
+
+    /* now replace first four bytes of client finish message. */
+    memcpy (&(s->hs_msgs[s->client_finish_msg_offset]),
+        s->peer_finish_first_four, 4);
+
+    /* compare with what we got from CSP */
+    if (!is_block || ssl_version == VER_TLS) {
+        cav_fprintf (cav_nb_fp, "len = %d\n", len);
+
+        if (memcmp (&s->hs_msgs[s->client_finish_msg_offset],
+                s->client_finished, len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): within memcmp() ERROR\n");
+            ret = 0;
+            goto err;
+        }
+    } else {
+        /* decrypt the received client finished */
+        if (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA
+            || s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA) {
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s %s\n",
+                "before Csp1DecryptRecordAes() ",
+                "for decrypting client finished msg\n");
+
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1DecryptRecordAes (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+            i = Csp1DecryptRecordAes (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+        } else {
+            // DES
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s %s\n",
+                "before Csp1DecryptRecord3Des() ",
+                "for decrypting client finished msg\n");
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake() s->hs_msgs: %d\n",
+                (s->hs_msgs_len - s->client_finish_msg_offset));
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+            i = Csp1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+        }
+        if (i == 0) {
+            memcpy (dec_peer_client_finished, s->dec_peer_client_finished,
+                s->peer_len);
+            peer_len = s->peer_len;
+
+        }
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                "Csp1RsaServerFullAes() EAGAIN");
+            s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+        }
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+      dec_peer:
+
+        if (memcmp (dec_peer_client_finished, s->client_finished,
+                peer_len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake(): within memcmp-2() ERROR\n");
+            ret = 0;
+            goto err;
+        }
+
+    }                            /*isblock */
+
+    cav_fprintf (cav_nb_fp, "pkp_handshake(): before s->s3->rrec.off=0\n");
+
+
+
+    if (s->cav_renego == 0) {
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake(): sent NEW change cipher spec msg\n");
+    }
+    s->init_num = 0;
+
+    /* activate cipher on the input (reading)  side */
+    s->read_cipher_active = 1;
+
+    //s->s3->tmp.peer_finish_md_len = len;
+
+    /* SEND SERVER FINISH */
+    cav_fprintf (cav_nb_fp, "pkp_handshake(): SEND SERVER FINISH\n");
+
+
+    memcpy ((unsigned char *) s->init_buf->data, s->server_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_SW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_SW_CHANGE_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* and of course the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+    s->reneg_flag = 0;
+  err:
+    if (s->reneg_flag)
+        return ret;
+
+    if (s->cav_renego > 0) {
+        s->cav_renego = 0;
+    }
+
+    return ret;
+
+}                                /*pkp_handshake */
+
+
+int
+pkp_ephemeral_handshake (SSL * s)
+{
+    int i, ret = 0, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int modlength, handshake_len, md_size, len, finish_size, pre_master_len = 0;
+    unsigned short peer_len;
+    unsigned char *p;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char dec_peer_client_finished[80];
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+    MasterSecretReturn master_secret_return;
+
+    if (s->cav_renego > 0 && s->reneg_flag == 0) {
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_ephemeral_handshake(): building old change cipher spec msg\n");
+
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+        if (i <= 0) {
+            s->reneg_flag = 1;
+            s->state = SSL3_ST_SR_FINISHED_A;
+            ret = 0;
+            goto err;
+        }
+
+        s->write_cipher_active = 0;
+
+    }
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+#ifndef NO_SESSION_CACHE
+
+    if (SSL_CTX_get_session_cache_mode (s->ctx) == SSL_SESS_CACHE_OFF)
+        master_secret_return = NOT_RETURNED;
+    else
+        master_secret_return = RETURN_ENCRYPTED;
+
+
+#else
+    master_secret_return = NOT_RETURNED;
+#endif
+
+
+
+    /* make p point to the CKE message */
+    p = (unsigned char *) &(s->hs_msgs[s->client_key_exch_msg_offset + 4]);    /* 4-byte handshake header */
+
+    /* n1 has the length of the message */
+    modlength = s->client_finish_msg_offset - s->client_key_exch_msg_offset - 4;    /* 4 header bytes */
+
+    if (s->version > SSL3_VERSION) {
+        n2s (p, i);
+        if (modlength != i + 2) {
+            if (!(s->options & SSL_OP_TLS_D5_BUG)) {
+                SSLerr (SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
+                goto err;
+            } else
+                p -= 2;
+        } else
+            modlength = i;
+    }
+
+
+    if ((modlength % 8)) {
+        ret = 0;
+        goto err;
+    }
+
+    handshake_len = s->client_finish_msg_offset;
+
+    /*
+     * Check if this is not the 1st call (i.e. that this
+     * call is to check for completion of a previously
+     * queued cmd).
+     */
+
+    if (s->cav_crypto_state == CAV_ST_IN_HANDSHAKE) {
+
+        rc = check_handshake_completion (s,
+            &i,
+            &len,
+            &md_size,
+            &finish_size,
+            &is_block, (char *) client_finished, (char *) server_finished);
+        if (rc == 1) {
+            memcpy (s->server_finished, server_finished, 80);
+            memcpy (s->client_finished, client_finished, 80);
+            goto handshake;
+        } else if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+        cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s %d\n",
+            "check_handshake_completion() completed, rc = ", rc);
+
+    } else if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER) {
+
+        rc = check_dec_peer_completion (s,
+            &i,
+            &len,
+            &md_size,
+            &finish_size,
+            &is_block, &peer_len, (char *) dec_peer_client_finished);
+
+        if (rc == 1)
+            goto dec_peer;
+
+        else if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+        cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s %d\n",
+            "check_handshake_completion() completed, rc = ", rc);
+    }
+
+
+
+    /* now first decrypt CKE message */
+    if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+        Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr, &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+        Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr, s->dev_id);
+#else
+        Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+#endif
+        s->alloc_flag = 1;
+    }
+    pre_master_len =
+        generate_pre_master_secret (s, modlength, p, s->cert->rsa_tmp);
+
+    if (pre_master_len != SSL_MAX_MASTER_KEY_LENGTH) {
+        ret = 0;
+        goto err;
+    }
+
+    if ((s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA))
+    {
+
+        Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+        len = finish_size + md_size;
+
+        if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherFullRc4 (OP_BLOCKING,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key, &s->cav_req_id);
+
+#else
+            i = Csp1OtherFullRc4 (s->cav_nb_mode,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherFullRc4 (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherFullRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        }
+        if (i == 0) {
+            // completed/
+            cav_fprintf (cav_nb_fp, "===>pkp_ephemeral_handshake(): %s\n",
+                "Csp1OtherFullRc4() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "Csp1OtherFullRc4() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        //end ... else i == EAGAIN
+        else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_ephemeral_handshake(): ERROR return %d %s\n", i,
+                "from Csp1OtherFullRc4()");
+        }
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    }
+
+    else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+
+
+
+    {
+        DesType des_type = get_Des_type (s->session->cipher->id);
+        is_block = 1;
+        len = ((finish_size + md_size + 7) / 8) * 8;
+
+
+        if (s->cav_renego > 0) {
+
+            if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherFull3Des (OP_BLOCKING, s->s3->tmp.ctx_ptr,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherFull3Des (s->cav_nb_mode, s->s3->tmp.ctx_ptr,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherFull3Des (OP_BLOCKING, s->s3->tmp.ctx_ptr,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherFull3Des (s->cav_nb_mode, s->s3->tmp.ctx_ptr,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            }
+        } else {
+            if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherFull3Des (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherFull3Des (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherFull3Des (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished,
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherFull3Des (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    master_secret_return,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,    /*server_pad_length, */
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    s->client_finished,
+                    s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            }
+        }
+
+        if (i == 0) {
+            // completed/
+            cav_fprintf (cav_nb_fp, "===>pkp_ephemeral_handshake(): %s\n",
+                "Csp1OtherFullDES() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_ephemeral_handshake(): %s\n",
+                "Csp1OtherFull3Des() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+        else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_ephemeral_handshake(): ERROR return %d %s\n", i,
+                "from Csp1OtherFull3Des()");
+        }
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    }
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    /* now replace first four bytes of client finish message. */
+
+  handshake:if (s->cav_renego > 0) {
+        if (s->context_pointer) {
+#ifdef CAVIUM_FIPS
+            Cfm1FreeContext (OP_BLOCKING, s->context_pointer, &s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer, s->dev_id);
+#else
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer);
+#endif
+#endif
+        }
+
+        s->context_pointer = s->s3->tmp.ctx_ptr;
+        s->alloc_flag = 0;
+    }
+    memcpy (&(s->hs_msgs[s->client_finish_msg_offset]),
+        s->peer_finish_first_four, 4);
+
+    /* compare with what we got from CSP */
+    if (!is_block || ssl_version == VER_TLS) {
+        if (memcmp (&s->hs_msgs[s->client_finish_msg_offset],
+                s->client_finished, len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_ephemeral_handshake(): within memcmp() ERROR\n");
+            ret = 0;
+            goto err;
+        }
+    } else {
+
+        /* decrypt the received client finished */
+#ifdef CAVIUM_FIPS
+        i = Cfm1DecryptRecord3Des (OP_BLOCKING,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            SSL_SERVER,
+            HANDSHAKE,
+            (unsigned short) (s->hs_msgs_len -
+                s->client_finish_msg_offset),
+            &s->hs_msgs[s->client_finish_msg_offset], &peer_len,
+            s->dec_peer_client_finished, &s->cav_req_id);
+#else
+
+        i = Csp1DecryptRecord3Des (s->cav_nb_mode,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            SSL_SERVER,
+            HANDSHAKE,
+            (unsigned short) (s->hs_msgs_len -
+                s->client_finish_msg_offset),
+            &s->hs_msgs[s->client_finish_msg_offset], &s->peer_len,
+            s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+#endif
+        if (i == 0) {
+
+            memcpy (dec_peer_client_finished, s->dec_peer_client_finished,
+                s->peer_len);
+            peer_len = s->peer_len;
+        }
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake(): %s\n",
+                "Csp1RsaServerFullAes() EAGAIN");
+            s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER;
+
+            /*
+             * Save the actual state in cav_saved_state.
+             * So we could navigate back to this
+             * function thru openSSL.
+             */
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+      dec_peer:if (memcmp (dec_peer_client_finished, s->client_finished,
+                peer_len) != 0) {
+
+            ret = 0;
+            goto err;
+        }
+
+    }                            /*isblock */
+    cav_fprintf (cav_nb_fp,
+        "pkp_ephemeral_handshake(): before s->s3->rrec.off=0\n");
+
+
+    if (s->cav_renego == 0) {
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_ephemeral_handshake(): sent NEW change cipher spec msg\n");
+
+    }
+
+    s->init_num = 0;
+
+    /* activate cipher on the input (reading)  side */
+    s->read_cipher_active = 1;
+
+    s->s3->tmp.peer_finish_md_len = len;
+
+    /* SEND SERVER FINISH */
+    cav_fprintf (cav_nb_fp,
+        "pkp_ephemeral_handshake(): SEND SERVER FINISH\n");
+    memcpy ((unsigned char *) s->init_buf->data, s->server_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_SW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_SW_CHANGE_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+    s->reneg_flag = 0;
+  err:
+    if (s->reneg_flag == 1)
+        return ret;
+
+    if (s->cav_renego > 0) {
+        s->cav_renego = 0;
+    }
+    return ret;
+
+}                                /* pkp_ephemeral_handshake(s); */
+
+
+
+int
+pkp_handshake_client_auth (SSL * s)
+{
+    int i, ret, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, len, finish_size;
+    unsigned short peer_len;
+    unsigned char *p;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char dec_peer_client_finished[80];
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+
+    cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth(): entry\n");
+
+
+    if (s->cav_renego > 0 && s->reneg_flag == 0) {
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake(): building old change cipher spec msg\n");
+
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        if (i <= 0) {
+            s->reneg_flag = 1;
+            s->state = SSL3_ST_SR_FINISHED_A;
+            ret = 0;
+            goto err;
+        }
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake(): sent OLD change cipher spec msg\n");
+
+        // so next msg is not encrypted twice
+        s->write_cipher_active = 0;
+
+    }
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+    /* make p point to the CertVerify msg */
+    p = (unsigned char *) &(s->hs_msgs[s->client_cert_verify_msg_offset]);
+
+    handshake_len =
+        s->client_finish_msg_offset - s->client_cert_verify_msg_offset;
+
+
+    /* Renegotiation Fix with client authentication */
+    if (s->cav_renego > 0 && s->alloc_flag == 1) {
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake_client_auth():freeing the context \n");
+        if (s->context_pointer) {
+#ifdef CAVIUM_FIPS
+            Cfm1FreeContext (OP_BLOCKING, s->context_pointer, &s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer, s->dev_id);
+#else
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer);
+#endif
+#endif
+        }
+
+        s->context_pointer = s->s3->tmp.ctx_ptr;
+        s->alloc_flag = 0;
+    }
+
+    /*
+     * Check if this is not the 1st call (i.e. that this
+     * call is to check for completion of a previously
+     * queued cmd).
+     */
+    if (s->state == CAV_ST_IN_HANDSHAKE) {
+
+        if (s->cav_crypto_state == CAV_ST_IN_HANDSHAKE) {
+
+            rc = check_handshake_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block,
+                (char *) client_finished, (char *) server_finished);
+            if (rc == 1) {
+                memcpy (s->server_finished, server_finished, 80);
+                memcpy (s->client_finished, client_finished, 80);
+            }
+        } else if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER) {
+
+            rc = check_dec_peer_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block, &peer_len, (char *) dec_peer_client_finished);
+            if (rc == 1)
+                goto dec_peer;
+        }
+
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+        cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth(): %s %d\n",
+            "check_handshake_completion() completed, rc = ", rc);
+
+    }                            // end if .. CAV_ST_IN_HANDSHAKE
+
+    else {
+
+        if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+            || (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+            len = finish_size + md_size;
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1FinishedRc4Finish (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+
+            i = Csp1FinishedRc4Finish (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+
+#endif
+            if (i == 0) {
+                // completed/
+                cav_fprintf (cav_nb_fp,
+                    "===>pkp_handshake_client_auth(): %s\n",
+                    "Csp1FinishedRc4Finish() done");
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth(): %s\n",
+                    "Csp1FinishedRc4Finish() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth(): ERROR return %d %s\n", i,
+                    "from Csp1FinishedRc4Finish()");
+            }
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+        } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+        {
+            is_block = 1;
+            len = ((finish_size + md_size + 7) / 8) * 8;
+
+            if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Finished3DesFinish (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+                    &s->cav_req_id);
+#else
+                i = Csp1Finished3DesFinish (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Finished3DesFinish (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+                    &s->cav_req_id);
+#else
+                i = Csp1Finished3DesFinish (s->cav_nb_mode,
+                    s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    RETURN_CFM_UNENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            }
+            if (i == 0) {
+                // completed/
+                cav_fprintf (cav_nb_fp,
+                    "===>pkp_handshake_client_auth(): %s\n",
+                    "Csp1Finished3DesFinish() done");
+            }
+            if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth(): %s\n",
+                    "Csp1Finished3DesFinish() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth ERROR return %d %s\n", i,
+                    "from Csp1Finished3DesFinish()");
+            }
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+        } else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+            || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+            ) {
+
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+            ClientFinishMessageOutput cfmo;
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake_client_auth(): AES case\n");
+
+            is_block = 1;
+
+            len = ((finish_size + md_size + 15) / 16) * 16;
+
+            // THIS WORKS for AES128-SHA and AES256-SHA with tls
+            if (ssl_version == VER_TLS) {
+                cfmo = RETURN_CFM_ENCRYPTED;
+            } else {
+                // ssl3
+                cfmo = RETURN_CFM_UNENCRYPTED;
+            }
+
+            if (ssl_version == VER_TLS || ssl_version == VER3_0) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth(): %s\n",
+                    "before Csp1FinishedAesFinish()");
+#ifdef CAVIUM_FIPS
+                i = Cfm1FinishedAesFinish (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version, aes_type,
+                    cfmo,    //RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+                    &s->cav_req_id);
+
+#else
+
+                i = Csp1FinishedAesFinish (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, aes_type,
+                    cfmo,    //RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+
+#endif
+                if (i == 0) {
+                    // completed/
+                    cav_fprintf (cav_nb_fp,
+                        "===>pkp_handshakeclient_auth(): %s\n",
+                        "Csp1FinishedAesFinish() done");
+                }
+                if (i == EAGAIN) {
+
+                    cav_fprintf (cav_nb_fp,
+                        "pkp_handshake_client_auth(): %s\n",
+                        "Csp1FinishedAesFinish() EAGAIN");
+
+                    s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                    s->cav_saved_state = s->state;
+                    s->state = CAV_ST_IN_HANDSHAKE;
+                    s->cav_req_id_check_done = 0;
+                    s->rwstate = SSL_NITROX_BUSY;
+
+                }                // end .. else i == EAGAIN
+                else {
+                    cav_fprintf (cav_nb_fp,
+                        "pkp_handshake_client_auth(): ERROR return %d %s\n",
+                        i, "from Csp1FinishedAesFinish()");
+                }
+
+                if (i != 0) {
+                    ret = 0;
+                    goto err;
+                }
+            } else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_handshake_client_auth(): %s\n",
+                    "ERROR not tls1 or ssl3 and AES\n");
+                return (0);
+            }
+
+        }                        // end else .. AES
+        else {
+            ret = 0;
+            goto err;
+        }
+
+    }                            // end .. else .. 1st time crypto call
+
+    /* now replace first four bytes of client finish message. */
+    memcpy (&(s->hs_msgs[s->client_finish_msg_offset]),
+        s->peer_finish_first_four, 4);
+
+    /* compare with what we got from CSP */
+    if (!is_block || ssl_version == VER_TLS) {
+        if (memcmp (&s->hs_msgs[s->client_finish_msg_offset],
+                s->client_finished, len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake_client_auth(): memcmp failed\n");
+            print_hex ("client_finished", s->client_finished, len);
+            print_hex ("client_finished_msg_offset",
+                &s->hs_msgs[s->client_finish_msg_offset], len);
+            ret = 0;
+            goto err;
+        }
+    } else {
+
+        /* decrypt the received client finished */
+        if (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA
+            || s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA) {
+            // AES
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1DecryptRecordAes (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+            i = Csp1DecryptRecordAes (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+            // DES
+#ifdef CAVIUM_FIPS
+            i = Cfm1DecryptRecord3Des (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+            i = Csp1DecryptRecord3Des (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_SERVER,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->client_finish_msg_offset),
+                &s->hs_msgs[s->client_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        }                        // end else .. DES
+
+        if (i == 0) {
+
+            memcpy (dec_peer_client_finished, s->dec_peer_client_finished,
+                s->peer_len);
+            peer_len = s->peer_len;
+        } else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth(): %s\n",
+                "Csp1RsaServerFullAes() EAGAIN");
+            s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+
+      dec_peer:
+        if (memcmp (dec_peer_client_finished, s->client_finished,
+                peer_len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_handshake_client_auth():memcmp failed \n");
+            ret = 0;
+            goto err;
+        }
+
+    }                            /*isblock */
+
+    /* renegotiation fix for client authentication */
+
+    if (s->cav_renego == 0) {
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_SW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_handshake(): sent NEW change cipher spec msg\n");
+
+    }
+
+    s->init_num = 0;
+
+    s->s3->tmp.peer_finish_md_len = len;
+    /* activate cipher on the input (reading)  side */
+    s->read_cipher_active = 1;
+
+
+    /* SEND SERVER FINISH */
+    memcpy ((unsigned char *) s->init_buf->data, s->server_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_SW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_SW_CHANGE_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+    s->reneg_flag = 0;
+  err:
+    if (s->reneg_flag)
+        return ret;
+
+    if (s->cav_renego > 0) {
+        s->cav_renego = 0;
+    }
+    return ret;
+
+}                                /* pkp_handshake_client_auth(s); */
+
+
+
+int
+pkp_resume_handshake (SSL * s)
+{
+
+    int i, ret, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, len, finish_size;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char *p;
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+
+    cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): entry\n");
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+    /* make p point to handshake msgs */
+    p = s->hs_msgs;
+
+    handshake_len = s->hs_msgs_len;
+    /*
+     * Check if this is not the 1st call (i.e. that this
+     * call is to check for completion of a previously
+     * queued cmd).
+     */
+    if (s->cav_crypto_state == CAV_ST_IN_RESUME_HANDSHAKE) {
+
+        rc = check_handshake_completion (s,
+            &i,
+            &len,
+            &md_size,
+            &finish_size,
+            &is_block, (char *) client_finished, (char *) server_finished);
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+        cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s %d\n",
+            "check_handshake_completion() completed, rc = ", rc);
+
+    }                            // end if .. CAV_ST_IN_HANDSHAKE
+
+    else {
+
+        if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+            || (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+
+            Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+
+            len = finish_size + md_size;
+#ifdef CAVIUM_FIPS
+            i = Cfm1ResumeRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                INPUT_ENCRYPTED,
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+
+            i = Csp1ResumeRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                INPUT_ENCRYPTED,
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            if (i == 0) {
+                // completed
+                cav_fprintf (cav_nb_fp, "===>pkp_resume_handshake(): %s\n",
+                    "Csp1ResumeRc4() done");
+                memcpy (client_finished, s->client_finished, 80);
+                memcpy (server_finished, s->server_finished, 80);
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                    "Csp1ResumeRc4() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+
+        } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+        {
+
+            DesType des_type = get_Des_type (s->session->cipher->id);
+            is_block = 1;
+            len = ((finish_size + md_size + 7) / 8) * 8;
+
+            if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Resume3Des (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    INPUT_ENCRYPTED,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished, &s->cav_req_id);
+#else
+
+                i = Csp1Resume3Des (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, des_type,
+                    INPUT_ENCRYPTED,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Resume3Des (s->cav_nb_mode, s->context_pointer, hash_type, ssl_version, des_type, INPUT_ENCRYPTED, RETURN_CFM_UNENCRYPTED, RETURN_SFM_ENCRYPTED, 0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished, &s->cav_req_id);
+#else
+                i = Csp1Resume3Des (s->cav_nb_mode, s->context_pointer, hash_type, ssl_version, des_type, INPUT_ENCRYPTED, RETURN_CFM_UNENCRYPTED, RETURN_SFM_ENCRYPTED, 0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            }
+
+            if (i == 0) {
+                // completed
+                cav_fprintf (cav_nb_fp, "===>pkp_resume_handshake(): %s\n",
+                    "Csp1Resume3Des() done");
+                memcpy (client_finished, s->client_finished, 64);
+                memcpy (server_finished, s->server_finished, 64);
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                    "Csp1Resume3Des() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+
+
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+        } else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+            || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+            ) {
+
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+            ClientFinishMessageOutput cfmo;
+
+            cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): AES case\n");
+
+            is_block = 1;
+
+            len = ((finish_size + md_size + 15) / 16) * 16;
+
+            if (ssl_version == VER_TLS) {
+                cfmo = RETURN_CFM_ENCRYPTED;
+            } else {
+                // ssl3
+                cfmo = RETURN_CFM_UNENCRYPTED;
+            }
+
+            if (ssl_version == VER_TLS || ssl_version == VER3_0) {
+
+                cav_fprintf (cav_nb_fp, "pkp__resume_handshake(): %s\n",
+                    "before Csp1ResumeAes()");
+#ifdef CAVIUM_FIPS
+                i = Cfm1ResumeAes (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, aes_type,
+                    INPUT_ENCRYPTED,
+                    cfmo,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished, &s->cav_req_id);
+#else
+
+                i = Csp1ResumeAes (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version, aes_type,
+                    INPUT_ENCRYPTED,
+                    cfmo,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    s->session->master_key,
+                    (unsigned short) handshake_len,
+                    p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+                if (i == 0) {
+                    // completed
+                    cav_fprintf (cav_nb_fp,
+                        "===>pkp_resume_handshake(): %s\n",
+                        "Csp1ResumeRc4() done");
+                    memcpy (client_finished, s->client_finished, 80);
+                    memcpy (server_finished, s->server_finished, 80);
+                }
+
+                else if (i == EAGAIN) {
+
+                    cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                        "Csp1ResumeRc4() EAGAIN");
+
+                    s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+                    s->cav_saved_state = s->state;
+                    s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+                    s->cav_req_id_check_done = 0;
+                    s->rwstate = SSL_NITROX_BUSY;
+
+                }                // end .. else i == EAGAIN
+
+                if (i != 0) {
+                    cav_fprintf (cav_nb_fp,
+                        "pkp__resume_handshake(): %s %d\n",
+                        "ERROR: Csp1ResumeAes() returned i = ", i);
+                    ret = 0;
+                    goto err;
+                }
+
+            } else {
+                cav_fprintf (cav_nb_fp, "pkp__resume_handshake(): %s\n",
+                    "ERROR not tls1 or ssl3 and AES\n");
+                return (0);
+            }
+
+        }                        // end else .. AES
+        else {
+            ret = 0;
+            goto err;
+        }
+
+    }
+    /******
+    if(!is_block)
+    {
+        len = finish_size+md_size;
+    }
+    else
+    {
+        len = ((finish_size+md_size+7)/8)*8;
+    }
+    ***/
+
+    s->s3->tmp.peer_finish_md_len = finish_size;
+
+
+    /* Send CCP msg */
+    s->s3->rrec.off = 0;
+    s->packet_length = 0;
+    p = (unsigned char *) s->init_buf->data;
+    *p = SSL3_MT_CCS;
+    s->init_num = 1;
+    s->init_off = 0;
+    s->state = SSL3_ST_SW_CHANGE_B;
+
+    /* SSL3_ST_CW_CHANGE_B */
+    i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+    s->init_num = 0;
+
+    /* SEND SERVER FINISH */
+    memcpy ((unsigned char *) s->init_buf->data, server_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_SW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_SW_FINISHED_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+
+  err:
+    return ret;
+
+    /* Remember that you have already calculated server finish message and have calulated local client finish messages */
+}                                /* pkp_resume_handshake */
+
+
+/* walks down the list of suported ciphers and returns 1 on success and 0 on failure */
+int
+find_cipher (SSL * s, unsigned long cipher_id)
+{
+    int i, ret = 0;
+    if (!pkp_device_present)
+        return ret;
+
+    for (i = 0; i < PKP_SUPPORTED_CIPHER_COUNT; i++) {
+        if (s->supported_ciphers[i] == cipher_id) {
+            ret = 1;
+            break;
+        }
+    }
+
+    return ret;
+}
+
+
+
+/* initializes the supported cipher list */
+int
+init_supported_cipher_list (SSL * s)
+{
+
+    /*s->supported_ciphers[0]  = TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5;
+       s->supported_ciphers[1]  = TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA;
+       s->supported_ciphers[2]  = TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA;
+       s->supported_ciphers[3]  = SSL3_CK_RSA_RC4_40_MD5;
+       s->supported_ciphers[4]  = SSL3_CK_RSA_RC4_128_MD5;
+       s->supported_ciphers[5]  = SSL3_CK_RSA_RC4_128_SHA;
+       s->supported_ciphers[6]  = SSL3_CK_RSA_DES_40_CBC_SHA;
+       s->supported_ciphers[7]  = SSL3_CK_RSA_DES_64_CBC_SHA;
+       s->supported_ciphers[8]  = SSL3_CK_RSA_DES_192_CBC3_SHA;
+       s->supported_ciphers[9]  = SSL3_CK_DH_RSA_DES_40_CBC_SHA;
+       s->supported_ciphers[10] = SSL3_CK_DH_RSA_DES_64_CBC_SHA ;
+       s->supported_ciphers[11] = SSL3_CK_DH_RSA_DES_192_CBC3_SHA;
+       s->supported_ciphers[12] = SSL3_CK_EDH_RSA_DES_40_CBC_SHA;
+       s->supported_ciphers[13] = SSL3_CK_EDH_RSA_DES_64_CBC_SHA;
+       s->supported_ciphers[14] = SSL3_CK_EDH_RSA_DES_192_CBC3_SHA;
+       s->supported_ciphers[15] = SSL3_CK_ADH_RC4_40_MD5;
+       s->supported_ciphers[16] = SSL3_CK_ADH_RC4_128_MD5;
+       s->supported_ciphers[17] = SSL3_CK_ADH_DES_40_CBC_SHA;
+       s->supported_ciphers[18] = SSL3_CK_ADH_DES_64_CBC_SHA;
+       s->supported_ciphers[19] = SSL3_CK_ADH_DES_192_CBC_SHA;
+     */
+    memset (s->supported_ciphers, 0,
+        sizeof (unsigned long) * PKP_SUPPORTED_CIPHER_COUNT);
+
+    /*s->supported_ciphers[1]  = TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA; */
+    s->supported_ciphers[0] = TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5;
+    s->supported_ciphers[1] = TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA;
+    s->supported_ciphers[2] = SSL3_CK_RSA_RC4_40_MD5;
+    s->supported_ciphers[3] = SSL3_CK_RSA_RC4_128_MD5;
+    s->supported_ciphers[4] = SSL3_CK_RSA_RC4_128_SHA;
+    s->supported_ciphers[5] = SSL3_CK_RSA_DES_40_CBC_SHA;
+    s->supported_ciphers[6] = SSL3_CK_RSA_DES_64_CBC_SHA;
+    s->supported_ciphers[7] = SSL3_CK_RSA_DES_192_CBC3_SHA;
+    /* ssl v2 */
+    s->supported_ciphers[8] = SSL2_CK_RC4_128_WITH_MD5;
+    s->supported_ciphers[9] = SSL2_CK_RC4_128_EXPORT40_WITH_MD5;
+    s->supported_ciphers[10] = SSL2_CK_DES_64_CBC_WITH_MD5;
+    s->supported_ciphers[11] = SSL2_CK_DES_192_EDE3_CBC_WITH_MD5;
+
+    s->supported_ciphers[12] = TLS1_CK_RSA_WITH_AES_128_SHA;
+    s->supported_ciphers[13] = TLS1_CK_RSA_WITH_AES_256_SHA;
+
+    return 1;
+}
+
+
+Rc4Type
+get_Rc4_type (unsigned long id)
+{
+    if ((id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA) ||
+        (id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)) {
+        return RC4_EXPORT_56;
+    } else if ((id == SSL3_CK_RSA_RC4_40_MD5) ||
+        (id == SSL2_CK_RC4_128_EXPORT40_WITH_MD5)) {
+        return RC4_EXPORT_40;
+    } else if ((id == SSL3_CK_RSA_RC4_128_MD5) ||
+        (id == SSL3_CK_RSA_RC4_128_SHA) ||
+        (id == SSL2_CK_RC4_128_WITH_MD5)) {
+        return RC4_128;
+    }
+
+
+
+    return UNSUPPORTED_RC4;
+}
+
+
+DesType
+get_Des_type (unsigned long id)
+{
+    if (id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA) {
+        return DES_EXPORT_40;
+    } else if (id == SSL3_CK_RSA_DES_40_CBC_SHA) {
+        return DES_EXPORT_40;
+    } else if ((id == SSL3_CK_RSA_DES_64_CBC_SHA) ||
+        (id == SSL2_CK_DES_64_CBC_WITH_MD5)) {
+        return DES;
+    } else if ((id == SSL3_CK_RSA_DES_192_CBC3_SHA) ||
+        (id == SSL2_CK_DES_192_EDE3_CBC_WITH_MD5)) {
+        return DES3_192;
+    }
+
+    return UNSUPPORTED_DES;
+
+}
+
+
+AesType
+get_Aes_type (unsigned long id)
+{
+    if (id == TLS1_CK_RSA_WITH_AES_128_SHA)
+        return (AES_128);
+    else if (id == TLS1_CK_RSA_WITH_AES_256_SHA)
+        return (AES_256);
+    else
+        //return (UNSUPPORTED_AES);
+        return (-1);
+}
+
+
+int
+pkp_cert_verify_mac (SSL * s)
+{
+    int i, ret = 0, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int modlength, handshake_len, md_size, finish_size;
+    int pre_master_len;
+    unsigned char *p;
+    unsigned char server_random[80], client_random[80], temp[512];
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+    MasterSecretReturn master_secret_return;
+
+    cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): entry\n");
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        cav_fprintf (cav_nb_fp,
+            "pkp_cert_verify_mac(): ssl_cipher_get_evp() failed\n");
+        return (0);
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        cav_fprintf (cav_nb_fp,
+            "pkp_cert_verify_mac(): invalid digest type %d\n",
+            digest_type);
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+#ifndef NO_SESSION_CACHE
+
+    if (SSL_CTX_get_session_cache_mode (s->ctx) == SSL_SESS_CACHE_OFF)
+        master_secret_return = NOT_RETURNED;
+    else
+        master_secret_return = RETURN_ENCRYPTED;
+
+#else
+    master_secret_return = NOT_RETURNED;
+#endif
+
+
+    /* make p point to the CKE message */
+    p = (unsigned char *) &(s->hs_msgs[s->client_key_exch_msg_offset + 4]);    /* 4-byte handshake header */
+
+    /* n1 has the length of the message */
+    modlength = s->hs_msgs_len - s->client_key_exch_msg_offset - 4;    /* 4 header bytes */
+
+    if (s->version > SSL3_VERSION) {
+        n2s (p, i);
+        if (modlength != i + 2) {
+            if (!(s->options & SSL_OP_TLS_D5_BUG)) {
+                SSLerr (SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,
+                    SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
+                cav_fprintf (cav_nb_fp,
+                    "pkp_cert_verify_mac(): invalid encrypted len\n");
+                goto err;
+            } else
+                p -= 2;
+        } else
+            modlength = i;
+    }
+
+
+    if ((modlength % 8)) {
+        ret = 0;
+        cav_fprintf (cav_nb_fp,
+            "pkp_cert_verify_mac(): invalid modlength\n");
+        goto err;
+    }
+
+
+    handshake_len = s->hs_msgs_len;
+
+    /*
+     * Check if this is not the 1st call (i.e. that this
+     * call is to check for completion of a previously
+     * queued cmd).
+     */
+    if (s->cav_crypto_state == CAV_ST_IN_VRFY_CERT) {
+
+        rc = check_handshake_completion (s,
+            &i,
+            &handshake_len,
+            &md_size,
+            &finish_size,
+            &is_block, (char *) client_random, (char *) server_random);
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        } else {
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s %d\n",
+                "check_handshake_completion() completed, rc = ", rc);
+            return rc;
+        }
+    }
+
+    /* end if .. CAV_ST_IN_HANDSHAKE */
+    if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+
+        Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+
+        /* check for ephemeral handhake */
+
+        if (s->s3->tmp.use_rsa_tmp) {
+
+            if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+                Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr,
+                    &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr,
+                    s->dev_id);
+#else
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+#endif
+                cav_fprintf (cav_nb_fp,
+                    "pkp_cert_verify_mac()alloc context worked\n");
+                s->alloc_flag = 1;
+            }
+            pre_master_len =
+                generate_pre_master_secret (s, modlength, p,
+                s->cert->rsa_tmp);
+
+
+            if (pre_master_len != SSL_MAX_MASTER_KEY_LENGTH) {
+                ret = 0;
+                goto err;
+            }
+
+            /* now generate verify message */
+            if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherVerifyRc4 (OP_BLOCKING,
+                    s->s3->tmp.ctx_ptr,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+
+                i = Csp1OtherVerifyRc4 (s->cav_nb_mode,
+                    s->s3->tmp.ctx_ptr,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherVerifyRc4 (OP_BLOCKING,
+                    s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherVerifyRc4 (s->cav_nb_mode,
+                    s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+
+            }
+        } /* if ephemeral */
+        else {
+
+#ifdef MC2
+            memcpy (temp, p, modlength);
+#else
+            swap_word_openssl (temp, p, modlength);
+#endif
+
+
+            /* Renegotiation fix for client Authentication */
+            if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+                Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr,
+                    &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr,
+                    s->dev_id);
+#else
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+#endif
+                s->alloc_flag = 1;
+            }
+
+            if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerifyRc4 (OP_BLOCKING,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerifyRc4 (s->cav_nb_mode,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerifyRc4 (OP_BLOCKING,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerifyRc4 (s->cav_nb_mode,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    rc4_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+
+#endif
+            }
+        }
+
+        if (i == 0) {
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_cert_verify_mac() RSAserververify rc4 returned success  \n");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s\n",
+                "Csp1RsaServerVerifyRc4() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+    {
+
+        DesType des_type = get_Des_type (s->session->cipher->id);
+        is_block = 1;
+
+        if (s->s3->tmp.use_rsa_tmp) {
+
+            if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+                Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr,
+                    &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr,
+                    s->dev_id);
+#else
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+
+#endif
+                s->alloc_flag = 1;
+            }
+            pre_master_len =
+                generate_pre_master_secret (s, modlength, p,
+                s->cert->rsa_tmp);
+            if (pre_master_len != SSL_MAX_MASTER_KEY_LENGTH) {
+                ret = 0;
+                goto err;
+            }
+
+            if (s->cav_renego > 0) {
+
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherVerify3Des (OP_BLOCKING,
+                    s->s3->tmp.ctx_ptr,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherVerify3Des (s->cav_nb_mode,
+                    s->s3->tmp.ctx_ptr,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1OtherVerify3Des (OP_BLOCKING,
+                    s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1OtherVerify3Des (s->cav_nb_mode,
+                    s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) pre_master_len,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+
+
+            }
+
+        }
+        /* ephemeral */
+        else {
+#ifdef MC2
+            memcpy (temp, p, modlength);
+#else
+            swap_word_openssl (temp, p, modlength);
+#endif
+            if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+                Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr,
+                    &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr,
+                    s->dev_id);
+#else
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+#endif
+                s->alloc_flag = 1;
+            }
+
+            if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerify3Des (OP_BLOCKING,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerify3Des (s->cav_nb_mode,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerify3Des (OP_BLOCKING,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerify3Des (s->cav_nb_mode,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    des_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+
+#endif
+            }
+        }
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s\n",
+                "Csp1RsaServerVerify3Des() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    } else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+        || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+        ) {
+
+        AesType aes_type = get_Aes_type (s->session->cipher->id);
+        is_block = 1;
+
+        if (s->s3->tmp.use_rsa_tmp) {
+
+            pre_master_len =
+                generate_pre_master_secret (s, modlength, p,
+                s->cert->rsa_tmp);
+            if (pre_master_len != SSL_MAX_MASTER_KEY_LENGTH) {
+                ret = 0;
+                cav_fprintf (cav_nb_fp,
+                    "pkp_cert_verify_mac(): invalid pre_master_len\n");
+                goto err;
+            }
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerifyAes (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                &(s->s3->tmp.cert_verify_md[0]),
+                s->session->master_key, &s->cav_req_id);
+#else
+
+            i = Csp1OtherVerifyAes (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                &(s->s3->tmp.cert_verify_md[0]), s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+        }
+        /* ephemeral */
+        else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_cert_verify_mac(): AES - regular\n");
+
+#ifdef MC2
+            memcpy (temp, p, modlength);
+#else
+            swap_word_openssl (temp, p, modlength);
+#endif
+            if (s->cav_renego > 0 && s->alloc_flag == 0) {
+#ifdef CAVIUM_FIPS
+                Cfm1AllocContext (OP_BLOCKING, &s->s3->tmp.ctx_ptr,
+                    &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr,
+                    s->dev_id);
+#else
+                Csp1AllocContext (CONTEXT_SSL, &s->s3->tmp.ctx_ptr);
+#endif
+#endif
+                s->alloc_flag = 1;
+            }
+
+            if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerifyAes (OP_BLOCKING,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    aes_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerifyAes (s->cav_nb_mode,
+                    s->s3->tmp.ctx_ptr,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    aes_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1RsaServerVerifyAes (OP_BLOCKING,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    aes_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key, &s->cav_req_id);
+#else
+                i = Csp1RsaServerVerifyAes (s->cav_nb_mode,
+                    s->context_pointer,
+                    &s->key_handle,
+                    hash_type,
+                    ssl_version,
+                    aes_type,
+                    master_secret_return,
+                    (unsigned short) modlength,
+                    temp,
+                    s->s3->client_random,
+                    s->s3->server_random,
+                    (unsigned short) handshake_len,
+                    s->hs_msgs,
+                    &(s->s3->tmp.cert_verify_md[0]),
+                    s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+
+            }
+        }
+
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_cert_verify_mac(): %s\n",
+                "Csp1RsaServerVerifyAes() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            cav_fprintf (cav_nb_fp, "%s %s %d\n",
+                "pkp_cert_verify_mac(): AES - ",
+                "Csp1OtherVerifyAes()/Csp1RsaServerVerifyAes() failed", i);
+            goto err;
+        }
+
+    } else {
+        ret = 0;
+        goto err;
+    }
+
+    ret = 1;
+  err:
+    return ret;
+}                                /*pkp_cert_verify_mac */
+
+
+#ifdef MC2
+
+int
+generate_pre_master_secret (SSL * s, int modlength, unsigned char *from,
+    RSA * rsa)
+{
+    int i, rc;
+    int modulus_size, exponent_size;
+    unsigned char *result;
+    unsigned char result1[256];
+    unsigned char *modulus_b = NULL, *exponent_b = NULL;
+    Uint16 ret;
+
+    result = alloca (modlength);
+    if (result == NULL)
+        return 0;
+
+    if (s->cav_crypto_state == CAV_ST_IN_WRITE_CONTEXT) {
+
+        s->state = s->cav_saved_state;
+        if (s->cav_req_id_check_done) {
+            rc = 0;
+        } else {
+            // should check for cmd completion here
+#ifdef CAVIUM_MULTICARD_API
+            rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+            rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+        }
+        switch (rc) {
+        case EAGAIN:
+            s->cav_saved_state = s->state;
+            if (s->state == SSL3_ST_SR_CERT_VRFY_A) {
+                s->state = CAV_ST_IN_VRFY_CERT;
+            } else
+                s->state = CAV_ST_IN_HANDSHAKE;
+            return (0);
+        case 0:
+            s->cav_crypto_state = 0;
+            s->cav_req_id_check_done = 1;
+            s->rwstate = SSL_NOTHING;
+            break;
+        default:
+            s->cav_crypto_state = 0;
+            s->cav_req_id_check_done = 1;
+            s->rwstate = SSL_NOTHING;
+            return (-1);
+        }                        // end switch
+        return s->pre_master_len;
+    }
+
+    else if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY) {
+
+        rc = check_pre_master_completion (s, &ret, (char *) result1);
+
+        if (rc == 1) {
+            s->pre_master_len = ret;
+            memcpy (result, result1, s->cryp_flen);
+            goto pre_master;
+        } else
+            return 0;
+    }
+
+    modulus_size = BN_num_bytes (rsa->n);
+    exponent_size = BN_num_bytes (rsa->d);
+
+    modulus_b = alloca (modulus_size);
+    if (modulus_b == NULL)
+        return 0;
+    memset (modulus_b, 0, modulus_size);
+
+
+    exponent_b = alloca (exponent_size);
+    if (exponent_b == NULL)
+        return 0;
+    memset (exponent_b, 0, exponent_size);
+
+
+    BN_bn2bin (rsa->n, modulus_b);
+    BN_bn2bin (rsa->d, exponent_b);
+
+    s->cryp_flen = modlength;
+
+    i = Csp1Pkcs1v15Dec (s->cav_nb_mode,
+        BT2,
+        (Uint16) modulus_size,
+        (Uint16) exponent_size,
+        modulus_b,
+        exponent_b, from, &s->pre_master_len, s->pre_master_result,
+#ifdef CAVIUM_MULTICARD_API
+        &s->cav_req_id, s->dev_id
+#else
+        &s->cav_req_id
+#endif
+        );
+
+    if (i == EAGAIN) {
+        cav_fprintf (cav_nb_fp, "generate_pre_master_secret(): %s\n",
+            "Csp1Pkcs1v15Des() EAGAIN");
+
+        s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+        s->cav_saved_state = s->state;
+        if (s->state == SSL3_ST_SR_CERT_VRFY_A) {
+            s->state = CAV_ST_IN_VRFY_CERT;
+        } else
+            s->state = CAV_ST_IN_HANDSHAKE;
+
+        s->cav_req_id_check_done = 0;
+        s->rwstate = SSL_NITROX_BUSY;
+        return 0;
+    }
+
+    else if (i) {
+        ret = 0;
+        return ret;
+    }
+
+    else
+        ret = (Uint32) ntohs (s->pre_master_len);
+    memcpy (result, s->pre_master_result, s->cryp_flen);
+
+  pre_master:
+
+    if (s->cav_renego > 0)
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1WriteContext (s->cav_nb_mode, s->s3->tmp.ctx_ptr + 128,
+            ret, result, &s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1WriteContext (s->cav_nb_mode, s->s3->tmp.ctx_ptr + 128,
+            ret, result, &s->cav_req_id);
+#endif
+
+    else {
+
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1WriteContext (s->cav_nb_mode, s->context_pointer + 128,
+            ret, result, &s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1WriteContext (s->cav_nb_mode, s->context_pointer + 128,
+            ret, result, &s->cav_req_id);
+#endif
+    }
+
+    if (rc == EAGAIN) {
+        cav_fprintf (cav_nb_fp, "generate_pre_master_secret(): %s\n",
+            "Csp1WriteContext() EAGAIN");
+
+        s->cav_crypto_state = CAV_ST_IN_WRITE_CONTEXT;
+        s->cav_saved_state = s->state;
+        if (s->state == SSL3_ST_SR_CERT_VRFY_A) {
+            s->state = CAV_ST_IN_VRFY_CERT;
+        } else
+            s->state = CAV_ST_IN_HANDSHAKE;
+
+        s->cav_req_id_check_done = 0;
+        s->rwstate = SSL_NITROX_BUSY;
+        return 0;
+    } else if (rc != 0) {
+        return 0;
+    }
+    return ret;
+
+}                                /*int generate_pre_master_secret(SSL *s, int modlength, unsigned char *p, RSA *rsa); */
+
+#else                            /* if !MC2 */
+
+int
+generate_pre_master_secret (SSL * s, int modlength, unsigned char *from,
+    RSA * rsa)
+{
+    int i, rc;
+    unsigned char *temp = NULL, *from_b = NULL;
+    unsigned char result1[256];
+#ifdef MC2
+    int ret = 0;
+#else
+    long long ret = 0;
+#endif
+#ifdef CAVIUM_FIPS
+    Uint64 out_length = 0;
+#endif
+
+#ifndef CAVIUM_FIPS
+    unsigned char *modulus_b = NULL, *exponent_b = NULL;
+    int modulus_size, exponent_size;
+
+
+    from_b = alloca (modlength);
+    if (from_b == NULL)
+        return 0;
+    memcpy (from_b, from, modlength);
+    s->cryp_flen = modlength;
+
+    if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY) {
+
+        rc = check_pre_master_completion (s,
+#ifdef MC2
+            (Uint32 *) & ret,
+#else
+            (Uint64 *) (unsigned long) &ret,
+#endif
+            (char *) result1);
+
+        if (rc == 1) {
+            return (Uint32) ret;
+        } else
+            return 0;
+    }
+
+
+
+
+    modulus_size = BN_num_bytes (rsa->n);
+    exponent_size = BN_num_bytes (rsa->d);
+
+    modulus_b = alloca (modulus_size);
+    if (modulus_b == NULL)
+        return 0;
+    memset (modulus_b, 0, modulus_size);
+
+
+    temp = alloca (modulus_size);
+    if (temp == NULL)
+        return 0;
+    memset (temp, 0, modulus_size);
+
+
+    exponent_b = alloca (modulus_size);
+    if (exponent_b == NULL)
+        return 0;
+    memset (exponent_b, 0, modulus_size);
+
+
+    BN_bn2bin (rsa->n, modulus_b);
+    BN_bn2bin (rsa->d, exponent_b);
+
+    if (exponent_size < modulus_size) {
+        pkp_leftfill (exponent_b, exponent_size, temp, modulus_size);
+        memcpy (exponent_b, temp, modulus_size);
+        memset (temp, 0, exponent_size);
+    }
+
+
+    swap_word_openssl (temp, modulus_b, modulus_size);
+    memcpy (modulus_b, temp, modulus_size);
+    memset (temp, 0, modulus_size);
+
+    swap_word_openssl (temp, exponent_b, modulus_size);
+    memcpy (exponent_b, temp, modulus_size);
+    memset (temp, 0, modulus_size);
+
+    swap_word_openssl (temp, from_b, modulus_size);
+    memcpy (from_b, temp, modulus_size);
+    memset (temp, 0, modulus_size);
+
+    if (s->cav_renego > 0) {
+        i = Csp1Pkcs1v15Dec (s->cav_nb_mode,
+            CONTEXT_PTR,
+            s->s3->tmp.ctx_ptr + 128,
+            INPUT_DATA,
+            s->key_handle,
+            BT2,
+            (unsigned short) modulus_size,
+            modulus_b, exponent_b, from_b, NULL, &s->pre_master_len,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+    } else {
+        i = Csp1Pkcs1v15Dec (s->cav_nb_mode,
+            CONTEXT_PTR,
+            s->context_pointer + 128,
+            INPUT_DATA,
+            s->key_handle,
+            BT2,
+            (unsigned short) modulus_size,
+            modulus_b, exponent_b, from_b, NULL, &s->pre_master_len,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+
+    }
+#else
+    Uint64 local_key_handle = 0;
+    if (s->cav_crypto_state == CAV_ST_IN_PRE_MASTER_KEY) {
+        rc = check_pre_master_completion (s,
+#ifdef MC2
+            (Uint32 *) & ret,
+#else
+            (Uint64 *) & ret,
+#endif
+            (char *) result1);
+
+        if (rc == 1) {
+            return (Uint32) ret;
+        } else
+            return 0;
+    }
+
+
+
+    ret = fips_import_private_key (rsa, &local_key_handle);
+    if (ret)
+        return (0);
+
+    from_b = alloca (modlength);
+    if (from_b == NULL)
+        return 0;
+    memcpy (from_b, from, modlength);
+
+    temp = alloca (modlength);
+    if (temp == NULL)
+        return 0;
+
+    memset (temp, 0, modlength);
+
+    swap_word_openssl (temp, from_b, modlength);
+    memcpy (from_b, temp, modlength);
+    memset (temp, 0, modlength);
+
+    if (s->cav_renego > 0) {
+        i = Cfm1Pkcs1v15Dec (OP_BLOCKING,
+            CONTEXT_PTR,
+            s->s3->tmp.ctx_ptr + 128,
+            &local_key_handle,
+            BT2,
+            (unsigned short) modlength,
+            from_b, NULL, &out_length, &s->cav_req_id);
+    } else {
+        i = Cfm1Pkcs1v15Dec (OP_BLOCKING,
+            CONTEXT_PTR,
+            s->context_pointer + 128,
+            &local_key_handle,
+            BT2,
+            (unsigned short) modlength,
+            from_b, NULL, &out_length, &s->cav_req_id);
+    }
+    s->pre_master_len = (Uint32) out_length;
+
+    /* now destroy the key */
+    Cfm1DeleteKey (local_key_handle);
+
+#endif
+
+    if (i == EAGAIN) {
+        cav_fprintf (cav_nb_fp, "generate_pre_master_secret(): %s\n",
+            "Csp1Pkcs1v15Des() EAGAIN");
+
+        s->cav_crypto_state = CAV_ST_IN_PRE_MASTER_KEY;
+        s->cav_saved_state = s->state;
+        if (s->state == SSL3_ST_SR_CERT_VRFY_A) {
+            s->state = CAV_ST_IN_VRFY_CERT;
+        } else
+            s->state = CAV_ST_IN_HANDSHAKE;
+        s->cav_req_id_check_done = 0;
+        s->rwstate = SSL_NITROX_BUSY;
+        return 0;
+    }
+
+    else if (i) {
+
+        ret = 0;
+        return ret;
+    }
+
+    else
+        ret = (Uint32) s->pre_master_len;
+
+    return ret;
+
+}                                /*int generate_pre_master_secret(SSL *s, int modlength, unsigned char *p, RSA *rsa); */
+#endif
+
+
+
+
+/*
+ * SSL 2.0 specific functions
+ */
+
+int
+pkp_handshake_20 (SSL * s)
+{
+#ifdef CAVIUM_FIPS
+    goto err;
+#else
+    int ret = 0, finished_size;
+    Uint8 *p;
+    Uint16 modlength = 0;
+    Uint16 master_secret_length = 0;
+
+    modlength =
+        BN_num_bytes (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey->pkey.
+        rsa->n);
+
+
+    if ((s->session->cipher->id == SSL2_CK_RC4_128_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_RC4_128_EXPORT40_WITH_MD5)) {
+        Rc4Type rc4_type;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+
+        rc4_type = get_Rc4_type (s->session->cipher->id);
+        if (rc4_type == UNSUPPORTED_RC4)
+            goto err;
+
+        ret = Csp1RsaSsl20ServerFullRc4 (s->cav_nb_mode,
+            s->context_pointer,
+            &s->key_handle,
+            rc4_type,
+            s->client_master_secret,
+            s->s2->tmp.clear,
+            s->s2->tmp.enc,
+            modlength,
+            s->s2->challenge,
+            s->s2->challenge_length,
+            s->s2->conn_id,
+            s->session->session_id,
+            s->client_finished,
+            s->server_finished,
+            s->server_verify,
+            s->session->master_key, &master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (ret != 0)
+            return 0;
+
+        s->session->master_key_length = master_secret_length;
+        /* just to make sure */
+        s->s2->tmp.cavium_block_cipher = 0;
+        s->s2->tmp.cavium_pad = 0;
+    }
+
+    else if ((s->session->cipher->id == SSL2_CK_DES_64_CBC_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_DES_192_EDE3_CBC_WITH_MD5)) {
+        DesType des_type;
+        int pad;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+        pad = 8 - (finished_size % 8);
+
+        finished_size += pad;
+
+        des_type = get_Des_type (s->session->cipher->id);
+        if (des_type == UNSUPPORTED_DES)
+            goto err;
+
+
+        ret = Csp1RsaSsl20ServerFull3Des (s->cav_nb_mode,
+            s->context_pointer,
+            &s->key_handle,
+            des_type,
+            s->client_master_secret,
+            s->s2->tmp.clear,
+            s->s2->tmp.enc,
+            modlength,
+            s->s2->challenge,
+            s->s2->challenge_length,
+            s->s2->conn_id,
+            s->session->session_id,
+            s->session->key_arg,
+            s->client_finished,
+            s->server_finished,
+            s->server_verify,
+            s->session->master_key, &master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        s->session->master_key_length = master_secret_length;
+        s->s2->tmp.cavium_block_cipher = 1;
+        s->s2->tmp.cavium_pad = pad;
+    } else
+        goto err;
+
+    /* send server verify message */
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_verify, finished_size);
+
+    s->init_num = finished_size;
+    s->init_off = 0;
+    ssl2_do_write (s);
+
+    /* send server finish message */
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_finished, finished_size);
+    s->init_num = finished_size;
+    s->init_off = 0;
+
+    ssl2_do_write (s);
+
+    /* activate encryption */
+    s->s2->clear_text = 0;
+
+    /* reset some values */
+    s->s2->ract_data_length = 0;
+    s->rstate = SSL_ST_READ_HEADER;
+
+    /* just to make sure */
+    s->s2->tmp.cavium_block_cipher = 0;
+    s->s2->tmp.cavium_pad = 0;
+#endif
+    return 1;
+  err:
+    return 0;
+
+}                                /* pkp_handshake_20 */
+
+
+
+int
+pkp_resume_handshake_20 (SSL * s)
+{
+#ifdef CAVIUM_FIPS
+    goto err;
+#else
+    int ret = 0, finished_size;
+    Uint8 *p;
+
+    if ((s->session->cipher->id == SSL2_CK_RC4_128_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_RC4_128_EXPORT40_WITH_MD5)) {
+        Rc4Type rc4_type;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+
+        rc4_type = get_Rc4_type (s->session->cipher->id);
+        if (rc4_type == UNSUPPORTED_RC4)
+            goto err;
+
+        ret = Csp1Ssl20ResumeRc4 (s->cav_nb_mode,
+            s->context_pointer,
+            &s->key_handle,
+            rc4_type,
+            s->session->master_key,
+            s->session->master_key_length,
+            s->s2->challenge,
+            s->s2->challenge_length,
+            s->s2->conn_id,
+            s->session->session_id,
+            s->client_finished, s->server_finished, s->server_verify,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (ret != 0)
+            return 0;
+
+        /* just to make sure */
+        s->s2->tmp.cavium_block_cipher = 0;
+        s->s2->tmp.cavium_pad = 0;
+    }
+
+    else if ((s->session->cipher->id == SSL2_CK_DES_64_CBC_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_DES_192_EDE3_CBC_WITH_MD5)) {
+        DesType des_type;
+        int pad;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+        pad = 8 - (finished_size % 8);
+
+        finished_size += pad;
+
+        des_type = get_Des_type (s->session->cipher->id);
+        if (des_type == UNSUPPORTED_DES)
+            goto err;
+
+
+        ret = Csp1Ssl20Resume3Des (s->cav_nb_mode,
+            s->context_pointer,
+            &s->key_handle,
+            des_type,
+            s->session->master_key,
+            s->session->master_key_length,
+            s->s2->challenge,
+            s->s2->challenge_length,
+            s->s2->conn_id,
+            s->session->session_id,
+            s->session->key_arg,
+            s->client_finished, s->server_finished, s->server_verify,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        s->s2->tmp.cavium_block_cipher = 1;
+        s->s2->tmp.cavium_pad = pad;
+    } else
+        goto err;
+
+    /* send server verify message */
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_verify, finished_size);
+
+    s->init_num = finished_size;
+    s->init_off = 0;
+    ssl2_do_write (s);
+
+    /* send server finish message */
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_finished, finished_size);
+    s->init_num = finished_size;
+    s->init_off = 0;
+
+    ssl2_do_write (s);
+
+    /* activate encryption */
+    s->s2->clear_text = 0;
+
+    /* reset some values */
+    s->s2->ract_data_length = 0;
+    s->rstate = SSL_ST_READ_HEADER;
+
+    /* just to make sure */
+    s->s2->tmp.cavium_block_cipher = 0;
+    s->s2->tmp.cavium_pad = 0;
+#endif
+    return 1;
+  err:
+    return 0;
+
+}                                /* pkp_resume_handshake_20 */
+
+
+
+int
+pkp_handshake_client_auth_20 (SSL * s)
+{
+#ifdef CAVIUM_FIPS
+    goto err;
+#else
+    int ret = 0, finished_size, cert_req_size;
+    int pad1 = 0, pad2 = 0;
+    Uint8 *p;
+    Uint16 modlength = 0;
+    Uint16 master_secret_length = 0;
+
+    cav_fprintf (cav_nb_fp, "pkp_handshake_client_auth_20(): entry\n");
+
+    if (!s->hit)
+        modlength =
+            BN_num_bytes (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey->
+            pkey.rsa->n);
+
+
+    if ((s->session->cipher->id == SSL2_CK_RC4_128_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_RC4_128_EXPORT40_WITH_MD5)) {
+        Rc4Type rc4_type;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+        cert_req_size = 16 + 1 + 1 + 16;    /* mac, message type, auth_type, challenge size */
+
+        rc4_type = get_Rc4_type (s->session->cipher->id);
+        if (rc4_type == UNSUPPORTED_RC4)
+            goto err;
+
+        if (!s->hit) {
+            ret = Csp1RsaSsl20ServerClientAuthRc4 (s->cav_nb_mode, s->context_pointer, &s->key_handle, rc4_type, s->client_master_secret, s->s2->tmp.clear, s->s2->tmp.enc, modlength, s->s2->challenge, s->s2->challenge_length, s->s2->conn_id, s->session->session_id, s->client_finished, SSL2_AT_MD5_WITH_RSA_ENCRYPTION, s->s2->tmp.ccl,    /* cert challenge */
+                /* output */
+                s->server_cert_req,
+                s->server_verify,
+                s->session->master_key, &master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+            if (ret != 0)
+                return 0;
+
+            s->session->master_key_length = master_secret_length;
+        } else {
+            ret = Csp1Ssl20ResumeClientAuthRc4 (s->cav_nb_mode, s->context_pointer, &s->key_handle, rc4_type, s->session->master_key, s->session->master_key_length, s->s2->challenge, s->s2->challenge_length, s->s2->conn_id, s->session->session_id, s->client_finished, SSL2_AT_MD5_WITH_RSA_ENCRYPTION, s->s2->tmp.ccl,    /* cert challenge */
+                /* output */
+                s->server_cert_req, s->server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+            if (ret != 0)
+                return 0;
+        }
+
+        /* just to make sure */
+        s->s2->tmp.cavium_block_cipher = 0;
+    }
+
+    else if ((s->session->cipher->id == SSL2_CK_DES_64_CBC_WITH_MD5) ||
+        (s->session->cipher->id == SSL2_CK_DES_192_EDE3_CBC_WITH_MD5)) {
+        DesType des_type;
+
+        finished_size = 16 + 1 + 16;    /* mac, mesage type, session_id/conn_id */
+        cert_req_size = 16 + 1 + 1 + 16;    /* mac, message type, auth_type, challenge size */
+
+        pad1 = 8 - (finished_size % 8);
+        finished_size += pad1;
+
+        pad2 = 8 - (cert_req_size % 8);
+        cert_req_size += pad2;
+
+        des_type = get_Des_type (s->session->cipher->id);
+        if (des_type == UNSUPPORTED_DES)
+            goto err;
+
+        if (!s->hit) {
+            ret = Csp1RsaSsl20ServerClientAuth3Des (s->cav_nb_mode, s->context_pointer, &s->key_handle, des_type, s->client_master_secret, s->s2->tmp.clear, s->s2->tmp.enc, modlength, s->s2->challenge, s->s2->challenge_length, s->s2->conn_id, s->session->session_id, s->session->key_arg, s->client_finished, SSL2_AT_MD5_WITH_RSA_ENCRYPTION, s->s2->tmp.ccl,    /* cert challenge */
+                /* output */
+                s->server_cert_req,
+                s->server_verify,
+                s->session->master_key, &master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+            if (ret != 0)
+                return 0;
+
+            s->session->master_key_length = master_secret_length;
+        } else {
+            ret = Csp1Ssl20ResumeClientAuth3Des (s->cav_nb_mode, s->context_pointer, &s->key_handle, des_type, s->session->master_key, s->session->master_key_length, s->s2->challenge, s->s2->challenge_length, s->s2->conn_id, s->session->session_id, s->session->key_arg, s->client_finished, SSL2_AT_MD5_WITH_RSA_ENCRYPTION, s->s2->tmp.ccl,    /* cert challenge */
+                /* output */
+                s->server_cert_req, s->server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+            if (ret != 0)
+                return 0;
+        }
+        s->s2->tmp.cavium_block_cipher = 1;
+    } else
+        goto err;
+
+    /* send server verify message */
+    s->s2->tmp.cavium_pad = pad1;
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_verify, finished_size);
+
+    s->init_num = finished_size;
+    s->init_off = 0;
+    ssl2_do_write (s);
+
+    /* send server cert request message */
+    s->s2->tmp.cavium_pad = pad2;
+    p = (unsigned char *) s->init_buf->data;
+    memcpy (p, s->server_cert_req, cert_req_size);
+    s->init_num = cert_req_size;
+    s->init_off = 0;
+
+    ssl2_do_write (s);
+
+    /* activate encryption */
+    s->s2->clear_text = 0;
+
+    /* reset some values */
+    s->s2->ract_data_length = 0;
+    s->rstate = SSL_ST_READ_HEADER;
+
+    /* just to make sure */
+    s->s2->tmp.cavium_block_cipher = 0;
+    s->s2->tmp.cavium_pad = 0;
+#endif
+    return 1;
+  err:
+    return 0;
+
+}                                /*int pkp_handshake_client_auth_20(SSL *s) */
+
+
+
+int
+pkp_encrypt_record_20 (SSL * s)
+{
+#ifdef CAVIUM_FIPS
+    int ret = -1;
+    goto err;
+#else
+    int ret, mac_size;
+    Uint16 record_size;
+    DesType des_type;
+    unsigned long digest_type, cipher_type;
+
+
+    digest_type = EVP_MD_type (s->write_hash);
+    cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    if (digest_type == NID_md5)
+        mac_size = 16;
+    else {
+        ret = -1;
+        goto err;
+    }
+
+
+
+    switch (cipher_type) {
+    case NID_rc4:
+    case NID_rc4_40:
+
+        ret = Csp1Ssl20EncryptRecordRc4 (CAVIUM_NON_BLOCKING,
+            //s->cav_nb_mode,
+            s->context_pointer,
+            s->s2->wact_data_length, s->s2->wact_data, s->s2->mac_data,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (ret) {
+            ret = -1;
+            goto err;
+        }
+
+
+        s->s2->wlength = s->s2->wact_data_length + mac_size;
+        ret = 1;
+        break;
+
+    case NID_des_ede3_cbc:
+    case NID_des_cbc:
+
+        record_size = 0;
+        des_type = get_Des_type (s->session->cipher->id);
+        if (des_type == UNSUPPORTED_DES) {
+            ret = -1;
+            goto err;
+        }
+
+        ret = Csp1Ssl20EncryptRecord3Des (CAVIUM_NON_BLOCKING,
+            //s->cav_nb_mode,
+            s->context_pointer,
+            des_type,
+            s->s2->wact_data_length,
+            s->s2->wact_data, &record_size, s->s2->mac_data,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (ret) {
+            ret = -1;
+            goto err;
+        }
+
+
+        s->s2->wlength = record_size;
+        ret = 1;
+        break;
+
+    default:
+        ret = -1;
+        goto err;
+
+    }                            /* switch cipher type */
+#endif
+  err:
+
+    return ret;
+}
+
+
+int
+pkp_decrypt_record_20 (SSL * s)
+{
+#ifdef CAVIUM_FIPS
+    int ret = -1;
+    goto err;
+#else
+    int ret, mac_size;
+    unsigned long digest_type, cipher_type;
+    DesType des_type;
+
+
+    digest_type = EVP_MD_type (s->read_hash);
+    cipher_type = EVP_CIPHER_CTX_nid (s->enc_read_ctx);
+
+    if (digest_type == NID_md5)
+        mac_size = 16;
+    else {
+        ret = -1;
+        goto err;
+    }
+
+    switch (cipher_type) {
+    case NID_rc4:
+    case NID_rc4_40:
+
+        ret = Csp1Ssl20DecryptRecordRc4 (CAVIUM_NON_BLOCKING,
+            //s->cav_nb_mode,
+            s->context_pointer,
+            s->s2->rlength, s->s2->mac_data, s->s2->mac_data,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (ret) {
+            ret = -1;
+            goto err;
+        }
+
+        s->s2->ract_data_length = s->s2->rlength - mac_size;
+        ret = 1;
+        break;
+
+    case NID_des_ede3_cbc:
+    case NID_des_cbc:
+        des_type = get_Des_type (s->session->cipher->id);
+        if (des_type == UNSUPPORTED_DES) {
+            ret = -1;
+            goto err;
+        }
+
+        ret = Csp1Ssl20DecryptRecord3Des (CAVIUM_NON_BLOCKING,
+            //s->cav_nb_mode,
+            s->context_pointer,
+            des_type, s->s2->rlength, s->s2->mac_data, s->s2->mac_data,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (ret) {
+            ret = -1;
+            goto err;
+        }
+
+        s->s2->ract_data_length =
+            s->s2->rlength - mac_size - s->s2->padding;
+
+        ret = 1;
+        break;
+
+    default:
+        ret = -1;
+        goto err;
+    }
+#endif
+
+  err:
+    return ret;
+}                                /* pkp_decrypt record 20 */
+
+
+
+
+
+/************************************************************
+ * Client side handshake functions
+ ************************************************************/
+
+/*generate master secret, key blob and two finished messages.
+   s->server_finished, s->client_finished.
+   Only write_cipher is activated.
+   Read cipher is activated after receiving server finished message. */
+int
+pkp_client_handshake (SSL * s)
+{
+    int i, ret = 0, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, len, finish_size;
+    int pre_master_len = 0;
+    unsigned char *p;
+    unsigned char client_finished[80], server_finished[80];
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+    MasterSecretReturn master_secret_return;
+
+    if (s->cav_renego > 0 && s->reneg_flag == 0) {
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_CW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        if (i <= 0) {
+            s->reneg_flag = 1;
+            s->state = SSL3_ST_CW_FINISHED_A;
+            ret = 0;
+            goto err;
+        }
+        s->session->cipher = s->s3->tmp.new_cipher;
+        if (s->s3->tmp.new_compression == NULL)
+            s->session->compress_meth = 0;
+        else
+            s->session->compress_meth = s->s3->tmp.new_compression->id;
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_handshake(): sent NEW change cipher spec msg\n");
+        s->write_cipher_active = 0;
+    }
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+#ifndef NO_SESSION_CACHE
+
+    if (SSL_CTX_get_session_cache_mode (s->ctx) == SSL_SESS_CACHE_OFF)
+        master_secret_return = NOT_RETURNED;
+    else
+        master_secret_return = RETURN_ENCRYPTED;
+
+
+#else
+    master_secret_return = NOT_RETURNED;
+#endif
+
+    pre_master_len = SSL_MAX_MASTER_KEY_LENGTH;
+    handshake_len = s->hs_msgs_len;
+
+    if (s->state == CAV_ST_IN_HANDSHAKE) {
+
+        rc = check_handshake_completion (s,
+            &i,
+            &len,
+            &md_size,
+            &finish_size,
+            &is_block, (char *) client_finished, (char *) server_finished);
+        if (rc == 1) {
+            memcpy (s->server_finished, server_finished, 80);
+            memcpy (s->client_finished, client_finished, 80);
+            goto handshake;
+        } else
+            return 0;
+
+    }
+
+    if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5))
+    {
+
+        Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+        len = finish_size + md_size;
+#ifdef CAVIUM_FIPS
+        i = Cfm1OtherFullRc4 (OP_BLOCKING,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            rc4_type,
+            master_secret_return,
+            (unsigned short) pre_master_len,
+            s->s3->client_random,
+            s->s3->server_random,
+            (unsigned short) handshake_len,
+            s->hs_msgs,
+            s->client_finished,
+            s->server_finished, s->session->master_key, &s->cav_req_id);
+#else
+
+        i = Csp1OtherFullRc4 (s->cav_nb_mode,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            rc4_type,
+            master_secret_return,
+            (unsigned short) pre_master_len,
+            s->s3->client_random,
+            s->s3->server_random,
+            (unsigned short) handshake_len,
+            s->hs_msgs,
+            s->client_finished, s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+#endif
+
+        if (i == 0) {
+            cav_fprintf (cav_nb_fp, "===>pkp_client_handshake(): %s\n",
+                "Csp1OtherFullRc4() done");
+
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_handshake(): %s\n",
+                "Csp1OtherFullRc4() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        //end ... else i == EAGAIN
+        else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_handshake(): ERROR return %d %s\n", i,
+                "from Csp1OtherFullRc4()");
+        }
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+
+
+
+    {
+        DesType des_type = get_Des_type (s->session->cipher->id);
+        is_block = 1;
+        len = ((finish_size + md_size + 7) / 8) * 8;
+
+        if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherFull3Des (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_ENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished,
+                s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherFull3Des (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_ENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherFull3Des (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_UNENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished,
+                s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherFull3Des (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_UNENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        }
+
+        if (i == 0) {
+            cav_fprintf (cav_nb_fp, "===>pkp_client_handshake(): %s\n",
+                "Csp1OtherFull3Des() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_handshake(): %s\n",
+                "Csp1OtherFull3Des() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        //end ... else i == EAGAIN
+        else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_handshake(): ERROR return %d %s\n", i,
+                "from Csp1OtherFull3Des()");
+        }
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    }                            // end else DES
+    else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+        || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+        ) {
+
+        AesType aes_type = get_Aes_type (s->session->cipher->id);
+        ServerFinishMessageOutput sfmo;
+
+        is_block = 1;
+
+        len = ((finish_size + md_size + 15) / 16) * 16;
+
+        if (ssl_version == VER_TLS) {
+            sfmo = RETURN_SFM_ENCRYPTED;
+        } else {
+            // ssl3
+            len = ((finish_size + md_size + 15) / 16) * 16;
+            sfmo = RETURN_SFM_UNENCRYPTED;
+        }
+
+
+        if (ssl_version == VER_TLS || ssl_version == VER3_0) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_handshake(): %s\n",
+                "before TLS Csp1RsaServerFullAes()");
+
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherFullAes (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, aes_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished,
+                s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherFullAes (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, aes_type,
+                master_secret_return,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->client_finished,
+                s->server_finished, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+            if (i == 0) {
+                cav_fprintf (cav_nb_fp, "===>pkp_client_handshake(): %s\n",
+                    "Csp1OtherFullAes() done");
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp, "pkp_client_handshake(): %s\n",
+                    "Csp1OtherFullAes() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    //end ... else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake(): ERROR return %d %s\n", i,
+                    "from Csp1OtherFullAes()");
+            }
+
+            if (i != 0) {
+                ret = 0;
+                goto err;
+            }
+
+        }                        // end if ssl3 or tls
+        else {
+            cav_fprintf (cav_nb_fp, "pkp_client_handshake(): %s\n",
+                "ERROR not tls1 or ssl3 and AES\n");
+            return (0);
+        }
+
+    }                            // end else AES
+    else {
+        ret = 0;
+        goto err;
+    }
+
+  handshake:
+    if (s->cav_renego == 0) {
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_CW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+        s->session->cipher = s->s3->tmp.new_cipher;
+        if (s->s3->tmp.new_compression == NULL)
+            s->session->compress_meth = 0;
+        else
+            s->session->compress_meth = s->s3->tmp.new_compression->id;
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_handshake(): sent NEW change cipher spec msg\n");
+    }
+
+    /* SEND SERVER FINISH */
+    memcpy ((unsigned char *) s->init_buf->data, s->client_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_CW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_CW_CHANGE_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+    s->reneg_flag = 0;
+  err:
+    if (s->reneg_flag)
+        return ret;
+
+    if (s->cav_renego > 0)
+        s->cav_renego = 0;
+
+    return ret;
+
+}                                /*pkp_client_handshake */
+
+
+int
+pkp_client_resume_handshake (SSL * s)
+{
+
+    int i, ret, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, len, finish_size;
+    unsigned short peer_len;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char dec_peer_client_finished[80];
+    unsigned char *p;
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+    /* make p point to handshake msgs */
+    p = s->hs_msgs;
+
+    handshake_len = s->server_finish_msg_offset;
+
+
+    if (s->state == CAV_ST_IN_RESUME_HANDSHAKE) {
+
+        if (s->cav_crypto_state == CAV_ST_IN_RESUME_HANDSHAKE) {
+
+            rc = check_handshake_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block,
+                (char *) client_finished, (char *) server_finished);
+            if (rc == 1) {
+                memcpy (s->server_finished, server_finished, 80);
+                memcpy (s->client_finished, client_finished, 80);
+                goto again;
+            }
+
+        }                        // end if .. CAV_ST_IN_HANDSHAKE
+        else if (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER) {
+
+            rc = check_dec_peer_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block, &peer_len, (char *) dec_peer_client_finished);
+            if (rc == 1) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_resume_handshake(): %s %d\n",
+                    "check_dec_peer_completion() completed, rc = ", rc);
+                goto dec_peer_res;
+            }
+        }
+
+        if (rc == 0) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "check_dec_peer_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "ERROR check_dec_peer_completion() failed");
+            return (-1);
+        }
+    }
+    if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+
+        Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+        len = finish_size + md_size;
+#ifdef CAVIUM_FIPS
+        i = Cfm1ResumeRc4 (OP_BLOCKING,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            rc4_type,
+            INPUT_ENCRYPTED,
+            s->s3->client_random,
+            s->s3->server_random,
+            s->session->master_key,
+            (unsigned short) handshake_len,
+            p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+        i = Csp1ResumeRc4 (s->cav_nb_mode,
+            s->context_pointer,
+            hash_type,
+            ssl_version,
+            rc4_type,
+            INPUT_ENCRYPTED,
+            s->s3->client_random,
+            s->s3->server_random,
+            s->session->master_key,
+            (unsigned short) handshake_len,
+            p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+#endif
+        if (i == 0) {
+            // completed
+            cav_fprintf (cav_nb_fp,
+                "===>pkp_client_resume_handshake(): %s\n",
+                "Csp1ResumeRc4() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "Csp1ResumeRc4() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+            s->flag = 1;
+
+        }                        // end .. else i == EAGAIN
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+    {
+
+        DesType des_type = get_Des_type (s->session->cipher->id);
+
+        len = ((finish_size + md_size + 7) / 8) * 8;
+        is_block = 1;
+
+        if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1Resume3Des (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_ENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+            i = Csp1Resume3Des (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_ENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+#ifdef CAVIUM_FIPS
+            i = Cfm1Resume3Des (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_UNENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+            i = Csp1Resume3Des (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, des_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                RETURN_SFM_UNENCRYPTED,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        }
+
+        if (i == 0) {
+            // completed
+            cav_fprintf (cav_nb_fp,
+                "===>pkp_client_resume_handshake(): %s\n",
+                "Csp1Resume3Des() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "Csp1Resume3Des() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+            s->flag = 1;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    }                            // end else ... DES
+    else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+        || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+        ) {
+
+        AesType aes_type = get_Aes_type (s->session->cipher->id);
+        ServerFinishMessageOutput sfmo;
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_resume_handshake(): AES case\n");
+
+        is_block = 1;
+
+        len = ((finish_size + md_size + 15) / 16) * 16;
+
+        if (ssl_version == VER_TLS) {
+            sfmo = RETURN_CFM_ENCRYPTED;
+        } else {
+            // ssl3
+            sfmo = RETURN_CFM_UNENCRYPTED;
+        }
+
+        if (ssl_version == VER_TLS || ssl_version == VER3_0) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1ResumeAes (OP_BLOCKING, s->context_pointer,
+                hash_type, ssl_version, aes_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+            i = Csp1ResumeAes (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, aes_type,
+                INPUT_ENCRYPTED,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                s->s3->client_random,
+                s->s3->server_random,
+                s->session->master_key,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "ERROR not tls1 or ssl3 and AES\n");
+            return (0);
+        }
+
+        if (i == 0) {
+            // completed
+            cav_fprintf (cav_nb_fp,
+                "===>pkp_client_resume_handshake(): %s\n",
+                "Csp1ResumeAes() done");
+        }
+
+        else if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_resume_handshake(): %s\n",
+                "Csp1ResumeAes() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+            s->flag = 1;
+
+        }                        // end .. else i == EAGAIN
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    }                            // end else ... AES
+    else {
+        ret = 0;
+        goto err;
+    }
+
+
+
+    /* compare the finished message which is received from server */
+    /* now replace first four bytes of client finish message. */
+  again:memcpy (&(s->hs_msgs[s->server_finish_msg_offset]),
+        s->peer_finish_first_four, 4);
+
+    /* compare with what we got from CSP */
+    if (!is_block || ssl_version == VER_TLS) {
+        if (memcmp (&s->hs_msgs[s->server_finish_msg_offset],
+                s->server_finished, len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_resume_handshake(): memcmp failed for rc4 \n");
+            ret = 0;
+            goto err;
+        }
+    } else {
+
+        /* decrypt the received client finished */
+        if (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA
+            || s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA) {
+            // AES
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+#if defined  (CAVIUM_FIPS) && !defined (MC2)
+            i = Cfm1DecryptRecordAesRecover (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_CLIENT,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->server_finish_msg_offset),
+                &s->hs_msgs[s->server_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+#ifndef MC2
+
+            i = Csp1DecryptRecordAesRecover
+#else
+            i = Csp1DecryptRecordAes
+#endif
+                (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_CLIENT,
+                aes_type,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->server_finish_msg_offset),
+                &s->hs_msgs[s->server_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+#endif
+        } else {
+            // DES
+#if defined  (CAVIUM_FIPS) && !defined (MC2)
+            i = Cfm1DecryptRecord3DesRecover (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_CLIENT,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->server_finish_msg_offset),
+                &s->hs_msgs[s->server_finish_msg_offset], &peer_len,
+                s->dec_peer_client_finished, &s->cav_req_id);
+#else
+#ifndef MC2
+            i = Csp1DecryptRecord3DesRecover
+#else
+            i = Csp1DecryptRecord3Des
+#endif
+                (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                SSL_CLIENT,
+                HANDSHAKE,
+                (unsigned short) (s->hs_msgs_len -
+                    s->server_finish_msg_offset),
+                &s->hs_msgs[s->server_finish_msg_offset], &s->peer_len,
+                s->dec_peer_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+        }
+
+        if (i == 0) {
+            memcpy (dec_peer_client_finished, s->dec_peer_client_finished,
+                s->peer_len);
+            peer_len = s->peer_len;
+
+        }
+        if (i == EAGAIN) {
+            cav_fprintf (cav_nb_fp, "pkp_resume_handshake(): %s\n",
+                "ssl3_get_finished() EAGAIN");
+            s->cav_crypto_state = CAV_ST_IN_CHK_DEC_PEER;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+            s->flag = 1;
+        }
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+      dec_peer_res:if (memcmp (dec_peer_client_finished, s->server_finished,
+                peer_len) != 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_resume_handshake ... memcmp failed \n");
+            ret = 0;
+            goto err;
+        }
+
+    }                            /*isblock */
+
+    s->s3->tmp.peer_finish_md_len = finish_size;
+
+    /* Send CCP msg */
+    s->s3->rrec.off = 0;
+    s->packet_length = 0;
+    p = (unsigned char *) s->init_buf->data;
+    *p = SSL3_MT_CCS;
+    s->init_num = 1;
+    s->init_off = 0;
+    s->state = SSL3_ST_CW_CHANGE_B;
+
+    /* SSL3_ST_CW_CHANGE_B */
+    i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+    s->init_num = 0;
+
+    /* SEND CLIENT FINISH */
+    memcpy ((unsigned char *) s->init_buf->data, s->client_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_CW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->init_num = 0;
+
+    s->state = SSL3_ST_CW_FINISHED_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        goto err;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+
+  err:
+    return ret;
+
+}                                /* pkp_client_resume_handshake */
+
+
+
+//int pkp_client_cert_verify_mac(unsigned char *mac, SSL *s)
+int
+pkp_client_cert_verify_mac (SSL * s)
+{
+    int i, ret = 0, rc =0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, pre_master_len;
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+    MasterSecretReturn master_secret_return;
+
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        return (0);
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION)
+        ssl_version = VER_TLS;
+    else
+        ssl_version = VER3_0;
+
+
+
+#ifndef NO_SESSION_CACHE
+
+    if (SSL_CTX_get_session_cache_mode (s->ctx) == SSL_SESS_CACHE_OFF)
+        master_secret_return = NOT_RETURNED;
+    else
+        master_secret_return = RETURN_ENCRYPTED;
+
+#else
+    master_secret_return = NOT_RETURNED;
+#endif
+
+    handshake_len = s->hs_msgs_len;
+    pre_master_len = SSL_MAX_MASTER_KEY_LENGTH;
+
+    if (s->cav_crypto_state == CAV_ST_IN_VRFY_CERT) {
+
+        rc = check_vryf_mac_completion (s);
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp, "pkp_client_cert_verify_mac(): %s\n",
+                "check_vrfy_mac_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp, "pkp_client_cert_verify_mac(): %s\n",
+                "ERROR check_vrfy_mac_completion() failed");
+            return (-1);
+        } else {
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_cert_verify_mac(): %s %d\n",
+                "check_vrfy_mac_completion() completed, rc = ", rc);
+            return rc;
+        }
+    }                            // end if .. CAV_ST_IN_HANDSHAKE
+
+    if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+        || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+
+        Rc4Type rc4_type = get_Rc4_type (s->session->cipher->id);
+
+        if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerifyRc4 (OP_BLOCKING,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+
+            i = Csp1OtherVerifyRc4 (s->cav_nb_mode,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_cert_verify_mac(): returned from csp1otherverifyrc4 : %d \n",
+                i);
+        }
+
+        else {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerifyRc4 (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherVerifyRc4 (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                rc4_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_cert_verify_mac(): returned from csp1otherverifyrc4 : %d \n",
+                i);
+        }
+
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_cert_verify_mac(): %s\n",
+                "Csp1OtherVerifyRc4() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+    } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+        ||
+        (s->session->cipher->id == TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+        || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+    {
+
+        DesType des_type = get_Des_type (s->session->cipher->id);
+
+        if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerify3Des (OP_BLOCKING,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                des_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+
+            i = Csp1OtherVerify3Des (s->cav_nb_mode,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                des_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerify3Des (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                des_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+
+            i = Csp1OtherVerify3Des (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                des_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+#endif
+        }
+
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_cert_verify_mac(): %s\n",
+                "Csp1OtherVerify3Des() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    }
+
+    else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+        || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+        ) {
+
+        AesType aes_type = get_Aes_type (s->session->cipher->id);
+
+        if (s->cav_renego > 0) {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerifyAes (OP_BLOCKING,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherVerifyAes (s->cav_nb_mode,
+                s->s3->tmp.ctx_ptr,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        } else {
+#ifdef CAVIUM_FIPS
+            i = Cfm1OtherVerifyAes (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs,
+                s->data_sign, s->session->master_key, &s->cav_req_id);
+#else
+            i = Csp1OtherVerifyAes (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                aes_type,
+                master_secret_return,
+                (unsigned short) pre_master_len,
+                s->s3->client_random,
+                s->s3->server_random,
+                (unsigned short) handshake_len,
+                s->hs_msgs, s->data_sign, s->session->master_key,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+#endif
+        }
+
+        if (i == EAGAIN) {
+
+            cav_fprintf (cav_nb_fp, "pkp_client_cert_verify_mac(): %s\n",
+                "Csp1OtherVerifyAes() EAGAIN");
+
+            s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+            s->cav_saved_state = s->state;
+            s->state = CAV_ST_IN_VRFY_CERT;
+            s->cav_req_id_check_done = 0;
+            s->rwstate = SSL_NITROX_BUSY;
+
+        }                        // end .. else i == EAGAIN
+
+        if (i != 0) {
+            ret = 0;
+            goto err;
+        }
+
+    }
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    ret = 1;
+  err:
+    return ret;
+}                                /*pkp_client_cert_verify_mac */
+
+int
+pkp_client_handshake_client_auth (SSL * s)
+{
+    int i, ret, rc = 0;
+    int is_block = 0;
+    int cipher_type, digest_type;
+    int handshake_len, md_size, len, finish_size;
+    unsigned char server_finished[80], client_finished[80];
+    unsigned char *p;
+    const EVP_MD *hash;
+    const EVP_CIPHER *c;
+    SSL_COMP *comp;
+    HashType hash_type;
+    SslVersion ssl_version;
+
+    if (s->cav_renego > 0 && s->reneg_flag == 0) {
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_CW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+
+        if (i <= 0) {
+            s->reneg_flag = 1;
+            s->state = SSL3_ST_CW_FINISHED_A;
+            ret = 0;
+            goto err;
+        }
+
+        s->session->cipher = s->s3->tmp.new_cipher;
+        if (s->s3->tmp.new_compression == NULL)
+            s->session->compress_meth = 0;
+        else
+            s->session->compress_meth = s->s3->tmp.new_compression->id;
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_handshake(): sent NEW change cipher spec msg\n");
+
+        s->write_cipher_active = 0;
+    }
+    s->session->cipher = s->s3->tmp.new_cipher;
+
+    if (!ssl_cipher_get_evp (s->session, &c, &hash, &comp)) {
+        SSLerr (SSL_F_SSL3_SETUP_KEY_BLOCK,
+            SSL_R_CIPHER_OR_HASH_UNAVAILABLE);
+        ret = 0;
+        goto err;
+    }
+
+    digest_type = EVP_MD_type (hash);
+    cipher_type = EVP_CIPHER_nid (c);
+    md_size = EVP_MD_size (hash);
+
+    if (digest_type == NID_md5)
+        hash_type = MD5_TYPE;
+
+    else if (digest_type == NID_sha1)
+        hash_type = SHA1_TYPE;
+
+    else {
+        ret = 0;
+        goto err;
+    }
+
+    if (s->version > SSL3_VERSION) {
+        finish_size = 16;
+        ssl_version = VER_TLS;
+    } else {
+        finish_size = 40;
+        ssl_version = VER3_0;
+    }
+
+
+    /* make p point to the CertVerify msg */
+    p = (unsigned char *) &(s->hs_msgs[s->client_cert_verify_msg_offset]);
+
+    handshake_len = s->hs_msgs_len - s->client_cert_verify_msg_offset;
+
+    if (s->cav_renego > 0 && s->alloc_flag == 0) {
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_handshake_client_auth():freeing context \n");
+        if (s->context_pointer) {
+#ifdef CAVIUM_FIPS
+            Cfm1FreeContext (OP_BLOCKING, s->context_pointer,
+                &s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer, s->dev_id);
+#else
+            Csp1FreeContext (CONTEXT_SSL, s->context_pointer);
+#endif
+#endif
+        }
+
+        s->context_pointer = s->s3->tmp.ctx_ptr;
+        s->alloc_flag = 1;
+    }
+
+    if (s->state == CAV_ST_IN_HANDSHAKE) {
+
+        if (s->cav_crypto_state == CAV_ST_IN_HANDSHAKE) {
+
+            rc = check_handshake_completion (s,
+                &i,
+                &len,
+                &md_size,
+                &finish_size,
+                &is_block,
+                (char *) client_finished, (char *) server_finished);
+            if (rc == 1) {
+                memcpy (s->server_finished, server_finished, 80);
+                memcpy (s->client_finished, client_finished, 80);
+            }
+        }
+
+        if (rc == 0) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_handshake_client_auth(): %s\n",
+                "check_handshake_completion() not completed");
+            return (0);
+        } else if (rc == -1) {
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_handshake_client_auth(): %s\n",
+                "ERROR check_handshake_completion() failed");
+            return (-1);
+        }
+
+    }                            // end if .. CAV_ST_IN_HANDSHAKE
+    else {
+        if ((s->session->cipher->id == SSL3_CK_RSA_RC4_128_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_128_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA)
+            || (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5)
+            || (s->session->cipher->id == SSL3_CK_RSA_RC4_40_MD5)) {
+            len = finish_size + md_size;
+#ifdef CAVIUM_FIPS
+            i = Cfm1FinishedRc4Finish (OP_BLOCKING,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+
+            i = Csp1FinishedRc4Finish (s->cav_nb_mode,
+                s->context_pointer,
+                hash_type,
+                ssl_version,
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+#endif
+            if (i == 0) {
+
+                cav_fprintf (cav_nb_fp,
+                    "===>pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1FinishedRc4Finish() done");
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1FinishedRc4Finish() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): ERROR return %d %s\n",
+                    i, "from Csp1FinishedRc4Finish()");
+            }
+
+            if (i != 0) {
+                ret = 0;
+                return ret;
+            }
+        } else if ((s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+            ||
+            (s->session->cipher->id ==
+                TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_40_CBC_SHA)
+            || (s->session->cipher->id == SSL3_CK_RSA_DES_64_CBC_SHA))
+        {
+            is_block = 1;
+            len = ((finish_size + md_size + 7) / 8) * 8;
+
+            if (ssl_version == VER_TLS) {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Finished3DesFinish (OP_BLOCKING, s->context_pointer,
+                    hash_type,
+                    ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished, &s->cav_req_id);
+#else
+                i = Csp1Finished3DesFinish (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_ENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            } else {
+#ifdef CAVIUM_FIPS
+                i = Cfm1Finished3DesFinish (OP_BLOCKING, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_UNENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p,
+                    s->client_finished,
+                    s->server_finished, &s->cav_req_id);
+#else
+                i = Csp1Finished3DesFinish (s->cav_nb_mode, s->context_pointer,
+                    hash_type, ssl_version,
+                    RETURN_CFM_ENCRYPTED,
+                    RETURN_SFM_UNENCRYPTED,
+                    0,    /*client_pad_length, */
+                    0,            /*server_pad_length, */
+                    (unsigned short) handshake_len,
+                    p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                    &s->cav_req_id, s->dev_id
+#else
+                    &s->cav_req_id
+#endif
+                    );
+#endif
+            }
+
+            if (i == 0) {
+                cav_fprintf (cav_nb_fp,
+                    "===>pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1Finished3DesFinish() done");
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1Finished3DesFinish() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): ERROR return %d %s\n",
+                    i, "from Csp1Finished3DesFinish()");
+            }
+            if (i != 0) {
+                ret = 0;
+                return ret;
+            }
+        }
+
+        else if ((s->session->cipher->id == TLS1_CK_RSA_WITH_AES_128_SHA)
+            || (s->session->cipher->id == TLS1_CK_RSA_WITH_AES_256_SHA)
+            ) {
+
+            AesType aes_type = get_Aes_type (s->session->cipher->id);
+            ServerFinishMessageOutput sfmo;
+
+            cav_fprintf (cav_nb_fp,
+                "pkp_client_handshake_client_auth(): AES case\n");
+
+            is_block = 1;
+
+            len = ((finish_size + md_size + 15) / 16) * 16;
+
+            if (ssl_version == VER_TLS) {
+                sfmo = RETURN_SFM_ENCRYPTED;
+            } else {
+                // ssl3
+                sfmo = RETURN_SFM_UNENCRYPTED;
+            }
+#ifdef CAVIUM_FIPS
+            i = Cfm1FinishedAesFinish (OP_BLOCKING, s->context_pointer,
+                hash_type,
+                ssl_version, aes_type,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished, &s->cav_req_id);
+#else
+
+            i = Csp1FinishedAesFinish (s->cav_nb_mode, s->context_pointer,
+                hash_type, ssl_version, aes_type,
+                RETURN_CFM_ENCRYPTED,
+                sfmo,
+                0,    /*client_pad_length, */
+                0,                /*server_pad_length, */
+                (unsigned short) handshake_len,
+                p, s->client_finished, s->server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                &s->cav_req_id, s->dev_id
+#else
+                &s->cav_req_id
+#endif
+                );
+
+#endif
+            if (i == 0) {
+                cav_fprintf (cav_nb_fp,
+                    "===>pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1FinishedAesFinish() done");
+            }
+
+            else if (i == EAGAIN) {
+
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): %s\n",
+                    "Csp1FinishedAesFinish() EAGAIN");
+
+                s->cav_crypto_state = CAV_ST_IN_HANDSHAKE;
+                s->cav_saved_state = s->state;
+                s->state = CAV_ST_IN_HANDSHAKE;
+                s->cav_req_id_check_done = 0;
+                s->rwstate = SSL_NITROX_BUSY;
+
+            }                    // end .. else i == EAGAIN
+            else {
+                cav_fprintf (cav_nb_fp,
+                    "pkp_client_handshake_client_auth(): ERROR return %d %s\n",
+                    i, "from Csp1FinishedAesFinish()");
+            }
+            if (i != 0) {
+                ret = 0;
+                return ret;
+            }
+        }
+
+        else {
+            ret = 0;
+            goto err;
+        }
+
+    }
+
+    if (s->cav_renego == 0) {
+        s->s3->rrec.off = 0;
+        s->packet_length = 0;
+        p = (unsigned char *) s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+        s->state = SSL3_ST_CW_CHANGE_B;
+
+        /* SSL3_ST_CW_CHANGE_B */
+        i = ssl3_do_write (s, SSL3_RT_CHANGE_CIPHER_SPEC);
+        s->session->cipher = s->s3->tmp.new_cipher;
+        if (s->s3->tmp.new_compression == NULL)
+            s->session->compress_meth = 0;
+        else
+            s->session->compress_meth = s->s3->tmp.new_compression->id;
+
+        //BIO_flush(s->wbio);
+
+        cav_fprintf (cav_nb_fp,
+            "pkp_client_handshake(): sent NEW change cipher spec msg\n");
+    }
+    /* SEND CLIENT FINISH */
+    s->s3->tmp.peer_finish_md_len = len;
+    memcpy ((unsigned char *) s->init_buf->data, s->client_finished, len);
+    s->init_num = len;
+    s->init_off = 0;
+    s->state = SSL3_ST_CW_FINISHED_B;
+    i = ssl3_do_write (s, SSL3_RT_HANDSHAKE);
+
+    /* activate cipher on the output (writing)  side */
+    s->write_cipher_active = 1;
+
+    s->state = SSL3_ST_CW_CHANGE_A;
+
+    if ((s->enc_read_ctx == NULL) &&
+        ((s->enc_read_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        return ret;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_read_ctx);
+    s->enc_read_ctx->cipher = c;
+    s->read_hash = hash;
+
+    if ((s->enc_write_ctx == NULL) &&
+        ((s->enc_write_ctx =
+                (EVP_CIPHER_CTX *)
+                OPENSSL_malloc (sizeof (EVP_CIPHER_CTX))) == NULL)) {
+        ret = 0;
+        return ret;
+    }
+
+    EVP_CIPHER_CTX_init (s->enc_write_ctx);
+    s->enc_write_ctx->cipher = c;
+    s->write_hash = hash;
+
+    /* Here update some variables for record processing */
+    s->ssl_version = ssl_version;
+
+    /* I hope that client and the server are using the same cipher :-)  */
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+
+    /* abd again the same hash */
+    s->digest_type = EVP_MD_type (hash);
+
+    s->md_size = md_size;
+
+    ret = 1;
+    s->reneg_flag = 0;
+
+  err:
+    if (s->reneg_flag) {
+        return ret;
+    }
+
+    if (s->cav_renego > 0) {
+        s->cav_renego = 0;
+        s->alloc_flag = 0;
+    }
+
+    return ret;
+
+}                                /*int pkp_client_handshake_client_auth(SSL *s) */
+
+
+/*
+ * Checks if a prior request has completed.
+ * Returns 0 if the request has not completed.
+ * Returns >0 if the request has completed.
+ * Returns -1 on error
+ */
+int
+check_decrypt_completion (SSL * s)
+{
+
+    int rc;
+
+    cav_fprintf (cav_nb_fp, "check_decrypt_completion(): entry\n");
+
+    /*
+     * Check whether the application has already checked
+     * for comletion, by directly calling Csp1CheckForCompletion.
+     */
+    if (s->cav_req_id_check_done) {
+
+        /*
+         * already checked, probably directly by app
+         */
+        cav_fprintf (cav_nb_fp, "check_decrypt_completion(): %s\n",
+            "already checked, probably directly by app\n");
+
+    } else {
+
+        /* completion check has not been done yet */
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+        if (rc == EAGAIN) {
+            cav_fprintf (cav_nb_fp, "check_decrypt_completion(): %s\n",
+                "Csp1CheckForCompletion() EAGAIN");
+            return (0);
+        } else if (rc != 0) {
+            cav_fprintf (cav_nb_fp,
+                "check_decrypt_completion(): %s %d, 0x%0x\n",
+                "Csp1CheckForCompletion() got ERROR, rc = ", rc, rc);
+            // -----
+            s->cav_crypto_state = 0;
+            s->cav_req_id_check_done = 1;
+            s->rwstate = SSL_NOTHING;
+            return (-1);
+        }
+
+        /* cmd completed */
+        s->cav_req_id_check_done = 1;
+
+    }
+
+    cav_fprintf (cav_nb_fp, "check_decrypt_completion(): %s\n",
+        "Csp1CheckForCompletion() done");
+
+    cav_fprintf (cav_nb_fp,
+        "check_decrypt_completion(): cav_process_flag = %d, md_size = %d, s->s3->rrec.length = %d, cav_msg_len = %d\n",
+        s->cav_process_flag, s->md_size, s->s3->rrec.length,
+        s->cav_msg_len);
+
+    cav_fprintf (cav_nb_fp,
+        "check_decrypt_completion(): *(Uint8 *)(s->s3->rrec.data + s->s3->rrec.length - 1) = %d\n",
+        *(Uint8 *) (s->s3->rrec.data + s->s3->rrec.length - 1));
+
+    if (s->cav_process_flag) {
+        s->cav_msg_len = s->s3->rrec.length - s->md_size;
+        s->cav_process_flag = 0;
+    } else {
+        /*
+         * 3Des --- we need some special processing
+         * to get record size.
+         */
+        s->cav_msg_len =
+            s->s3->rrec.length - s->md_size -
+            *(Uint8 *) (s->s3->rrec.data + s->s3->rrec.length - 1) - 1;
+    }
+
+    s->cav_crypto_state = 0;
+    s->cav_req_id = 0;
+    s->cav_req_id_check_done = 0;
+    s->rwstate = SSL_NOTHING;
+
+    if (s->cav_msg_len == 0) {
+        cav_fprintf (cav_nb_fp,
+            "check_decrypt_completion(): got 0 byte record\n");
+    }
+
+    return (int) s->cav_msg_len;
+
+}                                // end check_decrypt_completion()
+
+
+int
+check_encrypt_completion (SSL * s)
+{
+
+    int rc;
+
+    cav_fprintf (cav_nb_fp, "check_encrypt_completion(): entry\n");
+
+    /*
+     * Check whether the application has already checked
+     * for comletion, by directly calling Csp1CheckForCompletion.
+     */
+    if (s->cav_req_id_check_done) {
+        // already checked, probably directly by app
+        cav_fprintf (cav_nb_fp, "check_encrypt_completion(): %s\n",
+            "already checked, probably directly by app\n");
+    } else {
+
+        // should check for cmd completion here
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+        if (rc == EAGAIN) {
+            cav_fprintf (cav_nb_fp, "check_encrypt_completion(): %s\n",
+                "Csp1CheckForCompletion() EAGAIN");
+            return (0);
+        } else if (rc != 0) {
+            cav_fprintf (cav_nb_fp,
+                "check_encrypt_completion(): %s %d, 0x%0x\n",
+                "Csp1CheckForCompletion() got ERROR, rc = ", rc, rc);
+            // -----
+            s->cav_crypto_state = 0;
+            s->cav_req_id_check_done = 1;
+            s->rwstate = SSL_NOTHING;
+            return (-1);
+        }
+        // cmd completed
+        s->cav_req_id_check_done = 1;
+    }
+
+    cav_fprintf (cav_nb_fp, "check_encrypt_completion(): %s\n",
+        "Csp1CheckForCompletion() done");
+
+    if (s->cav_process_flag) {
+        s->cav_process_flag = 0;
+        s->cav_msg_len = s->s3->wrec.length + s->md_size;
+    }
+
+    s->cav_crypto_state = 0;
+    s->cav_req_id = 0;
+    s->cav_req_id_check_done = 0;
+    s->rwstate = SSL_NOTHING;
+
+    cav_fprintf (cav_nb_fp,
+        "check_encrypt_completion(): returning s->cav_msg_len = %d\n",
+        s->cav_msg_len);
+
+    return (int) s->cav_msg_len;
+
+}                                // end check_encrypt_completion()
+
+
+/*
+ * check_handshake_completion:
+ *
+ *  Returns:
+ *      0 if cmd has not completed
+ *      1 if cmd has completed
+ */
+int
+check_handshake_completion (SSL * s,
+    int *ip,
+    int *lenp,
+    int *md_sizep,
+    int *finish_sizep,
+    int *is_blockp, char *client_finishedp, char *server_finishedp)
+{
+    int rc;
+    Rc4Type rc4_type;
+    DesType des_type;
+
+    /*
+     * restore proper state that was saved in cav_saved_state,
+     * so we could navigate to this piece of code.
+     */
+    s->state = s->cav_saved_state;
+
+    if (s->cav_req_id_check_done) {
+        cav_fprintf (cav_nb_fp, "check_handshake_completion(): %s\n",
+            "already checked, probably directly by app\n");
+        rc = 0;
+    } else {
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+    }
+
+    cav_fprintf (cav_nb_fp,
+        "check_handshake_completion():Csp1CheckForCompletion() rc=%d\n",
+        rc);
+
+
+    switch (rc) {
+
+    case EAGAIN:
+        cav_fprintf (cav_nb_fp, "check_handshake_completion(): %s\n",
+            "Csp1CheckForCompletion() EAGAIN");
+        s->cav_saved_state = s->state;
+
+        if ((s->state == SSL3_ST_SR_CERT_VRFY_A)) {
+            s->state = CAV_ST_IN_VRFY_CERT;
+        } else if (((s->cav_renego == 0) &&
+                (s->state == SSL3_ST_SW_CHANGE_A)) || (s->flag == 1))
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+        else
+            s->state = CAV_ST_IN_HANDSHAKE;
+
+        return (0);
+
+    case 0:
+        // done:
+        cav_fprintf (cav_nb_fp, "===>check_handshake_completion(): %s\n",
+            "Csp1CheckForCompletion() completed");
+
+        s->flag = 0;
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        *ip = 0;
+        memcpy (client_finishedp, s->client_finished, 80);
+        memcpy (server_finishedp, s->server_finished, 80);
+
+
+        switch (s->session->cipher->id) {
+        case SSL3_CK_RSA_RC4_128_MD5:
+        case SSL3_CK_RSA_RC4_128_SHA:
+        case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA:
+        case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5:
+        case SSL3_CK_RSA_RC4_40_MD5:
+            rc4_type = get_Rc4_type (s->session->cipher->id);
+            *lenp = *finish_sizep + *md_sizep;
+            break;
+
+        case SSL3_CK_RSA_DES_192_CBC3_SHA:
+        case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+        case SSL3_CK_RSA_DES_40_CBC_SHA:
+        case SSL3_CK_RSA_DES_64_CBC_SHA:
+            des_type = get_Des_type (s->session->cipher->id);
+            cav_fprintf (cav_nb_fp,
+                "check_handshake_completion(): DES case\n");
+            *is_blockp = 1;
+            *lenp = ((*finish_sizep + *md_sizep + 7) / 8) * 8;
+            break;
+
+        case TLS1_CK_RSA_WITH_AES_128_SHA:
+        case TLS1_CK_RSA_WITH_AES_256_SHA:
+            cav_fprintf (cav_nb_fp,
+                "check_handshake_completion(): AES case\n");
+            *is_blockp = 1;
+            *lenp = ((*finish_sizep + *md_sizep + 15) / 16) * 16;
+            break;
+
+        default:
+            cav_fprintf (cav_nb_fp,
+                "check_handshake_completion(): ERROR: default case\n");
+            return (-1);
+
+        }                        // end switch
+
+        break;
+
+
+    default:
+        cav_fprintf (cav_nb_fp, "check_handshake_completion(): %s\n",
+            "Csp1CheckForCompletion() default case");
+        /*
+         * should we reset the cav_crypto_state to 0 here
+         * to prevent an infinite loop
+         */
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        return (-1);
+
+    }
+
+    return (1);
+
+
+}                                /* end check_handshake_completion() */
+
+int
+check_dec_peer_completion (SSL * s,
+    int *ip,
+    int *lenp,
+    int *md_sizep,
+    int *finish_sizep,
+    int *is_blockp,
+    unsigned short *peer_lenp, char *dec_peer_client_finishedp)
+{
+
+    int rc;
+    DesType des_type;
+
+    s->state = s->cav_saved_state;
+
+    if (s->cav_req_id_check_done) {
+        cav_fprintf (cav_nb_fp, "check_dec_peer_completion(): %s\n",
+            "already checked, probably directly by app\n");
+        rc = 0;
+    } else {
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+    }
+
+    cav_fprintf (cav_nb_fp,
+        "check_dec_peer_completion():Csp1CheckForCompletion() rc=%d\n",
+        rc);
+
+    switch (rc) {
+
+    case EAGAIN:
+        cav_fprintf (cav_nb_fp, "check_dec_peer_completion(): %s\n",
+            "Csp1CheckForCompletion() EAGAIN");
+        s->cav_saved_state = s->state;
+
+        if (((s->state == SSL3_ST_SR_FINISHED_B) ||
+                (s->state == SSL3_ST_CR_FINISHED_B))
+            && s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER_2) {
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+        } else if ((s->flag == 1) &&
+            (s->cav_crypto_state == CAV_ST_IN_CHK_DEC_PEER))
+            s->state = CAV_ST_IN_RESUME_HANDSHAKE;
+
+        else
+            s->state = CAV_ST_IN_HANDSHAKE;
+
+        return (0);
+
+    case 0:
+        cav_fprintf (cav_nb_fp, "===>check_dec_peer_completion(): %s\n",
+            "Csp1CheckForCompletion() completed");
+
+        s->flag = 0;            /* added due to reneg failing with reconnect for des and aes */
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        *ip = 0;
+        *peer_lenp = s->peer_len - 3;
+
+        memcpy (dec_peer_client_finishedp, s->dec_peer_client_finished,
+            80);
+        switch (s->session->cipher->id) {
+
+        case SSL3_CK_RSA_DES_192_CBC3_SHA:
+        case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+        case SSL3_CK_RSA_DES_40_CBC_SHA:
+        case SSL3_CK_RSA_DES_64_CBC_SHA:
+            des_type = get_Des_type (s->session->cipher->id);
+            cav_fprintf (cav_nb_fp,
+                "check_dec_peer_completion(): DES case\n");
+            *is_blockp = 1;
+            *lenp = ((*finish_sizep + *md_sizep + 7) / 8) * 8;
+            break;
+
+        case TLS1_CK_RSA_WITH_AES_128_SHA:
+        case TLS1_CK_RSA_WITH_AES_256_SHA:
+            cav_fprintf (cav_nb_fp,
+                "check_dec_peer_completion(): AES case\n");
+            *is_blockp = 1;
+            *lenp = ((*finish_sizep + *md_sizep + 15) / 16) * 16;
+            break;
+
+        default:
+            cav_fprintf (cav_nb_fp,
+                "check_dec_peer_completion(): ERROR: default case\n");
+            return (-1);
+        }
+        break;
+
+    default:
+        cav_fprintf (cav_nb_fp, "check_dec_peer_completion(): %s\n",
+            "Csp1CheckForCompletion() default case");
+        /*
+         * should we reset the cav_crypto_state to 0 here
+         * to prevent an infinite loop
+         */
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        return (-1);
+
+    }                            // end switch
+
+    return (1);
+}
+
+int
+check_pre_master_completion (SSL * s,
+#ifdef MC2
+    Uint16 * out_len,
+#else
+    Uint64 * out_len,
+#endif
+    char *result)
+{
+    int rc;
+
+    s->state = s->cav_saved_state;
+    if (s->cav_req_id_check_done) {
+        cav_fprintf (cav_nb_fp, "check_pre_master_completion(): %s\n",
+            "already checked, probably directly by app\n");
+        rc = 0;
+    } else {
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+    }
+    cav_fprintf (cav_nb_fp,
+        "check_pre_master_completion():Csp1CheckForCompletion() rc=%d\n",
+        rc);
+
+    switch (rc) {
+
+    case EAGAIN:
+        cav_fprintf (cav_nb_fp, "check_pre_master_completion(): %s\n",
+            "Csp1CheckForCompletion() EAGAIN");
+        s->cav_saved_state = s->state;
+        if (s->state == SSL3_ST_SR_CERT_VRFY_A)
+            s->state = CAV_ST_IN_VRFY_CERT;
+        else
+            s->state = CAV_ST_IN_HANDSHAKE;
+        return (0);
+    case 0:
+        cav_fprintf (cav_nb_fp, "===>check_pre_master_completion(): %s\n",
+            "Csp1CheckForCompletion() completed");
+
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+#ifdef MC2
+        *out_len = (Uint32) ntohs (s->pre_master_len);
+        memcpy (result, s->pre_master_result, s->cryp_flen);
+#else
+        *out_len = (Uint32) s->pre_master_len;
+#endif
+
+        break;
+    default:
+        cav_fprintf (cav_nb_fp, "check_pre_master_completion(): %s\n",
+            "Csp1CheckForCompletion() default case");
+        /*
+         * should we reset the cav_crypto_state to 0 here
+         * to prevent an infinite loop
+         */
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        return (-1);
+    }                            // end switch
+    return (1);
+}
+
+int
+check_vryf_mac_completion (SSL * s)
+{
+    int rc;
+
+    s->state = s->cav_saved_state;
+    if (s->cav_req_id_check_done) {
+        // already checked, probably directly by app
+        cav_fprintf (cav_nb_fp, "check_vrfy_mac_completion(): %s\n",
+            "already checked, probably directly by app\n");
+        rc = 0;
+    } else {
+        // should check for cmd completion here
+#ifdef CAVIUM_FIPS
+        rc = Cfm1CheckForCompletion (s->cav_req_id);
+#else
+#ifdef CAVIUM_MULTICARD_API
+        rc = Csp1CheckForCompletion (s->cav_req_id, s->dev_id);
+#else
+        rc = Csp1CheckForCompletion (s->cav_req_id);
+#endif
+#endif
+    }
+    cav_fprintf (cav_nb_fp,
+        "check_vrfy_mac_completion():Csp1CheckForCompletion() rc=%d\n",
+        rc);
+
+    switch (rc) {
+
+    case EAGAIN:
+        // not done yet
+        cav_fprintf (cav_nb_fp, "check_vrfy_mac_completion(): %s\n",
+            "Csp1CheckForCompletion() EAGAIN");
+        s->cav_saved_state = s->state;
+        s->cav_crypto_state = CAV_ST_IN_VRFY_CERT;
+        s->state = CAV_ST_IN_VRFY_CERT;
+        return (0);
+    case 0:
+        // done:
+        cav_fprintf (cav_nb_fp, "===>check_vrfy_mac_completion(): %s\n",
+            "Csp1CheckForCompletion() completed");
+
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        break;
+    default:
+        cav_fprintf (cav_nb_fp, "check_vrfy_mac_completion(): %s\n",
+            "Csp1CheckForCompletion() default case");
+        /*
+         * should we reset the cav_crypto_state to 0 here
+         * to prevent an infinite loop
+         */
+        s->cav_crypto_state = 0;
+        s->cav_req_id_check_done = 1;
+        s->rwstate = SSL_NOTHING;
+        return (-1);
+    }                            // end switch
+    return (1);
+}
+
+/*
+ * For Handshake Offloading
+ * Reads the shared secret key context from Nitrox and
+ * sets software context structures.
+ *
+ */
+
+int
+pkp_read_ssl_session_context (SSL * s)
+{
+
+    int i, is_ssl3_sha = 0;
+    unsigned char *p1;
+    Uint64 context_offset;
+#ifndef CAVIUM_FIPS
+    int res;
+#endif
+
+    if ((p1 =
+            (unsigned char *) OPENSSL_malloc (MAX_CRYPTO_CTX_SIZE)) ==
+        NULL)
+        goto err;
+
+    context_offset = CRYPTO_OFFSET_IN_CTX;
+#ifndef CAVIUM_FIPS
+    res = Csp1ReadContext (CAVIUM_BLOCKING,
+        s->context_pointer + context_offset, MAX_CRYPTO_CTX_SIZE, p1,
+#ifdef CAVIUM_MULTICARD_API
+        &s->cav_req_id, s->dev_id
+#else
+        &s->cav_req_id
+#endif
+        );
+    if (res != 0)
+        goto err;
+#endif
+
+    i = EVP_MD_size (s->write_hash);
+
+    if (s->ssl_version == VER3_0 &&
+        EVP_MD_type (s->write_hash) == NID_sha1)
+        is_ssl3_sha = 1;
+
+    switch (s->session->cipher->id) {
+
+    case SSL3_CK_RSA_RC4_128_SHA:
+    case SSL3_CK_RSA_RC4_128_MD5:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5:
+    case SSL3_CK_RSA_RC4_40_MD5:
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            rc4_init_cipher_ctx (s->enc_write_ctx,
+                s->enc_write_ctx->cipher, &(p1[56]), 1);
+
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[344]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), &(p1[320]), i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[344]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[368]), 8);
+            rc4_init_cipher_ctx (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                &(p1[376]), 0);
+        } else {
+
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            rc4_init_cipher_ctx (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                &(p1[56]), 0);
+
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[344]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), &(p1[320]), i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[344]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[368]), 8);
+            rc4_init_cipher_ctx (s->enc_write_ctx,
+                s->enc_write_ctx->cipher, &(p1[376]), 1);
+        }
+
+        break;
+
+    case SSL3_CK_RSA_DES_192_CBC3_SHA:
+    case SSL3_CK_RSA_DES_40_CBC_SHA:
+    case SSL3_CK_RSA_DES_64_CBC_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            EVP_CipherInit_ex (s->enc_write_ctx, s->enc_write_ctx->cipher,
+                NULL, &(p1[64]), &(p1[56]), 1);
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[120]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), &(p1[96]), i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[120]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[144]), 8);
+            EVP_CipherInit_ex (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                NULL, &(p1[160]), &(p1[152]), 0);
+        } else {
+
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            EVP_CipherInit_ex (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                NULL, &(p1[64]), &(p1[56]), 0);
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[120]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), &(p1[96]), i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[120]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[144]), 8);
+            EVP_CipherInit_ex (s->enc_write_ctx, s->enc_write_ctx->cipher,
+                NULL, &(p1[160]), &(p1[152]), 1);
+        }
+        break;
+
+    case TLS1_CK_RSA_WITH_AES_128_SHA:
+    case TLS1_CK_RSA_WITH_AES_256_SHA:
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            EVP_CipherInit_ex (s->enc_write_ctx, s->enc_write_ctx->cipher,
+                NULL, &(p1[72]), &(p1[56]), 1);
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[152]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), &(p1[128]), i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[152]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[176]), 8);
+            EVP_CipherInit_ex (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                NULL, &(p1[200]), &(p1[184]), 0);
+        } else {
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->read_mac_secret[0]), &(p1[24]), i);
+            else {
+                memcpy (&(s->s3->read_opad_hash[0]), p1, i);
+                memcpy (&(s->s3->read_ipad_hash[0]), &(p1[24]), i);
+            }
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            EVP_CipherInit_ex (s->enc_read_ctx, s->enc_read_ctx->cipher,
+                NULL, &(p1[72]), &(p1[56]), 0);
+            if (is_ssl3_sha)
+                memcpy (&(s->s3->write_mac_secret[0]), &(p1[152]), i);
+            else {
+                memcpy (&(s->s3->write_opad_hash[0]), &(p1[128]), i);
+                memcpy (&(s->s3->write_ipad_hash[0]), &(p1[152]), i);
+            }
+            memcpy (&(s->s3->write_sequence[0]), &(p1[176]), 8);
+            EVP_CipherInit_ex (s->enc_write_ctx, s->enc_write_ctx->cipher,
+                NULL, &(p1[200]), &(p1[184]), 1);
+        }
+        break;
+    }
+
+    OPENSSL_free (p1);
+    return (1);
+  err:
+
+    return (0);
+
+}
+
+/*
+ * For Handshake Offloading
+ * Updates the secret key context in Nitrox
+ * called when Renegotiation requested from either client or server
+ *
+ */
+
+
+int
+pkp_write_updated_ssl_session_context (SSL * s)
+{
+    unsigned char *read_state, *write_state;
+#ifndef CAVIUM_FIPS
+    int res;
+#endif
+    Uint64 wr_st_off, re_st_off;
+
+    // RC4 state and sequence Number Need to be updated in Nlite
+    // 264 + 8
+
+    if ((read_state = (unsigned char *) OPENSSL_malloc (272)) == NULL)
+        goto err;
+
+    if ((write_state = (unsigned char *) OPENSSL_malloc (272)) == NULL)
+        goto err;
+
+    memset (read_state, 0, 272);
+    memset (write_state, 0, 272);
+
+    switch (s->session->cipher->id) {
+    case SSL3_CK_RSA_RC4_128_SHA:
+    case SSL3_CK_RSA_RC4_128_MD5:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5:
+    case SSL3_CK_RSA_RC4_40_MD5:
+        wr_st_off = 8 * 28;
+        re_st_off = 8 * 68;
+
+        if (!s->server) {
+            memcpy (write_state, &(s->s3->write_sequence[0]), 8);
+            rc4_get_cipher_state (&(write_state[8]), s->enc_write_ctx);
+
+            memcpy (read_state, &(s->s3->read_sequence[0]), 8);
+            rc4_get_cipher_state (&(read_state[8]), s->enc_read_ctx);
+        } else {
+            memcpy (read_state, &(s->s3->write_sequence[0]), 8);
+            rc4_get_cipher_state (&(read_state[8]), s->enc_write_ctx);
+
+            memcpy (write_state, &(s->s3->read_sequence[0]), 8);
+            rc4_get_cipher_state (&(write_state[8]), s->enc_read_ctx);
+        }
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + wr_st_off, 272,    // RC4 state + seq number
+            write_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + re_st_off, 272, read_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+#endif
+
+        break;
+
+    case SSL3_CK_RSA_DES_192_CBC3_SHA:
+    case SSL3_CK_RSA_DES_40_CBC_SHA:
+    case SSL3_CK_RSA_DES_64_CBC_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+        wr_st_off = 8 * 28;
+        re_st_off = 8 * 40;
+        if (!s->server) {
+            memcpy (write_state, &(s->s3->write_sequence[0]), 8);
+            memcpy (&(write_state[8]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+
+            memcpy (read_state, &(s->s3->read_sequence[0]), 8);
+            memcpy (&(read_state[8]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            memcpy (read_state, &(s->s3->write_sequence[0]), 8);
+            memcpy (&(read_state[8]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+
+            memcpy (write_state, &(s->s3->read_sequence[0]), 8);
+            memcpy (&(write_state[8]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+
+        }
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + wr_st_off, 16,    // seq number + IV
+            write_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + re_st_off, 16, read_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+        if (res != 0)
+            goto err;
+#endif
+
+        break;
+
+    case TLS1_CK_RSA_WITH_AES_128_SHA:
+    case TLS1_CK_RSA_WITH_AES_256_SHA:
+        wr_st_off = 8 * 28;
+        re_st_off = 8 * 44;
+
+        if (!s->server) {
+            memcpy (write_state, &(s->s3->write_sequence[0]), 8);
+            memcpy (&(write_state[8]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            memcpy (read_state, &(s->s3->read_sequence[0]), 8);
+            memcpy (&(read_state[8]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            memcpy (read_state, &(s->s3->write_sequence[0]), 8);
+            memcpy (&(read_state[8]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            memcpy (write_state, &(s->s3->read_sequence[0]), 8);
+            memcpy (&(write_state[8]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        }
+
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + wr_st_off, 24,    // sequence num +IV
+            write_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + re_st_off, 24, read_state,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+#endif
+        break;
+    }
+
+    OPENSSL_free (read_state);
+    OPENSSL_free (write_state);
+    return (1);
+  err:
+    return (0);
+
+}
+
+
+/*
+ *For Record Process Offloading
+ * Writes secret key context to Nitrox
+ *
+ */
+
+int
+pkp_write_ssl_session_context (SSL * s)
+{
+    unsigned char *p1;
+    Uint64 context_offset;
+    int i, is_ssl3_sha = 0;;
+#ifndef CAVIUM_FIPS
+    int res;
+#endif
+
+    context_offset = CRYPTO_OFFSET_IN_CTX;
+    i = EVP_MD_size (s->write_hash);
+
+    //initialized for record processing in Nitrox
+
+    s->read_cipher_active = 1;
+    s->write_cipher_active = 1;
+    s->digest_type = EVP_MD_type (s->write_hash);
+    s->cipher_type = EVP_CIPHER_CTX_nid (s->enc_write_ctx);
+    s->md_size = i;
+    if (s->version > SSL3_VERSION)
+        s->ssl_version = VER_TLS;
+    else
+        s->ssl_version = VER3_0;
+
+    if (s->ssl_version == VER3_0 &&
+        EVP_MD_type (s->write_hash) == NID_sha1)
+        is_ssl3_sha = 1;
+
+    if ((p1 =
+            (unsigned char *) OPENSSL_malloc (MAX_CRYPTO_CTX_SIZE)) ==
+        NULL)
+        goto err;
+    memset (p1, 0, 640);
+    switch (s->session->cipher->id) {
+    case SSL3_CK_RSA_RC4_128_SHA:
+    case SSL3_CK_RSA_RC4_128_MD5:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5:
+    case SSL3_CK_RSA_RC4_40_MD5:
+
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->write_sequence[0]), 8);
+            rc4_get_cipher_state (&(p1[56]), s->enc_write_ctx);
+
+            if (is_ssl3_sha)
+                memcpy (&(p1[344]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[320]), &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[344]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[368]), &(s->s3->read_sequence[0]), 8);
+            rc4_get_cipher_state (&(p1[376]), s->enc_read_ctx);
+
+        } else {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->read_sequence[0]), 8);
+            rc4_get_cipher_state (&(p1[56]), s->enc_read_ctx);
+
+            if (is_ssl3_sha)
+                memcpy (&(p1[344]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[320]), &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[344]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[368]), &(s->s3->write_sequence[0]), 8);
+            rc4_get_cipher_state (&(p1[376]), s->enc_write_ctx);
+        }
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + context_offset, MAX_CRYPTO_CTX_SIZE, p1,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+#endif
+        break;
+
+    case SSL3_CK_RSA_DES_192_CBC3_SHA:
+    case SSL3_CK_RSA_DES_40_CBC_SHA:
+    case SSL3_CK_RSA_DES_64_CBC_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->write_sequence[0]), 8);
+            memcpy (&(p1[56]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            if (s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+                des3_get_key (&(p1[64]), s->enc_write_ctx);
+            else
+                des_get_key (&(p1[64]), s->enc_write_ctx);
+
+            memcpy (&(p1[88]), s->enc_write_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            if (is_ssl3_sha)
+                memcpy (&(p1[120]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[96]), &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[120]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[144]), &(s->s3->read_sequence[0]), 8);
+            memcpy (&(p1[152]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+            if (s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+                des3_get_key (&(p1[160]), s->enc_read_ctx);
+            else
+                des_get_key (&(p1[160]), s->enc_read_ctx);
+            memcpy (&(p1[184]), s->enc_read_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->read_sequence[0]), 8);
+            memcpy (&(p1[56]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+            if (s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+                des3_get_key (&(p1[64]), s->enc_read_ctx);
+            else
+                des_get_key (&(p1[64]), s->enc_read_ctx);
+            memcpy (&(p1[88]), s->enc_read_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+            if (is_ssl3_sha)
+                memcpy (&(p1[120]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[96]), &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[120]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[144]), &(s->s3->write_sequence[0]), 8);
+            memcpy (&(p1[152]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            if (s->session->cipher->id == SSL3_CK_RSA_DES_192_CBC3_SHA)
+                des3_get_key (&(p1[160]), s->enc_write_ctx);
+            else
+                des_get_key (&(p1[160]), s->enc_write_ctx);
+            memcpy (&(p1[184]), s->enc_write_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+        }
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + context_offset, 192,    // DES
+            p1,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+#endif
+
+        break;
+
+    case TLS1_CK_RSA_WITH_AES_128_SHA:
+    case TLS1_CK_RSA_WITH_AES_256_SHA:
+
+        if (!s->server) {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->write_sequence[0]), 8);
+            memcpy (&(p1[56]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            aes_get_key (&(p1[72]), s->enc_write_ctx);
+            memcpy (&(p1[104]), s->enc_write_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+
+            if (is_ssl3_sha)
+                memcpy (&(p1[152]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[128]), &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[152]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[176]), &(s->s3->read_sequence[0]), 8);
+            memcpy (&(p1[184]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+            aes_get_key (&(p1[200]), s->enc_read_ctx);
+            memcpy (&(p1[232]), s->enc_read_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            if (is_ssl3_sha)
+                memcpy (&(p1[24]), &(s->s3->read_mac_secret[0]), i);
+            else {
+                memcpy (p1, &(s->s3->read_opad_hash[0]), i);
+                memcpy (&(p1[24]), &(s->s3->read_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[48]), &(s->s3->read_sequence[0]), 8);
+            memcpy (&(p1[56]), s->enc_read_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+            aes_get_key (&(p1[72]), s->enc_read_ctx);
+            memcpy (&(p1[104]), s->enc_read_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+
+            if (is_ssl3_sha)
+                memcpy (&(p1[152]), &(s->s3->write_mac_secret[0]), i);
+            else {
+                memcpy (&(p1[128]), &(s->s3->write_opad_hash[0]), i);
+                memcpy (&(p1[152]), &(s->s3->write_ipad_hash[0]), i);
+            }
+            memcpy (&(p1[176]), &(s->s3->write_sequence[0]), 8);
+            memcpy (&(p1[184]), s->enc_write_ctx->iv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+            aes_get_key (&(p1[200]), s->enc_write_ctx);
+            memcpy (&(p1[232]), s->enc_write_ctx->oiv,
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+        }
+
+#ifndef CAVIUM_FIPS
+        res = Csp1WriteContext (CAVIUM_BLOCKING,
+            s->context_pointer + context_offset, 256,    // AES
+            p1,
+#ifdef CAVIUM_MULTICARD_API
+            &s->cav_req_id, s->dev_id
+#else
+            &s->cav_req_id
+#endif
+            );
+
+        if (res != 0)
+            goto err;
+#endif
+
+        break;
+
+    }
+    OPENSSL_free (p1);
+    return (1);
+  err:
+    return (0);
+
+}
+
+/*
+ * For Record Process Offloading
+ * Reads context from Nitrox and updates spftware context structures
+ * Called when Renegotiation requested from either client or server
+ *
+ */
+
+int
+pkp_read_updated_ssl_session_context (SSL * s)
+{
+
+    unsigned char *p1;
+#ifndef CAVIUM_FIPS
+    int res;
+#endif
+    Uint64 context_offset;
+
+
+    if ((p1 =
+            (unsigned char *) OPENSSL_malloc (MAX_CRYPTO_CTX_SIZE)) ==
+        NULL)
+        goto err;
+
+    context_offset = CRYPTO_OFFSET_IN_CTX;
+#ifndef CAVIUM_FIPS
+    res = Csp1ReadContext (CAVIUM_BLOCKING,
+        s->context_pointer + context_offset, MAX_CRYPTO_CTX_SIZE, p1,
+#ifdef CAVIUM_MULTICARD_API
+        &s->cav_req_id, s->dev_id
+#else
+        &s->cav_req_id
+#endif
+        );
+    if (res != 0)
+        goto err;
+#endif
+
+    switch (s->session->cipher->id) {
+    case SSL3_CK_RSA_RC4_128_SHA:
+    case SSL3_CK_RSA_RC4_128_MD5:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5:
+    case SSL3_CK_RSA_RC4_40_MD5:
+        if (!s->server) {
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            rc4_set_state (s->enc_write_ctx, &(p1[56]));
+
+            memcpy (&(s->s3->read_sequence[0]), &(p1[368]), 8);
+            rc4_set_state (s->enc_read_ctx, &(p1[376]));
+        } else {
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            rc4_set_state (s->enc_read_ctx, &(p1[56]));
+
+            memcpy (&(s->s3->write_sequence[0]), &(p1[368]), 8);
+            rc4_set_state (s->enc_write_ctx, &(p1[376]));
+        }
+        break;
+
+    case SSL3_CK_RSA_DES_192_CBC3_SHA:
+    case SSL3_CK_RSA_DES_40_CBC_SHA:
+    case SSL3_CK_RSA_DES_64_CBC_SHA:
+    case TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA:
+        if (!s->server) {
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            memcpy (s->enc_write_ctx->iv, &(p1[56]),
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+
+            memcpy (&(s->s3->read_sequence[0]), &(p1[144]), 8);
+            memcpy (s->enc_read_ctx->iv, &(p1[152]),
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            memcpy (s->enc_read_ctx->iv, &(p1[56]),
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+
+            memcpy (&(s->s3->write_sequence[0]), &(p1[144]), 8);
+            memcpy (s->enc_write_ctx->iv, &(p1[152]),
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+        }
+        break;
+
+    case TLS1_CK_RSA_WITH_AES_128_SHA:
+    case TLS1_CK_RSA_WITH_AES_256_SHA:
+
+        if (!s->server) {
+            memcpy (&(s->s3->write_sequence[0]), &(p1[48]), 8);
+            memcpy (s->enc_write_ctx->iv, &(p1[56]),
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+
+            memcpy (&(s->s3->read_sequence[0]), &(p1[176]), 8);
+            memcpy (s->enc_read_ctx->iv, &(p1[184]),
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+        } else {
+            memcpy (&(s->s3->read_sequence[0]), &(p1[48]), 8);
+            memcpy (s->enc_read_ctx->iv, &(p1[56]),
+                EVP_CIPHER_CTX_iv_length (s->enc_read_ctx));
+
+            memcpy (&(s->s3->write_sequence[0]), &(p1[176]), 8);
+            memcpy (s->enc_write_ctx->iv, &(p1[184]),
+                EVP_CIPHER_CTX_iv_length (s->enc_write_ctx));
+        }
+        break;
+
+    }
+
+    OPENSSL_free (p1);
+    return (1);
+
+err:
+    return (0);
+
+}
+
+
+/*This function assigns SSL session to a device.Application can use this API
+ * to override the default round robin mode of assignement.
+ */
+#ifdef CAVIUM_MULTICARD_API
+int
+SSL_set_crypto_dev (SSL * ssl, int dev_id)
+{
+    /*   Csp1FreeContext(CONTEXT_SSL,ssl->context_pointer,ssl->dev_id);
+
+       ssl->dev_id=dev_id;
+       ssl->key_handle=gpkpdev_keyhandle[dev_id];
+
+       if(Csp1AllocContext(CONTEXT_SSL, &ssl->context_pointer,ssl->dev_id))
+       {
+       printf("SSL_set_crypto_dev: failed to allocate context \n");
+       return -1;
+       } */
+    return 0;
+}
+#endif
diff -Naur openssl-0.9.8j/ssl/ssl_engine.h TurboSSL-0.9.8j/ssl/ssl_engine.h
--- openssl-0.9.8j/ssl/ssl_engine.h	1970-01-01 01:00:00.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/ssl_engine.h	2010-05-31 12:13:09.000000000 +0200
@@ -0,0 +1,154 @@
+/* ssl_engine.h */
+/*
+ * Copyright (c) 2003-2005, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all
+ * accompanying documentation are copyrighted. The Software made available
+ * here constitutes the proprietary information of Cavium Networks. You agree
+ * to take reasonable steps to prevent the disclosure, unauthorized use or
+ * unauthorized distribution of the Software. You shall use this Software
+ * solely with Cavium hardware.
+ *
+ * Except as expressly permitted in a separate Software License Agreement
+ * between You and Cavium Networks, You shall not modify, decompile,
+ * disassemble, extract, or otherwise reverse engineer this Software. You
+ * shall not make any copy of the Software or its accompanying documentation,
+ * except for copying incident to the ordinary and intended use of the
+ * Software and the Underlying Program and except for the making of a single
+ * archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export
+ * control laws, including the U.S. Export Administration Act and its
+ * associated regulations, and may be subject to export or import regulations
+ * in other countries. You warrant that You will comply strictly in all
+ * respects with all such regulations and acknowledge that you have the
+ * responsibility to obtain licenses to export, re-export or import the
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT
+ * TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY
+ * REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT
+ * DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES
+ * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR
+ * PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET
+ * POSSESSION OR CORRESPONDENCE TO DESCRIPTION. THE ENTIRE RISK ARISING OUT
+ * OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ *
+ */
+/*
+ *	Author	:	Imran Badr
+ 			Cavium Networks
+ *	
+ */
+
+
+#ifndef __SSL_ENGINE_H_
+#define __SSL_ENGINE_H_
+
+#ifndef CAVIUM_BROWSER_ISSUE
+#define CAVIUM_BROWSER_ISSUE
+#endif
+
+#ifndef CAVIUM_NB_CRYPTO
+#define CAVIUM_NB_CRYPTO
+#endif
+
+#ifndef CAVIUM_CRT_MOD_EX
+#define CAVIUM_CRT_MOD_EX
+#endif
+
+#define PKP_RANDOM_BUFFER_SIZE		128
+
+/* Context Data structure in NLite
+ * 
+ * Refer NITROX 1000 SSL Instruction Set Manual
+ * 2.6 RSA Server Key Exchange Instructions
+ *   
+ *  offset        
+ *    0      Handshake Hash Context
+ *    16     Master Secret
+ *    22     cryptographic context (RC4/AES/DES)-(MD5/SHA)
+ *    
+ *    RC4 --- OPAD, IPAD, SequenceNumber, State
+ *    DES --- OPAD, IPAD, sequenceNUmber, IV, DES key
+ *    AES --- OPAD, IPAD, sequenceNumber, IV, AES key
+ * 
+ * */
+
+#define MAX_CRYPTO_CTX_SIZE 640       // RC4--640 bytes , DES--192 bytes, AES---256 bytes
+#define CRYPTO_OFFSET_IN_CTX 22*8
+
+
+int check_dec_peer_completion(
+                SSL *s,
+		int *ip,
+                int *lenp,
+                int *md_sizep,
+                int *finish_sizep,
+		int *is_blockp,
+		unsigned short *peer_lenp,
+                char *dec_peer_client_finishedp);
+
+AesType get_Aes_type(unsigned long id);
+void pkp_init(void);
+#ifdef CAVIUM_MULTICARD_API
+int store_pkey(EVP_PKEY *pkey, Uint64 *key_handle,Uint32 dev_id);
+#else
+int store_pkey(EVP_PKEY *pkey, Uint64 *key_handle);
+#endif
+int pkp_get_random(char *out, int len, SSL *s);
+int pkp_encrypt_record(SSL *s);
+int pkp_decrypt_record(SSL *s);
+int pkp_handshake(SSL *s);
+int pkp_resume_handshake(SSL *s);
+int pkp_handshake_client_auth(SSL *s);
+int pkp_ephemeral_handshake(SSL *s);
+
+int pkp_cert_verify_mac(SSL *s);
+
+/* walks down the list of suported ciphers and returns 1 on success and 0 on failure */
+int find_cipher(SSL *s, unsigned long cipher_id);
+
+/* initializes the supported cipher list */
+int init_supported_cipher_list(SSL *s);
+
+extern void pkp_leftfill(unsigned char input[], int length, unsigned char output[], int finallength );
+
+Rc4Type get_Rc4_type(unsigned long id);
+DesType get_Des_type(unsigned long id);
+
+
+int pkp_handshake_20(SSL *s);
+int pkp_resume_handshake_20(SSL *s);
+int pkp_handshake_client_auth_20(SSL *s);
+int pkp_encrypt_record_20(SSL *s);
+int pkp_decrypt_record_20(SSL *s);
+int pkp_client_handshake(SSL *s);
+int pkp_client_resume_handshake(SSL *s);
+//int pkp_client_cert_verify_mac(unsigned char *mac, SSL *s);
+int pkp_client_cert_verify_mac(SSL *s);
+int pkp_client_handshake_client_auth(SSL *s);
+
+extern int check_pre_master_completion (SSL *s,
+#ifdef MC2
+					 Uint16 *out_len,
+#else
+					 Uint64 *out_len,
+#endif
+					 char *result);
+
+#endif
+
+// For Handshake offloading
+
+int pkp_read_ssl_session_context(SSL *);
+int pkp_write_updated_ssl_session_context(SSL *); // Renegotiation
+
+// For Record Process offloading
+
+int pkp_write_ssl_session_context(SSL *s);
+int pkp_read_updated_ssl_session_context(SSL *s); // Renegotiation
+
+
diff -Naur openssl-0.9.8j/ssl/ssl.h TurboSSL-0.9.8j/ssl/ssl.h
--- openssl-0.9.8j/ssl/ssl.h	2008-08-13 21:44:44.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl.h	2010-05-31 12:13:09.000000000 +0200
@@ -192,6 +192,8 @@
 #include <openssl/kssl.h>
 #include <openssl/safestack.h>
 #include <openssl/symhacks.h>
+#include <openssl/md5.h>
+#include <openssl/sha.h>
 
 #ifdef  __cplusplus
 extern "C" {
@@ -203,6 +205,12 @@
  */
 #define SSL_SESSION_ASN1_VERSION 0x0001
 
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_MULTICARD_API
+#define MAX_DEV_CNT 4
+#endif
+#endif
+
 /* text strings for the ciphers */
 #define SSL_TXT_NULL_WITH_MD5		SSL2_TXT_NULL_WITH_MD5			
 #define SSL_TXT_RC4_128_WITH_MD5	SSL2_TXT_RC4_128_WITH_MD5		
@@ -299,6 +307,27 @@
 #define SSL_TXT_ALL		"ALL"
 #define SSL_TXT_ECC		"ECCdraft" /* ECC ciphersuites are not yet official */
 
+#ifdef CAVIUM_SSL
+#define CH_SR_MSGS_LEN              2048    /* estimated clinet hello -  server response msgs size */
+#define PKP_SUPPORTED_CIPHER_COUNT  30
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+
+#ifdef CAVIUM_FIPS
+        struct private_key_info
+        {
+                Uint32 size;
+                int type;
+        };
+
+#endif
+#endif
+
 /*
  * COMPLEMENTOF* definitions. These identifiers are used to (de-select)
  * ciphers normally not being used.
@@ -473,6 +502,9 @@
 	/* These are used to make removal of session-ids more
 	 * efficient and to implement a maximum cache size. */
 	struct ssl_session_st *prev,*next;
+#ifdef CAVIUM_SSL
+    int dev_id;
+#endif
 #ifndef OPENSSL_NO_TLSEXT
 	char *tlsext_hostname;
 	/* RFC4507 info */
@@ -757,6 +789,20 @@
 #endif
 
 	int quiet_shutdown;
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_MULTICARD_API
+	Uint64 gpkpdev_keyhandle[MAX_DEV_CNT];		
+#endif		  
+	Uint64 key_handle;
+	Uint32 dev_id;
+	Uint32 dev_cnt;
+
+#ifdef CAVIUM_FIPS
+	struct private_key_info pkey_info;
+#endif
+	Uint8 dev_mask;
+
+#endif
 
 #ifndef OPENSSL_ENGINE
 	/* Engine to pass requests for client certs to
@@ -843,12 +889,18 @@
 #define SSL_WRITING	2
 #define SSL_READING	3
 #define SSL_X509_LOOKUP	4
+#ifdef CAVIUM_SSL
+#define SSL_NITROX_BUSY 501
+#endif
 
 /* These will only be used when doing non-blocking IO */
 #define SSL_want_nothing(s)	(SSL_want(s) == SSL_NOTHING)
 #define SSL_want_read(s)	(SSL_want(s) == SSL_READING)
 #define SSL_want_write(s)	(SSL_want(s) == SSL_WRITING)
 #define SSL_want_x509_lookup(s)	(SSL_want(s) == SSL_X509_LOOKUP)
+#ifdef CAVIUM_SSL
+#define SSL_want_cav_encrypt(s) (SSL_want(s) == SSL_NITROX_BUSY)
+#endif
 
 struct ssl_st
 	{
@@ -1008,6 +1060,85 @@
 	int first_packet;
 	int client_version;	/* what was passed, used for
 				 * SSLv3/TLS rollback check */
+#ifdef CAVIUM_SSL
+    unsigned char *hs_msgs; /* place holder to store handshake msgs */
+    int hs_msgs_len;
+    int hs_msgs_total_len;
+    int client_finish_msg_offset;
+    int client_cert_msg_offset;
+    int client_key_exch_msg_offset;
+    int client_cert_verify_msg_offset;
+    int server_finish_msg_offset;
+    int write_cipher_active;
+    int read_cipher_active;
+    unsigned char peer_finish_first_four[4];
+    unsigned long supported_ciphers[PKP_SUPPORTED_CIPHER_COUNT];
+    int cipher_support;
+    int handshake_support;
+    int record_process;  
+    Uint64 key_handle;
+
+    /* these arrays are usd in ssl3.0/tls resume and ssl2.0 case*/
+    unsigned char server_finished[64], client_finished[64], server_cert_req[64];
+
+    /* ssl 2.0 only */
+    Uint16 server_finished_len, client_finished_len;
+
+    /* these are only used in ss2.0 case */
+    unsigned char client_master_secret[512];
+    unsigned char server_verify[64];
+    //int server_verify_len,
+    int  client_master_secret_len;
+    int cipher_type,digest_type,md_size;
+    SslVersion ssl_version;
+    unsigned char *random_buffer;
+    unsigned long random_index;
+
+    // For - nb support
+
+    int cav_nb_mode;
+    Uint32 cav_req_id;
+    Uint8 cav_req_id_check_done;
+    int cav_saved_state;
+    int cav_crypto_state;
+    Uint8 cav_process_flag;
+    Uint16 cav_msg_len;
+    int cav_prefix_len;
+    int *cav_plen;
+    unsigned char dec_peer_client_finished[80];
+    unsigned short peer_len;
+#ifdef MC2
+    Uint16 pre_master_len;
+#else
+    Uint64 pre_master_len;
+#endif
+    unsigned char pre_master_result[512];
+    unsigned char data_sign[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];
+    Uint8 flag;
+    Uint8 flag1;
+    Uint8 reneg_flag ;
+    Uint8 alloc_flag;
+    int cryp_flen;
+    // end - for nb support
+#ifndef OPENSSL_NO_RSA
+    RSA *rsa;
+    EVP_PKEY *pkey;
+    X509 *peer_vrfy_cert;
+    unsigned char *p_vrfy_cert;
+    unsigned char *d_vrfy_cert;
+    unsigned char *q_vrfy_cert;
+    unsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];
+    unsigned char md_buf[EVP_MAX_MD_SIZE*4];
+    int vrfy_cert_i;
+    int j_clnt;
+    int n_clnt;
+#endif
+    int cav_renego;
+    Uint64 context_pointer;
+    int dev_id;
+
+#endif
+
 #ifndef OPENSSL_NO_TLSEXT
 	/* TLS extension debug callback */
 	void (*tlsext_debug_cb)(SSL *s, int client_server, int type,
@@ -2068,6 +2199,10 @@
 #define SSL_R_WRONG_VERSION_NUMBER			 267
 #define SSL_R_X509_LIB					 268
 #define SSL_R_X509_VERIFICATION_SETUP_PROBLEMS		 269
+#ifdef CAVIUM_SSL
+#define SSL_R_KEY_MATERIAL_GENERATION_FAILED    270
+#define SSL_R_CHANGE_CIPHER_STATE_FAILED    271
+#endif
 
 #ifdef  __cplusplus
 }
diff -Naur openssl-0.9.8j/ssl/ssl_lib.c TurboSSL-0.9.8j/ssl/ssl_lib.c
--- openssl-0.9.8j/ssl/ssl_lib.c	2008-06-16 18:56:42.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl_lib.c	2010-05-31 12:13:09.000000000 +0200
@@ -133,6 +133,16 @@
 #ifndef OPENSSL_NO_ENGINE
 #include <openssl/engine.h>
 #endif
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include "luna_api.h"
+#include "luna_common.h"
+#else
+#include "cavium_common.h"
+#endif
+#include "ssl_engine.h"
+#include "openssl/cav_debug.h"
+#endif
 
 const char *SSL_version_str=OPENSSL_VERSION_TEXT;
 
@@ -239,6 +249,9 @@
 		}
 	return(1);
 	}
+#ifdef CAVIUM_SSL
+extern int pkp_device_present;
+#endif
 
 SSL *SSL_new(SSL_CTX *ctx)
 	{
@@ -263,7 +276,49 @@
 	s->kssl_ctx = kssl_ctx_new();
 #endif	/* OPENSSL_NO_KRB5 */
 
+#ifdef CAVIUM_SSL
+    s->options=ctx->options | SSL_OP_ALL;
+    s->key_handle = ctx->key_handle;
+#ifdef CAVIUM_MULTICARD_API
+
+	while(1){	
+		if(ctx->dev_mask&(1<<ctx->dev_id))		
+			break;
+        	ctx->dev_id=((ctx->dev_id+1)%ctx->dev_cnt);
+	}
+    s->dev_id = ctx->dev_id;
+    s->key_handle = ctx->gpkpdev_keyhandle[s->dev_id];
+    ctx->dev_id=((ctx->dev_id+1)%ctx->dev_cnt);
+#endif
+        /* get context pointer */
+    if(pkp_device_present) {
+#ifdef CAVIUM_FIPS
+        if(Cfm1AllocContext(OP_BLOCKING,&s->context_pointer,NULL))
+
+#else
+#ifdef CAVIUM_MULTICARD_API
+        if(Csp1AllocContext(CONTEXT_SSL, &s->context_pointer,s->dev_id))
+#else
+	
+        if(Csp1AllocContext(CONTEXT_SSL, &s->context_pointer))
+#endif
+#endif 
+            goto err;
+	}
+    s->random_buffer = (unsigned char *)OPENSSL_malloc(PKP_RANDOM_BUFFER_SIZE);
+    if(s->random_buffer == NULL)
+        goto err;
+        s->random_index = 0;
+
+#if 0
+        if(Csp1Random(CAVIUM_BLOCKING, PKP_RANDOM_BUFFER_SIZE, s->random_buffer,&req_id))
+                goto err;
+#endif
+        RAND_pseudo_bytes(s->random_buffer, PKP_RANDOM_BUFFER_SIZE);
+
+#else
 	s->options=ctx->options;
+#endif	
 	s->mode=ctx->mode;
 	s->max_cert_list=ctx->max_cert_list;
 
@@ -286,7 +341,12 @@
 	else
 		s->cert=NULL; /* Cannot really happen (see SSL_CTX_new) */
 
-	s->read_ahead=ctx->read_ahead;
+#if defined (CAVIUM_SSL) && defined (READ_AHEAD)
+    s->read_ahead=1;
+#else
+	s->read_ahead=ctx->read_ahead; /* used to happen in SSL_clear */
+#endif	
+
 	s->msg_callback=ctx->msg_callback;
 	s->msg_callback_arg=ctx->msg_callback_arg;
 	s->verify_mode=ctx->verify_mode;
@@ -423,11 +483,22 @@
 			SSL2_SSL_SESSION_ID_LENGTH - id_len);
 		r.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
 		}
-
+#ifdef CAVIUM_SSL
+#ifndef NO_SESSION_CACHE
+    CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
+    p = (SSL_SESSION *)lh_retrieve(ssl->ctx->sessions, &r);
+    CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
+    return (p != NULL);
+#else
+    p = NULL;
+    return(p);
+#endif
+#else
 	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
 	p = (SSL_SESSION *)lh_retrieve(ssl->ctx->sessions, &r);
 	CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
 	return (p != NULL);
+#endif
 	}
 
 int SSL_CTX_set_purpose(SSL_CTX *s, int purpose)
@@ -528,6 +599,37 @@
 	if (s->kssl_ctx != NULL)
 		kssl_ctx_free(s->kssl_ctx);
 #endif	/* OPENSSL_NO_KRB5 */
+#ifdef CAVIUM_SSL
+    /*  printf("Freeing Context :%x\n",s->context_pointer); */
+    if (s->context_pointer){
+#ifdef CAVIUM_FIPS
+        Cfm1FreeContext(OP_BLOCKING,s->context_pointer,NULL);
+#else
+#ifdef CAVIUM_MULTICARD_API
+       Csp1FreeContext(CONTEXT_SSL,s->context_pointer,s->dev_id);
+#else
+       Csp1FreeContext(CONTEXT_SSL,s->context_pointer);
+#endif
+#endif
+    }
+    if(s->hs_msgs != NULL)
+    {
+        OPENSSL_free(s->hs_msgs);
+        s->hs_msgs=NULL;
+    }
+    if(s->random_buffer!=NULL)
+    {
+        OPENSSL_free(s->random_buffer);
+        s->random_buffer = NULL;
+    }
+
+    /*if(s->pre_master_result != NULL)
+    {
+        OPENSSL_free(s->pre_master_result);
+        s->pre_master_result=NULL;
+    }*/
+
+#endif
 
 	OPENSSL_free(s);
 	}
@@ -732,7 +834,11 @@
 
 void SSL_set_read_ahead(SSL *s,int yes)
 	{
+#if defined (CAVIUM_SSL) && defined (READ_AHEAD)
+    s->read_ahead=1;
+#else
 	s->read_ahead=yes;
+#endif	
 	}
 
 int SSL_get_read_ahead(const SSL *s)
@@ -816,6 +922,9 @@
 /* Fix this so it checks all the valid key/cert options */
 int SSL_CTX_check_private_key(const SSL_CTX *ctx)
 	{
+#ifdef CAVIUM_FIPS
+    return (1);
+#endif
 	if (	(ctx == NULL) ||
 		(ctx->cert == NULL) ||
 		(ctx->cert->key->x509 == NULL))
@@ -834,6 +943,9 @@
 /* Fix this function so that it takes an optional type parameter */
 int SSL_check_private_key(const SSL *ssl)
 	{
+#ifdef CAVIUM_FIPS
+    return (1);
+#endif
 	if (ssl == NULL)
 		{
 		SSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,ERR_R_PASSED_NULL_PARAMETER);
@@ -974,8 +1086,13 @@
 	case SSL_CTRL_GET_READ_AHEAD:
 		return(s->read_ahead);
 	case SSL_CTRL_SET_READ_AHEAD:
+#if defined (CAVIUM_SSL) && defined (READ_AHEAD)
+        l = 1;
+        s->read_ahead=1;
+#else
 		l=s->read_ahead;
 		s->read_ahead=larg;
+#endif		
 		return(l);
 
 	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
@@ -1031,8 +1148,13 @@
 	case SSL_CTRL_GET_READ_AHEAD:
 		return(ctx->read_ahead);
 	case SSL_CTRL_SET_READ_AHEAD:
+#if defined (CAVIUM_SSL) && defined (READ_AHEAD)
+        l = 1;
+        ctx->read_ahead = 1;
+#else
 		l=ctx->read_ahead;
 		ctx->read_ahead=larg;
+#endif		
 		return(l);
 		
 	case SSL_CTRL_SET_MSG_CALLBACK_ARG:
@@ -1390,6 +1512,11 @@
 	{
 	SSL_CTX *ret=NULL;
 	
+#if defined(CAVIUM_SSL) && defined(CAVIUM_MULTICARD_API)
+    Uint32 dev_id,dev_cnt=0;
+	Uint8 dev_mask=0;
+#endif
+	
 	if (meth == NULL)
 		{
 		SSLerr(SSL_F_SSL_CTX_NEW,SSL_R_NULL_SSL_METHOD_PASSED);
@@ -1448,7 +1575,11 @@
 	ret->app_verify_arg=NULL;
 
 	ret->max_cert_list=SSL_MAX_CERT_LIST_DEFAULT;
+#if defined (CAVIUM_SSL) && defined (READ_AHEAD)
+    ret->read_ahead=1;
+#else
 	ret->read_ahead=0;
+#endif	
 	ret->msg_callback=0;
 	ret->msg_callback_arg=NULL;
 	ret->verify_mode=SSL_VERIFY_NONE;
@@ -1509,6 +1640,80 @@
 
 	ret->extra_certs=NULL;
 	ret->comp_methods=SSL_COMP_get_compression_methods();
+#ifdef CAVIUM_SSL
+    ret->dev_id = 0;
+    ret->dev_cnt=0;
+    if (pkp_device_present) {
+#ifdef CAVIUM_MULTICARD_API
+ /*Get the number of Nitrox Crypto devices present*/
+    Csp1GetDevCnt(&dev_cnt,&dev_mask);
+    ret->dev_cnt=dev_cnt;
+    ret->dev_mask=dev_mask;
+    for(dev_id=0; dev_id<dev_cnt; dev_id++)
+    {
+	if(!(dev_mask&(1<<dev_id)))
+		continue;	
+/*#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)*/
+#ifndef CAVIUM_FIPS
+
+#if defined(CAVIUM_PKEY_INTERNAL_SRAM)
+        if(Csp1AllocKeyMem(READ_INTERNAL_SRAM,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+            goto err2;
+
+#elif defined(CAVIUM_PKEY_LOCAL_DDR)
+        if(Csp1AllocKeyMem(READ_LOCAL_DDR,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+            goto err2;
+
+#elif defined(CAVIUM_PKEY_HOST_MEM)
+        if(Csp1AllocKeyMem(READ_HOST_MEM,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+            goto err2;
+#else
+        if(Csp1AllocKeyMem(READ_INTERNAL_SRAM,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+        {
+            if(Csp1AllocKeyMem(READ_LOCAL_DDR,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+            {
+                if(Csp1AllocKeyMem(INPUT_DATA,&ret->gpkpdev_keyhandle[dev_id],dev_id))
+                    goto err2;
+            }
+       }
+   } /*end for loop*/
+
+#endif /*PKEY location stuff*/
+#endif
+//   ret->key_handle=gpkpdev_keyhandle[0];
+    ret->key_handle=ret->gpkpdev_keyhandle[CAVIUM_DEV_ID];
+
+#else /*CAVIUM_MULTICARD_API*/
+#ifndef CAVIUM_FIPS
+
+#if defined(CAVIUM_PKEY_INTERNAL_SRAM)
+
+        if(Csp1AllocKeyMem(READ_INTERNAL_SRAM,&ret->key_handle))
+            goto err2;
+
+#elif defined(CAVIUM_PKEY_LOCAL_DDR)
+        if(Csp1AllocKeyMem(READ_LOCAL_DDR,&ret->key_handle))
+            goto err2;
+
+#elif defined(CAVIUM_PKEY_HOST_MEM)
+        if(Csp1AllocKeyMem(READ_HOST_MEM,&ret->key_handle))
+            goto err2;
+
+#else
+        if(Csp1AllocKeyMem(READ_INTERNAL_SRAM,&ret->key_handle))
+        {
+            if(Csp1AllocKeyMem(READ_LOCAL_DDR,&ret->key_handle))
+            {
+                if(Csp1AllocKeyMem(INPUT_DATA,&ret->key_handle))
+                    goto err2;
+            }
+        }
+#endif /*PKEY location stuff */
+
+#endif
+#endif /*CAVIUM_MULTICARD_API*/
+}
+#endif /* CAVIUM_SSL */
 
 #ifndef OPENSSL_NO_TLSEXT
 	ret->tlsext_servername_callback = 0;
@@ -1615,6 +1820,21 @@
 #else
 	a->comp_methods = NULL;
 #endif
+#if defined  (CAVIUM_SSL) && !defined (CAVIUM_FIPS)
+#ifdef CAVIUM_MULTICARD_API
+   for(i=0; i<a->dev_cnt; i++)
+   {
+        if(a->gpkpdev_keyhandle[i])
+        {
+           Csp1FreeKeyMem(a->gpkpdev_keyhandle[i],i);
+           a->gpkpdev_keyhandle[i]=0;
+        }
+   }
+#else
+        Csp1FreeKeyMem(a->key_handle);
+#endif
+#endif
+
 #ifndef OPENSSL_NO_ENGINE
 	if (a->client_cert_engine)
 		ENGINE_finish(a->client_cert_engine);
@@ -1687,8 +1907,14 @@
 	have_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);
 #endif
 	cpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);
+#ifndef CAVIUM_FIPS
 	rsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);
 	rsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);
+#else	
+    rsa_enc = 1;
+    rsa_enc_export = 0;
+#endif
+	
 	cpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);
 	rsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);
 	cpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);
@@ -2040,11 +2266,20 @@
 	unsigned long l;
 	BIO *bio;
 
+#if defined (CAVIUM_SSL) && defined (CAVIUM_NB_CRYPTO)
+    if ( s->cav_crypto_state != 0 ) {
+        return(SSL_ERROR_WANT_CAVIUM_CRYPTO);
+    }
+#endif
 	if (i > 0) return(SSL_ERROR_NONE);
 
 	/* Make things return SSL_ERROR_SYSCALL when doing SSL_do_handshake
 	 * etc, where we do encode the error */
-	if ((l=ERR_peek_error()) != 0)
+	if (((l=ERR_peek_error()) != 0)
+#ifdef CAVIUM_SSL
+             && s->in_handshake
+#endif
+			)
 		{
 		if (ERR_GET_LIB(l) == ERR_LIB_SYS)
 			return(SSL_ERROR_SYSCALL);
diff -Naur openssl-0.9.8j/ssl/ssl_locl.h TurboSSL-0.9.8j/ssl/ssl_locl.h
--- openssl-0.9.8j/ssl/ssl_locl.h	2009-01-05 15:43:07.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/ssl_locl.h	2010-05-31 12:13:09.000000000 +0200
@@ -234,7 +234,9 @@
 #define TWO_BYTE_MASK	0x7fff
 #define THREE_BYTE_MASK	0x3fff
 
+#ifndef INC32
 #define INC32(a)	((a)=((a)+1)&0xffffffffL)
+#endif
 #define DEC32(a)	((a)=((a)-1)&0xffffffffL)
 #define MAX_MAC_SIZE	20 /* up from 16 for SSLv3 */
 
diff -Naur openssl-0.9.8j/ssl/ssl_rsa.c TurboSSL-0.9.8j/ssl/ssl_rsa.c
--- openssl-0.9.8j/ssl/ssl_rsa.c	2008-05-26 08:21:10.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl_rsa.c	2010-05-31 12:13:09.000000000 +0200
@@ -64,8 +64,31 @@
 #include <openssl/x509.h>
 #include <openssl/pem.h>
 
+#ifdef CAVIUM_SSL
+#ifdef CAVIUM_FIPS
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <ctype.h>
+#include "luna_common.h"
+#include "luna_ssl.h"
+#else
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+#endif
+#include "ssl_engine.h"
+#endif
+
+#ifdef CAVIUM_SSL
+extern int pkp_device_present;
+#endif
 static int ssl_set_cert(CERT *c, X509 *x509);
 static int ssl_set_pkey(CERT *c, EVP_PKEY *pkey);
+#if defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+static Uint64 str2hex64(char *str);
+static int get_fips_key_params(const char* file_name, Uint64* key_handle, Uint32* key_size);
+#endif
+
 int SSL_use_certificate(SSL *ssl, X509 *x)
 	{
 	if (x == NULL)
@@ -231,6 +254,13 @@
 	int j,ret=0;
 	BIO *in;
 	RSA *rsa=NULL;
+#if defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+        ret = get_fips_key_params(file, &ssl->key_handle, &ssl->ctx->pkey_info.size);
+        ssl->ctx->pkey_info.type = EVP_PKEY_RSA;
+        ssl->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey = (EVP_PKEY *)&ssl->ctx->pkey_info;
+
+            return (1);
+#endif
 
 	in=BIO_new(BIO_s_file_internal());
 	if (in == NULL)
@@ -316,6 +346,14 @@
 	int j,ret=0;
 	BIO *in;
 	EVP_PKEY *pkey=NULL;
+#if defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+        ret = get_fips_key_params(file, &ssl->key_handle, &ssl->ctx->pkey_info.size);
+        ssl->ctx->pkey_info.type = EVP_PKEY_RSA;
+
+        ssl->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey = (EVP_PKEY *)&ssl->ctx->pkey_info;
+
+         return (1);
+#endif
 
 	in=BIO_new(BIO_s_file_internal());
 	if (in == NULL)
@@ -522,6 +560,12 @@
 	{
 	int ret;
 	EVP_PKEY *pkey;
+#ifdef CAVIUM_SSL
+    int i;
+#ifdef CAVIUM_MULTICARD_API
+    int dev_id=0;
+#endif
+#endif
 
 	if (rsa == NULL)
 		{
@@ -541,8 +585,35 @@
 
 	RSA_up_ref(rsa);
 	EVP_PKEY_assign_RSA(pkey,rsa);
+#ifdef CAVIUM_SSL
+if(pkp_device_present)
+{
+    i = ssl_set_pkey(ctx->cert,pkey);
+    if(i)
+    {
+#ifdef CAVIUM_MULTICARD_API
+        for(dev_id=0; dev_id<ctx->dev_cnt;dev_id++)
+        {
+			if(!(ctx->dev_mask&(1<<dev_id)))
+			continue;
+
+            if(!store_pkey(pkey, &ctx->gpkpdev_keyhandle[dev_id],dev_id))
+                return 0;
+        }
+#else
+        if(!store_pkey(pkey, &ctx->key_handle))
+            return 0;
+#endif
+    }
+    return i;
+}
+else
+	
+	ret=(ssl_set_pkey(ctx->cert,pkey));
+#else
+	ret=(ssl_set_pkey(ctx->cert,pkey));
+#endif
 
-	ret=ssl_set_pkey(ctx->cert, pkey);
 	EVP_PKEY_free(pkey);
 	return(ret);
 	}
@@ -553,6 +624,14 @@
 	int j,ret=0;
 	BIO *in;
 	RSA *rsa=NULL;
+#if defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+        ret = get_fips_key_params(file, &ctx->key_handle, &ctx->pkey_info.size);
+        ctx->pkey_info.type = EVP_PKEY_RSA;
+
+        ctx->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey = (EVP_PKEY *)&ctx->pkey_info;
+
+        return (1);
+#endif
 
 	in=BIO_new(BIO_s_file_internal());
 	if (in == NULL)
@@ -616,6 +695,13 @@
 
 int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)
 	{
+#ifdef CAVIUM_SSL
+    int i;
+#ifdef CAVIUM_MULTICARD_API
+    int dev_id=0;
+#endif
+#endif
+
 	if (pkey == NULL)
 		{
 		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);
@@ -626,7 +712,35 @@
 		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);
 		return(0);
 		}
+#ifdef CAVIUM_SSL 
+    if(pkp_device_present) { 
+        i = ssl_set_pkey(ctx->cert,pkey);
+        if(i)
+        {
+            if(pkey->type != EVP_PKEY_DSA)
+            {
+#ifdef CAVIUM_MULTICARD_API
+               for(dev_id=0; dev_id<ctx->dev_cnt;dev_id++)
+                {
+			        if(!(ctx->dev_mask&(1<<dev_id)))
+				        continue;
+
+                    if(!store_pkey(pkey, &ctx->gpkpdev_keyhandle[dev_id],dev_id))
+                        return 0;
+               }
+#else
+               if(!store_pkey(pkey, &ctx->key_handle))
+                  return 0;
+#endif
+            }
+        }
+        return i;
+    }
+    else
+	return(ssl_set_pkey(ctx->cert,pkey));
+#else
 	return(ssl_set_pkey(ctx->cert,pkey));
+#endif	
 	}
 
 #ifndef OPENSSL_NO_STDIO
@@ -635,6 +749,14 @@
 	int j,ret=0;
 	BIO *in;
 	EVP_PKEY *pkey=NULL;
+#if defined (CAVIUM_SSL) && defined (CAVIUM_FIPS)
+        ret = get_fips_key_params(file, &ctx->key_handle, &ctx->pkey_info.size);
+        ctx->pkey_info.type = EVP_PKEY_RSA;
+
+        ctx->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey = (EVP_PKEY *)&ctx->pkey_info;
+
+            return (1);
+#endif
 
 	in=BIO_new(BIO_s_file_internal());
 	if (in == NULL)
@@ -777,3 +899,80 @@
 	return(ret);
 	}
 #endif
+#if defined(CAVIUM_SSL) && defined(CAVIUM_FIPS)
+
+#define MAX_KEY_BUFFER_LEN 256
+
+static int get_fips_key_params(const char* file_name, Uint64* key_handle, Uint32* key_size)
+{
+     FILE *fPtr = 0;
+     char buffer[MAX_KEY_BUFFER_LEN];
+     size_t bytes_read=0;
+     int loop_counter = 0;
+     int ret = 0;
+
+     fPtr = fopen(file_name, "rt");
+     if (fPtr == NULL)
+     {
+         printf("Unable to open file %s. Returning..\n", file_name);
+         return (1);
+     }
+
+    while (fgets(buffer, MAX_KEY_BUFFER_LEN, fPtr) != NULL )
+    {
+        bytes_read = strlen(buffer);
+
+        if (buffer[0] == ';') continue;
+        if (strtok(buffer, " \r\n") == NULL) continue;
+
+        /*printf("[%d] ==> [%s]\n", bytes_read, buffer);*/
+
+        switch (loop_counter)
+        {
+            case 0:
+              /* key size */
+              *key_size = str2hex64(buffer);
+              break;
+
+             case 1:
+               /* key handle */
+              *key_handle = str2hex64(buffer);
+               break;
+
+             default:
+               printf("Invalid entry in %s file\n", file_name);
+               ret = 1;
+               break;
+        }
+
+        loop_counter++;
+    }
+
+    fclose(fPtr);
+
+    return (ret);
+}
+
+
+static Uint64 str2hex64(char *str)
+{
+  Uint64 hex = 0;
+  char ch;
+
+  if ((*str == '0') && (*(str+1) == 'x')) str += 2;
+
+  while (*str)
+  {
+    hex*=16;
+
+    ch = tolower(*str++);
+
+    if (ch >= '0' && ch <= '9')      hex+= (ch - '0');
+    else if (ch >= 'a' && ch <= 'f') hex+= (ch -'a'+10);
+  }
+
+  return (hex);
+}
+
+#endif
+
diff -Naur openssl-0.9.8j/ssl/ssl_sess.c TurboSSL-0.9.8j/ssl/ssl_sess.c
--- openssl-0.9.8j/ssl/ssl_sess.c	2008-06-04 20:35:27.000000000 +0200
+++ TurboSSL-0.9.8j/ssl/ssl_sess.c	2010-05-31 12:14:16.000000000 +0200
@@ -63,6 +63,14 @@
 #include <openssl/engine.h>
 #endif
 #include "ssl_locl.h"
+#ifdef CAVIUM_SSL
+#include "ssl_engine.h"
+#ifdef CAVIUM_FIPS
+#include "luna_common.h"
+#else
+#include "cavium_common.h"
+#endif
+#endif
 
 static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s);
 static void SSL_SESSION_list_add(SSL_CTX *ctx,SSL_SESSION *s);
@@ -120,8 +128,18 @@
 
 	ss->verify_result = 1; /* avoid 0 (= X509_V_OK) just in case */
 	ss->references=1;
+#ifdef CAVIUM_SSL
+#ifndef NO_SESSION_CACHE
+        ss->timeout=60*5+4; /* 5 minute timeout by default */
+        ss->time=(unsigned long)time(NULL);
+#else
+        ss->timeout=0;
+        ss->time=0;
+#endif
+#else
 	ss->timeout=60*5+4; /* 5 minute timeout by default */
 	ss->time=(unsigned long)time(NULL);
+#endif	
 	ss->prev=NULL;
 	ss->next=NULL;
 	ss->compress_meth=0;
@@ -148,6 +166,10 @@
  * very close to 2^128 (or 2^256) SSL sessions to our server. How you might
  * store that many sessions is perhaps a more interesting question ... */
 
+#ifdef CAVIUM_SSL
+extern int pkp_device_present;
+#endif
+
 #define MAX_SESS_ID_ATTEMPTS 10
 static int def_generate_session_id(const SSL *ssl, unsigned char *id,
 				unsigned int *id_len)
@@ -299,6 +321,9 @@
 	s->session=ss;
 	ss->ssl_version=s->version;
 	ss->verify_result = X509_V_OK;
+#ifdef CAVIUM_SSL
+    ss->dev_id = s->dev_id;
+#endif
 
 	return(1);
 	}
diff -Naur openssl-0.9.8j/ssl/t1_enc.c TurboSSL-0.9.8j/ssl/t1_enc.c
--- openssl-0.9.8j/ssl/t1_enc.c	2009-01-05 15:43:07.000000000 +0100
+++ TurboSSL-0.9.8j/ssl/t1_enc.c	2010-05-31 12:14:39.000000000 +0200
@@ -244,6 +244,10 @@
 	const EVP_MD *m;
 	int is_export,n,i,j,k,exp_label_len,cl;
 	int reuse_dd = 0;
+#ifdef CAVIUM_SSL
+	if (s->cipher_support)
+		return 1;
+#endif
 
 	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
 	c=s->s3->tmp.new_sym_enc;
@@ -458,6 +462,10 @@
 	const EVP_MD *hash;
 	int num;
 	SSL_COMP *comp;
+#ifdef CAVIUM_SSL
+	if (s->cipher_support)
+		return 1;
+#endif
 
 #ifdef KSSL_DEBUG
 	printf ("tls1_setup_key_block()\n");
@@ -727,6 +735,9 @@
 	const EVP_MD *hash;
 	unsigned int md_size;
 	int i;
+#ifndef CAVIUM_SSL	
+    unsigned char *opad,*ipad;
+#endif	
 	HMAC_CTX hmac;
 	unsigned char buf[5]; 
 
@@ -735,6 +746,10 @@
 		rec= &(ssl->s3->wrec);
 		mac_sec= &(ssl->s3->write_mac_secret[0]);
 		seq= &(ssl->s3->write_sequence[0]);
+#ifndef CAVIUM_SSL 
+       opad = &(ssl->s3->write_opad_hash[0]);
+       ipad = &(ssl->s3->write_ipad_hash[0]);
+#endif
 		hash=ssl->write_hash;
 		}
 	else
@@ -742,6 +757,10 @@
 		rec= &(ssl->s3->rrec);
 		mac_sec= &(ssl->s3->read_mac_secret[0]);
 		seq= &(ssl->s3->read_sequence[0]);
+#ifndef CAVIUM_SSL 
+       opad = &(ssl->s3->read_opad_hash[0]);
+       ipad = &(ssl->s3->read_ipad_hash[0]);
+#endif
 		hash=ssl->read_hash;
 		}
 
@@ -763,7 +782,18 @@
 
 	/* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
 	HMAC_CTX_init(&hmac);
+#ifndef CAVIUM_SSL
+    if(ssl->handshake_support)
+        HMAC_New_Init_ex(&hmac,ipad,opad,hash);
+    else
+#endif
 	HMAC_Init_ex(&hmac,mac_sec,EVP_MD_size(hash),hash,NULL);
+#ifndef CAVIUM_SSL
+    if(ssl->record_process)  {
+        EVP_Copy_Pad(&(hmac.i_ctx),ipad);
+        EVP_Copy_Pad(&(hmac.o_ctx),opad);
+    }
+#endif
 
 	if (ssl->version == DTLS1_VERSION && ssl->client_version != DTLS1_BAD_VER)
 		{

diff -Naur openssl-0.9.8j/test/Makefile TurboSSL-0.9.8j/test/Makefile
--- openssl-0.9.8j/test/Makefile	2008-12-13 13:22:47.000000000 +0100
+++ TurboSSL-0.9.8j/test/Makefile	2010-05-31 12:13:09.000000000 +0200
@@ -5,7 +5,13 @@
 DIR=		test
 TOP=		..
 CC=		cc
-INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES) -I$(TOP)/fips
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../api
+else
+CAVIUM_INCLUDEDIR := $(shell /bin/pwd)/../../../include
+endif
+INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES) -I$(CAVIUM_INCLUDEDIR) -I$(TOP)/fips
+#INCLUDES=	-I$(TOP) -I../include $(KRB5_INCLUDES) -I$(TOP)/fips
 CFLAG=		-g
 MAKEDEPEND=	$(TOP)/util/domd $(TOP) -MD $(MAKEDEPPROG)
 PERL=		perl
@@ -154,6 +160,16 @@
 apps:
 	@(cd ..; $(MAKE) DIRS=apps all)
 
+ifeq ($(findstring CAVIUM_FIPS,$(CFLAG)),CAVIUM_FIPS)
+alltests: \
+	test_des test_idea test_sha test_md4 test_md5 test_hmac \
+	test_md2 test_mdc2 \
+	test_rmd test_rc2 test_rc4 test_rc5 test_bf test_cast test_aes \
+	test_rand test_bn test_ec test_ecdsa test_ecdh \
+	test_enc test_x509 test_rsa test_crl test_sid \
+	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
+	test_ss test_ca test_engine test_evp 
+else
 alltests: \
 	test_des test_idea test_sha test_md4 test_md5 test_hmac \
 	test_md2 test_mdc2 \
@@ -162,6 +178,7 @@
 	test_enc test_x509 test_rsa test_crl test_sid \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_ssl test_ige test_jpake
+endif
 
 test_evp:
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
