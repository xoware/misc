diff -Naur openssl-0.9.8r-orig/include/cavium_be.h openssl-0.9.8r/include/cavium_be.h
--- openssl-0.9.8r-orig/include/cavium_be.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_be.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,101 @@
+/* cavium_be.h */
+/*
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#ifndef _CAVIUM_ENDIAN_H
+#define _CAVIUM_ENDIAN_H
+
+#define CAVIUM_ENDIAN	__CAVIUM_BIG_ENDIAN
+
+#if 0
+#define COMPLETION_CODE_VALUE((p))	(Uint8 *)((p) >> COMPLETION_CODE_SHIFT)
+#endif
+
+#define ENDIAN_SWAP_8_BYTE(_i) \
+  ((((((Uint64)(_i)) >>  0) & (Uint64)0xff) << 56) | \
+   (((((Uint64)(_i)) >>  8) & (Uint64)0xff) << 48) | \
+   (((((Uint64)(_i)) >> 16) & (Uint64)0xff) << 40) | \
+   (((((Uint64)(_i)) >> 24) & (Uint64)0xff) << 32) | \
+   (((((Uint64)(_i)) >> 32) & (Uint64)0xff) << 24) | \
+   (((((Uint64)(_i)) >> 40) & (Uint64)0xff) << 16) | \
+   (((((Uint64)(_i)) >> 48) & (Uint64)0xff) <<  8) | \
+   (((((Uint64)(_i)) >> 56) & (Uint64)0xff) <<  0))
+
+#ifndef htobe64
+#define htobe64(_i)	(_i)
+#define htobe32(_i)	(_i)
+#define htobe16(_i)	(_i)
+#endif
+
+#ifndef htole64
+#define htole64(_i) ENDIAN_SWAP_8_BYTE((_i))
+#endif
+
+#define betoh64(_i)	(_i)
+#define letoh64(_i) ENDIAN_SWAP_8_BYTE((_i))
+#define betoh32(_i)	(_i)
+#define betoh16(_i)	(_i)
+
+#endif
+
+/*
+ * $Id: cavium_be.h,v 1.3 2009/06/11 08:02:33 aravikumar Exp $
+ * $Log: cavium_be.h,v $
+ * Revision 1.3  2009/06/11 08:02:33  aravikumar
+ * Changes made for FC-10
+ *
+ * Revision 1.2  2007/02/02 02:36:13  panicker
+ * * _ENDIAN definition in linux_sysdep.h
+ *
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.2  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.1  2004/06/10 05:14:41  bimran
+ * big endian macros
+ *
+ */
+
diff -Naur openssl-0.9.8r-orig/include/cavium_common.h openssl-0.9.8r/include/cavium_common.h
--- openssl-0.9.8r-orig/include/cavium_common.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_common.h	2013-08-02 13:25:41.248718729 +0200
@@ -0,0 +1,3189 @@
+/*! \file cavium_common.h */
+/*!\page page2 API Copyright
+ * \section Copyright_Api  API copyright
+ * \verbatim
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ * \endverbatim
+ */
+
+/*! \defgroup GP_OPS    General Purpose APIs */
+/*! \defgroup SSL_OPS   SSL APIs */
+/*! \defgroup IPSEC_OPS   IPSEC APIs */
+/*! \defgroup MISC      Misc APIs */
+#ifndef _CAVIUM_COMMON_H_
+#define _CAVIUM_COMMON_H_
+
+#ifndef CAVIUM_NO_MMAP
+#define CAVIUM_NO_MMAP
+#endif
+
+#ifndef INTERRUPT_ON_COMP
+#define INTERRUPT_ON_COMP
+#endif
+
+#ifndef CAVIUM_HUGE_MEMORY
+#define CAVIUM_HUGE_MEMORY
+#endif
+
+//#include "app_defines.h"
+//#define IPSEC_SCATTER_GATHER
+#define OP_IPSEC_PACKET_INBOUND                 0x10
+#define OP_IPSEC_PACKET_OUTBOUND                0x11
+
+#define N1_OPERATION_CODE   1
+#define N1_ALLOC_CONTEXT   2
+#define N1_FREE_CONTEXT      3
+#define N1_REQUEST_STATUS   4
+#define N1_ALLOC_KEYMEM         5
+#define N1_FREE_KEYMEM          6
+#define N1_WRITE_KEYMEM         7
+#define N1_FLUSH_ALL_CODE       8
+#define N1_FLUSH_CODE           9
+#define N1_DEBUG_WRITE_CODE   10
+#define N1_DEBUG_READ_CODE   11
+#define PCI_DEBUG_WRITE_CODE   12
+#define PCI_DEBUG_READ_CODE   13
+#define N1_INIT_CODE      14
+#define N1_SOFT_RESET_CODE   15
+#define N1_API_TEST_CODE   16
+#define N1_SG_OPERATION_CODE   17
+#define N1_GET_RANDOM_CODE   20   
+#define N1_GET_DEV_CNT       22
+#define N1_GET_ALL_REQUEST_STATUS  23
+#define N1_GET_DEVICE_TYPE   25  
+#define N1_GET_STATUS_DDR   26  
+#define N1_CORE_ASSIGNMENT   24
+#define N1_GET_DRIVER_STATE 27
+
+#define MAJOR_OP_INIT 0
+#define MAJOR_OP_RANDOM_WRITE_CONTEXT 1
+#define MAJOR_OP_ME_PKCS_LARGE 2
+#define MAJOR_OP_RSASERVER_LARGE 3
+#define MAJOR_OP_ME_PKCS 4
+#define MAJOR_OP_RSASERVER 5
+#define MAJOR_OP_HASH 6
+#define MAJOR_OP_HMAC 7
+#define MAJOR_OP_HANDSHAKE 8
+#define MAJOR_OP_OTHER 10
+#define MAJOR_OP_FINISHED 11
+#define MAJOR_OP_RESUME 12
+#define MAJOR_OP_ENCRYPT_DECRYPT_RECORD 13
+#define MAJOR_OP_ENCRYPT_DECRYPT 14
+#define MAJOR_OP_ACQUIRE_CORE 4
+
+/* boot and admin codes */
+#define OP_BOOT_INIT            0x0000
+#define OP_BOOT_SETUP_UCODE         0x0016
+#define OP_BOOT_LOAD_UCODE         0x0015
+#if 0
+#define OP_BOOT_IMPORT_PKCS_KEY      0x0115
+#define OP_ADMIN_SETUP_UCODE      0x0016   /* ??? */
+#define OP_ADMIN_GEN_RSA_KEY_PAIR   0x0016   /* ??? */
+#define OP_ADMIN_SIGN            0x0017   /* ??? */
+#define OP_ADMIN_LOAD_UCODE         0x0015
+#define OP_ADMIN_LOGIN            0x0215
+#define OP_ADMIN_LOGOUT            0x0415
+#define OP_ADMIN_EXPORT_KEY_PKCS8   0x0815
+#define OP_ADMIN_IMPORT_KEY_PKCS8   0x1015
+#define OP_ADMIN_DELETE_KEY         0x0215
+#endif /* if 0 */
+
+/*microcode types*/
+#define CODE_TYPE_MAINLINE   1
+#define CODE_TYPE_BOOT      2
+#define CODE_TYPE_SPECIAL   3
+
+#define CODE_TYPE_ADMIN   CODE_TYPE_SPECIAL
+
+#define NPX_DEVICE      0x0010
+#define N1_LITE_DEVICE  0x0003
+#define N1_DEVICE       0x0001
+
+/* Driver state */
+#define DRV_ST_SSL_DFL     0  /* ssl running with default cores */
+#define DRV_ST_SSL_CORES   1  /* ssl running with specified number of cores */
+#define DRV_ST_IPSEC_DFL   2  /* ipsec running with default cores */ 
+#define DRV_ST_IPSEC_CORES 3  /* ipsec running with specified number of cores */
+#define DRV_ST_SSL_IPSEC   4  /* driver running with both ssl and ipsec */
+#define DRV_ST_UNKNOWN     5  
+
+#ifndef MC2
+/*! \enum HashType Sha-1 or MD-5 */
+typedef enum
+{ SHA1_TYPE = 0, MD5_TYPE = 1 }
+HashType;
+/*! \enum AesType AES128CBC AES192CBC AES256CBC*/
+typedef enum
+{ AES_128 = 0, AES_192 = 1, AES_256 = 2 }
+AesType;
+#else
+/*! \enum HashType Sha-256 or Sha-1 or MD-5 */
+typedef enum
+{ SHA512_TYPE = 5, SHA384_TYPE = 4, SHA256_TYPE = 3, SHA1_TYPE = 2, MD5_TYPE = 1 }
+HashType;
+/*! \enum AesType AES128CBC AES192CBC AES256CBC*/
+typedef enum
+{ AES_128 = 5, AES_192 = 6, AES_256 = 7}
+AesType;
+#endif
+/*! \enum RsaBlockType Public BT1 Private BT2*/
+typedef enum
+{ BT1 = 0, BT2 = 1 }
+RsaBlockType;
+/*! \enum ContextUpdate YES/NO*/
+typedef enum
+{ CAVIUM_NO_UPDATE = 0, CAVIUM_UPDATE = 1 }
+ContextUpdate;
+
+/*! \enum ContextType Context Type to allocate or deallocate */
+typedef enum
+{ CONTEXT_SSL = 0, CONTEXT_IPSEC = 1 , CONTEXT_ECC_P256 = 2, CONTEXT_ECC_P384 = 3}
+ContextType;
+/*! \enum RsaModExType Normal or Chinese Remainder Theorem */
+typedef enum
+{ NORMAL_MOD_EX = 0, CRT_MOD_EX = 1 }
+RsaModExType;
+
+/*! \enum KeyMaterialInput How Key Material is stored */
+typedef enum
+{ READ_INTERNAL_SRAM = 0, KEY_HANDLE = 0, INPUT_DATA = 1, READ_LOCAL_DDR =
+    2, READ_LOCAL_HOST = 3 }
+KeyMaterialInput;
+
+/*! \enum KeyMaterialLocation Where Key Material is stored */
+typedef enum {INTERNAL_SRAM = 0, HOST_MEM = 1, LOCAL_DDR = 2} KeyMaterialLocation;
+
+/* \enum  EncryptionAlgorithmIndentifier */
+typedef enum
+{ PBE_MD2_DES_CBC = 0x51, PBE_MD5_DES_CBC = 0x53 }
+EncryptionAlgorithmIdentifier;
+
+/*! \enum Csp1ResponseOrder */
+typedef enum
+{ CAVIUM_RESPONSE_ORDERED = 0, CAVIUM_RESPONSE_UNORDERED = 1, CAVIUM_RESPONSE_REALTIME=2 }
+Csp1ResponseOrder, n1_response_order;
+
+
+/* Csp1RequestType Blocking or NonBlocking */
+/*! \enum n1_request_type Blocking, Non-Blocking, Signal*/
+typedef enum
+{ CAVIUM_BLOCKING = 0, CAVIUM_NON_BLOCKING = 1, CAVIUM_SIGNAL = 2, CAVIUM_SPEED = 3 }
+n1_request_type, Csp1RequestType;
+
+/*! \enum n1_request_type Blocking or NonBlocking #Csp1RequestType */
+
+/*! \enum Csp1DmaMode Direct or Scatter Gather*/
+typedef enum
+{ CAVIUM_DIRECT = 0, CAVIUM_SCATTER_GATHER = 1 }
+Csp1DmaMode, n1_dma_mode, DmaMode;
+
+/*! \enum Csp1MicrocodeType Ipsec or SSL/GP Ops*/
+typedef enum
+{ CAVIUM_IPSEC_MICROCODE = 0, CAVIUM_SSL_MICROCODE = 1, CAVIUM_GP_GRP = 0, CAVIUM_SSL_GRP = 1, CAVIUM_IPSEC_GRP = 2 }
+Csp1MicrocodeType, Csp1Group;
+
+/*! \enum ResultLocation Cptr or Rptr */
+typedef enum
+{ CONTEXT_PTR = 0, RESULT_PTR = 1 }
+ResultLocation;
+
+/*! \enum Csp1InterruptMode */
+typedef enum
+{ CAVIUM_NO_INTERRUPT = 0, CAVIUM_GEN_INTERRUPT = 1 }
+Csp1InterruptMode;
+
+/*! \enum Csp1SgMode */
+typedef enum
+{ CAVIUM_SG_READ = 0, CAVIUM_SG_WRITE = 1 }
+Csp1SgMode;
+
+/*
+ * IPSEC and IKE enumerated constants 
+ */
+typedef enum
+{ TRANSPORT = 0, TUNNEL = 1 }
+IpsecMode;
+typedef enum
+{ AH = 0, ESP = 1 }
+IpsecProto;
+typedef enum
+{ IPV4 = 0, IPV6 = 1 }
+Version;
+#ifndef MC2
+typedef enum
+{ NO_CYPHER = 0, DES3CBC = 1, AES128CBC = 2, AES192CBC = 3, AES256CBC =
+    4, DESCBC = 9 }
+EncType;
+#else
+typedef enum
+{ NO_CYPHER = 0, DESCBC = 1, DES3CBC = 2, AES128CBC = 3, AES192CBC =
+    4, AES256CBC = 5 }
+EncType;
+typedef enum
+{ INVALID_SA = 0, VALID_SA = 1 }
+ValidSa;
+#endif
+typedef enum
+{ NO_AUTH = 0, MD5HMAC96 = 1, SHA1HMAC96 = 2 }
+AuthType;
+typedef enum
+{ IPSEC_NO_ERROR = 0, LENGTH_INCORRECT = 1, MODE_INCORRECT = 2, PROTOCOL_INCORRECT =
+    3,
+  AUTH_INCORRECT = 4, PADDING_INCORRECT = 5
+}
+IpsecError;
+typedef enum
+{ INBOUND = 0, OUTBOUND = 1 } 
+Direction;
+typedef enum {POST_FRAG=0, PRE_FRAG=1} FragType;
+
+#include "cavium_sysdep.h"
+
+#ifndef ROUNDUP4
+#define ROUNDUP4(val) (((val) + 3)&0xfffffffc)
+#endif
+
+#ifndef ROUNDUP8
+#define ROUNDUP8(val) (((val) + 7)&0xfffffff8)
+#endif
+
+#ifndef ROUNDUP16
+#define ROUNDUP16(val) (((val) + 15)&0xfffffff0)
+#endif
+
+#ifdef PORT_TO_64BIT
+typedef Uint64 VOIDPTR;
+typedef Uint64 UINT8PTR;
+typedef Uint64 UINT16PTR;
+typedef Uint64 UINT32PTR;
+typedef Uint64 UINT64PTR;
+typedef Uint64 CBFUNCPTR;
+
+#define CAST_TO_X_PTR (Uint64)(ptrlong)
+#define CAST_FRM_X_PTR (void *)(ptrlong)
+
+#else
+typedef void *  VOIDPTR;
+typedef Uint8 * UINT8PTR;
+typedef Uint16 * UINT16PTR;
+typedef Uint32 * UINT32PTR;
+typedef Uint64 * UINT64PTR;
+typedef void (*CBFUNCPTR) (int, void *);
+#define CAST_TO_X_PTR
+#define CAST_FRM_X_PTR
+#endif
+
+#ifdef CSP1_KERNEL
+
+
+typedef struct _cmd
+{
+  Uint16 opcode;
+  Uint16 size;
+  Uint16 param;
+  Uint16 dlen;
+}
+Cmd;
+
+typedef struct _Request
+{
+  Uint64 cmd;         /* command portion of request */
+  Uint64 dptr;         /* pointer to data buffer */
+  Uint64 rptr;         /* pointer to result buffer */
+  Uint64 cptr;         /* pointer to context */
+}
+Request;
+
+#define INVALID_CORE 255
+
+/* Core tracking data */
+typedef struct core {
+   Uint8   next_id;
+   Uint8   ucode_idx;
+   Uint8   ready;
+   Uint8   pend2048;
+   int     lrsrq_idx; /* Index of last SRQ request */
+   Uint32  doorbell;
+   volatile Uint64  *lrcc_ptr;
+   Uint8   *ctp_ptr;
+   int     ctp_idx;
+   int     ctp_srq_idx;
+}core_t;
+
+
+/* Max entries in SRQ */
+#define MAX_SRQ_SIZE 1000
+#define MAX_SRQ_NORMAL 900 /* 100 entries for Priority commands */
+#define HIGH_PRIO_QUEUE 2
+
+/* States of entries in SRQ */
+#define SR_FREE      0
+#define SR_IN_USE    1
+#define SR_IN_CTP    2
+
+/* Soft Request Queue */
+typedef struct {
+   cavium_spinlock_t lock;
+   Uint32   head;
+   Uint32   tail;
+   Uint32   qsize;
+   volatile Uint64   *ccptr[MAX_SRQ_SIZE];
+   Uint8    state[MAX_SRQ_SIZE];
+   Uint8    core_id[MAX_SRQ_SIZE];
+   Request  queue[MAX_SRQ_SIZE];
+} softreq_t;
+
+#define SRAM_ADDRESS_LEN 8
+
+struct MICROCODE
+{
+   Uint8 core_grp; /* core groups are used only for PX_PLUS mode. */
+   Uint8 code_type;
+   Uint8 *code;
+   Uint32 code_size; /* in bytes*/
+   Uint8 *data;     /* constants */
+   Uint32 data_size; /* in bytes*/
+   Uint8 sram_address[SRAM_ADDRESS_LEN];
+   cavium_dmaaddr  data_dma_addr;
+   Uint8 core_id;
+                      /* Paired cores and software queues */
+   Uint8 paired_cores;                  /* are not supported in PX_PLUS mode */
+   /* Software Request Queue */
+   softreq_t srq;
+   /* Use count */
+   int use_count;
+};
+
+#endif /* CSP1_KERNEL */
+
+#define OP_DECRYPT         1
+#ifndef MC2
+#define IPSEC_DIRECTION_SHIFT 1
+#define IPSEC_VERSION_SHIFT 2
+#define IPSEC_MODE_SHIFT 3
+#define IPSEC_PROT_SHIFT 4
+#define IPSEC_AUTH_SHIFT 5
+#define IPSEC_CIPHER_SHIFT 8
+#define IPSEC_DF_SHIFT 12
+#define IPSEC_UDP_SHIFT 13
+#define IPSEC_COMPARE_SHIFT      14
+#define IPSEC_INTERRUPT_SHIFT      15
+#else
+#define IPSEC_VALID_SHIFT 0
+#define IPSEC_DIRECTION_SHIFT 1
+#define IPSEC_VERSION_SHIFT 2
+#define IPSEC_MODE_SHIFT 4
+#define IPSEC_PROT_SHIFT 5
+#define IPSEC_ENCAP_SHIFT 6
+#define IPSEC_CIPHER_SHIFT 8
+#define IPSEC_AUTH_SHIFT 11
+#define IPSEC_DF_SHIFT 13
+#define IPSEC_SELECTOR_SHIFT 13
+#define IPSEC_FT_SHIFT 14
+#define IPSEC_SELECTOR_TYPE_SHIFT 14
+#define IPSEC_NEXT_SA_SHIFT 15
+#endif
+
+#define CIPHER_KEY_OFFSET   0
+#define ESP_OFFSET      32
+#define IV_OFFSET      40
+#define HMAC_OFFSET      56
+
+typedef struct
+{
+  Csp1RequestType request_type;
+  Csp1ResponseOrder response_order;
+  Csp1DmaMode dma_mode;
+  Csp1InterruptMode interrupt_mode;
+  Csp1MicrocodeType microcode_type;
+}
+Csp1RequestInfo;
+
+
+#define MAX_INCNT    32
+#define MAX_OUTCNT   32
+#define MAX_BUFCNT   MAX_INCNT
+
+typedef struct
+{
+  Uint16 opcode;
+  Uint16 size;
+  Uint16 param;
+  Uint16 dlen;         /* length in bytes of the input data */
+  Uint16 rlen;         /* length in bytes of the output data */
+  Uint16 incnt;         /* for getting a pointer to the data */
+  Uint16 outcnt;      /* for getting a pointer to the data */
+  Uint16 reserved;      /* for future use */
+
+  Uint32 insize[MAX_INCNT];
+  Uint32 inoffset[MAX_INCNT];
+  Uint32 inunit[MAX_INCNT];
+  Uint32 outsize[MAX_OUTCNT];
+  Uint32 outoffset[MAX_OUTCNT];
+  Uint32 outunit[MAX_OUTCNT];
+  Uint32 request_id;
+  Uint32 time_in;
+  Uint32 timeout;
+  Uint32 req_queue;
+
+  n1_dma_mode dma_mode;
+  n1_request_type req_type;   /* Only for op buf */
+  n1_response_order res_order;
+  Uint32  status; /*To store the status of Operation i.e. EAGAIN/SUCCESS('0')*/
+
+  Uint64 ctx_ptr ;
+  UINT8PTR inptr[MAX_INCNT];
+  UINT8PTR outptr[MAX_OUTCNT];
+  CBFUNCPTR callback; /* void (*callback) (int, void *);*/
+  VOIDPTR cb_arg;
+  UINT64PTR completion_address;
+  Csp1Group group;
+  int  ucode_idx;
+  Uint8  resvd2[4]; //reserved field to ensure 64-bit alignement of structure.
+  Uint8 resvd3[OP_BUF_ALIGN];
+}
+Csp1OperationBuffer, n1_request_buffer, n1_operation_buffer;
+
+
+typedef struct
+{
+  Uint16 bufcnt;
+  Uint32 *bufptr[MAX_BUFCNT];
+  Uint32 bufsize[MAX_BUFCNT];
+}
+Csp1ScatterBuffer, n1_scatter_buffer;
+
+
+typedef struct
+{
+  Uint32 condition_code;
+  Uint64 ctx_ptr;
+}
+Csp1ResponseBuffer;
+
+typedef struct {
+    Uint32 request_id;
+    Uint32 status;
+} Csp1RequestStatusBuffer;
+
+typedef struct {
+    /*input */
+    Uint32 cnt; /* length of req_stat_buf in size multiple of Csp1RequestStatusBuffer size */
+    /*output */
+    Uint32 res_count;           /* number of elements update by driver */
+   
+   Uint64 req_stat_buf;/* pointer to "Csp1RequestStatusBuffer" */
+} Csp1StatusOperationBuffer;
+
+#define BOOT_IDX 0
+#define MICROCODE_MAX   3
+
+#define UCODE_IDX 1
+
+#define FREE_IDX BOOT_IDX
+#define MAX_INIT MICROCODE_MAX
+
+typedef struct 
+{
+   Uint8  mc_present[MICROCODE_MAX];
+   Uint32 core_mask[MICROCODE_MAX]; 
+} Csp1CoreAssignment;
+
+typedef struct
+{
+  Uint32 dev_cnt;
+  Uint8  dev_mask;
+}Csp1DevMask,n1_dev_mask;
+
+typedef struct
+{
+   Uint8 size;         /* number of init buffers */
+   Uint8 resvd1[7];   /*reserved field for Alignment.*/
+   Uint8 version_info[MAX_INIT][32];
+   Uint8 sram_address[MAX_INIT][8];
+   Uint8 signature[MAX_INIT][256];
+
+   Uint32 code_length[MAX_INIT];
+   Uint32 data_length[MAX_INIT];
+
+   UINT8PTR code[MAX_INIT];
+   UINT8PTR data[MAX_INIT];
+
+   Uint8 ucode_idx[MAX_INIT];
+   Uint8 resvd2[8-MAX_INIT];
+} Csp1InitBuffer;
+
+
+typedef struct _Selector
+{
+        Uint8 protocol;
+
+        Uint16 src_port_upper;
+
+#define SELECTOR(ps) ((void*)&(ps)->src_port_upper)
+#define SELECTOR_SIZE(v) (((v) == IPV4) ? 24 : 72)
+
+}__attribute__((__packed__)) Selector;
+
+typedef struct _Ipv4Selector
+{
+        Uint8 protocol;
+
+        Uint16 src_port_upper;
+        Uint16 src_port_lower;
+        Uint16 dst_port_upper;
+        Uint16 dst_port_lower;
+
+        Uint32 src_addr_upper;
+        Uint32 src_addr_lower;
+        Uint32 dst_addr_upper;
+        Uint32 dst_addr_lower;
+} __attribute__((__packed__))Ipv4Selector;
+
+typedef struct _Ipv6Selector
+{
+        Uint8 protocol;
+
+        Uint16 src_port_upper;
+        Uint16 src_port_lower;
+        Uint16 dst_port_upper;
+        Uint16 dst_port_lower;
+
+        Uint32 src_addr_upper[4];
+        Uint32 src_addr_lower[4];
+        Uint32 dst_addr_upper[4];
+        Uint32 dst_addr_lower[4];
+} __attribute__((__packed__))Ipv6Selector;
+
+/*! \enum Csp1ErrorCodes FAILURE/PENDING codes*/
+typedef enum
+{
+  /* Driver */
+  ERR_DRIVER_NOT_READY = (0x40000000 | 256),   /* 0x40000100 */
+  ERR_MEMORY_ALLOC_FAILURE,          /* 0x40000101 */
+  ERR_DOOR_BEL_TIMEOUT,            /* 0x40000102 */
+  ERR_REQ_TIMEOUT,            /* 0x40000103 */
+  ERR_CONTEXT_ALLOC_FAILURE,         /* 0x40000104 */
+  ERR_CONTEXT_DEALLOC_FAILURE,         /* 0x40000105 */
+  ERR_KEY_MEM_ALLOC_FAILURE,         /* 0x40000106 */
+  ERR_KEY_MEM_DEALLOC_FAILURE,         /* 0x40000107 */
+  ERR_UCODE_LOAD_FAILURE,         /* 0x40000108 */
+  ERR_INIT_FAILURE,            /* 0x40000109 */
+  ERR_EXEC_WAIT_TIMEOUT,         /* 0x4000010a */
+  ERR_OUTBOUND_FIFO_WAIT_TIMEOUT,      /* 0x4000010b */
+  ERR_INVALID_COMMAND,            /* 0x4000010c */
+  ERR_SCATTER_GATHER_SETUP_FAILURE,      /* 0x4000010d */
+  ERR_OPERATION_NOT_SUPPORTED,         /* 0x4000010e */
+  ERR_NO_MORE_DEVICE,            /* 0x4000010f */
+  ERR_REQ_PENDING,            /* 0x40000110 */
+  ERR_DIRECT_SETUP_FAILURE,         /* 0x40000111 */
+  ERR_INVALID_REQ_ID,            /* 0x40000112 */
+  ERR_ILLEGAL_ASSIGNMENT,         /* 0x40000113 */
+  ERR_DMA_MAP_FAILURE,            /* 0x40000114 */
+  ERR_UNKNOWN_ERROR,            /* 0x40000115 */
+
+  /* API Layer */
+  ERR_ILLEGAL_INPUT_LENGTH = (0x40000000 | 384),/* 0x40000180 */
+  ERR_ILLEGAL_OUTPUT_LENGTH,         /* 0x40000181 */
+  ERR_ILLEGAL_KEY_LENGTH,         /* 0x40000182 */
+  ERR_ILLEGAL_KEY_HANDLE,         /* 0x40000183 */
+  ERR_ILLEGAL_CONTEXT_HANDLE,         /* 0x40000184 */
+  ERR_ILLEGAL_BLOCK_TYPE,         /* 0x40000185 */
+  ERR_ILLEGAL_KEY_MATERIAL_INPUT,      /* 0x40000186 */
+  ERR_BAD_PKCS_PAD_OR_LENGTH,         /* 0x40000187 */
+  ERR_BAD_CIPHER_OR_MAC,         /* 0x40000188 */
+  ERR_ILLEGAL_MOD_EX_TYPE,         /* 0x40000189 */
+
+  ERR_ECC_ILLEGAL_ARGUMENT     = (0x40000000 | 512)+0,
+  ERR_ECC_UNSUPPORTED_ARGUMENT,
+  ERR_ECC_OUT_OF_MEMORY,
+  ERR_ECC_MAX_ECRNG_RANDOM_INT_TRIALS_EXCEED,
+  ERR_ECC_INTERNAL_FAILURE
+}Csp1ErrorCodes;
+
+/* Microcode generated error codes */
+/*!\page page1 General Info
+ * \section errorCodes  Error Codes Info
+ * \verbatim
+ * SSL1.x error codes 
+ * ------------------
+ *
+ *  ERR_BAD_RECORD               0x40000002 
+ *  There was a MAC miscompare or otherwise a record was found bad on a 
+ *  decrypt.
+ *  
+ *  ERR_BAD_SIZE_OR_DLEN_VAL            0x4000000b
+ *  Either the size of the request was bad or the read stream input length
+ *  (indicated either by the Dlen value or the scatter/gather list) did not
+ *  match the length expected by the request.
+ *  
+ *  ERR_BAD_PKCS_PAD_OR_LENGTH            0x4000000c
+ *  A PKCS#1v15 decrypt found a bad pad value or length
+ *
+ *  ERR_BAD_PKCS_TYPE               0x4000000e
+ *  A PKCS#1v15 decrypt found a bad type.
+ *  
+ *  ERR_BAD_SCATTER_GATHER_WRITE_LENGTH         0x4000000d
+ *  The write stream length indicated by the scatter list did not match the
+ *  write stream length of the request.
+ *
+ *
+ * IPsec 1.x error codes
+ * ---------------------
+ * 
+ *  BAD_PACKET_LENGTH               0x40000080
+ *  BAD_IPSEC_MODE               0x40000081
+ *  BAD_IPSEC_PROTOCOL               0x40000082
+ *  BAD_IPSEC_AUTHENTICATION            0x40000083
+ *  BAD_IPSEC_PADDING               0x40000084
+ *  BAD_IP_VERSION               0x40000085
+ *  BAD_IPSEC_AUTH_TYPE               0x40000086
+ *  BAD_IPSEC_ENCRYPT_TYPE            0x40000087
+ *  BAD_IKE_DH_GROUP               0x40000088
+ *  BAD_MODLENGTH               0x40000089
+ *  BAD_PKCS_PAD_OR_LENGTH            0x4000008a
+ *  BAD_PKCS_TYPE               0x4000008b
+ *  BAD_IPSEC_SPI               0x4000008c
+ *  BAD_CHECKSUM               0x4000008d
+ *  BAD_IPSEC_CONTEXT               0x4000008e
+ *
+ *
+ * MC2 (Microcode 2.x) SSL and IPsec combined error codes
+ * ------------------------------------------------------
+ *
+ * BAD_OPCODE                  0x40000001
+ * BAD_RECORD                  0x40000002
+ * BAD_SCATTER_GATHER_LIST            0x40000003
+ * BAD_ICV_AESGCM              0x4000000c
+ * BAD_KEY_LENGTH_AESGCM       0x40000010
+ * BAD_SCATTER_GATHER_WRITE_LENGTH         0x4000000d
+ * BAD_LENGTH                  0x4000000f 
+ * BAD_BOOT_COMPLETION               0x40000011
+ * BAD_PACKET_LENGTH               0x40000012
+ * BAD_IPSEC_MODE               0x40000013
+ * BAD_IPSEC_PROTOCOL               0x40000014
+ * BAD_IPSEC_AUTHENTICATION            0x40000015
+ * BAD_IPSEC_PADDING               0x40000016
+ * BAD_IP_VERSION               0x40000017
+ * BAD_AUTH_TYPE               0x40000018
+ * BAD_PKCS_DATA               0x4000001b
+ * BAD_IPSEC_SPI               0x4000001c
+ * BAD_CHECKSUM                  0x4000001d
+ * BAD_IPSEC_CONTEXT               0x4000001e
+ * BAD_IPSEC_CONTEXT_DIRECTION            0x4000001f
+ * BAD_IPSEC_CONTEXT_FLAG_MISMATCH         0x40000020
+ * IPCOMP_PAYLOAD               0x40000021
+ * BAD_FRAG_OFFSET               0x40000022
+ * BAD_SELECTOR_MATCH               0x40000023
+ * BAD_AES_TYPE                  0x40000024
+ * BAD_FRAGMENT_SIZE               0x40000026
+ * BAD_DSA_VERIFY               0x40000027
+ * BAD_PUBLIC_KEY               0x40000028
+ * BAD_IKE_DH_GROUP               0x4000002b
+ *
+ * \endverbatim
+ */
+
+
+enum
+{
+  UNIT_8_BIT,
+  UNIT_16_BIT,
+  UNIT_32_BIT,
+  UNIT_64_BIT
+};
+
+
+typedef struct
+{
+  Uint16 opcode;
+  Uint8 *inptr0;
+  Uint32 insize0;
+  Uint8 *inptr1;
+  Uint32 insize1;
+  Uint8 *inptr2;
+  Uint32 insize2;
+}
+DownloadBuffer;
+
+
+typedef struct
+{
+  unsigned long  addr;
+  unsigned long  data;
+}
+DebugRWReg;
+
+
+typedef struct
+{
+  unsigned long timeout_max;
+}
+Csp1Config;
+
+typedef struct
+{
+  Uint64 ctx_ptr;
+  ContextType type;
+  Uint8   resvd[8-sizeof(ContextType)];  /*reserved field for Alignment*/
+}
+n1_context_buf;
+
+
+/* Store Key Buffer */
+typedef struct
+{
+  Uint64 key_handle;
+  /*Uint8 *key;*/
+  UINT8PTR key;
+  Uint16 length;
+  Uint8  resvd[KEY_BUF_ALIGN]; /*reserved field for Alignment*/
+}
+n1_write_key_buf;
+
+/* Store Speed_Test_Info buffer  */
+typedef struct
+{
+  Uint64 time_taken;   /* microseconds */
+  Uint64 req_completed;
+  Uint64 dlen;
+  Uint64 rlen;
+}
+Speed_Test_Info;
+
+
+/*+***************************************************************************/
+/*!\ingroup GP_MISC
+ *
+ * SpeedTestResult
+ *
+ * Calculate the result of speedtest
+ *       
+ * Input  
+ *  info = information of speedtest.
+ *      
+ * Output
+ *           
+ * Return Value
+ *      ret = speed values in Mbps 
+              0 (if time_taken = 0 microsecond )
+ */  
+/*-****************************************************************************/
+Uint64 SpeedTestResult(Speed_Test_Info *info);
+
+
+/*+***************************************************************************/
+/*!\ingroup GP_MISC
+ *
+ * Csp1GetAllResults
+ *
+ * Returns the status of all requests sent by the current process
+ *
+ * Input
+ * \param req_stat_buf  array of Csp1RequestStatusBuffer structures
+ * \param buf_size  size of req_stat_buf in multiple of Csp1RequestStatusBuffer size.
+ *                           (buf_size % sizeof(Csp1RequestStatusBuffer) = 0)
+ * \if CAVIUM_MULTICARD_API
+ * \param device_id	Device ID
+ * \endif
+ *
+ * Output
+ * \param res_count  number of elements returned in req_stat_buf.
+ *
+ * Return Value
+ * \result completion code  0 (for success), ERR_BAD_IOCTL
+ */
+/*-****************************************************************************/
+Uint32 Csp1GetAllResults(Csp1RequestStatusBuffer *req_stat_buf,
+                                  Uint32 buf_size,
+                                  Uint32 *res_count
+#ifdef CAVIUM_MULTICARD_API
+                                  ,Uint32 device_id
+#endif
+                                  );
+
+
+
+#define cavium_dump(str_,buf_,len_) \
+{ \
+   Uint32 i=0; \
+   cavium_print("%s\n",str_); \
+        cavium_print("0x%04X : ", i*8); \
+   for (i=0;i<(Uint32)(len_);i++){    \
+      if(i && ((i%8) == 0)) \
+                        { \
+         cavium_print( "%s", "\n"); \
+                        cavium_print("0x%04X : ", (i)); \
+                        } \
+      cavium_print("%02x ",(buf_)[i]);\
+                     } \
+   cavium_print("\n%s\n",str_); \
+}
+
+#define OP_MEM_ALLOC_KEY_SRAM_MEM       0
+#define OP_MEM_ALLOC_KEY_HOST_MEM       1
+#define OP_MEM_ALLOC_KEY_DDR_MEM        2
+#define OP_MEM_FREE_KEY_HOST_MEM        3
+#define OP_MEM_FREE_KEY_DDR_MEM         4
+#define OP_MEM_FREE_KEY_SRAM_MEM        5
+#define OP_MEM_STORE_KEY_HOST_MEM       6
+
+#ifndef CSP1_KERNEL
+
+extern int CSP1_driver_handle;
+
+
+
+/*+****************************************************************************/
+/*!\page page1 General Info
+ * \section keyMaterial  Key memory and format
+ * \verbatim 
+ *
+ *  Key memory and format
+ *
+ * Asymmetric keys can come from three sources:
+ *   - the input stream (i.e. the dptr)
+ *   - the on-chip (FSK) key memory
+ *    - the extended key memory in local DRAM
+ *
+ * The FSK memory is 8KB and is addressed, read, and
+ * written in multiples of 64-bit words
+ *
+ * The extended key memory in local DRAM can be up to
+ * 4MB.
+ *
+ * The chinese remainder theorem (CRT) is a theorem that
+ * allows for faster private key modular exponentiations.
+ * This can (conditionally) be used to improve performance.
+ *
+ * Without CRT, full modular exponentions are performed
+ * (up to 2048-bit). The format of the key material is:
+ *      modulus   (modlength 64-bit words)
+ *       exponent  (modlength 64-bit words)
+ *
+ * (The operation is result = (input ^ exponent) mod modulus.)
+ *
+ * With CRT (on private keys), the format of the key material is:
+ *      Q        (modlength/2 64-bit words)
+ *      Eq       (modlength/2 64-bit words)
+ *      P        (modlength/2 64-bit words)
+ *      Ep       (modlength/2 64-bit words)
+ *      iqmp     (modlength/2 64-bit words)
+ *
+ * The following are requirements of this key material with CRT:
+ *   modulus = Q * P (Q, P are prime factors of modulus, P > Q)
+ *   Q, P are 1/2 the length (in bits or words) of the modulus
+ *   Eq = exponent mod (Q - 1)
+ *   Ep = exponent mod (P - 1)
+ *   iqmp = (q ^ -1) mod p = (q ^ (p-2)) mod p
+ * Eq and Ep are the precomputed exponents. iqmp is also precomputed.
+ *
+ * With CRT, the calculation to  get result = (input ^ exponent) mod modulus
+ * is:
+ *   inputq = input mod Q
+ *   inputp = input mod P
+ *   Mq = (inputq ^ Eq) mod Q
+ *   Mp = (inputp ^ Ep) mod P
+ *      temp = Mp - Mq
+ *   if(temp < 0)
+ *      temp += p
+ *   temp = (temp * iqmp) mod p
+ *   result = temp * q + Mq  // modular multiplication not necessary since the result is < modulus
+ *   
+ *
+ * #ifndef MC2
+ *      The key material should be in integer format. That means that the least-significant 64-bit
+ *      word should be the first word and the most-significant word is the last word. 
+ *      (Within a word the bytes are still big-endian - the most-significant byte contains the 
+ *      most-significant bits, as you might expect.)
+ * #endif
+ * \endverbatim
+ */
+/*-***************************************************************************/
+
+
+/*+****************************************************************************/
+/*!\ingroup GP_OPS
+ * Csp1Initialize
+ *
+ * Prepares the aplication.
+ *
+ * \param dma_mode  CAVIUM_DIRECT or CAVIUM_SCATTER_GATHER
+ * 
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0 
+ * \retval FAILURE #Csp1ErrorCodes
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1Initialize(Csp1DmaMode dma_mode, Uint32 dev_id);
+#else
+Uint32
+Csp1Initialize(Csp1DmaMode dma_mode);
+#endif
+
+
+/*+****************************************************************************/
+/*!\ingroup MISC
+ * Csp1Shutdown
+ *
+ * Cleanup the driver.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCESS 0           
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1Shutdown (Uint32 dev_id);
+#else
+Uint32 Csp1Shutdown (void);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup MISC 
+ * Csp1CheckForCompletion
+ *
+ * Checks the status of the request.
+ *
+ * \param request_id	Unique ID for this request.
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1CheckForCompletion (Uint32 request_id,Uint32 dev_id);
+#else
+Uint32 Csp1CheckForCompletion (Uint32 request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+/*! \ingroup MISC
+ * Csp1FlushAllRequests
+ *
+ * Removes all pending requests for the calling process. This call can make the 
+ * current process go to sleep. The driver will wait for all pending requests 
+ * to complete or timeout.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval  SUCCESS 0
+ * \retval  FAILURE/PENDING #Csp1ErrorCodes
+
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1FlushAllRequests (Uint32 dev_id);
+#else
+Uint32 Csp1FlushAllRequests (void);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup MISC 
+ * Csp1FlushRequest
+ *
+ * Removes the request for the calling process. This call can make the 
+ * current process go to sleep. The driver will wait for the request 
+ * to complete or timeout.
+ *
+ * \param request_id	Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1FlushRequest (Uint32 request_id,Uint32 dev_id);
+#else
+Uint32 Csp1FlushRequest (Uint32 request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1AllocContext
+ *
+ * Allocates a context segment (in the local DDR DRAM or the host memory 
+ * depending on the system) and returns its handle that will be passed to the 
+ * processor in the final 8 bytes of the request as Cptr.
+ *
+ * \param  cntx_type     CONTEXT_SSL or CONTEXT_IPSEC
+ * \param  context_handle pointer to 8-byte address of the context for use by 
+ *	   the Cavium processor
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0 
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1AllocContext (ContextType cntx_type, Uint64 * context_handle,Uint32 dev_id);
+#else
+Uint32 Csp1AllocContext (ContextType cntx_type, Uint64 * context_handle);
+#endif
+
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1FreeContext
+ *
+ * Free a context segment for use by another SSL connection.
+ *
+ * \param cntx_type       CONTEXT_SSL or CONTEXT_IPSEC
+ * \param context_handle    8-byte address of the context for use by 
+ *             the Cavium processor
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0 
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1FreeContext (ContextType cntx_type, Uint64 context_handle,Uint32 dev_id);
+#else
+Uint32 Csp1FreeContext (ContextType cntx_type, Uint64 context_handle);
+#endif
+
+
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1AllocKeyMem
+ *
+ * Acquires the handle to a key memory segment and returns a handle.
+ *
+ * \param key_material_loc   INTERNAL_SRAM, HOST_MEM, or LOCAL_DDR
+ *
+ * \param key_handle      pointer to 8-byte handle to key memory segment
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0 
+ * \retval COMPLETION_CODE #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1AllocKeyMem (KeyMaterialLocation key_material_loc, Uint64 * key_handle,Uint32 dev_id);
+#else
+Uint32
+Csp1AllocKeyMem (KeyMaterialLocation key_material_loc, Uint64 * key_handle);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1FreeKeyMem
+ *
+ * Free a key memory segment.
+ *
+ * \param key_handle   8-byte handle to key memory segment
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+
+#ifdef CAVIUM_MULTICARD_API
+Uint32 Csp1FreeKeyMem (Uint64 key_handle,Uint32 dev_id);
+#else
+Uint32 Csp1FreeKeyMem (Uint64 key_handle);
+#endif
+
+
+       
+/*+****************************************************************************/
+/*! \ingroup MISC
+ * Csp1StoreKey
+ *
+ * Store a key to memory segment indicated by key handle.
+ *
+ * \param key_handle     8-byte handle to key memory segment
+ * \param length    size of key in bytes
+ * \param key       pointer to key
+ * \param mod_ex_type    NORMAL_MOD_EX or CRT_MOD_EX
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1StoreKey (Uint64 * key_handle,
+         Uint16 length, Uint8 * key, RsaModExType mod_ex_type,Uint32 dev_id);
+#else
+Uint32
+Csp1StoreKey (Uint64 * key_handle,
+         Uint16 length, Uint8 * key, RsaModExType mod_ex_type);
+#endif
+
+
+
+/*****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1ReadEpci
+ *
+ * Routine to read the onchip SRAM memory
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param key_handle     64-bit key handle pointer.
+ * \param length    size of data to read in bytes (8<=length<=880, length\%8=0).
+ * \param  data    Result data (size variable based on size)
+ * \param request_id    Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/****************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1ReadEpci (n1_request_type request_type,
+         Uint64 * key_handle,
+         Uint16 length, Uint8 * data, Uint32 * request_id,Uint32 dev_id);
+#else
+Uint32
+Csp1ReadEpci (n1_request_type request_type,
+         Uint64 * key_handle,
+         Uint16 length, Uint8 * data, Uint32 * request_id);
+#endif
+
+
+
+/*****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1WriteEpci
+ *
+ * write data to onchip SRAM.
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param key_handle     64-bit key handle pointer.
+ * \param length    size of data to write in bytes (8<=length<=880, length\%8=0).
+ * \param data       input data 
+ * \param request_id    Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/****************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1WriteEpci (n1_request_type request_type,
+          Uint64 * key_handle,
+          Uint16 length, Uint8 * data, Uint32 * request_id,Uint32 dev_id);
+#else
+Uint32
+Csp1WriteEpci (n1_request_type request_type,
+          Uint64 * key_handle,
+          Uint16 length, Uint8 * data, Uint32 * request_id);
+#endif
+
+
+
+/*****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1ReadContext
+ *
+ * Routine to read data from context.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit context handle pointer.
+ * \param length     size of data to read in bytes (8<=length<=1024, length\%8=0).
+ * \param data        Result data (size variable based on size)
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/****************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1ReadContext (n1_request_type request_type,
+       Uint64 context_handle,
+       Uint16 length, Uint8 * data, Uint32 * request_id,Uint32 dev_id);
+#else
+Uint32
+Csp1ReadContext (n1_request_type request_type,
+       Uint64 context_handle,
+       Uint16 length, Uint8 * data, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1WriteContext
+ *
+ * Write data to context memory.
+ *
+ * \param request_type     CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit context handle pointer (context_handle\%8=0)
+ * \param length     size of the data in bytes (8<=length<=1024,length\%8=0)
+ * \param data        pointer to length bytes of data to be stored
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1WriteContext (n1_request_type request_type,
+        Uint64 context_handle,
+        Uint16 length, Uint8 * data, Uint32 * request_id,Uint32 dev_id);
+#else
+Uint32
+Csp1WriteContext (n1_request_type request_type,
+        Uint64 context_handle,
+        Uint16 length, Uint8 * data, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup IPSEC_OPS
+ *
+ * Csp1WriteIpsecSa
+ *
+ * Write Ipsec SA data to context memory.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param proto	ESP or AH
+ * \param inner_version	Protocol version of inner IP header.
+ * \param outer_version	Protocol version of outer IP header.
+ * \param mode	SA mode (TUNNEL or TRANSPORT)
+ * \param dir	Direction (INBOUND or OUTBOUND)
+ * \param cypher	Encryption algorithm 
+ *             	(DESCBC, DES3CBC, AES128CBC, AES192CBC, AES256CBC)
+ * \param auth	Authentication algorithm
+ *           	(MD5HMAC96 or SHA1HMAC96)
+ * \param template   Template for Outer IP header
+ * \param spi	32 bit SPI value
+ * \param copy_df   0 (copy the df bit for packet fragments) or 1 (do not copy)
+ * \param ft is fragment type (0 for POST_FRAG and 1 for PRE_FRAG)
+ * \param inter_frag_padding is the padding size between fragments
+ * \param udp_encap  0 (no UDP encapsulation) or 1 (UDP encapsulation)
+ * \param context_handle  64-bit context handle pointer (context_handle\%8=0)
+ * \param next_context_handle	context handle pointer for next SA.
+ * \param selectors for selector checking
+ * \param e_key	Encryption key
+ * \param a_key	Authentication key
+ * \param res_order	Response order (CAVIUM_RESPONSE_ORDERED or CAVIUM_RESPONSE_UNORDERED).
+ * \param req_queue	Queue on which this request has to be sent.
+ * \param request_id	Unique ID for this request.
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+#ifndef SSL
+#ifndef MC2
+Uint32
+Csp1WriteIpsecSa(IpsecProto proto,
+                Version version,
+                IpsecMode mode,
+                Direction dir,
+                EncType cypher,
+                Uint8 *e_key,
+                AuthType auth,
+                Uint8 *a_key,
+#ifndef IPV6_EXT_HEADER_SUPPORT
+                Uint8 template[40],
+#else
+                Uint8 template[384],
+#endif
+                Uint32 spi,
+                Uint8 copy_df,
+                FragType ft,
+                Uint16 inter_frag_padding,
+                Uint8 udp_encap,
+                Uint64 context_handle,
+                Uint64 next_context_handle,
+                int res_order,
+                int req_queue,
+                Uint32 *request_id);
+
+#else
+Uint32
+Csp1WriteIpsecSa(n1_request_type request_type,
+                IpsecProto proto,
+                Version inner_version,
+                Version outer_version,
+                IpsecMode mode,
+                Direction dir,
+                EncType cypher,
+                Uint8 *e_key,
+                AuthType auth,
+                Uint8 *a_key,
+#ifndef IPV6_EXT_HEADER_SUPPORT
+                Uint8 template[40],
+#else
+                Uint8 template[384],
+#endif
+                Uint32 spi,
+                Uint8 copy_df,
+                FragType ft,
+                Uint16 inter_frag_padding,
+                Uint8 udp_encap,
+                Uint64 context_handle,
+                Uint64 next_context_handle,
+                Selector* selectors,  /* selectors, must match in_ver */
+                int res_order,
+                int req_queue,
+                Uint32 *request_id);
+
+#endif
+#endif
+/*+****************************************************************************/
+/*! \ingroup IPSEC_OPS
+ * Csp1ProcessPacket
+ *
+ * Process inbound and outbound packets in userspace.
+ *
+ * \param size	Param1 field as defined in the Microcode Spec. 
+ * \param param	Param2 field as defined in the Microcode Spec. 
+ * \param dir	Direction (INBOUND or OUTBOUND)
+ *\param dlen	length of input (packet)
+ *\param inv	pointer to input data (packet to be processed)
+ *\param outv	pointer to output buffer
+ *\param rlen	length of output buffer (processed packet)
+ *\param context_handle	64-bit context handle pointer (context_handle\%8=0)
+ *\param response_order	Response order (CAVIUM_RESPONSE_ORDERED or CAVIUM_RESPONSE_UNORDERED).
+ *\param req_queue	Queue on which this request has to be sent. 
+ *\param request_id  Unique ID for this request.   
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+#ifndef SSL
+Uint32
+Csp1ProcessPacket(Uint16 size, 
+			Uint16 param,
+                        Direction dir,
+			Uint16 dlen,
+	                n1_scatter_buffer *inv,
+			n1_scatter_buffer *outv, 
+			int rlen,
+	                Uint64 context_handle, 
+	                int response_order, 
+			int req_queue,
+			Uint32 *request_id);
+#endif
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Random
+ *
+ * Get random data from random pool maintained by the driver.
+ *
+ * \param request_type CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING \n
+ *          This api will only block if driver will have to refill
+ *          its random number pool. THis argument is ignored by the 
+ *          driver.
+ * \param length       size of random data in bytes 
+ * \param random      pointer to length bytes of random data
+<<<<<<< cavium_common.h
+ * \param request_id  Unique ID for this request. This argument is ignored by 
+ *                     the driver.
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+=======
+ * \param request_id  Unique ID for this request. This argument is ignored 
+ *                     the driver.
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+>>>>>>> 1.44
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1Random (n1_request_type request_type,
+       Uint16 length, Uint8 * random, Uint32 * request_id,Uint32 dev_id);
+#else
+Uint32
+Csp1Random (n1_request_type request_type,
+       Uint16 length, Uint8 * random, Uint32 * request_id);
+#endif
+
+
+/*+***************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Hash
+ *
+ * Compute the HASH of a complete message. Does not use context.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param hash_type	MD5_TYPE or SHA1_TYPE or SHA256_TYPE 
+ * \param message_length	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message	pointer to length bytes of input to be HMACed
+ * \param hash		pointer to the hash_size HASH result 
+ * \param request_id	Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+/*-***************************************************************************/
+#define SHA256_HASH_LEN 32
+#define SHA384_HASH_LEN 48
+#define SHA512_HASH_LEN 64
+#define SHA2_HASH_IV_LEN 64
+#ifdef MC2
+Uint32 
+Csp1Hash(n1_request_type request_type,
+	 HashType hash_type, 
+	 Uint16 message_length, 
+	 Uint8 *message, 
+	 Uint8 *hash,
+#ifdef CAVIUM_MULTICARD_API
+	 Uint32 *request_id,Uint32 dev_id);
+#else
+	 Uint32 *request_id);
+#endif
+
+#endif
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Hmac
+ *
+ * Compute the HMAC of a complete message. Does not use context.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param hash_type     MD5_TYPE or SHA1_TYPE or SHA256_TYPE or SHA384_TYPE or SHA512_TYPE 
+ * \param iv            iv for SHA384 and SHA512 
+ * \param key_length     size of the key in bytes (key_length\%8=0, 8<=key_length<=64)
+ * \param key        pointer to key_length-byte key
+ * \param message_length  size of input in bytes (0<=message_length<=2^16-1)
+ * \param message     pointer to length bytes of input to be HMACed
+ * \param hmac        pointer to the hash_size HMAC result 
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1Hmac (n1_request_type request_type,
+     HashType hash_type,
+     Uint8 * iv, 
+     Uint16 key_length,
+     Uint8 * key,
+     Uint16 message_length,
+#ifdef CAVIUM_MULTICARD_API
+     Uint8 * message, Uint8 * hmac, Uint32 * request_id,Uint32 dev_id);
+#else
+     Uint8 * message, Uint8 * hmac, Uint32 * request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1HmacStart
+ *
+ *   Compute the first stage in a multi-step HMAC.
+ *   
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type     MD5_TYPE or SHA1_TYPE  or SHA256_TYPE
+ * \param key_length     size of the key in bytes (key_length\%8=0, 8<=key_length<=64)
+ * \param key        pointer to key_length-byte key
+ * \param message_length  size of input in bytes (0<=message_length<=2^16-1)
+ * \param message     pointer to length bytes of input to be HMACed
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1HmacStart (n1_request_type request_type,
+          Uint64 context_handle,
+          HashType hash_type,
+          Uint16 key_length,
+          Uint8 * key,
+#ifdef CAVIUM_MULTICARD_API
+          Uint16 message_length, Uint8 * message, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint16 message_length, Uint8 * message, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1HmacUpdate
+ *
+ *   Compute an intermediate step in a multi-step HMAC.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type     MD5_TYPE or SHA1_TYPE  or SHA256_TYPE
+ * \param message_length  size of input in bytes (0<=message_length<=2^16-1)
+ * \param message     pointer to length bytes of input to be HMACed
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1HmacUpdate (n1_request_type request_type,
+      Uint64 context_handle,
+      HashType hash_type,
+#ifdef CAVIUM_MULTICARD_API
+      Uint16 message_length, Uint8 * message, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint16 message_length, Uint8 * message, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1HmacFinish
+ *
+ *   Compute the final step in a multi-step HMAC.
+ *
+ * \param request_type CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle 64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type MD5_TYPE or SHA1_TYPE or SHA256_TYPE
+ * \param message_length size of input in bytes (0<=message_length<=2^16-1)
+ * \param message pointer to length bytes of input to be HMACed
+ * \param final_hmac pointer to the hash_size-word HMAC result 
+ * \param request_id Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1HmacFinish (n1_request_type request_type,
+      Uint64 context_handle,
+      HashType hash_type,
+      Uint16 message_length,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * message, Uint8 * final_hmac, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * message, Uint8 * final_hmac, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS 
+ * Csp1Me
+ *
+ * Modular exponentiation.
+ *
+ * p = x^e mod m
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \if MC2
+ * \param modlength   size of modulus in bytes (17<=modlength<=256)
+ * \param explength   size of exponent in bytes 
+ * \param datalength   size of data in bytes
+ * \param modulus   pointer to modlength-byte modulus
+ * \param exponent   pointer to explength-byte exponent
+ * \param data      pointer to datalength-byte data
+ *   
+ * \else
+ * \param result_location  CONTEXT_PTR or RESULT_PTR 
+ * \param context_handle   64-bit pointer to context (context_handle\%8=0)
+ * \param modlength      size of modulus in bytes (modlength\%8=0, 24<modlength<=256)
+ * \param data pointer      to modlength-byte value to be exponentiated
+ * \param modulus      pointer to modlength-byte modulus
+ * \param exponent      pointer to modlength-byte exponent
+ * \endif 
+ *
+ * \if MC2
+ * \param result pointer to modlength-byte output
+ * \else
+ * \param result if (result_location == RESULT_PTR) pointer to modlength-byte 
+ * \endif          output in byte format
+ * \param  request_id Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ * \note exp_length <= mod_length \n
+ *    data_length <= mod_length
+ *
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Me (n1_request_type request_type,
+   Uint16 modlength,
+   Uint16 explength,
+   Uint16 datalength,
+   Uint8 * modulus,
+#ifdef CAVIUM_MULTICARD_API
+   Uint8 * exponent, Uint8 * data, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+   Uint8 * exponent, Uint8 * data, Uint8 * result, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Me (n1_request_type request_type,
+   ResultLocation result_location,
+   Uint64 context_handle,
+   Uint16 modlength,
+   Uint8 * data,
+   Uint8 * modulus,
+#ifdef CAVIUM_MULTICARD_API
+   Uint8 * exponent, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+   Uint8 * exponent, Uint8 * result, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS 
+ * Csp1Pkcs1v15Enc
+ *
+ * Creates PKCS#1v1.5 container.
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \if MC2
+ * \param block_type   type of PKCS#1v1.5 padding (BT1 or BT2)
+ * \param modlength   size of modulus in bytes (17 <= modlength <= 256)
+ * \param explength   size of exponent in bytes (explength <= modlength -11)
+ * \param datalength   size of data in bytes (datalength <= modlength -11)
+ * \param modulus   pointer to modlength-byte modulus
+ * \param exponent   pointer to explength-byte exponent
+ * \param data      pointer to datalength-byte data
+ * \else
+ * \param result_location    CONTEXT_PTR or RESULT_PTR 
+ * \param context_handle     64-bit pointer to context (context_handle\%8=0)
+ * \param key_material_input KEY_HANDLE or INPUT_DATA
+ * \param key_handle        64-bit handle for key memory 
+ * \param block_type        type of PKCS#1v1.5 padding (BT1 or BT2)
+ * \param modlength        size of modulus in bytes (modlength\%8=0, 24<=modlength<=256)
+ * \param modulus        (key_material_input == INPUT_DATA) ? pointer to RSA modulus : don't care
+ * \param exponent        (key_material_input == INPUT_DATA) ? pointer to RSA exponent : don't care
+ * \param length        size of the input value 
+ * \param data           pointer to length-byte value to be exponentiated
+ * \endif
+ *
+ * 
+ * \if MC2
+ * \param result   pointer to modlength bytes of output
+ * \else
+ * \param result   (result_location == RESULT_PTR) ? (pointer to modlength bytes of output: don't care)
+ * \endif 
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Pkcs1v15Enc (n1_request_type request_type,
+       RsaBlockType block_type,
+       Uint16 modlength,
+       Uint16 explength,
+       Uint16 datalength,
+       Uint8 * modulus,
+       Uint8 * exponent,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * data, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * data, Uint8 * result, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Pkcs1v15Enc (n1_request_type request_type,
+       ResultLocation result_location,
+       Uint64 context_handle,
+       KeyMaterialInput key_material_input,
+       Uint64 key_handle,
+       RsaBlockType block_type,
+       Uint16 modlength,
+       Uint8 * modulus,
+       Uint8 * exponent,
+       Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * data, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * data, Uint8 * result, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Pkcs1v15CrtEnc
+ *
+ * Creates PKCS#1v1.5 container using the Chinese Remainder Theorem.
+ * The combination of block type BT2 and CRT may produce unpredictable results.
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \if MC2
+ * \param block_type   type of PKCS#1v1.5 padding (BT1 only)
+ * \param modlength   size of modulus in bytes (34 <= modlength <=256, modlength\%2 !=0)
+ * \param datalength   size of input data in bytes (datalength <= modlength -11).
+ * \param Q      prime factor of RSA modulus
+ * \param Eq      exponent mod(Q-1)
+ * \param P      prime factor of RSA modulus
+ * \param Ep      exponent mod(P-1)
+ * \param iqmp      (Q^-1) mod P
+ * \else
+ * \param result_location     CONTEXT_PTR or RESULT_PTR 
+ * \param context_handle      64-bit pointer to context (context_handle\%8=0)
+ * \param key_material_input  KEY_HANDLE or INPUT_DATA
+ * \param key_handle         64-bit handle for key memory 
+ * \param block_type         type of PKCS#1v1.5 padding (BT1 only)
+ * \param modlength         size of modulus in bytes (modlength\%8=0, 48<=modlength<=256)
+ * \param Q            (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ * \param Eq            (key_material_input == INPUT_DATA) ? exponent mod(Q-1) : don't care
+ * \param P            (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ * \param Ep            (key_material_input == INPUT_DATA) ? exponent mod(P-1) : don't care
+ * \param iqmp            (key_material_input == INPUT_DATA) ? (Q^-1) mod P : don't care
+ * \param length         size of the input value 
+ * \endif
+ * \param data pointer to length-byte value to be exponentiated
+ *
+ * \if MC2
+ * \param result     pointer to modlength bytes of output
+ * \else
+ * \param result   (result_location == RESULT_PTR) ? (pointer to modlength bytes of output : don't care
+ * \endif
+ * \param request_id   Unique ID for this request.
+ * 
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ * \note modlength must be even
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Pkcs1v15CrtEnc (n1_request_type request_type,
+          RsaBlockType block_type,
+          Uint16 modlength,
+          Uint16 datalength,
+          Uint8 * Q,
+          Uint8 * Eq,
+          Uint8 * P,
+          Uint8 * Ep,
+          Uint8 * iqmp,
+#ifdef CAVIUM_MULTICARD_API
+          Uint8 * data, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint8 * data, Uint8 * result, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Pkcs1v15CrtEnc (n1_request_type request_type,
+          ResultLocation result_location,
+          Uint64 context_handle,
+          KeyMaterialInput key_material_input,
+          Uint64 key_handle,
+          RsaBlockType block_type,
+          Uint16 modlength,
+          Uint8 * Q,
+          Uint8 * Eq,
+          Uint8 * P,
+          Uint8 * Ep,
+          Uint8 * iqmp,
+          Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+          Uint8 * data, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint8 * data, Uint8 * result, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Pkcs1v15Dec
+ *
+ * Decrypts PKCS#1v1.5 container.
+ *
+ *
+ * \param request_type   CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \if MC2
+ * \param block_type   type of PKCS#1v1.5 padding (BT1 only)
+ * \param modlength   size of modulus in bytes (17 <= modlength <=256)
+ * \param explength   size of exponent in bytes (explength <= modlength - 11)
+ * \param modulus   pointer to modlength-byte modulus
+ * \param exponent   pointer to explength-byte exponent
+ * \param data      pointer to modlength-11 bytes input
+ * \else
+ * \param result_location      CONTEXT_PTR or RESULT_PTR 
+ * \param context_handle      64-bit pointer to context (context_handle\%8=0)
+ * \param key_material_input      KEY_HANDLE or INPUT_DATA
+ * \param key_handle         64-bit handle for key memory 
+ * \param block_type         type of PKCS#1v1.5 padding (BT1 or BT2)
+ * \param modlength         size of modulus in bytes (modlength\%8=0, 24<=modlength<=256)
+ * \param modulus         (key_material_input == INPUT_DATA) ? pointer to RSA modulus : don't care
+ * \param exponent         (key_material_input == INPUT_DATA) ? pointer to RSA exponent : don't care
+ * \param data            pointer to modlength-byte value to be exponentiated
+ * \endif
+ *
+ * \if MC2
+ * \param out_length   size of decrypted data in Network Byte order.
+ * \param result   out_length byte size result
+ * \else
+ * \param result   (result_location == RESULT_PTR) ? (pointer to modlength bytes of output, 
+ *             *out_length bytes used) : don't care
+ * \param out_length   pointer to output length in bytes
+ * \endif
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Pkcs1v15Dec (n1_request_type request_type,
+       RsaBlockType block_type,
+       Uint16 modlength,
+       Uint16 explength,
+       Uint8 * modulus,
+       Uint8 * exponent,
+       Uint8 * data,
+#ifdef CAVIUM_MULTICARD_API
+       Uint16 * out_length, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint16 * out_length, Uint8 * result, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Pkcs1v15Dec (n1_request_type request_type,
+       ResultLocation result_location,
+       Uint64 context_handle,
+       KeyMaterialInput key_material_input,
+       Uint64 key_handle,
+       RsaBlockType block_type,
+       Uint16 modlength,
+       Uint8 * modulus,
+       Uint8 * exponent,
+       Uint8 * data,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * result, Uint64 * out_length, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * result, Uint64 * out_length, Uint32 * request_id);
+#endif
+
+#endif
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Pkcs1v15CrtDec
+ *
+ * Decrypts PKCS#1v1.5 container using the Chinese Remainder Theorem.
+ * The combination of block type 01 and CRT may produce unpredictable results.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \if MC2
+ * \param block_type   type of PKCS#1v1.5 padding (BT2 only)
+ * \param modlength   size of modulus in bytes (34 <= modlength <= 256)
+ * \param Q      prime factor of RSA modulus
+ * \param Eq      exponent mod(Q-1)
+ * \param P      prime factor of RSA modulus
+ * \param Ep      exponent mod(P-1)
+ * \param iqmp      (Q^-1) mod P
+ * \param data      pointer to modlength-byte value to be exponentiated
+ * \else
+ * \param result_location     CONTEXT_PTR or RESULT_PTR 
+ * \param context_handle      64-bit pointer to context (context_handle\%8=0)
+ * \param key_material_input  KEY_HANDLE or INPUT_DATA
+ * \param key_handle         64-bit handle for key memory 
+ * \param block_type         type of PKCS#1v1.5 padding (BT2 only)
+ * \param modlength         size of modulus in bytes (modlength\%8=0, 48<=modlength<=256)
+ * \param Q            (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ * \param Eq            (key_material_input == INPUT_DATA) ? exponent mod(Q-1) : don't care
+ * \param P            (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ * \param Ep            (key_material_input == INPUT_DATA) ? exponent mod(P-1) : don't care
+ * \param iqmp            (key_material_input == INPUT_DATA) ? (Q^-1) mod P : don't care
+ * \param data            pointer to modlength-byte value to be exponentiated
+ * \endif
+ *
+ * \if MC2
+ * \param out_length   pointer to output length in bytes (Network Byte order)
+ * \param result   (pointer to modlength bytes of output,   *out_length bytes used)
+ * \else
+ * \param result   (result_location == RESULT_PTR) ? (pointer to modlength bytes of output, 
+ *                     *out_length bytes used) : don't care
+ * \param out_length   pointer to output length in bytes
+ * \endif
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ * \note modlength must be even
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Pkcs1v15CrtDec (n1_request_type request_type,
+          RsaBlockType block_type,
+          Uint16 modlength,
+          Uint8 * Q,
+          Uint8 * Eq,
+          Uint8 * P,
+          Uint8 * Ep,
+          Uint8 * iqmp,
+          Uint8 * data,
+#ifdef CAVIUM_MULTICARD_API
+          Uint16 * out_length, Uint8 * result, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint16 * out_length, Uint8 * result, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Pkcs1v15CrtDec (n1_request_type request_type,
+          ResultLocation result_location,
+          Uint64 context_handle,
+          KeyMaterialInput key_material_input,
+          Uint64 key_handle,
+          RsaBlockType block_type,
+          Uint16 modlength,
+          Uint8 * Q,
+          Uint8 * Eq,
+          Uint8 * P,
+          Uint8 * Ep,
+          Uint8 * iqmp,
+          Uint8 * data,
+#ifdef CAVIUM_MULTICARD_API
+          Uint8 * result, Uint64 * out_length, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint8 * result, Uint64 * out_length, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1InitializeRc4
+ *
+ *    Initializes  RC4 state in the context and stores the key in context.
+ *
+ * \param request_type     CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param key_length     size of key in bytes (1<=length<=256)
+ * \param key        pointer to length-byte key 
+ *
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1InitializeRc4 (n1_request_type request_type,
+         Uint64 context_handle,
+#ifdef CAVIUM_MULTICARD_API
+         Uint16 key_length, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+         Uint16 key_length, Uint8 * key, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1EncryptRc4
+ *
+ *  Encrypts the data provided at input with the key initialized in
+ *  the context.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param context_update  UPDATE or NO_UPDATE
+ * \param length     size of input in bytes (0<=length<=2^16-1)
+ * \param input        pointer to length-byte input
+ *
+ * \param output     pointer to length-byte output 
+ * \param request_id     Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1EncryptRc4 (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * input, Uint8 * output, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * input, Uint8 * output, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Initialize3DES
+ *
+ *    Initializes  3DES state in the context and stores the key in context.
+ *
+ * \param request_type      CAVIUM_BLOCKING
+ * \param context_handle   64-bit pointer to context (context_handle\%8=0)
+ * \param iv         pointer to 8-byte initialization vector
+ * \param key         pointer to 24-byte key 
+ * \param request_id           Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1Initialize3DES (n1_request_type request_type,
+          Uint64 context_handle,
+#ifdef CAVIUM_MULTICARD_API
+          Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+          Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Encrypt3Des
+ *
+ *  Encrypts the data provided at input with the key initialized in
+ *  the context.
+ *
+ * \param request_type     CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param context_update  UPDATE or NO_UPDATE
+ * \param input        pointer to length-byte input
+ *\if MC2
+ * \param length     size of input in bytes (0<=length<=2^16-32, length\%8=0)
+ *\else
+ * \param length     size of input in bytes (0<=length<=2^16-8, length\%8=0)
+ *\endif 
+ * \if MC2
+ * \param iv   pointer to 8-byte IV
+ * \param key   pointer to 24-byte key
+ * \endif
+ *
+ * \param output   pointer to ROUNDUP8(length)-byte output, 
+ * \param request_id   Unique ID for this request.
+ *      
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Encrypt3Des (n1_request_type request_type,
+       Uint64 context_handle,
+       ContextUpdate context_update,
+       Uint16 length,
+       Uint8 * input,
+       Uint8 * output,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Encrypt3Des (n1_request_type request_type,
+       Uint64 context_handle,
+       ContextUpdate context_update,
+       Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * input, Uint8 * output, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * input, Uint8 * output, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1Decrypt3Des
+ *
+ *  Decrypts the data provided at input with the key initialized in
+ *  the context.
+ *
+ * \param request_type    CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param context_update  UPDATE or NO_UPDATE
+ * \param length     size of input in bytes (length\%8=0, 0<=length<=2^16-1)
+ * \param input        pointer to length-byte input
+ * \if MC2
+ * \param iv        pointer to 8-byte IV
+ * \param key        pointer to 24-byte key
+ * \endif
+ *
+ * \param output   pointer to length-byte output, 
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1Decrypt3Des (n1_request_type request_type,
+       Uint64 context_handle,
+       ContextUpdate context_update,
+       Uint16 length,
+       Uint8 * input,
+       Uint8 * output,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1Decrypt3Des (n1_request_type request_type,
+       Uint64 context_handle,
+       ContextUpdate context_update,
+       Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+       Uint8 * input, Uint8 * output, Uint32 * request_id,Uint32 dev_id);
+#else
+       Uint8 * input, Uint8 * output, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1InitializeAES
+ *
+ *    Initializes  AES state in the context and stores the key in context.
+ *
+ * \param request_type     CAVIUM_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param aes_type     AES_128, AES_192, or AES_256
+ * \param iv        pointer to 16-byte initialization vector
+ * \param key        pointer to key, whose length depends on aes_type 
+ * \param request_id   Unique ID for this request. (ignored)
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1InitializeAES (n1_request_type request_type,
+         Uint64 context_handle,
+         AesType aes_type,
+#ifdef CAVIUM_MULTICARD_API
+         Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+         Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+
+ * Csp1SrtpAesCtr
+ *
+ * Performs SRTP (Secure Real Time Protocol) AES-CTR (Counter mode) Encrypt/Decrypt.
+ *
+ * \param request_type      CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle   64-bit pointer to context (context_handle\%8=0)
+ * \param context_update   UPDATE or NO_UPDATE
+ * \param aes_type      AES_128 
+ * \param length      size of input in bytes (0<=length<=2^16-1)
+ * \param input         pointer to length-byte input
+ * \if MC2
+ * \param iv      pointer to 16- byte IV
+ * \param key      pointer to 16- byte key 
+ * \endif
+ *
+ * \param output   pointer to ROUNDUP16(length)-byte output
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1SrtpAesCtr(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           );
+
+#else
+Uint32 
+Csp1SrtpAesCtr(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+          );
+
+#endif
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1ProcessSrtp
+ * Performs SRTP (Secure Real Time Protocol) AES-CTR (Counter mode) Encrypt/Decrypt
+ *           and Authentication in Single Pass.
+ * \param request_type      CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param encrypt           0 - encrypt, 1 -decrypt
+ * \param keytype           AES_128, AES_192, or AES_256
+ * \param authtype          NULL or SHA1 
+<<<<<<< cavium_common.h
+ * \param in_len            size of input in bytes (0<=length<=2^16-1)
+=======
+ * \param proto             0 - SRTP, 1 - SRTCP
+ * \param in_len            size of input in bytes (0<=length<=2^16-1)
+>>>>>>> 1.44
+ * \param hdr_ln            size of the hdr in bytes (0 <= hdr_ln <= 72)
+ * \param index_ln          size of the Tag len [7:4] and Index len[3:0] in bytes (0 <= index_ln <= 4)
+ * \param iv                pointer to 16- byte IV
+ * \param key               pointer to key depending upon aes type
+ * \param auth_key          pointer to auth_key depending upon auth type
+ * \param index             pointer to index depending upon index_ln
+ * \param auth_tag          pointer to auth_tag depending upon auth type & encrypt
+ * \param input             pointer to ROUNDUP8(length) + ROUNDUP8(hdr_ln) bytes input
+ *
+ * \param output            pointer to length + ( proto ? Index_ln : 0) + auth_tag[(auth_type&!encrypt)? Tag len : 0] output
+ * \param request_id        Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+
+#ifdef MC2
+Uint32
+Csp1ProcessSrtp(n1_request_type request_type,
+                Uint8 encrypt,
+                Uint8 keytype,
+                Uint8 authtype,
+                Uint8 proto,
+                Uint16 in_len,
+                Uint8 hdr_ln,
+                Uint8 index_ln,
+                Uint8 *iv,
+                Uint8 *key,
+                Uint8 *auth_key,
+                Uint8 *index,
+                Uint8 *auth_tag,
+                Uint8 *input,
+                Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+                Uint32 *request_id,Uint32 dev_id
+#else
+                Uint32 *request_id
+#endif
+                );
+#endif
+
+/*+****************************************************************************/
+/*! \ingroup MISC
+ *
+ * Csp1AesXcbcPrf128 
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	key = pointer to key
+ * 	key_length = size of the key ( 1 <= key_length <= 912)
+ *	data = pointer to input data
+ * 	data_length = size of input data
+ *
+ * Output
+ *      output = pointer to (AESXCBC_BLOCK_SIZE)-byte output
+ *      request_id = Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * 		dev_id = Device ID
+ * \endif
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1AesXcbcPrf128(n1_request_type request_type,
+	Uint8 *key,
+	Uint16 key_length, 
+	Uint8 *data, 
+	Uint16 data_length,
+	Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+	Uint32 *request_id,Uint32 dev_id
+#else
+	Uint32 *request_id
+#endif
+	);
+
+#else
+Uint32 
+Csp1AesXcbcPrf128(n1_request_type request_type,
+	Uint8 *key,
+	Uint16 key_length, 
+	Uint8 *data, 
+	Uint16 data_length,
+	Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+	Uint32 *request_id,Uint32 dev_id
+#else
+	Uint32 *request_id
+#endif
+	);
+
+#endif
+
+/*+****************************************************************************/
+/*! \ingroup MISC
+ *
+ * Csp1AesCfbRfc3826
+ *
+ * Input
+ * \param request_type is either CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param key is pointer to key
+ * \param aes_type is AES_128=5, AES_192=6, AES_256=7
+ * \param iv is Initial Vector 
+ * \param data is pointer to input data
+ * \param data_length is size of input data
+ * \param encrypt  0 for decrypt, 1 for encrypt
+ *
+ * Output
+ * \param output is pointer to (AESXCBC_BLOCK_SIZE)-byte output
+ * \param request_id is Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * 		dev_id = Device ID
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \if CAVIUM_MULTICARD_API
+ * 		dev_id = Device ID
+ * \endif
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1AesCfbRfc3826(n1_request_type request_type,
+	Uint8 *key,
+	AesType aes_type,
+	Uint8 *iv,
+	Uint8 *data, 
+	Uint16 data_length,
+	Uint8 *output,
+	Uint8 encrypt, /* 0:1 (decrypt:encrypt) */
+#ifdef CAVIUM_MULTICARD_API
+	Uint32 *request_id,Uint32 dev_id
+#else
+	Uint32 *request_id
+#endif
+	);
+#endif
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1EncryptAes
+ *
+ *  Encrypts the data provided at input with the key initialized in
+ *  the context.
+ *
+ * \param request_type      CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle   64-bit pointer to context (context_handle\%8=0)
+ * \param context_update   UPDATE or NO_UPDATE
+ * \param aes_type      AES_128, AES_192, or AES_256
+ * \param length      size of input in bytes (0<=length<=2^16-1)
+ * \param input         pointer to length-byte input
+ * \if MC2
+ * \param iv      pointer to 16- byte IV
+ * \param key      pointer to key depending upon aes type
+ * \endif
+ *
+ * \param output   pointer to ROUNDUP16(length)-byte output
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1EncryptAes (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      AesType aes_type,
+      Uint16 length,
+      Uint8 * input,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * output, Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * output, Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1EncryptAes (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      AesType aes_type,
+      Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * input, Uint8 * output, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * input, Uint8 * output, Uint32 * request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1DecryptAes
+ *
+ *  Decrypts the data provided at input with the key initialized in
+ *  the context.
+ *
+ * \param request_type     CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle  64-bit pointer to context (context_handle\%8=0)
+ * \param context_update  UPDATE or NO_UPDATE
+ * \param aes_type     AES_128, AES_192, or AES_256
+ * \param length     size of input in bytes (length\%16=0, 0<=length<=2^16-1)
+ * \param input        pointer to length-byte input
+ * \if MC2
+ * \param iv        pointer to 16- byte IV
+ * \param key        pointer to key depending upon aes type
+ * \endif
+ *
+ * \param output    pointer to length-byte output
+ * \param request_id    Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+#ifdef MC2
+Uint32
+Csp1DecryptAes (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      AesType aes_type,
+      Uint16 length,
+      Uint8 * input,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * output, Uint8 * iv, Uint8 * key, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * output, Uint8 * iv, Uint8 * key, Uint32 * request_id);
+#endif
+
+#else
+Uint32
+Csp1DecryptAes (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      AesType aes_type,
+      Uint16 length,
+#ifdef CAVIUM_MULTICARD_API
+      Uint8 * input, Uint8 * output, Uint32 * request_id,Uint32 dev_id);
+#else
+      Uint8 * input, Uint8 * output, Uint32 * request_id);
+#endif
+
+#endif
+
+#ifdef MC2
+/*+****************************************************************************/
+/*! \ingroup GP_OPS
+ * Csp1EncryptAesGcmGmac
+ *
+ *  Encrypts+Authenticates/authenticates the data provided at input 
+ *  with the key initialized in the context.
+ *
+ * \param request_type      CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle   64-bit pointer to context (context_handle\%8=0)
+ * \param context_update   UPDATE or NO_UPDATE
+ * \param aes_type      AES_128, AES_192, or AES_256
+ * \param length      size of input in bytes (0<=length<=2^16-1)
+ * \param input         pointer to length-byte input
+ * \param aad         pointer to aditional authentication data
+ *                    (aad length includes SPI and sequence number (8Bytes).
+ *                    and + 4 bytes if esequence number is implemented) in case
+ *                    of GCM. In GMAC, input length is 0, the payload data is 
+ *                    included in the AAD data.
+ * \param eseqnumber   when = 1, extended sequence number is included in AAD.
+ * \param gcm_gmac_bit  when set, gmac is done
+ * \if MC2
+ * \param iv      pointer to 16- byte IV
+ * \param key      pointer to key depending upon aes type
+ * \endif
+ *
+ * \param output   pointer to ROUNDUP16(length)-byte output
+ * \param request_id   Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ */
+/*-***************************************************************************/
+Uint32
+Csp1EncryptAesGcmGmac (n1_request_type request_type,
+      Uint64 context_handle,
+      ContextUpdate context_update,
+      AesType aes_type,
+      Uint16 length,
+      Uint8 *input,
+      Uint8 *aad,
+      Uint8 eseqnumber,
+      Uint8 *output, Uint8 gcm_gmac_bit, Uint8 *iv, Uint8 *key, 
+#ifdef CAVIUM_MULTICARD_API
+      Uint32 *request_id,Uint32 dev_id
+#else
+      Uint32 *request_id
+#endif
+      );
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptAesGcm
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type     = AES_128, AES_192, or AES_256
+ *      length       = size of input in bytes (length%16=0, 0<=length<=2^16-1)
+ *      input        = pointer to length-byte input in case of GCM
+ *      eseqnum      = extented sequence number bit
+ *      tag_length   = can be 4, 8. 12 and 16B
+ *      aad          = pointer to AAD data incase of GCM, 
+ *                     pointer to length-byte AAD in GMAC
+ *      output       = pointer to length-byte output in GCM, 
+ *                     pointer to 0B output in case of GMAC. 
+ *      gcm_gmac_bit = set if GMAC, otherwise GCM
+ *      iv = pointer to 16- byte IV
+ *      key = pointer to key depending upon aes type
+ *
+ * Output
+ *      output = pointer to length-byte output
+ *      request_id = Unique ID for this request.
+ *
+<<<<<<< cavium_common.h
+ * \if CAVIUM_MULTICARD_API
+ * 		dev_id	= Device ID
+ * \endif
+ *
+=======
+ * \if CAVIUM_MULTICARD_API
+ * 		dev_id = Device ID
+ * \endif
+ *
+>>>>>>> 1.44
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32 
+Csp1DecryptAesGcm(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 eseqnumber,           
+            Uint16 tag_length,
+            Uint8 *aad,
+            Uint8 *output,
+            Uint8 gcm_gmac_bit,
+            Uint8 *iv,
+            Uint8 *key,
+                 
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           );
+#endif
+
+#ifdef MC2
+/*+****************************************************************************
+ *
+ * Csp1Hash
+ *
+ * Compute the HASH of a complete message. Does not use context.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param hash_type	MD5_TYPE or SHA1_TYPE or SHA256_TYPE
+ * \param message_length	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message	pointer to length bytes of input to be HMACed
+ * \param hash	pointer to the hash_size HASH result 
+ * \param request_id	Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Hash(n1_request_type request_type,
+    HashType hash_type, 
+    Uint16 message_length, 
+    Uint8 *message, 
+    Uint8 *hash,
+#ifdef CAVIUM_MULTICARD_API
+    Uint32 *request_id,Uint32 dev_id);
+#else
+    Uint32 *request_id);
+#endif
+
+#endif
+#define INC32(a)        {\
+            Uint32 __tmp__    = (Uint32)a;\
+            __tmp__    = (__tmp__ + 1)&0xffffffffL;\
+            a       = __tmp__;\
+         }
+
+#endif /*CSP1_KERNEL */
+
+#ifdef MC2
+#define IPSEC_CONTEXT_SIZE 512
+#else
+#define IPSEC_CONTEXT_SIZE 128
+#endif
+
+Uint32 Csp1GetDevCnt(Uint32 *pdev_count,Uint8 *dev_mask);
+Uint32 Csp1GetDevType(Uint32 *device);
+
+#ifdef CAVIUM_MULTICARD_API
+extern int default_device;
+#define CAVIUM_DEV_ID  default_device
+#define MAX_DEV_CNT 4
+extern int gpkpdev_hdlr[];
+#endif
+
+
+#endif /* _CAVIUM_COMMON_H_ */
+
+/*
+ * $Id: cavium_common.h,v 1.45 2009/09/09 14:13:36 aravikumar Exp $
+ * $Log: cavium_common.h,v $
+ * Revision 1.45  2009/09/09 14:13:36  aravikumar
+ * NPLUS macro dependency removed and made it dynamic
+ *
+ * Revision 1.44  2009/08/07 07:10:59  rdhana
+ * Removed returning of SRTP header at output.
+ *
+ * Revision 1.43  2009/07/27 14:00:37  kkiran
+ *  - Edited documentation for Csp1GetAllResults
+ *
+ * Revision 1.42  2009/07/27 13:55:04  kkiran
+ * - Edited documentation.
+ *
+ * Revision 1.41  2009/07/27 12:14:28  kkiran
+ *  - Documentation for Csp1GetAllResults and SpeedTestInfoResult added.
+ *
+ * Revision 1.40  2009/07/24 12:26:14  pnalla
+ * - Added function prototype for Csp1GetAllResults.
+ *
+ * Revision 1.39  2009/07/22 10:44:03  pnalla
+ * Context memory is increased from 256 bytes to 512 as microcode expects.
+ *
+ * Revision 1.38  2009/07/17 12:45:27  aravikumar
+ * Added dev_id info
+ *
+ * Revision 1.37  2009/07/03 07:09:53  rdhana
+ * Updated SRTP_AES_CTR to support variable Tag len and non-returning of ROC incase of SRTP.
+ * API changes:
+ * minor OPcode[6] = 0 - SRTP and 1 - SRTCP
+ * Param2[15:12] =  Tag length in bytes.
+ * Param2[11:8]  =  Index length in bytes
+ *
+ * Revision 1.36  2009/06/23 08:34:03  kmonendra
+ * Updating member of Speed_Test_Info.
+ *
+ * Revision 1.35  2009/06/22 06:55:01  rsruthi
+ * -- Added AES_CFB Support.
+ *
+ * Revision 1.34  2009/06/18 09:54:27  rdhana
+ * Added IPv6 Extension header and Selector Check support.
+ *
+ * Revision 1.33  2009/04/07 05:48:47  kmonendra
+ * Added request type CAVIUM_SPEED for speedtest.
+ *
+ * Revision 1.32  2009/04/07 05:33:06  kmonendra
+ e Added Speed_Test_Info structure and SpeedTestResult() for speedtest.
+ *
+ * Revision 1.31  2009/03/14 10:16:36  jsrikanth
+ * Operation and keybuf alignment for 32bit app on 64bit driver
+ *
+ * Revision 1.30  2009/03/10 11:49:32  rdhana
+ * Added Single PASS [AES_xxx + SHA1] SRTP support in SSL and IPSEC.
+ *
+ * Revision 1.29  2009/01/09 05:54:39  kmaheshwar
+ * Added AesXcbcPrf128 (RFC 3566,3664, and 4434) support and it is disabled in Makefile
+ *
+ * Revision 1.28  2008/12/22 05:43:42  jrana
+ * - OPCODES added
+ *
+ * Revision 1.27  2008/11/06 09:13:21  ysandeep
+ * Removed PX_PLUS
+ *
+ * Revision 1.26  2008/10/16 09:26:47  aramesh
+ * default_device varibale added.
+ *
+ * Revision 1.25  2008/10/15 08:03:39  ysandeep
+ * Multicard support for NPLUS added.
+ *
+ * Revision 1.24  2008/08/12 10:47:53  aramesh
+ * deleted gpkpdev_keyhandle.
+ *
+ * Revision 1.23  2008/08/11 10:21:31  aramesh
+ * CAVIUM_DEV_ID is changed to 0.
+ *
+ * Revision 1.22  2008/07/29 14:51:51  aramesh
+ * N1_GET_STATUS_DDR is added.
+ *
+ * Revision 1.21  2008/07/07 12:33:13  aramesh
+ * Csp1GetDevCnt api parameters are chnaged.
+ *
+ * Revision 1.20  2008/07/03 09:55:44  aramesh
+ * added Csp1GetDevType API definition.
+ *
+ * Revision 1.18  2008/06/03 07:16:29  rsruthi
+ * - Added AesGCM/GMAC Encrypt/Decrypt APIs, added additional parameter, IV in Csp1Hmac for SHA2 SUPPORT.
+ *
+ * Revision 1.17  2008/04/25 05:53:32  rdhana
+ * Added the FRAG_SUPPORT code in normal flow and removed FRAG_SUPPORT define.
+ *
+ * Revision 1.16  2008/03/06 11:41:34  jsrikanth
+ * Doxygen format changes
+ *
+ * Revision 1.15  2008/02/22 09:37:33  aramesh
+ * defined CAVIUM_NO_MMAP and  INTERRUPT_ON_COMP.
+ *
+ * Revision 1.14  2008/02/04 07:45:02  kmaheshwar
+ * Added Csp1SrtpAesCtr
+ *
+ * Revision 1.13  2007/12/07 05:24:18  ksadasivuni
+ * 1.  changed context memory to use buffer pool as px doesn't have DDR
+ * 2.  PX_ECC_FreeContext now takes cid argument
+ *
+ * Revision 1.12  2007/12/03 06:19:24  ksadasivuni
+ * - ecrng random int inital checkin
+ *
+ * Revision 1.11  2007/11/30 07:05:30  ksadasivuni
+ * ECRNG generate random string done.
+ *
+ * Revision 1.10  2007/11/21 07:07:33  ksadasivuni
+ * all driver load messages now will be printed at CAVIUM_DEBUG_LEVEL>0
+ *
+ * Revision 1.9  2007/11/19 11:11:55  lpathy
+ * ported to 64 bit windows.
+ *
+ * Revision 1.8  2007/09/10 10:13:17  kchunduri
+ * --Define new API to accept "dev_id" as input parameter.
+ *
+ * Revision 1.7  2007/07/04 04:49:58  kchunduri
+ * --IOCTL for returning nitrox devices detected.
+ *
+ * Revision 1.6  2007/06/11 13:38:07  tghoriparti
+ * DMA_MAP error code added
+ *
+ * Revision 1.5  2007/03/08 20:44:58  panicker
+ * * NPLUS mode changes. pre-release
+ * * NitroxPX now supports N1-style NPLUS operation.
+ * * Native PX mode PLUS operations are enabled only if PX_PLUS flag is enabled
+ *
+ * Revision 1.4  2007/03/06 02:16:59  panicker
+ * * PX will use the same core id lookup mechanism as N1. So core_t is now
+ *   defined for PX (minus the ctp & srq fields).
+ * * From MICROCODE structure removed core_mask for PX; included core_id.
+ *   get_core_mask() will work the same way for N1 and PX.
+ *
+ * Revision 1.3  2007/02/02 02:39:06  panicker
+ * * DebugRWReg uses unsigned long - since they may send/receive addresses.
+ *
+ * Revision 1.2  2007/01/13 01:18:19  panicker
+ * -  core_t, softreq_t structure defs not required in PX for NPLUS mode.
+ * -  core_id, paired_cores etc in MICROCODE not required in PX for NPLUS mode.
+ * -  core_mask is added to MICROCODE for PX mode.
+ *
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.39  2006/08/23 05:46:58  pnalla
+ * Added Fragmentation and UDP Encapsulation support
+ *
+ * Revision 1.38  2006/08/21 11:05:38  ksnaren
+ * Fixed compilation errors for FreeBSD6.1
+ *
+ * Revision 1.37  2006/08/16 14:14:50  kchunduri
+ * --defined new field to store 'status' of OPERATION.
+ *
+ * Revision 1.36  2006/08/08 13:14:40  kchunduri
+ * removed C++ style comments and moved MACROS related to 64-bit port from cavium_sysdep.h to enable freebsd compilation
+ *
+ * Revision 1.35  2006/08/01 08:02:05  kchunduri
+ * Modified DebugRWReg to fix POTS RANDOM TEST failure on PPC-64Bit
+ *
+ * Revision 1.34  2006/05/16 09:38:14  kchunduri
+ * --fields in API structures aligned so that structure size is same on both 32bit and 64 bit platforms.
+ *
+ * Revision 1.33  2006/04/17 04:08:09  kchunduri
+ * --defined new type Csp1StatusOperationBuffer for Csp1GetAllResults --kiran
+ *
+ * Revision 1.32  2006/03/27 04:58:30  kchunduri
+ * --kchunduri new type Csp1RequestStatusBuffer to support api Csp1GetAllResults
+ *
+ * Revision 1.31  2006/03/24 09:47:07  pyelgar
+ *   - Checkin of Scatter/Gather code changes in driver and IPSec.
+ *
+ * Revision 1.30  2005/12/22 10:17:35  ksadasivuni
+ * - NPLUS Release. Freeswan klips code is assuming ipsec context size of 128, driver is assuming 256 for MC2.
+ *   Moved IPSEC_CONTEXT_SIZE #define to cavium_common.h
+ *
+ * Revision 1.29  2005/11/17 13:31:09  kanantha
+ * Updating with the 64 bit modifications, with proper matching of data types
+ *
+ * Revision 1.28  2005/10/20 10:03:11  phegde
+ * - Added 2 new function prototypes called Csp1WriteIpsecSa() and Csp1ProcessPacket() to support for IPSec functionality
+ *
+ * Revision 1.27  2005/10/13 08:56:40  ksnaren
+ * removed compile warning
+ *
+ * Revision 1.26  2005/09/28 15:53:37  ksadasivuni
+ * - Merging FreeBSD 6.0 AMD64 release with CVS Head
+ *
+ * Revision 1.25  2005/09/27 05:29:50  sgadam
+ * Compilation error in FC4 fixed
+ *
+ * Revision 1.24  2005/09/21 06:37:44  lpathy
+ * Merging windows server 2003 release with CVS head
+ *
+ * Revision 1.23  2005/09/08 12:56:26  sgadam
+ * - Csp1Hash prototype Added
+ *
+ * Revision 1.22  2005/06/03 07:29:46  rkumar
+ * Priority associated commands in SRQ
+ *
+ * Revision 1.21  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.20  2005/01/06 18:43:32  mvarga
+ * Added realtime support
+ *
+ * Revision 1.19  2004/06/23 19:06:20  bimran
+ * NetBSD port.
+ * Fixed cavium_dump to become OSI
+ *
+ * Revision 1.18  2004/05/04 00:27:02  danny
+ * 2.00b documentation ver 0.01, doxygen ccmment corrections
+ *
+ * Revision 1.17  2004/05/03 23:30:08  danny
+ * Added Doxygen formating to header files
+ *
+ * Revision 1.16  2004/05/03 22:33:21  danny
+ * Added Doxygen formating to header files
+ *
+ * Revision 1.15  2004/05/03 20:33:13  bimran
+ * Removed all references to CAVIUM_IKE context_type.
+ *
+ * Revision 1.14  2004/05/03 19:53:57  bimran
+ * Added all error codes.
+ *
+ * Revision 1.13  2004/05/02 19:45:59  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.12  2004/05/01 07:15:35  bimran
+ * Added non-blocking error codes.
+ *
+ * Revision 1.11  2004/05/01 05:58:06  bimran
+ * Fixed a function descriptions on each function to match with the latest microcode and driver.
+ *
+ * Revision 1.10  2004/04/28 03:14:59  bimran
+ * Fixed comments.
+ *
+ * Revision 1.9  2004/04/26 23:29:23  bimran
+ * Removed unused data types.
+ *
+ * Revision 1.8  2004/04/26 22:32:52  tsingh
+ * Fixed some typedefs for MC2 (bimran).
+ *
+ * Revision 1.7  2004/04/23 21:49:34  bimran
+ * Csp1Initialze now accepts microcode type to support Plus mode.
+ *
+ * Revision 1.6  2004/04/22 02:49:34  bimran
+ * Removed enumerated error codes from microcode.
+ *
+ * Revision 1.5  2004/04/22 01:12:11  bimran
+ * Moved NPLUS related structures around to avoid compilation problems with user mode programs like nplus_init.
+ *
+ * Revision 1.4  2004/04/21 20:00:29  bimran
+ * NPLUS support.
+ *
+ * Revision 1.3  2004/04/20 17:45:11  bimran
+ * Defined microcode structure.
+ * Some early NPLUS related changes.
+ *
+ * Revision 1.2  2004/04/17 01:37:49  bimran
+ * Fixed includes.
+ * Added function protos.
+ *
+ * Revision 1.1  2004/04/15 22:40:50  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
diff -Naur openssl-0.9.8r-orig/include/cavium_endian.h openssl-0.9.8r/include/cavium_endian.h
--- openssl-0.9.8r-orig/include/cavium_endian.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_endian.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,18 @@
+#if !defined (__CAVIUM_ENDIAN_H__)
+#define __CAVIUM_ENDIAN_H__
+
+#if defined (_X86_) || defined (i386) || defined (i686)
+#include "cavium_le.h"
+#elif defined (mips) || defined (ppc)
+#include "cavium_be.h"
+#elif defined(__amd64__) || defined (_AMD64_) || defined (AMD64)
+#include "cavium_le.h"
+#elif defined(__i386__) || defined (_IA64_) || defined (IA64)
+#include "cavium_le.h"
+#elif defined(PPC) || defined (__PPC__) || defined(powerpc)
+#include "cavium_be.h"
+#else
+#include "cavium_le.h"
+#endif
+
+#endif
diff -Naur openssl-0.9.8r-orig/include/cavium_ioctl.h openssl-0.9.8r/include/cavium_ioctl.h
--- openssl-0.9.8r-orig/include/cavium_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_ioctl.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,16 @@
+#if !defined (__CAVIUM_IOCTL_H__)
+#define __CAVIUM_IOCTL_H__
+
+#if defined (_WIN32)
+#include "windows_ioctl.h"
+#elif defined (linux)
+#include "linux_ioctl.h"
+#elif defined (__FreeBSD__)
+#include "freebsd_ioctl.h"
+#elif defined (__NetBSD__)
+#include "netbsd_ioctl.h"
+#else
+#include "custom_ioctl.h"
+#endif
+
+#endif
diff -Naur openssl-0.9.8r-orig/include/cavium_le.h openssl-0.9.8r/include/cavium_le.h
--- openssl-0.9.8r-orig/include/cavium_le.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_le.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,124 @@
+/* cavium_le.h */
+/*
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#ifndef _CAVIUM_ENDIAN_H
+#define _CAVIUM_ENDIAN_H
+
+#define CAVIUM_ENDIAN	__CAVIUM_LITTLE_ENDIAN
+
+#if 0
+#define COMPLETION_CODE_VALUE((p))	(Uint8 *)((p) >> COMPLETION_CODE_SHIFT)
+#endif
+
+#define ENDIAN_SWAP_8_BYTE(_i) \
+  ((((((Uint64)(_i)) >>  0) & (Uint64)0xff) << 56) | \
+   (((((Uint64)(_i)) >>  8) & (Uint64)0xff) << 48) | \
+   (((((Uint64)(_i)) >> 16) & (Uint64)0xff) << 40) | \
+   (((((Uint64)(_i)) >> 24) & (Uint64)0xff) << 32) | \
+   (((((Uint64)(_i)) >> 32) & (Uint64)0xff) << 24) | \
+   (((((Uint64)(_i)) >> 40) & (Uint64)0xff) << 16) | \
+   (((((Uint64)(_i)) >> 48) & (Uint64)0xff) <<  8) | \
+   (((((Uint64)(_i)) >> 56) & (Uint64)0xff) <<  0))
+
+
+#define ENDIAN_SWAP_4_BYTE(_i)			\
+  (((((Uint32)(_i)) & 0xff000000) >> 24) |	\
+   ((((Uint32)(_i)) & 0x00ff0000) >>  8) |	\
+   ((((Uint32)(_i)) & 0x0000ff00) <<  8) |	\
+   ((((Uint32)(_i)) & 0x000000ff) << 24))
+
+#define ENDIAN_SWAP_2_BYTE(_i)			\
+  (((((Uint16)(_i)) & 0xff00) >> 8) |		\
+   ((((Uint16)(_i)) & 0x00ff) << 8))
+
+#ifndef htobe64
+#define htobe64(_i) ENDIAN_SWAP_8_BYTE((_i))
+#define htobe32(_i)	ENDIAN_SWAP_4_BYTE(_i)
+#define htobe16(_i)	ENDIAN_SWAP_2_BYTE(_i)
+#endif
+
+#ifndef htole64
+#define htole64(_i) (_i)
+#define htole32(_i) (_i)
+#define htole16(_i) (_i)
+#endif
+
+#define betoh64(_i) ENDIAN_SWAP_8_BYTE((_i))
+#define letoh64(_i) (_i)
+#define betoh32(_i)	ENDIAN_SWAP_4_BYTE(_i)
+#define letoh32(_i) (_i)
+#define betoh16(_i)	ENDIAN_SWAP_2_BYTE(_i)
+#define letoh16(_i) (_i)
+#endif
+
+/*
+ * $Id: cavium_le.h,v 1.3 2009/06/11 08:02:33 aravikumar Exp $
+ * $Log: cavium_le.h,v $
+ * Revision 1.3  2009/06/11 08:02:33  aravikumar
+ * Changes made for FC-10
+ *
+ * Revision 1.2  2007/02/02 02:36:48  panicker
+ * * _ENDIAN definition in linux_sysdep.h
+ *
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.5  2005/09/21 06:42:56  lpathy
+ * Merging windows server 2003 release with CVS head
+ *
+ * Revision 1.4  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.3  2004/06/28 20:51:24  tahuja
+ * added netbsd_ioctl.h & netbsd_sysdep.h.
+ *
+ * Revision 1.2  2004/05/02 19:45:59  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.1  2004/04/15 22:40:50  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
+
diff -Naur openssl-0.9.8r-orig/include/cavium_ssl.h openssl-0.9.8r/include/cavium_ssl.h
--- openssl-0.9.8r-orig/include/cavium_ssl.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_ssl.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,3795 @@
+/*! \file cavium_ssl.h */
+/*
+ * Copyright (c) 2003-2005, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+
+#ifndef _CAVIUM_SSL_H_
+#define _CAVIUM_SSL_H_
+
+#ifndef CSP1_KERNEL
+
+
+/*! \enum SslVersion SSL/TLS protocol version */
+typedef enum {VER_TLS = 0, VER3_0 = 1, VER_DTLS = 0x400} SslVersion;
+
+#ifdef MC2
+/*! \enum Rc4Type RC4 cipher type */
+typedef enum {UNSUPPORTED_RC4 = -1, RC4_128 = 8, RC4_EXPORT_40 = 9, RC4_EXPORT_56 = 11} Rc4Type;
+
+/*! \enum DesType  (3)DES cipher type */
+typedef enum {UNSUPPORTED_DES = -1, DES = 12, DES_EXPORT_40 = 13, DES3_192 = 14} DesType;
+#else
+/*! \enum Rc4Type RC4 cipher type */
+typedef enum {UNSUPPORTED_RC4 = -1, RC4_128 = 0, RC4_EXPORT_40 = 1, RC4_EXPORT_56 = 7} Rc4Type;
+
+/*! \enum DesType  (3)DES cipher type */
+typedef enum {UNSUPPORTED_DES = -1, DES = 0, DES_EXPORT_40 = 1, DES3_192 = 2} DesType;
+#endif
+/*! \enum MessageType  SSL/TLS Record Type */
+typedef enum {CHANGE_CIPHER_SPEC = 0, ALERT = 1, HANDSHAKE = 2, APP_DATA = 3} MessageType;
+
+/*! \enum MasterSecretReturn  SSL/TLS Record Type */
+typedef enum {NOT_RETURNED = 0, RETURN_ENCRYPTED = 1} MasterSecretReturn;
+
+/*! \enum MasterSecretInput  Master secret location */
+typedef enum {READ_FROM_CONTEXT = 0, INPUT_ENCRYPTED = 1} MasterSecretInput;
+
+/*! \enum ClientFinishMessageOutput  predicted ClientFinished message format */
+typedef enum {RETURN_CFM_ENCRYPTED = 0, RETURN_CFM_UNENCRYPTED = 1} ClientFinishMessageOutput;
+
+/*! \enum ServerFinishMessageOutput  ServerFinished message format */
+typedef enum {RETURN_SFM_ENCRYPTED = 0, RETURN_SFM_UNENCRYPTED = 1} ServerFinishMessageOutput;
+
+/*! \enum SslPartyType server or client */
+typedef enum {SSL_SERVER = 0, SSL_CLIENT = 1} SslPartyType;
+
+
+/* SSLv2 specific Context Offsets */
+
+#define OFFSET_SSL2_MASTER_SECRET			16
+
+#define OFFSET_SSL2_3DES_SERVER_READ_SEQ		22
+#define OFFSET_SSL2_3DES_SERVER_READ_KM			24
+#define OFFSET_SSL2_3DES_SERVER_WRITE_SEQ		28
+#define OFFSET_SSL2_3DES_SERVER_WRITE_KM		30
+
+#define OFFSET_SSL2_RC4_SERVER_READ_SEQ			22
+#define OFFSET_SSL2_RC4_SERVER_READ_KM			24
+#define OFFSET_SSL2_RC4_SERVER_READ_STATE		26
+#define OFFSET_SSL2_RC4_SERVER_WRITE_SEQ		60
+#define OFFSET_SSL2_RC4_SERVER_WRITE_KM			62
+#define OFFSET_SSL2_RC4_SERVER_WRITE_STATE		64
+
+
+#ifdef USE_SSL_QUEUE1
+#define SSL_QUEUE 1
+#else
+#define SSL_QUEUE 0
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup MISC
+ *
+ * Csp1GetDmaMode
+ * 
+ * Returns the current DMA mode
+ *
+ *
+ * \retval CAVIUM_DIRECT, CAVIUM_SCATTER_GATHER #DmaMode
+ */
+ /*-***************************************************************************/
+DmaMode 
+Csp1GetDmaMode(void);
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup MISC
+ *
+ * Csp1GetDriverState
+ * 
+ * Function to check whether the driver handle is initialized or not.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval 0  driver handle is ready.
+ * \retval -1 driver handle is not initialized
+ */
+ /*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+int 
+Csp1GetDriverState(Uint32 dev_id);
+#else
+int 
+Csp1GetDriverState(void);
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1SetEncryptedMasterSecretKey
+ *
+ * Sets the key material for encryption of master secrets used by resume 
+ * operations.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \param 	key pointer to 48 bytes of key material
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 
+Csp1SetEncryptedMasterSecretKey(Uint8 *key,Uint32 dev_id);
+#else
+Uint32 
+Csp1SetEncryptedMasterSecretKey(Uint8 *key);
+#endif
+
+#ifndef MC2
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Handshake
+ *
+ * Calculates the hashes needed by the SSL handshake.
+ *
+ * \param request_type 		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING #Csp1RequestType
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param message_length 	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message 		pointer to length bytes of input
+ *
+ * \param md5_final_hash 	pointer to the 4-halfword handshake final result 
+ * \param sha1_final_hash 	pointer to the 5-halfword handshake final result 
+ * \param request_id 		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Handshake(Csp1RequestType request_type,
+	  Uint64 context_handle, 
+	  Uint16 message_length, 
+	  Uint8 *message, 
+	  Uint8 *md5_final_hash, 
+	  Uint8 *sha1_final_hash,
+#ifdef CAVIUM_MULTICARD_API
+	  Uint32 *request_id,Uint32 dev_id);
+#else
+	  Uint32 *request_id);
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1HandshakeStart
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING #Csp1RequestType
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param message_length	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message		pointer to length bytes of input
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1HandshakeStart(Csp1RequestType request_type,
+		   Uint64 context_handle, 
+		   Uint16 message_length, 
+		   Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                   Uint32 *request_id,Uint32 dev_id);
+#else
+                   Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1HandshakeUpdate
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param message_length	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message		pointer to length bytes of input
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1HandshakeUpdate(n1_request_type request_type,
+		Uint64 context_handle, 
+		Uint16 message_length, 
+		Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                Uint32 *request_id,Uint32 dev_id);
+#else
+                Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1HandshakeFinish
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param message_length	size of input in bytes (0<=message_length<=2^16-1)
+ * \param message		pointer to length bytes of input
+ * \param md5_final_hash	pointer to the 4-word handshake final result 
+ * \param sha1_final_hash	pointer to the 5-word handshake final result 
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1HandshakeFinish(n1_request_type request_type,
+		Uint64 context_handle, 
+		Uint16 message_length, 
+		Uint8 *message, 
+		Uint8 *md5_final_hash, 
+		Uint8 *sha1_final_hash,
+#ifdef CAVIUM_MULTICARD_API
+                Uint32 *request_id,Uint32 dev_id);
+#else
+                Uint32 *request_id);
+#endif
+
+
+#endif /* MC2*/
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFullRc4
+ *
+ * Does a full handshake on the server with RSA <= 2048. This entry point 
+ * handles all the RC4 cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value.
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *						returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFullRc4(n1_request_type request_type,
+		 Uint64 context_handle, 
+		 Uint64 *key_handle, 
+		 HashType hash_type, 
+		 SslVersion ssl_version, 
+		 Rc4Type rc4_type,
+		 MasterSecretReturn master_secret_ret,
+		 Uint16 modlength, 
+		 Uint8 *encrypt_premaster_secret, 
+		 Uint8 *client_random, 
+		 Uint8 *server_random, 
+		 Uint16 handshake_length, 
+		 Uint8 *handshake, 
+		 Uint8 *client_finished_message,
+		 Uint8 *server_finished_message, 
+		 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                 Uint32 *request_id,Uint32 dev_id);
+#else
+                 Uint32 *request_id);
+#endif
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFullRc4Finish
+ *
+ * Does a full handshake on the server with RSA <= 2048. This entry point 
+ * handles all the RC4 cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request (previously hashed plus included 
+ * messsage data) should include all handshake message data after (and 
+ * including) the client hello message up until (but not including) the first 
+ * finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFullRc4Finish(n1_request_type request_type,
+			   Uint64 context_handle, 
+			   Uint64 *key_handle, 
+			   HashType hash_type, 
+			   SslVersion ssl_version, 
+			   Rc4Type rc4_type, 
+			   MasterSecretReturn master_secret_ret,
+			   Uint16 modlength, 
+			   Uint8 *encrypt_premaster_secret, 
+			   Uint8 *client_random, 
+			   Uint8 *server_random, 
+			   Uint16 handshake_length, 
+			   Uint8 *handshake, 
+			   Uint8 *client_finished_message,
+			   Uint8 *server_finished_message, 
+			   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 *request_id,Uint32 dev_id);
+#else
+                           Uint32 *request_id);
+#endif
+
+#endif /* MC2*/
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerifyRc4
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message.  
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyRc4(n1_request_type request_type,
+		   Uint64 context_handle, 
+		   Uint64 *key_handle, 
+		   HashType hash_type, 
+		   SslVersion ssl_version, 
+		   Rc4Type rc4_type, 
+		   MasterSecretReturn master_secret_ret,
+		   Uint16 modlength, 
+		   Uint8 *encrypt_premaster_secret, 
+		   Uint8 *client_random, 
+		   Uint8 *server_random, 
+		   Uint16 handshake_length, 
+		   Uint8 *handshake, 
+		   Uint8 *verify_data,
+		   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                   Uint32 *request_id,Uint32 dev_id);
+#else
+                   Uint32 *request_id);
+#endif
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerifyRc4Finish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * Handshake data can be accumulated prior to this request by calls to 
+ * Handshake*, and this request will append the included handshake 
+ * message data to the pre-existing handshake hash state. The handshake message 
+ * data for this request (previously hashed plus included messsage data) should 
+ * include all handshake message data after (and including) the client hello 
+ * message up until (but not including) the client verify message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyRc4Finish(n1_request_type request_type,
+			 Uint64 context_handle, 
+			 Uint64 *key_handle, 
+			 HashType hash_type, 
+			 SslVersion ssl_version, 
+			 Rc4Type rc4_type, 
+			 MasterSecretReturn master_secret_ret,
+			 Uint16 modlength, 
+			 Uint8 *encrypt_premaster_secret, 
+			 Uint8 *client_random, 
+			 Uint8 *server_random, 
+			 Uint16 handshake_length, 
+			 Uint8 *handshake, 
+			 Uint8 *verify_data,
+			 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                         Uint32 *request_id,Uint32 dev_id);
+#else
+                         Uint32 *request_id);
+#endif
+
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFull3Des
+ *
+ * Does a full handshake on the server with RSA <= 2048. This entry point 
+ * handles all the DES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value.
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFull3Des(n1_request_type request_type,
+		  Uint64 context_handle, 
+		  Uint64 *key_handle, 
+		  HashType hash_type, 
+		  SslVersion ssl_version, 
+		  DesType des_type, 
+		  MasterSecretReturn master_secret_ret,
+		  ClientFinishMessageOutput clnt_fin_msg_out,
+		  ServerFinishMessageOutput srvr_fin_msg_out,
+		  Uint16 client_pad_length,
+		  Uint16 server_pad_length,
+		  Uint16 modlength, 
+		  Uint8 *encrypt_premaster_secret, 
+		  Uint8 *client_random, 
+		  Uint8 *server_random, 
+		  Uint16 handshake_length, 
+		  Uint8 *handshake, 
+		  Uint8 *client_finished_message,
+		  Uint8 *server_finished_message, 
+		  Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 *request_id,Uint32 dev_id);
+#else
+                  Uint32 *request_id);
+#endif
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFull3DesFinish
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the DES cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value.
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFull3DesFinish(n1_request_type request_type,
+			Uint64 context_handle, 
+	            	Uint64 *key_handle, 
+			HashType hash_type, 
+			SslVersion ssl_version, 
+			DesType des_type, 
+			MasterSecretReturn master_secret_ret,
+			ClientFinishMessageOutput clnt_fin_msg_out,
+			ServerFinishMessageOutput srvr_fin_msg_out,
+			Uint16 client_pad_length,
+			Uint16 server_pad_length,
+			Uint16 modlength, 
+			Uint8 *encrypt_premaster_secret, 
+			Uint8 *client_random, 
+			Uint8 *server_random, 
+			Uint16 handshake_length, 
+			Uint8 *handshake, 
+			Uint8 *client_finished_message,
+			Uint8 *server_finished_message, 
+			Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 *request_id,Uint32 dev_id);
+#else
+                        Uint32 *request_id);
+#endif
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerify3Des
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40, DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerify3Des(n1_request_type request_type,
+			Uint64 context_handle, 
+			Uint64 *key_handle, 
+			HashType hash_type, 
+			SslVersion ssl_version, 
+			DesType des_type, 
+			MasterSecretReturn master_secret_ret,
+			Uint16 modlength, 
+			Uint8 *encrypt_premaster_secret, 
+			Uint8 *client_random, 
+			Uint8 *server_random, 
+			Uint16 handshake_length, 
+			Uint8 *handshake, 
+			Uint8 *verify_data,
+			Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 *request_id,Uint32 dev_id);
+#else
+                        Uint32 *request_id);
+#endif
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerify3DesFinish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength	size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerify3DesFinish(n1_request_type request_type,
+			  Uint64 context_handle, 
+			  Uint64 *key_handle, 
+			  HashType hash_type, 
+			  SslVersion ssl_version, 
+			  DesType des_type, 
+			  MasterSecretReturn master_secret_ret,
+			  Uint16 modlength, 
+			  Uint8 *encrypt_premaster_secret, 
+			  Uint8 *client_random, 
+			  Uint8 *server_random, 
+			  Uint16 handshake_length, 
+			  Uint8 *handshake, 
+			  Uint8 *verify_data,
+			  Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                          Uint32 *request_id,Uint32 dev_id);
+#else
+                          Uint32 *request_id);
+#endif
+
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFullAes
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the AES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param aes_type		AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value.
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFullAes(n1_request_type request_type,
+		 Uint64 context_handle, 
+		 Uint64 *key_handle, 
+		 HashType hash_type, 
+		 SslVersion ssl_version, 
+		 AesType aes_type, 
+		 MasterSecretReturn master_secret_ret,
+		 ClientFinishMessageOutput clnt_fin_msg_out,
+		 ServerFinishMessageOutput srvr_fin_msg_out,
+		 Uint16 client_pad_length,
+		 Uint16 server_pad_length,
+		 Uint16 modlength, 
+		 Uint8 *encrypt_premaster_secret, 
+		 Uint8 *client_random, 
+		 Uint8 *server_random, 
+		 Uint16 handshake_length, 
+		 Uint8 *handshake, 
+		 Uint8 *client_finished_message,
+		 Uint8 *server_finished_message, 
+		 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                 Uint32 *request_id,Uint32 dev_id);
+#else
+                 Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerFullAesFinish
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the aes cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param aes_type		AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerFullAesFinish(n1_request_type request_type,
+			   Uint64 context_handle, 
+			   Uint64 *key_handle, 
+			   HashType hash_type, 
+			   SslVersion ssl_version, 
+			   AesType aes_type, 
+			   MasterSecretReturn master_secret_ret,
+			   ClientFinishMessageOutput clnt_fin_msg_out,
+			   ServerFinishMessageOutput srvr_fin_msg_out,
+			   Uint16 client_pad_length,
+			   Uint16 server_pad_length,
+			   Uint16 modlength, 
+			   Uint8 *encrypt_premaster_secret, 
+			   Uint8 *client_random, 
+			   Uint8 *server_random, 
+			   Uint16 handshake_length, 
+			   Uint8 *handshake, 
+			   Uint8 *client_finished_message,
+			   Uint8 *server_finished_message, 
+			   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 *request_id,Uint32 dev_id);
+#else
+                           Uint32 *request_id);
+#endif
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerifyAes
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param aes_type		AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \if MC2
+ * \param encrypt_premaster_secret	pointer to modlength-byte value.
+ * \else
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \endif
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyAes(n1_request_type request_type,
+		   Uint64 context_handle, 
+		   Uint64 *key_handle, 
+		   HashType hash_type, 
+		   SslVersion ssl_version, 
+		   AesType aes_type, 
+		   MasterSecretReturn master_secret_ret,
+		   Uint16 modlength, 
+		   Uint8 *encrypt_premaster_secret, 
+		   Uint8 *client_random, 
+		   Uint8 *server_random, 
+		   Uint16 handshake_length, 
+		   Uint8 *handshake, 
+		   Uint8 *verify_data,
+		   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                   Uint32 *request_id,Uint32 dev_id);
+#else
+                   Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaServerVerifyAesFinish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle		pointer to 64-bit key memory handle
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param aes_type		AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param modlength		size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)
+ * \param encrypt_premaster_secret	pointer to modlength-byte value in integer format
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1RsaServerVerifyAesFinish(n1_request_type request_type,
+			 Uint64 context_handle, 
+			 Uint64 *key_handle, 
+			 HashType hash_type, 
+			 SslVersion ssl_version, 
+			 AesType aes_type, 
+			 MasterSecretReturn master_secret_ret,
+			 Uint16 modlength, 
+			 Uint8 *encrypt_premaster_secret, 
+			 Uint8 *client_random, 
+			 Uint8 *server_random, 
+			 Uint16 handshake_length, 
+			 Uint8 *handshake, 
+			 Uint8 *verify_data,
+			 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                         Uint32 *request_id,Uint32 dev_id);
+#else
+                         Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFullRc4
+ *
+ * Do a full handshake without RSA operation. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the RC4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *				(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 		TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFullRc4(n1_request_type request_type,
+		 Uint64 context_handle, 
+		 HashType hash_type, 
+		 SslVersion ssl_version, 
+		 Rc4Type rc4_type, 
+		 MasterSecretReturn master_secret_ret,
+		 Uint16 pre_master_length, 
+		 Uint8 *client_random, 
+		 Uint8 *server_random, 
+		 Uint16 handshake_length, 
+		 Uint8 *handshake, 
+		 Uint8 *client_finished_message,
+		 Uint8 *server_finished_message, 
+		 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                 Uint32 *request_id,Uint32 dev_id);
+#else
+                 Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFullRc4Finish
+ *
+ * Do a full handshake without RSA operation. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the rc4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *				(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 		TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFullRc4Finish(n1_request_type request_type,
+		   Uint64 context_handle, 
+		   HashType hash_type, 
+		   SslVersion ssl_version, 
+		   Rc4Type rc4_type, 
+		   MasterSecretReturn master_secret_ret,
+		   Uint16 pre_master_length, 
+		   Uint8 *client_random, 
+		   Uint8 *server_random, 
+		   Uint16 handshake_length, 
+		   Uint8 *handshake, 
+		   Uint8 *client_finished_message,
+		   Uint8 *server_finished_message, 
+		   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                   Uint32 *request_id,Uint32 dev_id);
+#else
+                   Uint32 *request_id);
+#endif
+
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerifyRc4
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *				(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 		TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerifyRc4(n1_request_type request_type,
+		  Uint64 context_handle, 
+		  HashType hash_type, 
+		  SslVersion ssl_version, 
+		  Rc4Type rc4_type, 
+		  MasterSecretReturn master_secret_ret,
+		  Uint16 pre_master_length, 
+		  Uint8 *client_random, 
+		  Uint8 *server_random, 
+		  Uint16 handshake_length, 
+		  Uint8 *handshake, 
+		  Uint8 *verify_data,
+		  Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 *request_id,Uint32 dev_id);
+#else
+                  Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerifyRc4Finish
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the rc4 cases.
+ *
+ * The handshake message data for this request should include all handshake message
+ * data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param rc4_type		RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *				(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 		TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param verify_data		pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerifyRc4Finish(n1_request_type request_type,
+			 Uint64 context_handle, 
+			 HashType hash_type, 
+			 SslVersion ssl_version, 
+			 Rc4Type rc4_type, 
+			 MasterSecretReturn master_secret_ret,
+			 Uint16 pre_master_length, 
+			 Uint8 *client_random, 
+			 Uint8 *server_random, 
+			 Uint16 handshake_length, 
+			 Uint8 *handshake, 
+			 Uint8 *verify_data,
+			 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                         Uint32 *request_id,Uint32 dev_id);
+#else
+                         Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFull3Des
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param pre_master_length	size of premaster secret in bytes 
+ *	 			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *	  			TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *					returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFull3Des(n1_request_type request_type,
+		  Uint64 context_handle, 
+	          HashType hash_type, 
+	          SslVersion ssl_version, 
+		  DesType des_type, 
+		  MasterSecretReturn master_secret_ret,
+		  ClientFinishMessageOutput clnt_fin_msg_out,
+		  ServerFinishMessageOutput srvr_fin_msg_out,
+		  Uint16 client_pad_length,
+		  Uint16 server_pad_length,
+		  Uint16 pre_master_length, 
+		  Uint8 *client_random, 
+		  Uint8 *server_random, 
+		  Uint16 handshake_length, 
+		  Uint8 *handshake, 
+		  Uint8 *client_finished_message,
+		  Uint8 *server_finished_message, 
+		  Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 *request_id,Uint32 dev_id);
+#else
+                  Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFull3DesFinish
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type		CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type		MD5_TYPE or SHA1_TYPE
+ * \param ssl_version		VER3_0 or VER_TLS
+ * \param des_type		DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param pre_master_length	size of premaster secret in bytes 
+ *				(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 		TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake		pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ * \param request_id		Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFull3DesFinish(n1_request_type request_type,
+			Uint64 context_handle, 
+			HashType hash_type, 
+			SslVersion ssl_version, 
+			DesType des_type, 
+			MasterSecretReturn master_secret_ret,
+			ClientFinishMessageOutput clnt_fin_msg_out,
+			ServerFinishMessageOutput srvr_fin_msg_out,
+			Uint16 client_pad_length,
+			Uint16 server_pad_length,
+			Uint16 pre_master_length, 
+			Uint8 *client_random, 
+			Uint8 *server_random, 
+			Uint16 handshake_length, 
+			Uint8 *handshake, 
+			Uint8 *client_finished_message,
+			Uint8 *server_finished_message, 
+			Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 *request_id,Uint32 dev_id);
+#else
+                        Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerify3Des
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param des_type	DES, DES_EXPORT_40, DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param verify_data	pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerify3Des(n1_request_type request_type,
+					Uint64 context_handle, 
+			        HashType hash_type, 
+			        SslVersion ssl_version, 
+			        DesType des_type, 
+				    MasterSecretReturn master_secret_ret,
+			        Uint16 pre_master_length, 
+			        Uint8 *client_random, 
+			        Uint8 *server_random, 
+			        Uint16 handshake_length, 
+			        Uint8 *handshake, 
+			        Uint8 *verify_data,
+					Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerify3DesFinish
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle 64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param des_type	DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random		pointer to 32 bytes of random data
+ * \param server_random		pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param verify_data	pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerify3DesFinish(n1_request_type request_type,
+						  Uint64 context_handle, 
+					      HashType hash_type, 
+					      SslVersion ssl_version, 
+					      DesType des_type, 
+					      MasterSecretReturn master_secret_ret,
+					      Uint16 pre_master_length, 
+					      Uint8 *client_random, 
+					      Uint8 *server_random, 
+					      Uint16 handshake_length, 
+					      Uint8 *handshake, 
+					      Uint8 *verify_data,
+					      Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                                              Uint32 *request_id,Uint32 dev_id);
+#else
+                                              Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFullAes
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ * 
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFullAes(n1_request_type request_type,
+				 Uint64 context_handle, 
+		    	 HashType hash_type, 
+			     SslVersion ssl_version, 
+			     AesType aes_type, 
+			     MasterSecretReturn master_secret_ret,
+				 ClientFinishMessageOutput clnt_fin_msg_out,
+				 ServerFinishMessageOutput srvr_fin_msg_out,
+			     Uint16 client_pad_length,
+			     Uint16 server_pad_length,
+			     Uint16 pre_master_length, 
+			     Uint8 *client_random, 
+			     Uint8 *server_random, 
+			     Uint16 handshake_length, 
+			     Uint8 *handshake, 
+			     Uint8 *client_finished_message,
+			     Uint8 *server_finished_message, 
+				 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                             Uint32 *request_id,Uint32 dev_id);
+#else
+                             Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherFullAesFinish
+ *
+ * When not (RSA <= 2048), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			 	(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *			 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message dat
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherFullAesFinish(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+				       AesType aes_type, 
+				       MasterSecretReturn master_secret_ret,
+					   ClientFinishMessageOutput clnt_fin_msg_out,
+					   ServerFinishMessageOutput srvr_fin_msg_out,
+				       Uint16 client_pad_length,
+				       Uint16 server_pad_length,
+				       Uint16 pre_master_length, 
+				       Uint8 *client_random, 
+				       Uint8 *server_random, 
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *client_finished_message,
+				       Uint8 *server_finished_message, 
+					   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                                       Uint32 *request_id,Uint32 dev_id);
+#else
+                                        Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerifyAes
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param verify_data	pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ * 
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerifyAes(n1_request_type request_type,
+				   Uint64 context_handle, 
+			       HashType hash_type, 
+			       SslVersion ssl_version, 
+			       AesType aes_type, 
+			       MasterSecretReturn master_secret_ret,
+			       Uint16 pre_master_length, 
+			       Uint8 *client_random, 
+			       Uint8 *server_random, 
+			       Uint16 handshake_length, 
+			       Uint8 *handshake, 
+			       Uint8 *verify_data,
+				   Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                              Uint32 *request_id,Uint32 dev_id);
+#else
+                              Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1OtherVerifyAesFinish
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_ret	NOT_RETURNED or RETURN_ENCRYPTED
+ * \param pre_master_length	size of premaster secret in bytes 
+ *			(SSLv3: 4<=modlength<=256, modlength\%4=0; 
+ *		 	TLS: 16<=modlength<=128, modlength\%16=0)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param verify_data	pointer to 36 bytes of verify data 
+ * \param encrypt_master_secret	(master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1OtherVerifyAesFinish(n1_request_type request_type,
+						 Uint64 context_handle, 
+					     HashType hash_type, 
+				    	 SslVersion ssl_version, 
+					     AesType aes_type, 
+					     MasterSecretReturn master_secret_ret,
+					     Uint16 pre_master_length, 
+					     Uint8 *client_random, 
+					     Uint8 *server_random, 
+					     Uint16 handshake_length, 
+				    	 Uint8 *handshake, 
+				    	 Uint8 *verify_data,
+					 Uint8 *encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                                         Uint32 *request_id,Uint32 dev_id);
+#else
+                                         Uint32 *request_id);
+#endif
+
+
+#endif
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1FinishedRc4Finish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the RC4 cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyRc4* or 
+ * OtherVerifyRc4*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1FinishedRc4Finish(n1_request_type request_type,
+					  Uint64 context_handle, 
+				      HashType hash_type, 
+				      SslVersion ssl_version, 
+				      Uint16 handshake_length, 
+				      Uint8 *handshake, 
+				      Uint8 *client_finished_message, 
+				      Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                      Uint32 *request_id,Uint32 dev_id);
+#else
+                                      Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Finished3DesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all DES/3DES 
+ * cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerify3Des* or 
+ * OtherVerify3Des*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ * 
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Finished3DesFinish(n1_request_type request_type,
+					   Uint64 context_handle, 
+				       HashType hash_type, 
+				       SslVersion ssl_version, 
+					   ClientFinishMessageOutput clnt_fin_msg_out,
+					   ServerFinishMessageOutput srvr_fin_msg_out,
+				       Uint16 client_pad_length,
+				       Uint16 server_pad_length,
+				       Uint16 handshake_length, 
+				       Uint8 *handshake, 
+				       Uint8 *client_finished_message, 
+				       Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                       Uint32 *request_id,Uint32 dev_id);
+#else
+                                       Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1FinishedAesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the AES cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyAes* or 
+ * OtherVerifyAes*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1FinishedAesFinish(n1_request_type request_type,
+					  Uint64 context_handle, 
+				      HashType hash_type, 
+				      SslVersion ssl_version, 
+				      AesType aes_type, 
+					  ClientFinishMessageOutput clnt_fin_msg_out,
+					  ServerFinishMessageOutput srvr_fin_msg_out,
+				      Uint16 client_pad_length,
+				      Uint16 server_pad_length,
+				      Uint16 handshake_length, 
+				      Uint8 *handshake, 
+				      Uint8 *client_finished_message, 
+				      Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                      Uint32 *request_id,Uint32 dev_id);
+#else
+                                      Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1ResumeRc4
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param rc4_type	RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1ResumeRc4(n1_request_type request_type,
+			  Uint64 context_handle, 
+		      HashType hash_type, 
+		      SslVersion ssl_version, 
+		      Rc4Type rc4_type,
+		      MasterSecretInput master_secret_inp,
+		      Uint8 *client_random, 
+		      Uint8 *server_random,
+		      Uint8 *encrypt_master_secret,
+		      Uint16 handshake_length, 
+		      Uint8 *handshake, 
+		      Uint8 *client_finished_message, 
+		      Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 *request_id,Uint32 dev_id);
+#else
+                      Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1ResumeRc4Finish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param rc4_type	RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1ResumeRc4Finish(n1_request_type request_type,
+					Uint64 context_handle, 
+			    	HashType hash_type, 
+			    	SslVersion ssl_version, 
+			    	Rc4Type rc4_type, 
+			    	MasterSecretInput master_secret_inp,
+			    	Uint8 *client_random, 
+			    	Uint8 *server_random, 
+			    	Uint8 *encrypt_master_secret,
+			    	Uint16 handshake_length, 
+			    	Uint8 *handshake, 
+			    	Uint8 *client_finished_message, 
+			    	Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Resume3Des
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param des_type	DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min(not applicable to MC2)
+ * \param server_pad_length	number of 64-bit words to pad above min(not applicable to MC2)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Resume3Des(n1_request_type request_type,
+			   Uint64 context_handle, 
+		       HashType hash_type, 
+		       SslVersion ssl_version, 
+		       DesType des_type, 
+		       MasterSecretInput master_secret_inp,
+			   ClientFinishMessageOutput clnt_fin_msg_out,
+			   ServerFinishMessageOutput srvr_fin_msg_out,
+		       Uint16 client_pad_length,
+		       Uint16 server_pad_length,
+		       Uint8 *client_random, 
+		       Uint8 *server_random, 
+		       Uint8 *encrypt_master_secret,
+		       Uint16 handshake_length, 
+	   	       Uint8 *handshake, 
+		       Uint8 *client_finished_message, 
+		       Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                       Uint32 *request_id,Uint32 dev_id);
+#else
+                       Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Resume3DesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param des_type	DES, DES_EXPORT_40 or DES3_192
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 64-bit words to pad above min
+ * \param server_pad_length	number of 64-bit words to pad above min
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Resume3DesFinish(n1_request_type request_type,
+					 Uint64 context_handle, 
+			    	 HashType hash_type, 
+			    	 SslVersion ssl_version, 
+			    	 DesType des_type, 
+			    	 MasterSecretInput master_secret_inp,
+					 ClientFinishMessageOutput clnt_fin_msg_out,
+					 ServerFinishMessageOutput srvr_fin_msg_out,
+			    	 Uint16 client_pad_length,
+			    	 Uint16 server_pad_length,
+			    	 Uint8 *client_random, 
+			    	 Uint8 *server_random, 
+			    	 Uint8 *encrypt_master_secret,
+			    	 Uint16 handshake_length, 
+			    	 Uint8 *handshake, 
+			    	 Uint8 *client_finished_message, 
+			    	 Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                 Uint32 *request_id,Uint32 dev_id);
+#else
+                                 Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1ResumeAes
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min(not applicable to MC2)
+ * \param server_pad_length	number of 128-bit words to pad above min(not applicable to MC2)
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ *
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1ResumeAes(n1_request_type request_type,
+			  Uint64 context_handle, 
+	    	  HashType hash_type, 
+	    	  SslVersion ssl_version, 
+	    	  AesType aes_type, 
+		      MasterSecretInput master_secret_inp,
+			  ClientFinishMessageOutput clnt_fin_msg_out,
+			  ServerFinishMessageOutput srvr_fin_msg_out,
+		      Uint16 client_pad_length,
+		      Uint16 server_pad_length,
+		      Uint8 *client_random, 
+	    	  Uint8 *server_random, 
+		      Uint8 *encrypt_master_secret,
+		      Uint16 handshake_length, 
+		      Uint8 *handshake, 
+		      Uint8 *client_finished_message, 
+		      Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 *request_id,Uint32 dev_id);
+#else
+                      Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1ResumeAesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param master_secret_inp	READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ * \param clnt_fin_msg_out	RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ * \param srvr_fin_msg_out	RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ * \param client_pad_length	number of 128-bit words to pad above min
+ * \param server_pad_length	number of 128-bit words to pad above min
+ * \param client_random	pointer to 32 bytes of random data
+ * \param server_random	pointer to 32 bytes of random data
+ * \param encrypt_master_secret	pointer to 48-byte secret
+ * \param handshake_length	size in bytes of the handshake message data
+ * \param handshake	pointer to the handshake message data
+ * 
+ * \param client_finished_message	pointer to encrypted part of client finished message 
+ * \param server_finished_message	pointer to encrypted part of server finished message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1ResumeAesFinish(n1_request_type request_type,
+					Uint64 context_handle, 
+			    	HashType hash_type, 
+			    	SslVersion ssl_version, 
+			    	AesType aes_type, 
+			    	MasterSecretInput master_secret_inp,
+					ClientFinishMessageOutput clnt_fin_msg_out,
+					ServerFinishMessageOutput srvr_fin_msg_out,
+			    	Uint16 client_pad_length,
+			    	Uint16 server_pad_length,
+			    	Uint8 *client_random, 
+			    	Uint8 *server_random, 
+			    	Uint8 *encrypt_master_secret,
+			    	Uint16 handshake_length, 
+			    	Uint8 *handshake, 
+			    	Uint8 *client_finished_message, 
+			    	Uint8 *server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1EncryptRecordRc4
+ *
+ *    Encrypts the SSL record for RC4 cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param message_length	size of message in bytes (0<=length<=2^14+1024)
+ * \param message	pointer to length-byte message 
+ *
+ * \param record	pointer to (length + hash_size) bytes of encrypted record 
+ * \param request_id	Unique ID for this request.
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1EncryptRecordRc4(n1_request_type request_type,
+					 Uint64 context_handle, 
+			HashType hash_type,  
+			SslVersion ssl_version, 
+			SslPartyType ssl_party,
+			MessageType message_type,
+			Uint16 message_length, 
+			Uint8 *message, 
+			Uint8 *record,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 *request_id,Uint32 dev_id);
+#else
+                        Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1DecryptRecordRc4
+ *
+ *    Decrypts the SSL record for RC4 cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param record_length	size of record in bytes (0<=length<=2^14+1024)
+ * \param record	pointer to length-byte encrypted part of record 
+ *
+ * \param message	pointer to (record length - hash size) bytes 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1DecryptRecordRc4(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+		 			 SslPartyType ssl_party,
+					 MessageType message_type, 
+					 Uint16 record_length, 
+					 Uint8 *record, 
+					 Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                         Uint32 *request_id,Uint32 dev_id);
+#else
+                                          Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1EncryptRecord3Des
+ *
+ *    Encrypts the SSL record for 3Des cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param pad_length	size of extra padding in 8-byte blocks
+ * \param message_length	size of param in bytes (0<=length<=2^14+1024)
+ * \param message	pointer to length-byte input message
+ *
+ * \param record_length	pointer to length of the encrypted part of the record in bytes
+ * \param record	pointer to *record_length-byte output 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1EncryptRecord3Des(n1_request_type request_type,
+					  Uint64 context_handle, 
+					  HashType hash_type, 
+					  SslVersion ssl_version, 
+					  SslPartyType ssl_party,
+					  MessageType message_type, 
+					  Uint16 pad_length,
+					  Uint16 message_length, 
+					  Uint8 *message, 
+					  Uint16 *record_length, 
+					  Uint8 *record,
+#ifdef CAVIUM_MULTICARD_API
+                                          Uint32 *request_id,Uint32 dev_id);
+#else
+                                          Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1DecryptRecord3Des
+ *
+ *    Decrypts the SSL record for 3Des cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param record_length	size of the encrypted part of the input record in bytes 
+ *		(length\%8=0, 0<=length<=2^14+1024)
+ * \param record	pointer to length-byte encrypted part of the input record
+ *
+ * \param message_length	pointer to length in bytes of the decrypted message
+ * \param message	pointer to *message_length-byte output 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1DecryptRecord3Des(n1_request_type request_type,
+					  Uint64 context_handle, 
+					  HashType hash_type, 
+					  SslVersion ssl_version, 
+					  SslPartyType ssl_party,
+					  MessageType message_type,
+					  Uint16 record_length, 
+					  Uint8 *record, 
+					  Uint16 *message_length, 
+					  Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                          Uint32 *request_id,Uint32 dev_id);
+#else
+                                          Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1DecryptRecord3DesRecover
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param record_length	size of the encrypted part of the input record in bytes 
+ *		(length\%8=0, 0<=length<=2^14+1024)
+ * \param record	pointer to length-byte encrypted part of the input record
+ * 
+ * \param message_length	pointer to length in bytes of the decrypted message
+ * \param message	pointer to *message_length-byte output, 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1DecryptRecord3DesRecover(n1_request_type request_type,
+							 Uint64 context_handle, 
+							 HashType hash_type, 
+							 SslVersion ssl_version,
+				 			 SslPartyType ssl_party,
+							 MessageType message_type,
+							 Uint16 record_length, 
+							 Uint8 *record, 
+							 Uint16 *message_length, 
+							 Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                                         Uint32 *request_id,Uint32 dev_id);
+#else
+                                                         Uint32 *request_id);
+#endif
+
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1EncryptRecordAes
+ *
+ *    Encrypts the SSL record for Aes cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param aes_type	AES_128 or AES_256
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param pad_length	size of extra padding in 8-byte blocks
+ * \param message_length	size of input in bytes (0<=length<=2^14+1024)
+ * \param message	pointer to length-byte input
+ *
+ * \param record_length	pointer to length of the encrypted part of the record in bytes
+ * \param record	pointer to *record_length-byte output, 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1EncryptRecordAes(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+		 			 SslPartyType ssl_party,
+					 AesType aes_type, 
+					 MessageType message_type,
+					 Uint16 pad_length,
+					 Uint16 message_length, 
+					 Uint8 *message, 
+					 Uint16 *record_length, 
+					 Uint8 *record,
+#ifdef CAVIUM_MULTICARD_API
+                                         Uint32 *request_id,Uint32 dev_id);
+#else
+                                         Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1DecryptRecordAes
+ *
+ *    Decrypts the SSL record for Aes cipher.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE 
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param ssl_party	SERVER or CLIENT
+ * \param aes_type	AES_128 or AES_256
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param record_length	size of input in bytes (length\%16=0, 0<=length<=2^14+1024)
+ * \param record	pointer to length-byte input
+ * 
+ * \param message_length	pointer to length in bytes of the decrypted message
+ * \param message	pointer to *message_length-byte output
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1DecryptRecordAes(n1_request_type request_type,
+					 Uint64 context_handle, 
+					 HashType hash_type, 
+					 SslVersion ssl_version, 
+					 SslPartyType ssl_party,
+					 AesType aes_type, 
+					 MessageType message_type,
+					 Uint16 record_length, 
+					 Uint8 *record, 
+					 Uint16 *message_length, 
+					 Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                         Uint32 *request_id,Uint32 dev_id);
+#else
+                                          Uint32 *request_id);
+#endif
+
+
+
+#ifndef MC2
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1DecryptRecordAesRecover
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param hash_type	MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ * \param ssl_version	VER3_0 or VER_TLS
+ * \param aes_type	AES_128 or AES_256
+ * \param ssl_party	SERVER or CLIENT
+ * \param message_type	CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ * \param record_length	size of input in bytes (length\%16=0, 0<=length<=2^14+1024)
+ * \param record	pointer to length-byte input
+ * 
+ * \param message_length	pointer to length in bytes of the decrypted message
+ * \param message	pointer to *message_length-byte output
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1DecryptRecordAesRecover(n1_request_type request_type,
+			    Uint64 context_handle, 
+			    HashType hash_type, 
+			    SslVersion ssl_version, 
+			    SslPartyType ssl_party,
+			    AesType aes_type, 
+			    MessageType message_type,
+			    Uint16 record_length, 
+			    Uint8 *record, 
+			    Uint16 *message_length, 
+			    Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                            Uint32 *request_id,Uint32 dev_id);
+#else
+                            Uint32 *request_id);
+#endif
+
+
+#endif
+
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaSsl20ServerFullRc4
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param rc4_type	RC4_128 or RC4_EXPORT_40
+ * \param client_master_secret	master key received in client-master-key handshake message.
+ * \param clear_master_secret_length	length (in bytes) of clear portion of client_master_secret
+ * \param encrypted_master_secret_length	length (in bytes) of encrypted portion of client_master_secret
+ * \param modlength	size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)	
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ *
+ *
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param server_finished	pointer to encrypted part of server finished message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param master_secret	master secret to used in session caching for reuse.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ *
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1RsaSsl20ServerFullRc4(n1_request_type request_type,
+						  Uint64 context_handle,
+						  Uint64 *key_handle,
+						  Rc4Type rc4_type,
+						  Uint8 *client_master_secret,
+						  Uint16 clear_master_secret_length,
+						  Uint16 encrypted_master_secret_length,
+						  Uint16 modlength,
+						  Uint8 *challenge,
+						  Uint16 challenge_length,	
+						  Uint8 *connection_id,
+						  Uint8 *session_id,
+						  Uint8 *client_finished,	
+						  Uint8 *server_finished,	
+						  Uint8 *server_verify,		
+						  Uint8 *master_secret,
+						  Uint16 *master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                                  Uint32 *request_id,Uint32 dev_id);
+#else
+                                                  Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaSsl20ServerClientAuthRc4
+ *
+ * Generates key material, and certificate req, verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param rc4_type	RC4_128 or RC4_EXPORT_40
+ * \param client_master_secret	master key received in client-master-key handshake message.
+ * \param clear_master_secret_length	length (in bytes) of clear portion of client_master_secret
+ * \param encrypted_master_secret_length	length (in bytes) of encrypted portion of client_master_secret
+ * \param modlength	size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)	
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param auth_type	SSLv2 authentication type
+ * \param cert_challenge	SSLv2 certificate challenge
+ *
+ * \param cert_request	SSLv2 certificate request
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param master_secret	master secret to used in session caching for reuse.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param request_id	Unique ID for this request
+ * 
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuthRc4(
+					n1_request_type request_type,
+				 	Uint64 context_handle,
+				  	Uint64 *key_handle,
+				  	Rc4Type rc4_type,
+				  	Uint8 *client_master_secret,
+				  	Uint16 clear_master_secret_length,
+				  	Uint16 encrypted_master_secret_length,
+				  	Uint16 modlength,
+				  	Uint8 *challenge,
+				  	Uint16 challenge_length,	
+				  	Uint8 *connection_id,		
+				  	Uint8 *session_id,
+				  	Uint8 *client_finished,	
+					Uint8 auth_type,
+					Uint8 *cert_challenge,
+					Uint8 *cert_request,
+				  	Uint8 *server_verify,		
+				  	Uint8 *master_secret,
+				  	Uint16 *master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                        Uint32 *request_id,Uint32 dev_id);
+#else
+                                        Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20ResumeRc4
+ *
+ * Resumes a previously negotiated session.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param rc4_type	RC4_128 or RC4_EXPORT_40
+ * \param master_secret	master secret from previous session.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param client_finished	pointer to encrypted part of client finished message.
+ * \param server_finished	pointer to encrypted part of server finished message. 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeRc4 (n1_request_type request_type,
+			Uint64 context_handle,
+			Uint64 *key_handle,
+			Rc4Type rc4_type,
+			Uint8 *master_secret,
+			Uint16 master_secret_length,
+			Uint8 *challenge,
+			Uint16 challenge_length,	
+			Uint8 *connection_id,		
+			Uint8 *session_id,
+			Uint8 *client_finished,	
+			Uint8 *server_finished,	
+			Uint8 *server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 *request_id,Uint32 dev_id);
+#else
+                        Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20ResumeClientAuthRc4
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param rc4_type	RC4_128 or RC4_EXPORT_40
+ * \param master_secret	master secret from previous session.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param auth_type	client auth type
+ * \param cert_challenge	cert challenge
+ *
+ * \param cert_request	pointer to encrypted part of cert request message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeClientAuthRc4 (n1_request_type request_type,
+					Uint64 context_handle,
+					Uint64 *key_handle,
+					Rc4Type rc4_type,
+					Uint8 *master_secret,
+					Uint16 master_secret_length,
+					Uint8 *challenge,
+					Uint16 challenge_length,	
+					Uint8 *connection_id,		
+					Uint8 *session_id,
+					Uint8 *client_finished,	
+					Uint8 auth_type,
+					Uint8 *cert_challenge,
+					Uint8 *cert_request,
+					Uint8 *server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                                        Uint32 *request_id,Uint32 dev_id);
+#else
+                                        Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaSsl20ServerFull3Des
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param des_type	DES or DES3_192
+ * \param client_master_secret	master key received in client-master-key handshake message.
+ * \param clear_master_secret_length	length (in bytes) of clear portion of client_master_secret
+ * \param encrypted_master_secret_length	length (in bytes) of encrypted portion of client_master_secret
+ * \param modlength	size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)	
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param iv	initialization vectore sent by client
+ *
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param server_finished	pointer to encrypted part of server finished message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param master_secret	master secret to used in session caching for reuse.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1RsaSsl20ServerFull3Des(n1_request_type request_type,
+						   Uint64 context_handle,
+						  Uint64 *key_handle,
+						  DesType des_type,
+						  Uint8 *client_master_secret,
+						  Uint16 clear_master_secret_length,
+						  Uint16 encrypted_master_secret_length,
+						  Uint16 modlength,
+						  Uint8 *challenge,
+						  Uint16 challenge_length,	
+						  Uint8 *connection_id,		
+						  Uint8 *session_id,
+						  Uint8 *iv,
+						  Uint8 *client_finished,	
+						  Uint8 *server_finished,	
+						  Uint8 *server_verify,		
+						  Uint8 *master_secret,
+						  Uint16 *master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                                   Uint32 *request_id,Uint32 dev_id);
+#else
+                                                   Uint32 *request_id);
+#endif
+
+
+
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1RsaSsl20ServerClientAuth3Des
+ *
+ * Generates key material, verifies cllient finished msg, creates server verify
+ * and cert request messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param des_type	DES or DES3_192
+ * \param client_master_secret	master key received in client-master-key handshake message.
+ * \param clear_master_secret_length	length (in bytes) of clear portion of client_master_secret
+ * \param encrypted_master_secret_length	length (in bytes) of encrypted portion of client_master_secret
+ * \param modlength	size of RSA operation in bytes (64<=modlength<=256, modlength\%8=0)	
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param iv	initialization vectore sent by client
+ * \param auth_type	client auth type
+ * \param cert_challenge	certficate challenge.
+ *
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param cert_request	pointer to encrypted part of certificate request message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param master_secret	master secret to used in session caching for reuse.
+ * \param master_secret_length	size in bytes of master secret.
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuth3Des(
+						n1_request_type request_type,
+						Uint64 context_handle,
+						Uint64 *key_handle,
+						DesType des_type,
+						Uint8 *client_master_secret,
+						Uint16 clear_master_secret_length,
+						Uint16 encrypted_master_secret_length,
+						Uint16 modlength,
+						Uint8 *challenge,
+						Uint16 challenge_length,	
+						Uint8 *connection_id,		
+						Uint8 *session_id,
+						Uint8 *iv,
+						Uint8 *client_finished,	
+						Uint8 auth_type,
+						Uint8 *cert_challenge,
+						Uint8 *cert_request,	
+						Uint8 *server_verify,		
+						Uint8 *master_secret,
+						Uint16 *master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                                Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20Resume3Des
+ *
+ * Resumes a previouly negotiated handshake. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+ *	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param des_type	DES or DES3_192
+ * \param master_secret	master key generated in previous handshake
+ * \param master_secret_length	size in bytes of master secret.
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param iv	initialization vectore sent by client
+ *
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param server_finished	pointer to encrypted part of server finished message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1Ssl20Resume3Des(
+			n1_request_type request_type,
+			Uint64 context_handle,
+		  Uint64 *key_handle,
+		  DesType des_type,
+		  Uint8 *master_secret,
+		  Uint16 master_secret_length,
+		  Uint8 *challenge,
+		  Uint16 challenge_length,	
+		  Uint8 *connection_id,		
+		  Uint8 *session_id,
+		  Uint8 *iv,
+		  Uint8 *client_finished,	
+		  Uint8 *server_finished,	
+		  Uint8 *server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 *request_id,Uint32 dev_id);
+#else
+                  Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20ResumeClientAuth3Des
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit byte-pointer to context (context_handle\%8=0)
+ * \param key_handle	pointer to 64-bit key memory handle
+ * \param des_type	DES or DES3_192
+ * \param master_secret	master key generated in previous handshake
+ * \param master_secret_length	size in bytes of master secret.
+ * \param challenge	pointer to challenge data.
+ * \param challenge_length	length (in bytes) of challenge data.
+ * \param connection_id	pointer to 16 bytes of connection ID.
+ * \param session_id	pointer to 16 bytes of Session ID.
+ * \param iv	initialization vectore sent by client
+ * \param client_finished	pointer to encrypted part of client finished message 
+ * \param auth_type	client authentication type
+ * \param cert_challenge	cert request challenge
+ * \param cert_request	certificate request
+ *
+ *
+ *
+ * \param cert_request	pointer to encrypted part of cert request message 
+ * \param server_verify	pointer to encrypted part of server verify message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ * \verbatim
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ * \endverbatim
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1Ssl20ResumeClientAuth3Des(
+			n1_request_type request_type,
+			Uint64 context_handle,
+		  Uint64 *key_handle,
+		  DesType des_type,
+		  Uint8 *master_secret,
+		  Uint16 master_secret_length,
+		  Uint8 *challenge,
+		  Uint16 challenge_length,	
+		  Uint8 *connection_id,		
+		  Uint8 *session_id,
+		  Uint8 *iv,
+		  Uint8 *client_finished,
+		  Uint8 auth_type,
+		  Uint8 *cert_challenge,
+		  Uint8 *cert_request,	
+		  Uint8 *server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 *request_id,Uint32 dev_id);
+#else
+                  Uint32 *request_id);
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20DecryptRecordRc4
+ *
+ *    Decrypts the SSL record for Rc4  cipher when using SSLversion 2.0.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param record_length	size of record in bytes (0<=length<=2^16-1)
+ * \param record	pointer to length-byte encrypted part of record 
+ *
+ * \param message	pointer to decrypted message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1Ssl20DecryptRecordRc4(
+				n1_request_type request_type,
+				Uint64 context_handle,
+				Uint16 record_length,
+				Uint8 *record,
+				Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20EncryptRecordRc4
+ *
+ *    Encrypts the SSL record for RC4 cipher when using SSLversion 2.0.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param message_length	size of message in bytes (0<=length<=2^16-1)
+ * \param message	pointer to length-byte message 
+ *
+ * \param record	pointer to encrypted record 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1Ssl20EncryptRecordRc4(
+				n1_request_type request_type,
+				Uint64 context_handle,
+				Uint16 message_length,
+				Uint8 *message,
+				Uint8 *record,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20DecryptRecord3Des
+ *
+ *    Decrypts the SSL record for 3Des cipher when using SSLversion 2.0.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param des_type	DES or DES3_192
+ * \param record_length	size of record in bytes (0<=length<=2^16-1)
+ * \param record	pointer to length-byte encrypted part of record 
+ *
+ * \param message	pointer to decrypted message 
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32 
+Csp1Ssl20DecryptRecord3Des(
+				   n1_request_type request_type,
+				   Uint64 context_handle,
+				   DesType des_type,
+				   Uint16 record_length,
+				   Uint8 *record,
+				   Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+                                   Uint32 *request_id,Uint32 dev_id);
+#else
+                                   Uint32 *request_id);
+#endif
+
+
+/*+****************************************************************************/
+ /*! \ingroup SSL_OPS
+ *
+ * Csp1Ssl20EncryptRecord3Des
+ *
+ *    Encrypts the SSL record for 3Des cipher when using SSLversion 2.0.
+ *
+ * \param request_type	CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ * \param context_handle	64-bit pointer to context (context_handle\%8=0)
+ * \param des_type	DES or DES3_192
+ * \param message_length	size of message in bytes (0<=length<=2^16-1)
+ * \param message	pointer to length-byte message 
+ *
+ * \param record	pointer to encrypted record 
+ * \param record_length	SSLv2 record size in bytes
+ * \param request_id	Unique ID for this request
+ *
+ * \if CAVIUM_MULTICARD_API
+ * \param dev_id	Device ID
+ * \endif
+ *
+ * \retval SUCCESS 0
+ * \retval FAILURE/PENDING #Csp1ErrorCodes
+ */
+ /*-***************************************************************************/
+Uint32
+Csp1Ssl20EncryptRecord3Des(	
+				n1_request_type request_type,
+				Uint64 context_handle,
+				DesType des_type,
+				Uint16 message_length,
+				Uint8 *message,
+				Uint16 *record_length,
+				Uint8 *record,
+#ifdef CAVIUM_MULTICARD_API
+                                Uint32 *request_id,Uint32 dev_id);
+#else
+                                Uint32 *request_id);
+#endif
+
+
+
+
+
+#endif /* CSP1_KERNEL */
+
+#endif /* _CAVIUM_SSL_H_ */
diff -Naur openssl-0.9.8r-orig/include/cavium_sysdep.h openssl-0.9.8r/include/cavium_sysdep.h
--- openssl-0.9.8r-orig/include/cavium_sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/cavium_sysdep.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,16 @@
+#if !defined (__CAVIUM_SYSDEP_H__)
+#define __CAVIUM_SYSDEP_H__
+
+#if defined (_WIN32)
+#include "windows_sysdep.h"
+#elif defined (linux)
+#include "linux_sysdep.h"
+#elif defined (__FreeBSD__)
+#include "freebsd_sysdep.h"
+#elif defined (__NetBSD__)
+#include "netbsd_sysdep.h"
+#else
+#include "custom_sysdep.h"
+#endif
+
+#endif
diff -Naur openssl-0.9.8r-orig/include/custom_ioctl.h openssl-0.9.8r/include/custom_ioctl.h
--- openssl-0.9.8r-orig/include/custom_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/custom_ioctl.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,72 @@
+/* custom_ioctl.h */
+/*
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+
+#define IOCTL_CSP1_DIRECT_OPERATION_CODE	CSP1_OPERATION_CODE
+#define IOCTL_CSP1_SG_OPERATION_CODE		CSP1_SG_OPERATION_CODE
+#define IOCTL_CSP1_ALLOC_CODE  				CSP1_ALLOC_CODE
+#define IOCTL_CSP1_FREE_CODE  				CSP1_FREE_CODE
+#define IOCTL_CSP1_FSK_ALLOC_CODE			CSP1_FSK_ALLOC_CODE
+#define IOCTL_CSP1_FSK_FREE_CODE			CSP1_FSK_FREE_CODE
+#define IOCTL_CSP1_STATISTICS 				CSP1_STATISTICS_CODE
+#define IOCTL_CSP1_CONFIGURATION_CODE  		CSP1_CONFIGURATION_CODE
+
+/*
+ * $Id: custom_ioctl.h,v 1.1 2007/01/06 02:47:40 panicker Exp $
+ * $Log: custom_ioctl.h,v $
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.3  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.2  2004/05/02 19:45:59  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.1  2004/04/15 22:40:50  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
+
diff -Naur openssl-0.9.8r-orig/include/linux_ioctl.h openssl-0.9.8r/include/linux_ioctl.h
--- openssl-0.9.8r-orig/include/linux_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/linux_ioctl.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,142 @@
+/* linux_ioctl.h */
+/*
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#ifndef _LINUX_IOCTL_H_
+#define _LINUX_IOCTL_H_
+
+#include <linux/ioctl.h>
+
+#define N1_MAGIC	0xC0
+#define IOCTL_N1_OPERATION_CODE		_IOWR(N1_MAGIC, N1_OPERATION_CODE, \
+						n1_operation_buffer)
+#define IOCTL_N1_DO_OPERATION		_IOWR(N1_MAGIC, N1_OPERATION_CODE, \
+						n1_operation_buffer)
+#define IOCTL_N1_DO_SG_OPERATION	_IOWR(N1_MAGIC, N1_SG_OPERATION_CODE, \
+						n1_operation_buffer)
+#define IOCTL_N1_POLL_CODE		_IOWR(N1_MAGIC, N1_REQUEST_STATUS, \
+						Csp1RequestStatusBuffer) 
+#define IOCTL_N1_GET_REQUEST_STATUS	_IOWR(N1_MAGIC, N1_REQUEST_STATUS, \
+						Csp1RequestStatusBuffer) 
+#define IOCTL_N1_ALLOC_CONTEXT		_IOWR(N1_MAGIC, N1_ALLOC_CONTEXT, \
+						n1_operation_buffer)
+#define IOCTL_N1_FREE_CONTEXT		_IOWR(N1_MAGIC, N1_FREE_CONTEXT, \
+						n1_operation_buffer)
+#define IOCTL_N1_ALLOC_KEYMEM		_IOWR(N1_MAGIC, N1_ALLOC_KEYMEM, \
+						Uint64)
+#define IOCTL_N1_FREE_KEYMEM		_IOWR(N1_MAGIC, N1_FREE_KEYMEM, \
+						n1_write_key_buf)
+#define IOCTL_N1_WRITE_KEYMEM		_IOWR(N1_MAGIC, N1_WRITE_KEYMEM, \
+						n1_write_key_buf)
+#define IOCTL_N1_FLUSH_ALL_CODE		_IO(N1_MAGIC, N1_FLUSH_ALL_CODE)
+#define IOCTL_N1_FLUSH_CODE		_IOWR(N1_MAGIC, N1_FLUSH_CODE, Uint32)
+#define IOCTL_N1_DEBUG_WRITE_CODE	_IOWR(N1_MAGIC, N1_DEBUG_WRITE_CODE, DebugRWReg)
+#define IOCTL_N1_DEBUG_READ_CODE	_IOWR(N1_MAGIC, N1_DEBUG_READ_CODE, DebugRWReg)
+#define IOCTL_PCI_DEBUG_WRITE_CODE	_IOWR(N1_MAGIC, PCI_DEBUG_WRITE_CODE, DebugRWReg)
+#define IOCTL_PCI_DEBUG_READ_CODE	_IOWR(N1_MAGIC, PCI_DEBUG_READ_CODE, DebugRWReg)
+#define IOCTL_N1_INIT_CODE		_IOWR(N1_MAGIC, N1_INIT_CODE, Csp1InitBuffer)
+#define IOCTL_N1_SOFT_RESET_CODE	_IOWR(N1_MAGIC, N1_SOFT_RESET_CODE,Uint32)
+#define IOCTL_N1_API_TEST_CODE		_IO(N1_MAGIC, N1_API_TEST_CODE)
+#define IOCTL_N1_GET_RANDOM_CODE	_IOWR(N1_MAGIC, N1_GET_RANDOM_CODE, \
+						n1_operation_buffer)
+#define IOCTL_N1_GET_DEV_TYPE	_IOR(N1_MAGIC, N1_GET_DEVICE_TYPE, \
+						Uint32)
+
+#define IOCTL_CSP1_GET_CORE_ASSIGNMENT	_IOR(N1_MAGIC, N1_CORE_ASSIGNMENT,Csp1CoreAssignment)
+#define IOCTL_CSP1_SET_CORE_ASSIGNMENT	_IOW(N1_MAGIC, N1_CORE_ASSIGNMENT,Csp1CoreAssignment)
+
+#define IOCTL_N1_GET_ALL_REQUEST_STATUS _IOWR(N1_MAGIC, N1_GET_ALL_REQUEST_STATUS, Csp1StatusOperationBuffer)
+
+#define IOCTL_N1_GET_DEV_CNT _IOR(N1_MAGIC, N1_GET_DEV_CNT, Csp1DevMask)
+
+#define IOCTL_N1_GET_DRIVER_STATE _IOR(N1_MAGIC, N1_GET_DRIVER_STATE, uint8_t)
+
+#define IOCTL_N1_GET_STATUS_DDR	_IOWR(N1_MAGIC, N1_GET_STATUS_DDR,Uint32)
+
+#endif
+
+/*
+ * $Id: linux_ioctl.h,v 1.7 2009/09/09 14:14:45 aravikumar Exp $
+ * $Log: linux_ioctl.h,v $
+ * Revision 1.7  2009/09/09 14:14:45  aravikumar
+ * NPLUS macro dependency removed and made it dynamic
+ *
+ * Revision 1.6  2008/07/30 10:40:04  aramesh
+ * IOCTL arguments given properly.
+ *
+ * Revision 1.5  2008/07/29 14:52:23  aramesh
+ * added IOCTL_GET_DDR_STATUS.
+ *
+ * Revision 1.4  2008/07/29 11:09:47  aramesh
+ * argument added to SET_SOFT_RESET.
+ *
+ * Revision 1.3  2008/07/02 12:44:45  aramesh
+ * deleted config part and corresponding flags.
+ *
+ * Revision 1.2  2007/07/04 04:50:48  kchunduri
+ * --new IOCTL to return number of nitrox devices detected.
+ *
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.6  2006/08/16 14:05:40  kchunduri
+ * --modified definition of GET_REQUEST_STATUS to use Csp1RequestStatusBuffer
+ *
+ * Revision 1.5  2006/04/17 04:10:25  kchunduri
+ * --new IOCTL to support Csp1GetAllResults
+ *
+ * Revision 1.4  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.3  2004/05/02 19:45:59  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.2  2004/04/21 20:00:29  bimran
+ * NPLUS support.
+ *
+ * Revision 1.1  2004/04/15 22:40:50  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
+
diff -Naur openssl-0.9.8r-orig/include/linux_sysdep.h openssl-0.9.8r/include/linux_sysdep.h
--- openssl-0.9.8r-orig/include/linux_sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8r/include/linux_sysdep.h	2013-08-02 13:25:18.481719407 +0200
@@ -0,0 +1,1107 @@
+/* linux_sysdep.h */
+/*
+ * Copyright (c) 2003-2005 Cavium Networks (support@cavium.com). All rights 
+ * reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright notice, 
+ * this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright notice, 
+ *    this list of conditions and the following disclaimer in the documentation 
+ *    and/or other materials provided with the distribution.
+ * 
+ * 3. All advertising materials mentioning features or use of this software 
+ *    must display the following acknowledgement:
+ * 
+ *   This product includes software developed by Cavium Networks
+ * 
+ * 4. Cavium Networks' name may not be used to endorse or promote products 
+ *    derived from this software without specific prior written permission.
+ * 
+ * 5. User agrees to enable and utilize only the features and performance 
+ *    purchased on the target hardware.
+ * 
+ * This Software,including technical data,may be subject to U.S. export control 
+ * laws, including the U.S. Export Administration Act and its associated 
+ * regulations, and may be subject to export or import regulations in other 
+ * countries.You warrant that You will comply strictly in all respects with all 
+ * such regulations and acknowledge that you have the responsibility to obtain 
+ * licenses to export, re-export or import the Software.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED,STATUTORY, OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT,FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES, ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#ifndef _LINUX_SYSDEP_H
+#define _LINUX_SYSDEP_H
+
+/*Define PORT_TO_64BIT for 64bit aligned API data structure.*/
+#define PORT_TO_64BIT
+
+#ifndef CAVIUM_NO_MMAP
+#define CAVIUM_NO_MMAP
+#endif
+
+#ifndef CTX_MEM_IS_HOST_MEM
+#define CTX_MEM_IS_HOST_MEM
+#endif
+
+#ifndef DMA_DYN_MAP
+#define DMA_DYN_MAP
+#endif
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#ifdef DMA_DYN_MAP
+#include <linux/pci.h>
+#endif
+#else
+#include <sys/types.h>
+#endif
+typedef  u_int8_t          Uint8;
+typedef  u_int16_t         Uint16;
+typedef  u_int32_t         Uint32;
+typedef  u_int64_t 	   Uint64;
+
+typedef unsigned long ptrlong;
+
+#ifndef OP_BUF_ALIGN
+#define OP_BUF_ALIGN	0
+#endif
+
+#ifndef KEY_BUF_ALIGN
+#define KEY_BUF_ALIGN	6
+#endif
+
+#ifdef __KERNEL__
+#define CSP1_KERNEL
+#endif
+
+#ifndef CAVIUM_IPSEC
+
+#ifdef __KERNEL__
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))  
+#include <linux/config.h>
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))  
+#include <linux/highmem.h>
+#endif
+
+#ifdef CNS3000
+typedef struct {
+	uint32_t unused;
+	unsigned long config_addr;
+} cns3000_dev_t;
+#endif
+
+#
+#if 0
+#undef __NO_VERSION__ /* don't define kernel_verion in module.h */
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#  define MODVERSIONS
+#endif /*CONFIG_MODVERSIONS*/
+
+#ifdef MODVERSIONS
+#  include <linux/modversions.h>
+#endif /*MODVERSIONS*/
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h> 
+#include <linux/slab.h> 
+#include <linux/types.h>  
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <asm/byteorder.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+#include <linux/smp_lock.h>
+#endif
+
+
+#if 0
+#define MPRINTFLOW()   \
+        printk("--> %s:%s\n", __FILE__, __FUNCTION__)
+#else
+#define MPRINTFLOW()  do{}while(0) 
+#endif
+
+#ifndef __CAVIUM_LITTLE_ENDIAN
+#define __CAVIUM_LITTLE_ENDIAN 4321
+#endif
+
+#ifndef __CAVIUM_BIG_ENDIAN
+#define __CAVIUM_BIG_ENDIAN 1234
+#endif
+
+
+#ifdef __LITTLE_ENDIAN_BITFIELD
+#define __CAVIUM_BYTE_ORDER __CAVIUM_LITTLE_ENDIAN 
+#else /* presumably Big Endian :-) */
+#define __CAVIUM_BYTE_ORDER __CAVIUM_BIG_ENDIAN 
+#endif
+
+#if BITS_PER_LONG == 32
+#define CAST64(v) ((unsigned long long)(v))
+#elif BITS_PER_LONG == 64
+#define CAST64(v) ((unsigned long long)(unsigned long)(v))
+#else
+#error "Unknown system architecture"
+#endif
+
+#define CAVIUM_PCI_DMA_TODEVICE       PCI_DMA_TODEVICE
+#define CAVIUM_PCI_DMA_FROMDEVICE     PCI_DMA_FROMDEVICE
+#define CAVIUM_PCI_DMA_BIDIRECTIONAL  PCI_DMA_BIDIRECTIONAL
+
+#define CAVIUM_HZ		      HZ
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+#define INTERRUPT_RETURN
+#else
+typedef void irqreturn_t;
+#endif
+
+/*
+ * cavium_print
+ *
+ * Prints message (x) to stdout
+ */
+typedef dma_addr_t cavium_dmaaddr;
+
+extern int cavium_debug_level;
+#define cavium_print(format,...)	if(cavium_debug_level) \
+						printk(format,## __VA_ARGS__)
+#define cavium_error(format,...)	printk(format,## __VA_ARGS__)
+
+#define cavium_dbgprint(format,...)	if(cavium_debug_level > 1) \
+						printk(format,## __VA_ARGS__)
+
+
+typedef void (*CallBackFn)(int, void *);
+/*
+ * cavium_spinlock_t
+ */
+typedef spinlock_t  cavium_spinlock_t;		
+#define CAVIUM_SPIN_LOCK_UNLOCKED SPIN_LOCK_UNLOCKED
+
+/* 
+ * cavium_semaphore
+ */
+typedef struct semaphore  cavium_semaphore; 
+
+
+/*
+ * cavium_spin_lock_init
+ *
+ * initializes spinlock
+ */
+#define cavium_spin_lock_init(lock)		spin_lock_init((lock))
+
+
+/*
+ * cavium_spin_lock
+ *
+ * acquire lock
+ */
+#define cavium_spin_lock(lock)			spin_lock((lock))	
+
+
+
+/*
+ * cavium_spin_unlock
+ *
+ * release lock
+ */
+#define cavium_spin_unlock(lock)		spin_unlock((lock))	
+
+/* Added for compatibility with BSD series */
+#define cavium_spin_lock_destroy(lock)		
+/*
+ * cavium_spin_lock_irq
+ *
+ * acquire lock
+ */
+#define cavium_spin_lock_irq(lock)			spin_lock_irq((lock))	
+
+
+
+/*
+ * cavium_spin_unlock_irq
+ *
+ * release lock
+ */
+#define cavium_spin_unlock_irq(lock)		spin_unlock_irq((lock))	
+
+/*
+ * cavium_spin_lock_irqsave
+ *
+ * acquire lock, disable interrupt and store interrupt status in flags
+ */
+#define cavium_spin_lock_irqsave(lock, flags)			spin_lock_irqsave((lock), (flags))	
+
+
+
+/*
+ * cavium_spin_unlock_irqrestore
+ *
+ * release lock and restore interrupts
+ */
+#define cavium_spin_unlock_irqrestore(lock, flags)		spin_unlock_irqrestore((lock), (flags))
+
+
+/*
+ * cavium_spinlock_softirqsave
+ * acquire lock in softirq save mode
+ */
+
+#define cavium_spin_lock_softirqsave(lock) spin_lock_bh((lock))
+
+
+/*
+ * cavium_spin_unlock_softirqrestore
+ * releases lock in softirq save mode
+ */
+#define cavium_spin_unlock_softirqrestore(lock) spin_unlock_bh((lock))
+
+static inline void cavium_softirq_disable(int _flags)
+{	
+	local_bh_disable();
+}
+static inline void cavium_softirq_enable(int _flags)
+{
+	local_bh_enable(); 
+}
+
+#if 0
+/*
+ * cavium_spinlock_softirqsave
+ * acquire lock in softirq save mode
+ */
+#define cavium_spin_lock_softirqsave(lock)	spin_lock_bh(lock)
+
+
+/*
+ * cavium_spin_unlock_softirqrestore
+ * releases lock in softirq save mode
+ */
+#define cavium_spin_unlock_softirqrestore(lock)		spin_unlock_bh(lock)
+
+#endif
+
+/*
+ * cavium_sema_init
+ *
+ * Initializes semaphore
+ */
+
+#define cavium_sema_init(sema, count)	sema_init((sema),(count))
+
+/*
+ * cavium_sema_down
+ *
+ */
+#define cavium_sema_down(sema)	down_trylock((sema)) 
+#define cavium_sema_down_interruptible(sema)	down_interruptible((sema)) 
+
+
+
+/*
+ * cavium_sema_up
+ *
+ */
+#define cavium_sema_up(sema)	up((sema))
+
+
+/*
+ * write_PKP_register(pdev, addr, val) 
+ */
+#ifdef CNS3000
+#define write_PKP_register(pdev,addr,value) \
+{ \
+	*(Uint32 *)addr = value; \
+}
+#else
+#define write_PKP_register(pdev,addr,value) \
+{ \
+        if((pdev)->device_id == NPX_DEVICE) { \
+                writel((value),(addr)); \
+        } \
+        else { \
+                outl((value),(ptrlong)(addr)); \
+        }; \
+}
+#endif
+
+/*
+ * read_PKP_register(pdev, addr, pvalue)
+ */
+#ifdef CNS3000
+#define read_PKP_register(pdev, addr, pvalue) \
+{ \
+   *(pvalue) = *(Uint32 *)addr; \
+}	
+#else
+#define read_PKP_register(pdev,addr,pvalue) \
+{ \
+        if((pdev)->device_id == NPX_DEVICE) { \
+                *(pvalue)=readl(addr); \
+        } \
+        else { \
+                *(pvalue)=inl((ptrlong)(addr)); \
+        }; \
+}
+#endif
+
+/*
+ * write_PCI_register(pdev, offset, value)
+ */
+#ifndef CNS3000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define write_PCI_register(pdev,offset,value)	((struct pci_dev *)((cavium_device_ptr)(pdev))->dev)->bus->ops->write_dword((struct pci_dev *)((cavium_device_ptr)(pdev))->dev,(offset),(value))
+#else
+#define write_PCI_register(pdev, offset,value)	((struct pci_dev *)((cavium_device_ptr)(pdev))->dev)->bus->ops->write( (struct pci_bus*)(((struct pci_dev *)pdev->dev)->bus),((struct pci_dev*)pdev->dev)->devfn,(offset), 4,(value))
+#endif
+#else
+//#define write_PCI_register(pdev, offset,value)	 *(uint32_t *)(((cns3000_dev_t *)((cavium_device_ptr)(pdev))->dev)->config_addr + offset) = (value);
+#define write_PCI_register(pdev, offset,value)	 ;
+#endif
+
+/*
+ * read_PCI_register(pdev, offset, pvalue)
+ */
+#ifndef CNS3000
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define read_PCI_register(pdev, offset,pvalue)	((struct pci_dev *)((cavium_device_ptr)(pdev))->dev)->bus->ops->read_dword((struct pci_dev *)((cavium_device_ptr)(pdev))->dev,(offset),(unsigned int *)pvalue);
+#else
+/* Kernel > 2.6.0 */
+#define read_PCI_register(pdev, offset,pvalue)	((struct pci_dev *)((cavium_device_ptr)(pdev))->dev)->bus->ops->read( (struct pci_bus*)(((struct pci_dev *)pdev->dev)->bus),((struct pci_dev*)pdev->dev)->devfn,(offset), 4,(unsigned int *)(pvalue))
+#endif
+#else
+// #define read_PCI_register(pdev, offset,pvalue)	 *(uint32_t *)pvalue = *(uint32_t *)(((cns3000_dev_t *)((cavium_device_ptr)(pdev))->dev)->config_addr + offset);
+#define read_PCI_register(pdev, offset,pvalue)	 ;
+#endif
+
+/*
+ * cavium_udelay(value)	
+ *	
+ * delays execution by value micro-seconds
+ */
+#define cavium_udelay(value)		udelay((value))
+
+
+/*
+ * cavium_mdelay(value)	
+ *	
+ * delays execution by value milli-seconds
+ */
+#define cavium_mdelay(value)		mdelay((value))
+
+
+
+/*
+ * cavium_jiffies
+ *
+ * system ticks to keep track of elapsed time
+ */
+
+#define   cavium_jiffies	jiffies
+
+/*
+ * when comapring jiffies use these safe macros which take care 
+ * of rollover problems
+ */
+#define	cavium_time_before(a,b) time_before(a,b)
+#define cavium_time_after(a,b) time_after(a,b)
+
+/*wmb() support*/
+#define cavium_wmb() wmb()
+
+/*
+ * cavium_malloc_dma( size, flags)
+ *
+ * allocates a contiguous non_paged kernel  memory chunk.
+ *
+ */
+#define cavium_malloc_dma(size, flags)	kmalloc((size),GFP_ATOMIC)
+#define cavium_malloc(size, flags)      kmalloc((size),GFP_ATOMIC)
+
+
+
+/*
+ * cavium_free_dma
+ *
+ * frees a buffer previously allocated by cavium_malloc_dma
+ *
+ */
+#define cavium_free_dma(pbuffer)	kfree((pbuffer))	
+#define cavium_free(pbuffer)        kfree((pbuffer))
+
+
+/*
+ * cavium_malloc_nc_dma(size, flags)
+ *
+ * allocates a contiguous non_cached, non_paged kernel x memory chunk.
+ *
+ */
+#ifdef DMA_DYN_MAP
+#ifdef CNS3000
+#define cavium_malloc_nc_dma(pdev,size,pbus_addr) \
+        ({ \
+               ptrlong vaddr; \
+               vaddr = (ptrlong)pci_alloc_consistent(NULL,size,pbus_addr);\
+               vaddr; \
+         })
+#else
+#define cavium_malloc_nc_dma(pdev,size,pbus_addr) \
+        ({ \
+               ptrlong vaddr; \
+               vaddr = (ptrlong)pci_alloc_consistent(pdev->dev,size,pbus_addr);\
+               vaddr; \
+         })
+#endif
+#else
+
+#define cavium_malloc_nc_dma(pdev,size,pbus_addr) \
+	({ \
+		ptrlong vaddr; \
+		vaddr = (ptrlong)kmalloc ((size), GFP_ATOMIC | GFP_KERNEL); \
+		*(pbus_addr) = (unsigned long)__virt_to_phys((void *)vaddr); \
+		vaddr; \
+	})
+#endif
+
+/*
+ * cavium_free_nc_dma(size, flags)
+ *
+ * frees the buffer previously allocated by cavium_malloc_nc_dma.
+ *
+ */
+#ifdef DMA_DYN_MAP
+#ifdef CNS3000
+#define cavium_free_nc_dma(pdev,size,pcpu_addr,bus_addr) \
+                pci_free_consistent(NULL,size,pcpu_addr,bus_addr)
+#else
+#define cavium_free_nc_dma(pdev,size,pcpu_addr,bus_addr) \
+                pci_free_consistent(pdev->dev,size,pcpu_addr,bus_addr)
+#endif
+#else
+#define cavium_free_nc_dma(pdev,size,pcpu_addr,bus_addr) \
+	kfree((pcpu_addr))
+#endif
+
+
+/*
+ *  cavium_map_kernel_buffer(pdev,pbuffer,size,flags)
+ *   
+ *  maps buffer to DMAable location wgich was previously allocated by
+ *  cavium_malloc_dma.
+ *  
+ *
+ */
+#ifdef DMA_DYN_MAP
+#ifdef CNS3000
+#define cavium_map_kernel_buffer(pdev,pbuffer,size,flags) ({ \
+                     unsigned int ret;\
+                     ret=pci_map_single(NULL,(void *)(pbuffer),(size),flags);\
+                     ret;\
+})
+#else
+#define cavium_map_kernel_buffer(pdev,pbuffer,size,flags) \
+                     pci_map_single((pdev)->dev,(void *)(pbuffer),(size),flags)
+#endif
+#else
+#define cavium_map_kernel_buffer(pdev,pbuffer,size,flags) \
+                     cavium_vtophys((pbuffer))
+#endif
+
+
+/*
+ *  cavium_unmap_kernel_buffer(pdev,bus_addr,size,flags)
+ *   
+ *  unmaps buffer which was previuosly mapped by cavium_map_kernel_buffer.
+ *  
+ *
+ */
+#ifdef DMA_DYN_MAP
+#ifdef CNS3000
+#define cavium_unmap_kernel_buffer(pdev,bus_addr,size,flags) \
+                     pci_unmap_single(NULL,(bus_addr),(size),flags)
+#else
+#define cavium_unmap_kernel_buffer(pdev,bus_addr,size,flags) \
+                     pci_unmap_single((pdev)->dev,(bus_addr),(size),flags)
+#endif
+#else
+#define cavium_unmap_kernel_buffer(pdev,bus_addr,size,flags) 
+#endif
+
+
+/* 
+ * cavium_sync_kernel_buffer(pdev,buas_addr,size,flags)
+ *
+ * flushes the content of the buffer to physical memory.
+ *
+ */
+#ifdef CNS3000
+#define cavium_flush_cache(pdev,size,v_addr,bus_addr,flags) \
+	pci_dma_sync_single_for_device(NULL, virt_to_phys((Uint8 *)v_addr), size, PCI_DMA_TODEVICE);
+#else
+#define cavium_flush_cache(pdev,size,v_addr,bus_addr,flags) 
+#endif
+
+/*
+ * invalidate cache
+ */
+#ifdef CNS3000
+#define cavium_invalidate_cache(pdev,size,v_addr,bus_addr,flags) \
+	pci_dma_sync_single_for_device(NULL, virt_to_phys((Uint8 *)v_addr), size, PCI_DMA_FROMDEVICE);
+#else
+#define cavium_invalidate_cache(pdev,size,v_addr,bus_addr,flags) 
+#endif
+
+/*
+ * cavium_malloc_virt(size)
+ *
+ * allocates virtual memory to necessary contiguous and mapped to physical memory.
+ *
+ */
+#define cavium_malloc_virt(size) vmalloc((size))
+
+
+/*
+ * cavium_free_virt(size)
+ *
+ * frees virtual memory.
+ *
+ */
+#define cavium_free_virt(pbuffer) vfree((pbuffer))
+
+
+/* 
+ * cavium_vtophys
+ *
+ * Returns bus/physical (DMAable) address
+ */
+#define cavium_vtophys(vaddr)	(unsigned long)__virt_to_phys((Uint8 *)vaddr)
+//#define cavium_vtophys(vaddr)	virt_to_bus((Uint8 *)vaddr)
+
+
+
+/* 
+ * cavium_phystov
+ *
+ * Returns kernel address 
+ */
+#define cavium_phystov(paddr)	(void *)__phys_to_virt((paddr))
+//#define cavium_phystov(paddr)	bus_to_virt((paddr))
+
+
+
+/*
+ * cavium_copy_in
+ *
+ * Copy size bytes from src to dest buffer.
+ * For OS with user and system/kernel level partitioning, 
+ * it copies  bytes from user to kernel layer.
+ * For others, it could be just memcpy.
+ *
+ */
+#define cavium_copy_in(dest, src, size)		copy_from_user((dest), (src), (size))	
+
+/*
+ * cavium_copy_out
+ *
+ * Copy size bytes from src to dest buffer.
+ * For OS with user and system/kernel level partitioning, 
+ * it copies  bytes from kernel to user layer.
+ * For others, it could be just memcpy.
+ *
+ */
+#define cavium_copy_out(dest, src, size)	copy_to_user((dest), (src), (size))	
+
+/*
+ * cavium_memcpy(dest, src, size)
+ *
+ * copies size bytes from src to dest.
+ *
+ */
+#define cavium_memcpy(dest, src, size)		memcpy((dest), (src), (size))
+
+
+
+/*
+ * cavium_memset(buf, val, size)
+ *
+ * sets size bytes pointed to by buf to val.
+ *
+ */
+#define cavium_memset(buf, val, size)		memset((buf), (val), (size))
+
+
+/*
+ * wait channel 
+ */
+typedef wait_queue_head_t cavium_wait_channel;
+
+typedef pid_t cavium_pid_t;
+
+/*
+ * init_wait_channel
+ */
+
+#define init_wait_channel(wc)		init_waitqueue_head(wc)
+#define cavium_get_channel(wc)		init_wait_channel(wc)
+
+/*
+ * sleep
+ */
+#define cavium_yield(wc,to)	schedule() 
+
+#define cavium_sleep_timeout(wc,to)	interruptible_sleep_on_timeout(wc,to)
+
+#define cavium_sleep(wc) interruptible_sleep_on(wc)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define cavium_wait_interruptible_timeout(wc,cond,to) \
+		cavium_sleep_timeout(&wc,to)
+#else
+#define cavium_wait_interruptible_timeout(wc,cond,to) \
+		wait_event_interruptible_timeout(wc,cond,to)
+#endif
+
+/*
+ * wakeup
+ */
+
+#define cavium_wakeup(wc)	wake_up_interruptible(wc)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+#define cavium_send_signal(pid, signo) kill_proc(pid, signo, 1)
+#else
+#define cavium_send_signal(pid, signo) kill_pid(task_pid(current), signo, 1)
+#endif
+
+
+/*
+ *  Tasklets
+ */
+
+typedef struct tasklet_struct cavium_tasklet_t;
+
+#define cavium_tasklet_init(taskp, func, data)  tasklet_init(taskp, func, (ptrlong) data)
+
+#define cavium_tasklet_kill(taskp)              tasklet_kill(taskp)
+
+#define cavium_tasklet_schedule(taskp)          tasklet_schedule(taskp)
+
+#ifndef CAVIUM_NO_MMAP
+
+/*
+ * Get kernel address
+ */
+
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+{
+        unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20))  
+        pud_t *pud; 
+#endif
+	if (!pgd_none(*pgd)) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20))  
+		pud = pud_offset(pgd,adr);
+                pmd = pmd_offset(pud, adr);
+#else
+                pmd = pmd_offset(pgd, adr);
+#endif
+                if (!pmd_none(*pmd)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20) 
+			ptep = pte_offset(pmd, adr);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20))  
+                        ptep = pte_offset_map(pmd, adr);
+#endif
+                        pte = *ptep;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20))  
+			pte_unmap(ptep);
+#endif
+                        if(pte_present(pte)) {
+				ret  = (unsigned long) page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE - 1));
+			}
+                }
+        }
+        cavium_dbgprint("uv2kva(%lx-->%lx)\n", adr, ret);
+	return ret;
+}
+
+/* 
+ * It is must to have these statically defined, they can be made extern, but it
+ * does not follow gcc semantics
+ * And, BTW this will not work with -fno-inline option, so inlining has to be 
+ * enabled
+ */ 
+
+static inline unsigned char * cavium_get_kernel_address(unsigned char *addr)
+{
+	unsigned char * out;
+	
+	down_write(&current->mm->mmap_sem);
+	spin_lock(&current->mm->page_table_lock);
+	out = (unsigned char *)uvirt_to_kva(pgd_offset(current->mm, (unsigned long)addr), 
+					    (unsigned long)addr);
+	spin_unlock(&current->mm->page_table_lock);
+	up_write(&current->mm->mmap_sem);
+
+	return out;
+}	
+#else
+static inline unsigned char * cavium_get_kernel_address(unsigned char *addr)
+{
+	return NULL;
+}
+#endif
+
+static inline pid_t cavium_get_pid(void)
+{
+	return current->pid;
+}
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) 
+#define CAVIUM_MOD_INC_USE_COUNT MOD_INC_USE_COUNT
+#define CAVIUM_MOD_DEC_USE_COUNT MOD_DEC_USE_COUNT
+#else
+#define CAVIUM_MOD_INC_USE_COUNT try_module_get(THIS_MODULE);
+#define CAVIUM_MOD_DEC_USE_COUNT module_put(THIS_MODULE);
+#endif
+
+#define CAVIUM_SIGNAL_NUM	SIGUSR1
+
+
+#ifdef N1_TIMER_ROLLOVER
+#define  cavium_check_timeout(time_to_check, system_time) \
+				cavium_time_before((time_to_check), (system_time))
+#else
+#define  cavium_check_timeout(time_to_check, system_time) \
+				((time_to_check) < (cavium_jiffies))
+#endif
+
+#if defined(__i386__)
+
+static inline Uint64 cavium_rdtsc(void)
+{
+     Uint64 x;
+     __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
+     return x;
+}
+#elif defined(__x86_64__)
+
+static inline Uint64 cavium_rdtsc(void)
+{
+  unsigned hi, lo;
+  __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
+  return ( (Uint64)lo)|( ((Uint64)hi)<<32 );
+}
+
+#elif defined(__powerpc__)
+
+static inline Uint64 cavium_rdtsc(void)
+{
+  Uint64 result=0;
+  Uint32 upper, lower,tmp;
+  __asm__ volatile(
+                "0:                  \n"
+                "\tmftbu   %0           \n"
+                "\tmftb    %1           \n"
+                "\tmftbu   %2           \n"
+                "\tcmpw    %2,%0        \n"
+                "\tbne     0b         \n"
+                : "=r"(upper),"=r"(lower),"=r"(tmp)
+                );
+  result = upper;
+  result = result<<32;
+  result = result|lower;
+  return(result);
+}
+
+#else
+
+#ifdef CNS3000
+#define BIT_CONT(x) (1 << x)
+static inline void cavium_rdtsc_init(void)
+{
+	uint32_t result_pm = 0;
+	uint32_t write_pm = 0;
+	/* disable pmc */
+	write_pm = 0;
+	asm volatile ("mcr p15, 0, %0, c15, c12, 0" : : "r" (write_pm));
+	asm volatile ("mrc p15, 0, %0, c15, c12, 0" : "=r" (result_pm));
+	/* enable pmc */
+	write_pm = BIT_CONT(0) | BIT_CONT(2);
+	asm volatile ("mcr p15, 0, %0, c15, c12, 0" : : "r" (write_pm));
+	asm volatile ("mrc p15, 0, %0, c15, c12, 0" : "=r" (result_pm));
+//	printk (KERN_CRIT "rdtsc_pm in cns3xxx is %u\n", result_pm);
+}
+
+static inline Uint64 cavium_rdtsc(void)
+{
+	uint32_t result = 0;
+	asm volatile ("mrc p15, 0, %0, c15, c12, 1" : "=r" (result));
+    return result;
+}
+
+#else
+static inline Uint64 cavium_rdtsc(void)
+{
+	return cavium_jiffies;
+}
+
+#endif
+#endif
+
+static inline Uint32 cavium_speed_unit(void)
+{
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__)
+	return cpu_khz;
+#else
+#ifdef CNS3000
+#define CNS3000_CORE_CLK_KHZ 600000
+	return CNS3000_CORE_CLK_KHZ;
+#else
+	return CAVIUM_HZ;
+#endif
+#endif
+}
+
+
+
+#else /* __KERNEL__ */
+#include <fcntl.h>
+#include <stdio.h>
+#include <endian.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define __CAVIUM_BYTE_ORDER __CAVIUM_LITTLE_ENDIAN
+#endif
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define __CAVIUM_BYTE_ORDER __CAVIUM_BIG_ENDIAN
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* CAVIUM_IPSEC */
+	 
+#endif /* _LINUX_SYSDEP_H */
+
+/*
+ * $Id: linux_sysdep.h,v 1.21 2009/05/15 10:19:20 kmonendra Exp $
+ * $Log: linux_sysdep.h,v $
+ * Revision 1.21  2009/05/15 10:19:20  kmonendra
+ * Added cavium_rdtsc() which return the current clock cycle of processor.
+ *
+ * Revision 1.20  2009/04/28 10:33:48  pnalla
+ * Changed "cavium_send_signal" to use proper function depending on the kernel version under use.
+ *
+ * Revision 1.19  2009/03/14 10:05:53  jsrikanth
+ * Operation and key buf align constats added
+ *
+ * Revision 1.18  2008/12/18 15:16:54  jsrikanth
+ * pci BAR addr related changes and device count ioctl changes
+ *
+ * Revision 1.17  2008/12/16 12:04:42  jsrikanth
+ * Added Common driver and Multi-Card Changes for FreeBSD
+ *
+ * Revision 1.16  2008/09/30 13:19:09  jsrikanth
+ * Changed printk formatting
+ *
+ * Revision 1.15  2008/07/02 12:22:37  aramesh
+ * deleted config_part and corresponding flags.
+ *
+ * Revision 1.14  2008/03/14 06:22:02  aramesh
+ * CTX_MEM_IS_HOST_MEM is defined always.
+ *
+ * Revision 1.13  2008/02/22 09:10:09  aramesh
+ * driver cleanup done.
+ *
+ * Revision 1.12  2008/02/15 09:23:13  dvenkata
+ * config.h is not included in 2.6.18 kernel
+ *
+ * Revision 1.11  2007/10/22 08:44:29  aramesh
+ * register addr is typecasted to ptrlong instead of Uint64 in read/write_PKP_register for compatability of 32bit and 64 bit machines.
+ *
+ * Revision 1.10  2007/10/18 09:19:18  lpathy
+ * moved cavium_pcie_print to sysdep files
+ *
+ * Revision 1.9  2007/10/16 06:30:28  aramesh
+ * --Changes to support NLite/N1 family.
+ *
+ * Revision 1.8  2007/07/16 12:33:33  tghoriparti
+ * typecasting to volatile of reg addr is removed as it is not updating the proper registers
+ *
+ * Revision 1.7  2007/05/04 10:47:23  rsruthi
+ * fix comipler warning.
+ *
+ * Revision 1.6  2007/05/01 05:41:01  kchunduri
+ * * definition for cavium_wmb()
+ *
+ * Revision 1.5  2007/04/04 21:54:13  panicker
+ * * Added support for CN1600
+ * * correction for 2.6.19 and above.
+ *
+ * Revision 1.4  2007/02/21 23:29:14  panicker
+ * * CAST64() macro fixed
+ *
+ * Revision 1.3  2007/02/20 23:16:00  panicker
+ * * CAST64() macro modified
+ *
+ * Revision 1.2  2007/02/02 02:38:23  panicker
+ * * _ENDIAN definition is now in linux_sysdep.h
+ * * CAST64 - macro to typecast to 64 bits
+ * * cavium_check_timeout() - macro to check timeout
+ * * read/write_PKP_register - modified for PX
+ *
+ * Revision 1.1  2007/01/06 02:47:40  panicker
+ * * first cut - NITROX PX driver
+ *
+ * Revision 1.39  2006/08/08 13:20:32  kchunduri
+ * moved ptrlong definition from cavium_sysdep.h
+ *
+ * Revision 1.38  2006/08/01 08:03:38  kchunduri
+ * cavium_wait_interruptible_timeout defined to replace deprecated interruptible_sleep_on_timeout
+ *
+ * Revision 1.37  2006/05/16 09:36:22  kchunduri
+ * --support for Dynamic DMA mapping instead of virt_to_phys
+ *
+ * Revision 1.36  2006/01/19 09:51:10  sgadam
+ * -IPsec 2.6.11 changes
+ *
+ * Revision 1.35  2006/01/19 06:56:42  pyelgar
+ *    - Changed the cavium_softirq_en/disable macro to accept a flag as input.
+ *      (It is required for freebsd).
+ *
+ * Revision 1.34  2005/12/14 09:23:06  kkiran
+ * - Fixed compile error under Linux 2.4.20.
+ *
+ * Revision 1.33  2005/12/07 04:52:19  kanantha
+ * Mapped the typedefs to system definitions:wq
+ *
+ * Revision 1.32  2005/11/21 06:00:23  kanantha
+ * Removed warnings for MMAP mode on FC4 64 bit
+ *
+ * Revision 1.30  2005/10/19 09:25:55  sgadam
+ * - fixed dependencies
+ *
+ * Revision 1.29  2005/10/11 12:00:11  sgadam
+ * - moved pgtable.h inside define
+ *
+ * Revision 1.28  2005/09/28 12:40:01  pyelgar
+ *    - Fixed the delay in driver polling mode for RHEL3.
+ *
+ * Revision 1.27  2005/09/27 11:48:18  sgadam
+ * mmap issue fixed
+ *
+ * Revision 1.26  2005/09/27 09:28:23  sgadam
+ * FC4 Warnings fixed
+ *
+ * Revision 1.25  2005/09/27 06:24:59  sgadam
+ * Warning fixed
+ *
+ * Revision 1.24  2005/09/12 18:20:11  bimran
+ * Fixed for FC4 SMP.
+ *
+ * Revision 1.23  2005/09/06 12:44:29  ksadasivuni
+ * - Added cavium_spin_lock_destroy() for compatibility with BSD operating systems.
+ *
+ * Revision 1.22  2005/08/31 02:39:18  bimran
+ * removed functions that we don't need for no mmap.
+ *
+ * Revision 1.21  2005/06/10 09:10:58  rkumar
+ * pte_offset in 7.3 was not being used..
+ *
+ * Revision 1.20  2005/06/03 07:32:43  rkumar
+ * *** empty log message ***
+ *
+ * Revision 1.19  2005/05/21 05:04:41  rkumar
+ * Merge with India CVS head
+ *
+ * Revision 1.18  2005/02/03 19:21:14  tsingh
+ * fixed kernel version dependency
+ *
+ * Revision 1.17  2005/02/01 04:12:05  bimran
+ * copyright fix
+ *
+ * Revision 1.16  2005/01/28 18:31:46  mvarga
+ * Fixed kernel version dependency (bimran)
+ *
+ * Revision 1.15  2005/01/26 20:33:20  bimran
+ * Fixed dependency on RH distribution. Made it kernel version dependent.
+ *
+ * Revision 1.14  2005/01/18 01:30:58  tsingh
+ * Fixed SMP lock issue on 2.4.27 kernel. It was the matter of just extra brackets on the macro. On other kernel unmodified code works just fine. May be just a kernel issue.(bimran)
+ *
+ * Revision 1.13  2005/01/06 18:57:05  mvarga
+ * Put back to original.
+ *
+ * Revision 1.12  2005/01/06 18:43:32  mvarga
+ * Added realtime support
+ *
+ * Revision 1.11  2004/08/13 18:22:16  tsingh
+ * fixed pte_offset definition based on RedHat version.
+ *
+ * Revision 1.10  2004/07/06 21:31:24  tsingh
+ * moved CallBackFn definition from linux_main.h to linux_sysdep.h
+ *
+ * Revision 1.9  2004/06/26 01:14:51  bimran
+ * defined linux specific mod counts.
+ *
+ * Revision 1.8  2004/06/03 21:16:20  bimran
+ * added invalidate cache
+ *
+ * Revision 1.7  2004/06/01 22:07:33  tsingh
+ * typo fixed
+ *
+ * Revision 1.6  2004/05/28 17:54:50  bimran
+ * cavium_malloc_dma and cavium_malloc now uses __GFP_ATOMIC flag.
+ *
+ * Revision 1.5  2004/05/11 19:41:27  bimran
+ * Added code for lock debug
+ *
+ * Revision 1.4  2004/05/02 19:45:59  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.3  2004/04/23 21:50:14  bimran
+ * Added header files for user mode programs.
+ *
+ * Revision 1.2  2004/04/22 02:03:33  bimran
+ * changed one cavium_print to debug print.
+ *
+ * Revision 1.1  2004/04/15 22:40:50  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
+
