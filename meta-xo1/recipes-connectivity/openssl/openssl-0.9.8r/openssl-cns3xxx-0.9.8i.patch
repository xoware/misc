diff -Naur openssl-0.9.8i/apps/speed.c openssl-0.9.8i-cns3xxx/apps/speed.c
--- openssl-0.9.8i/apps/speed.c	2010-05-31 12:02:25.000000000 +0200
+++ openssl-0.9.8i-cns3xxx/apps/speed.c	2011-01-06 09:23:28.000000000 +0100
@@ -114,7 +114,8 @@
 # define TIMES
 #endif
 #if !defined(_UNICOS) && !defined(__OpenBSD__) && !defined(sgi) && !defined(__FreeBSD__) && !(defined(__bsdi) || defined(__bsdi__)) && !defined(_AIX) && !defined(OPENSSL_SYS_MPE) && !defined(__NetBSD__) && !defined(OPENSSL_SYS_VXWORKS) /* FIXME */
-# define TIMEB
+//# define TIMEB
+# define TIMES
 #endif
 
 #if defined(OPENSSL_SYS_NETWARE)
diff -Naur openssl-0.9.8i/Configure openssl-0.9.8i-cns3xxx/Configure
--- openssl-0.9.8i/Configure	2010-05-31 12:02:25.000000000 +0200
+++ openssl-0.9.8i-cns3xxx/Configure	2010-05-31 12:11:51.000000000 +0200
@@ -318,7 +318,8 @@
 ####
 # *-generic* is endian-neutral target, but ./config is free to
 # throw in -D[BL]_ENDIAN, whichever appropriate...
-"linux-generic32","gcc:-DTERMIO -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-generic32","gcc:-DTERMIO -O -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-arm","arm-linux-gcc:-O -Wall:::::BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:::-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):arm-linux-ranlib",
 "linux-ppc",	"gcc:-DB_ENDIAN -DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL::linux_ppc32.o::::::::::dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
 #### IA-32 targets...
 "linux-ia32-icc",	"icc:-DL_ENDIAN -DTERMIO -O2 -no_cpprt::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-KPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
diff -Naur openssl-0.9.8i/crypto/engine/cav_crypto_engine.c openssl-0.9.8i-cns3xxx/crypto/engine/cav_crypto_engine.c
--- openssl-0.9.8i/crypto/engine/cav_crypto_engine.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8i-cns3xxx/crypto/engine/cav_crypto_engine.c	2010-05-31 12:12:23.000000000 +0200
@@ -0,0 +1,1137 @@
+
+/* cav_crypto_engine.c */
+/*
+ * Copyright (c) 2003-2006, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#if defined(linux)
+   #include <alloca.h>
+   #include <malloc.h>
+#elif defined(__FreeBSD__)
+   #include <stdlib.h>
+#endif
+
+#include <string.h>
+#include <openssl/ssl.h>
+#include <openssl/bn.h>
+#include "cavium_common.h"
+#include "cavium_ssl.h"
+
+
+#define NITROX_PX
+void pkp_leftfill(unsigned char input[], int length, unsigned char output[], int finallength )
+{
+  int i;
+  int j;
+  memset(output,0,finallength);
+  j = finallength-1;
+  for (i=length-1; i>=0; i--) 
+  {
+    output[j] = input[i];
+    j = j-1;
+  }
+}
+
+#ifdef CAVIUM_MODEX_DEBUG
+#include <stdio.h>
+#endif
+
+#ifdef MC2
+
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m)
+{
+  unsigned char *ab, *pb, *mb, *rb;
+  int sizep,sizem,sizea;
+  int driver_ready=-1;
+  int ret = 0;
+  Uint32 req_id;
+
+
+  sizem = BN_num_bytes(m);
+  if( (sizem < 24) || (sizem>256) ) return 0;
+
+  driver_ready = Csp1GetDriverState();
+  if(driver_ready == -1)
+  {
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+  }
+
+  sizea = BN_num_bytes(a);
+  sizep = BN_num_bytes(p);
+
+  mb = alloca(sizem);
+  if(mb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(mb,0,sizem);
+
+  ab = alloca(sizea);
+  if(ab==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(ab,0,sizea);
+
+  pb = alloca(sizep);
+  if(pb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(pb,0,sizep);   
+
+  rb = alloca(sizem); 
+  if(rb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(rb,0,sizem);
+
+  BN_bn2bin(a,ab); 
+
+  BN_bn2bin(p,pb); 
+
+  BN_bn2bin(m,mb); 
+
+  if (Csp1Me(CAVIUM_BLOCKING,sizem, sizep, sizea, mb, pb,ab, rb, &req_id))
+   {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+   }
+  
+
+  BN_bin2bn(rb,sizem,r); 
+  ret = 1;
+
+mod_exp_cleanup:
+  if(driver_ready == -1)
+	  Csp1Shutdown();
+  return ret;
+
+}
+
+
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+	Uint32 req_id;
+	int driver_ready = -1;
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if((modulus_size<17)||(modulus_size>512))
+#else
+	if((modulus_size<17)||(modulus_size>256))
+#endif
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+
+	memcpy(from_b,from,modulus_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+	
+	i = Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+		BT1,
+		(Uint16)modulus_size, 
+		(Uint16)exponent_size,
+	   	 modulus_b, 
+	   	 exponent_b, 
+		 from_b,
+		&out_length,
+		to,
+		&req_id);
+
+	if(i) ret=0;
+	else ret = (Uint32)ntohs(out_length);
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}/*pkp_rsa_public_decrypt*/
+
+
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if((modulus_size<17)||(modulus_size>512))
+#else
+	if((modulus_size<17)||(modulus_size>256))
+#endif
+		goto rsa_priv_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+   	i = Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+				BT2,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				&out_length,
+				to,
+				&req_id);
+
+	if(i) ret=0;
+	else ret = (Uint32)ntohs(out_length);
+
+rsa_priv_dec_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+
+
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if((modulus_size<17)||(modulus_size>512))
+#else
+	if((modulus_size<17)||(modulus_size>256))
+#endif
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+   i = Csp1Pkcs1v15Enc(CAVIUM_BLOCKING,
+			    BT2,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				to,
+			    &req_id);
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+
+
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	int modulus_size, exponent_size, data_size;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if((modulus_size<17)||(modulus_size>512))
+#else
+	if((modulus_size<17)||(modulus_size>256))
+#endif
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,exponent_size);
+
+	data_size = flen;
+	from_b = alloca(data_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+
+
+	memcpy(from_b,from,data_size);
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+	i = Csp1Pkcs1v15Enc(CAVIUM_BLOCKING,
+			    BT1,
+			    (Uint16)modulus_size, 
+				(Uint16)exponent_size,
+				(Uint16)data_size, 
+			    modulus_b, 
+			    exponent_b, 
+			    from_b,
+				to,
+			    &req_id);
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+
+	return ret;
+}
+
+#else
+static void swap_word_openssl(unsigned char *d, unsigned char *s, int len)
+{
+  int i,j;
+  Uint64 *ps;
+  Uint64 *pd;
+
+  j=0;
+
+  ps = (Uint64 *)s;
+  pd = (Uint64 *)d;
+
+  for(i=(len>>3)-1; i>=0; i--)
+   {
+     pd[j] = ps[i];
+     j++;      
+   }
+
+}
+
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m)
+{
+  unsigned char *ab, *pb, *mb, *rb, *temp;
+  int sizep,sizem,sizea,osizem;
+  int driver_ready=-1;
+  int ret = 0;
+  Uint32 req_id;
+
+#ifdef CAVIUM_MODEX_DEBUG
+  int i; 
+  FILE *fptr;
+#endif
+
+  osizem = BN_num_bytes(m);
+  if( (osizem < 24) || (osizem>256) ) return 0;
+
+  driver_ready = Csp1GetDriverState();
+  if(driver_ready == -1)
+  {
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+  }
+
+  sizem = ((osizem+7)/8)*8;
+  sizea = BN_num_bytes(a);
+  sizep = BN_num_bytes(p);
+
+  mb = alloca(sizem);
+  if(mb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(mb,0,sizem);
+
+  ab = alloca(sizem);
+  if(ab==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(ab,0,sizem);
+
+  pb = alloca(sizem);
+  if(pb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(pb,0,sizem);   
+
+  temp = alloca(sizem); 
+  if(temp==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(temp,0,sizem);
+
+  rb = alloca(sizem); 
+  if(rb==NULL)
+  {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+  }
+  memset(rb,0,sizem);
+
+  BN_bn2bin(a,ab); 
+
+  BN_bn2bin(p,pb); 
+
+  if(sizep < sizem)
+   {
+    pkp_leftfill(pb,sizep,temp,sizem);
+    memcpy(pb,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+   if(sizea < sizem)
+   {
+    pkp_leftfill(ab,sizea,temp,sizem);
+    memcpy(ab,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+  BN_bn2bin(m,mb); 
+  if(sizem > osizem)
+   {
+    pkp_leftfill(mb,osizem,temp,sizem);
+    memcpy(mb,temp,sizem);
+    memset(temp,0,sizem); 
+   }
+
+#ifdef CAVIUM_MODEX_DEBUG
+   fptr = fopen("me.tst", "a");
+   fprintf(fptr, "\ndata:\n");
+   for (i=0;i<sizem; i++)
+     fprintf(fptr, "%02x ", ab[i]);
+   fprintf(fptr, "\nexponent\n");
+   for(i=0;i<sizem;i++)
+    fprintf(fptr,"%02x ", pb[i]);
+   fprintf(fptr,"\nmodulus:\n");
+   for(i=0;i<sizem;i++)
+     fprintf(fptr, "%02x ",mb[i]);
+#endif
+  
+  swap_word_openssl(temp, ab, sizem);
+  memcpy(ab,temp,sizem);
+  memset(temp,0,sizem);
+
+  swap_word_openssl(temp, pb, sizem);
+  memcpy(pb,temp,sizem);
+  memset(temp,0,sizem);
+
+  swap_word_openssl(temp, mb, sizem);
+  memcpy(mb,temp,sizem);
+  memset(temp,0,sizem);
+
+#ifdef CAVIUM_MODEX_DEBUG
+  fprintf(fptr, "\ndata after swap :\n");
+   for (i=0;i<sizem; i++)
+     fprintf(fptr, "%02x ", ab[i]);
+   fprintf(fptr, "\nexponent after swap\n");
+   for(i=0;i<sizem;i++)
+    fprintf(fptr,"%02x ", pb[i]);
+   fprintf(fptr,"\nmodulus after swap:\n");
+   for(i=0;i<sizem;i++)
+     fprintf(fptr, "%02x ",mb[i]); 
+#endif
+
+   if (Csp1Me(CAVIUM_BLOCKING,RESULT_PTR, (Uint64)NULL, sizem, ab, mb, pb, rb, &req_id))
+   {
+	  ret= 0;
+	  goto mod_exp_cleanup;
+   }
+
+
+#ifdef CAVIUM_MODEX_DEBUG
+   fprintf(fptr, "\nresult:\n");
+   for(i=0;i<sizem;i++)
+   {
+    fprintf(fptr, "%02x ",rb[i]);
+   }
+  fclose(fptr);
+#endif
+
+  
+  BN_bin2bn(rb,sizem,r); 
+  ret = 1;
+
+mod_exp_cleanup:
+  if(driver_ready == -1)
+	  Csp1Shutdown();
+  return ret;
+
+}
+
+
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+	Uint64 out_length=0;
+	Uint32 req_id;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_ctx_ptr = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+#else
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+#endif
+		goto rsa_pub_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret=0;
+		goto rsa_pub_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, from_b, modulus_size);
+   memcpy(from_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+	i=	Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+						RESULT_PTR, /* got it ?? */
+						dummy_ctx_ptr, 
+						INPUT_DATA,
+						dummy_key_handle, 
+						BT1,
+						(unsigned short)modulus_size, 
+					    modulus_b, 
+					    exponent_b, 
+					    from_b,
+						to,
+						&out_length,
+						&req_id);
+
+
+	if(i) ret=0;
+	else ret = (Uint32)out_length;
+
+rsa_pub_dec_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+	Uint64 out_length=0;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_ctx_ptr = 0;
+	Uint64 dummy_key_handle = 0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+#else
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+#endif
+		goto rsa_priv_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+	}
+	memcpy(from_b,from,modulus_size);
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, from_b, modulus_size);
+   memcpy(from_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+	i=	Csp1Pkcs1v15Dec(CAVIUM_BLOCKING,
+	   					RESULT_PTR, /* got it ?? */
+						dummy_ctx_ptr, 
+						INPUT_DATA,
+						dummy_key_handle, 
+						BT2,
+						(unsigned short)modulus_size, 
+					    modulus_b, 
+					    exponent_b, 
+					    from_b,
+						to,
+						&out_length,
+						&req_id);
+
+
+	if(i) ret=0;
+	else ret = (Uint32)out_length;
+
+rsa_priv_dec_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+    Uint64 dummy_key_handle = 0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+#else
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+#endif
+		goto rsa_pub_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->e);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_pub_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->e,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+	
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   i = Csp1Pkcs1v15Enc( CAVIUM_BLOCKING,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT2,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						(unsigned short)flen, 
+						from_b,
+						to,
+						&req_id);
+
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_pub_enc_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+
+
+
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa)
+{
+
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL, *temp=NULL;
+	int modulus_size, exponent_size;
+
+	/* I donot really need this variable here because I am going to get result back in user pointer*/
+	Uint64 dummy_context_pointer = 0;
+	Uint64 dummy_key_handle=0;
+	int driver_ready = -1;
+	Uint32 req_id;
+
+
+	driver_ready = Csp1GetDriverState();
+	if(driver_ready == -1)
+	{
+#ifdef NPLUS
+	  if(Csp1Initialize(CAVIUM_DIRECT, SSL_SPM_IDX))
+#else
+	  if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+		  return 0;
+	}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+#ifdef NITROX_PX
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>512))
+#else
+	if(((modulus_size&0x7)!=0)||(modulus_size<24)||(modulus_size>256))
+#endif
+		goto rsa_priv_enc_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if(modulus_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(modulus_b,0,modulus_size);
+
+
+	temp = alloca(modulus_size);
+	if(temp==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(temp,0,modulus_size);
+
+
+	exponent_b = alloca(modulus_size);
+	if(exponent_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(exponent_b,0,modulus_size);
+
+	from_b = alloca(modulus_size);
+	if(from_b==NULL)
+	{
+		ret = 0;
+		goto rsa_priv_enc_cleanup;
+	}
+	memset(from_b,0,modulus_size);
+	memcpy(from_b, from,flen);
+
+
+
+
+	BN_bn2bin(rsa->n,modulus_b); 
+	BN_bn2bin(rsa->d,exponent_b);
+
+    if(exponent_size < modulus_size)
+    {
+     pkp_leftfill(exponent_b,exponent_size,temp,modulus_size);
+     memcpy(exponent_b,temp,modulus_size);
+     memset(temp,0,modulus_size); 
+    }
+
+
+   swap_word_openssl(temp, modulus_b, modulus_size);
+   memcpy(modulus_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+   swap_word_openssl(temp, exponent_b, modulus_size);
+   memcpy(exponent_b,temp,modulus_size);
+   memset(temp,0,modulus_size);
+
+
+   i = Csp1Pkcs1v15Enc( CAVIUM_BLOCKING,
+   						RESULT_PTR, 
+						dummy_context_pointer,
+						INPUT_DATA,
+						dummy_key_handle,
+						BT1,
+						(unsigned short)modulus_size, 
+						modulus_b, 
+						exponent_b, 
+						flen, 
+						from_b,
+						to,
+						&req_id);
+
+
+
+	if(i) ret=0;
+	else ret = modulus_size;
+
+rsa_priv_enc_cleanup:
+	if(driver_ready == -1)
+	  Csp1Shutdown();
+  
+	return ret;
+}
+#endif /* MC2 else */
+
+                               
diff -Naur openssl-0.9.8i/crypto/engine/cav_crypto_engine.h openssl-0.9.8i-cns3xxx/crypto/engine/cav_crypto_engine.h
--- openssl-0.9.8i/crypto/engine/cav_crypto_engine.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8i-cns3xxx/crypto/engine/cav_crypto_engine.h	2010-05-31 12:11:59.000000000 +0200
@@ -0,0 +1,57 @@
+/* cav_crypto_engine.h */
+/*
+ * Copyright (c) 2003-2006, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+#ifndef CAV_CRYPTO_ENGINE_H
+#define CAV_CRYPTO_ENGINE_H
+
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+
+int cav_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m);
+int pkp_rsa_public_decrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_decrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_public_encrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_encrypt(int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+int pkp_rsa_private_encrypt_cav(void *s,int flen, unsigned char *from, unsigned char *to, RSA * rsa);
+
+
+#endif
diff -Naur openssl-0.9.8i/crypto/engine/cavium_common.c openssl-0.9.8i-cns3xxx/crypto/engine/cavium_common.c
--- openssl-0.9.8i/crypto/engine/cavium_common.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8i-cns3xxx/crypto/engine/cavium_common.c	2010-05-31 12:11:59.000000000 +0200
@@ -0,0 +1,6261 @@
+/* cavium_common.c */
+/*
+ * Copyright (c) 2003-2005, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+
+#ifdef _WIN32
+#include <windows.h>
+#include <winioctl.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <fcntl.h>
+#undef	NO_ERROR
+
+int	open (const char *, int);
+int	close (int);
+int	ioctl (int, int, ...);
+#endif
+#include<string.h>
+#include <cavium_sysdep.h>
+#include <cavium_common.h>
+#include <cavium_ioctl.h>
+#include <cavium_endian.h>
+#ifndef SSL
+#define OP_WRITE_IPSEC_SA         0x14
+#define OP_IPSEC_PACKET_INBOUND       0x10
+#define OP_IPSEC_PACKET_OUTBOUND      0x11
+#define OP_WRITE_INBOUND_IPSEC_SA      0x2014
+#define OP_WRITE_OUTBOUND_IPSEC_SA      0x4014
+#define OP_ERASE_CONTEXT         0x114
+#define IPv4    0
+#endif
+
+#define AESXCBC_BLOCK_SIZE 16
+
+#ifndef UINT64_C 
+#define UINT64_C(x)   ((unsigned long long) (x ## ull))
+#endif
+
+int CSP1_driver_handle=-1;
+Csp1DmaMode global_dma_mode=CAVIUM_DIRECT; /* default mode */
+
+#ifdef CAVIUM_MULTICARD_API
+int gpkpdev_cnt=0;
+int gpkpdev_hdlr[MAX_DEV_CNT]={-1,-1,-1,-1};
+int default_device;
+#endif
+
+
+static int
+#ifdef CAVIUM_MULTICARD_API
+CSP1_open_device_file(int dev_id)
+#else
+CSP1_open_device_file()
+#endif
+{
+	char   name[32];
+
+	strcpy(name, "/dev/pkp_dev");
+
+#ifdef CAVIUM_MULTICARD_API
+    if(dev_id)
+       sprintf(name,"%s%d",name,dev_id);
+       
+#endif
+	return open(name, O_RDWR);
+}
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Initialize
+ *
+ * Prepares the aplication.
+ *
+ * Input 
+ *      dma_mode = CAVIUM_DIRECT or CAVIUM_SCATTER_GATHER
+ * 
+ * Return Value
+ *   completion code = 0 (for success) 
+ *                   > 0 (for failure) 
+ *
+ *-***************************************************************************/
+
+#ifdef CAVIUM_MULTICARD_API
+Uint32
+Csp1Initialize(Csp1DmaMode dma_mode, Uint32 dev_id)
+#else
+Uint32
+Csp1Initialize(Csp1DmaMode dma_mode)
+#endif
+{
+   Uint32 cond_code = 0;
+   int dev_handle = -1;
+
+#ifdef CAVIUM_MULTICARD_API
+   dev_handle = gpkpdev_hdlr[dev_id]; 
+#else
+   dev_handle = CSP1_driver_handle;
+#endif
+
+   if(dev_handle < 0)
+   {
+#ifdef CAVIUM_MULTICARD_API
+      dev_handle = CSP1_open_device_file(dev_id);
+      gpkpdev_hdlr[dev_id]=dev_handle;
+#else
+      dev_handle = CSP1_open_device_file();
+      CSP1_driver_handle = dev_handle;
+#endif
+
+      if (dev_handle < 0) 
+         cond_code = errno;
+      else {
+         global_dma_mode = dma_mode;
+         cond_code = 0;
+      }
+   }
+
+   return cond_code;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Shutdown
+ *
+ * Cleanup the driver.
+ *
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1Shutdown(Uint32 dev_id)
+#else
+Csp1Shutdown(void)
+#endif
+{
+   Uint32 cond_code = 0;
+
+#ifdef CAVIUM_MULTICARD_API
+   if(gpkpdev_hdlr[dev_id] != -1)
+      close(gpkpdev_hdlr[dev_id]);
+
+   gpkpdev_hdlr[dev_id] = -1;
+#else
+   if(CSP1_driver_handle != -1)
+      close(CSP1_driver_handle);
+
+   CSP1_driver_handle = -1;
+#endif
+
+   global_dma_mode=CAVIUM_DIRECT; /*default mode */
+
+   return cond_code;
+}
+
+/*+****************************************************************************
+ *
+ * Csp1CheckForCompletion
+ *
+ * Checks the status of the request.
+ *
+ * Input 
+ *   request_id.
+ *
+ * Output
+ *   none.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+#ifdef CAVIUM_MULTICARD_API
+Csp1CheckForCompletion(Uint32 request_id,Uint32 dev_id)
+#else
+Csp1CheckForCompletion(Uint32 request_id)
+#endif
+{
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Csp1RequestStatusBuffer reqStatus;
+   memset(&reqStatus,0,sizeof(Csp1RequestStatusBuffer));
+
+   reqStatus.request_id = request_id;
+   reqStatus.status = 0;
+#ifdef CAVIUM_MULTICARD_API
+   cond_code = ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_POLL_CODE, &reqStatus);
+#else
+   cond_code = ioctl(CSP1_driver_handle, IOCTL_N1_POLL_CODE, &reqStatus);
+#endif
+   if(cond_code)
+      ret_val = cond_code; /*return err val*/
+   else
+      ret_val = reqStatus.status;/*return status of request:'0' or 'EAGAIN'*/ 
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1FlushAllRequests
+ *
+ * Removes all pending requests for the calling process. This call can make the 
+ * current process go to sleep. The driver will wait for all pending requests 
+ * to complete or timeout.
+ *
+ * Input 
+ *   none.
+ *
+ * Output
+ *   none.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef CAVIUM_MULTICARD_API
+Uint32 
+Csp1FlushAllRequests(Uint32 dev_id)
+#else
+Uint32 
+Csp1FlushAllRequests(void)
+#endif
+{
+   Uint32 cond_code;
+   
+#ifdef CAVIUM_MULTICARD_API
+   cond_code = ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_FLUSH_ALL_CODE);
+#else
+   cond_code = ioctl(CSP1_driver_handle, IOCTL_N1_FLUSH_ALL_CODE);
+#endif
+
+   return cond_code;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1FlushRequest
+ *
+ * Removes the request for the calling process. This call can make the 
+ * current process go to sleep. The driver will wait for the request 
+ * to complete or timeout.
+ *
+ * Input 
+ *   request_id.
+ *
+ * Output
+ *    none.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1FlushRequest(Uint32 request_id,Uint32 dev_id)
+#else
+Csp1FlushRequest(Uint32 request_id)
+#endif
+{
+   Uint32 cond_code;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+      ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_FLUSH_CODE, (Uint32)request_id);
+#else
+      ioctl(CSP1_driver_handle, IOCTL_N1_FLUSH_CODE, (Uint32)request_id);
+#endif
+   return cond_code;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1AllocContext
+ *
+ * Allocates a context segment (in the local DDR DRAM or the host memory 
+ * depending on the system) and returns its handle that will be passed to the 
+ * processor in the final 8 bytes of the request as Cptr.
+ *
+ * Input 
+ *   cntx_type = CONTEXT_SSL or CONTEXT_IPSEC
+ *
+ * Output
+ *   context_handle = pointer to 8-byte address of the context for use by 
+ *      the Cavium processor
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1AllocContext(ContextType cntx_type, 
+       Uint64 *context_handle,Uint32 dev_id)
+#else
+Csp1AllocContext(ContextType cntx_type, 
+       Uint64 *context_handle)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   n1_context_buf cbuf;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   cbuf.type = cntx_type;
+
+   buffer.opcode = 0;
+   /* 
+    * Set the context size to be allocated. 
+    */
+   buffer.size = cntx_type;
+   buffer.param = 0;
+   buffer.dlen = 0;
+   buffer.rlen = 0;
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.incnt = 0;      
+   buffer.outcnt = 0;      
+#ifdef CAVIUM_MULTICARD_API
+   cond_code = ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_ALLOC_CONTEXT, (ptrlong)&cbuf);
+#else
+   cond_code = ioctl(CSP1_driver_handle, IOCTL_N1_ALLOC_CONTEXT, (ptrlong)&cbuf);
+#endif
+
+    if (cond_code) {
+        ret_val=cond_code;
+    } else { /* success*/   
+        ret_val = 0;
+        *context_handle = cbuf.ctx_ptr;
+    }
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1FreeContext
+ *
+ * Free a context segment for use by another SSL connection/IPsec tunnel.
+ *
+ * Input
+ *   cntx_type = CONTEXT_SSL or CONTEXT_IPSEC
+ *   context_handle = 8-byte address of the context for use by 
+ *      the Cavium processor
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1FreeContext(ContextType cntx_type, 
+      Uint64 context_handle,Uint32 dev_id)
+#else
+Csp1FreeContext(ContextType cntx_type, 
+      Uint64 context_handle)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   n1_context_buf cbuf;
+
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+   {
+      if ((context_handle & 0xf) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+   }
+   else
+   {
+      if ((context_handle & 0x7) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+   }
+
+
+   buffer.opcode = 0;
+   /* 
+    * Set the context type to be deallocated. 
+    */
+   buffer.size = cntx_type;
+   buffer.param = 0;
+   buffer.dlen = 0;
+   buffer.rlen = 0;
+
+   buffer.incnt = 0;      
+   buffer.outcnt = 0;
+   buffer.ctx_ptr = context_handle;      
+
+   cbuf.type = cntx_type;
+   cbuf.ctx_ptr = context_handle;
+#ifdef CAVIUM_MULTICARD_API
+   cond_code = ioctl(gpkpdev_hdlr[dev_id],IOCTL_N1_FREE_CONTEXT,(ptrlong)&cbuf);
+#else
+   cond_code = ioctl(CSP1_driver_handle,IOCTL_N1_FREE_CONTEXT,(ptrlong)&cbuf);
+#endif
+
+   if (cond_code)
+      ret_val=cond_code;
+   else /* success*/   
+      ret_val = 0;
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1AllocKeyMem
+ *
+ * Acquires the handle to a key memory segment and returns a handle.
+ *
+ * Input
+ *  key_material_loc = INTERNAL_SRAM, HOST_MEM, or LOCAL_DDR
+ *
+ * Output
+ *   key_handle = pointer to 8-byte handle to key memory segment
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1AllocKeyMem(KeyMaterialLocation key_material_loc, Uint64 *key_handle,Uint32 dev_id)
+#else
+Csp1AllocKeyMem(KeyMaterialLocation key_material_loc, Uint64 *key_handle)
+#endif
+{
+   Uint32 ret_val;
+   n1_write_key_buf key_buf;
+   memset(&key_buf,0,sizeof(n1_write_key_buf));
+
+#ifdef CAVIUM_MULTICARD_API
+   ret_val=ioctl(gpkpdev_hdlr[dev_id],IOCTL_N1_ALLOC_KEYMEM,(ptrlong)&key_buf);
+#else
+   ret_val=ioctl(CSP1_driver_handle,IOCTL_N1_ALLOC_KEYMEM, (ptrlong)&key_buf);
+#endif
+   *key_handle = key_buf.key_handle;
+   return ret_val;
+}
+
+/*+****************************************************************************
+ *
+ * Csp1FreeKeyMem
+ *
+ * Free a key memory segment.
+ *
+ * Input
+ *   key_handle = 8-byte handle to key memory segment
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1FreeKeyMem(Uint64 key_handle,Uint32 dev_id)
+#else
+Csp1FreeKeyMem(Uint64 key_handle)
+#endif
+{
+   Uint32 ret_val;
+   n1_write_key_buf key_buf;
+   memset(&key_buf,0,sizeof(n1_write_key_buf));
+#ifdef MC2
+   /* turn off crt bit 49 */
+   key_handle &= ((((Uint64)0xfffdffff) << 32) | (Uint64)0xffffffff);
+#else
+   /* turn off crt bit 48 */
+   key_handle &= ((((Uint64)0xfffeffff) << 32) | (Uint64)0xffffffff);
+#endif
+
+   key_buf.key_handle = key_handle;
+#ifdef CAVIUM_MULTICARD_API
+   ret_val=ioctl(gpkpdev_hdlr[dev_id],IOCTL_N1_FREE_KEYMEM, (ptrlong)&key_buf);
+#else
+   ret_val = ioctl(CSP1_driver_handle,IOCTL_N1_FREE_KEYMEM, (ptrlong)&key_buf);
+#endif
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1StoreKey
+ *
+ * Store a key to memory segment indicated by key handle.
+ *
+ * Input
+ *   key_handle = 8-byte handle to key memory segment
+ *   length = size of key in bytes
+ *   key = pointer to key
+ *   mod_ex_type = NORMAL_MOD_EX or CRT_MOD_EX
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1StoreKey(Uint64 *key_handle, 
+    Uint16 length, 
+    Uint8 *key, 
+    RsaModExType mod_ex_type,Uint32 dev_id)
+#else
+Csp1StoreKey(Uint64 *key_handle, 
+    Uint16 length, 
+    Uint8 *key, 
+    RsaModExType mod_ex_type)
+#endif
+{
+    n1_write_key_buf key_buf;
+    Uint32 ret_val;
+
+   memset(&key_buf,0,sizeof(n1_write_key_buf));
+#ifdef MC2
+    /* turn off crt bit 49 */
+    *key_handle &= ((((Uint64)0xfffdffff) << 32) | (Uint64)0xffffffff);
+#else
+    /* turn off crt bit 48 */
+    *key_handle &= ((((Uint64)0xfffeffff) << 32) | (Uint64)0xffffffff);
+#endif
+    key_buf.key_handle = *key_handle;
+    key_buf.length = length;
+    key_buf.key = CAST_TO_X_PTR(key);
+#ifdef CAVIUM_MULTICARD_API
+    ret_val = ioctl(gpkpdev_hdlr[dev_id],IOCTL_N1_WRITE_KEYMEM,(ptrlong)&key_buf);
+#else
+    ret_val = ioctl(CSP1_driver_handle, IOCTL_N1_WRITE_KEYMEM, (ptrlong)&key_buf);
+#endif
+
+    if(!ret_val) {
+   if (mod_ex_type == CRT_MOD_EX)
+#ifdef MC2
+      *key_handle |= (((Uint64)0x20000) << 32);
+#else
+      *key_handle |= (((Uint64)0x10000) << 32);
+#endif
+   }
+   return ret_val;
+}
+
+
+/*****************************************************************************
+ *
+ * Csp1ReadEpci
+ *
+ * Routine to read the onchip SRAM memory
+ *
+ * input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *    key_handle = 64-bit key handle pointer.
+ *    length = size of data to read in bytes (8<length<=880, length%8=0).
+ *
+ * output
+ *      data = Result data (size variable based on size)
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ ****************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1ReadEpci(n1_request_type request_type,
+    Uint64 *key_handle, 
+    Uint16 length,
+    Uint8 *data,
+    Uint32 *request_id,Uint32 dev_id)
+#else
+Csp1ReadEpci(n1_request_type request_type,
+    Uint64 *key_handle, 
+    Uint16 length,
+    Uint8 *data,
+    Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((length < 8) || (length > 880) || ((length & 0x7) != 0))
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   buffer.opcode = (0x8<<8) | (global_dma_mode<<7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+#ifdef MC2
+   buffer.size = length;
+   buffer.param = 0;
+   buffer.dlen = 8;
+   buffer.rlen = length;
+#else
+   buffer.size = length>>3;
+   buffer.param = 0x10;
+   buffer.dlen = (8)>>3;
+   buffer.rlen = (length + 8)>>3;
+#endif
+   buffer.ctx_ptr = 0;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *)key_handle);
+   buffer.insize[0] = 8;
+   buffer.inoffset[0] = 8;
+   buffer.inunit[0] = UNIT_64_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(data);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+      ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+      ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+    
+   return ret_val;
+}
+
+
+/*****************************************************************************
+ *
+ * Csp1WriteEpci
+ * write data to onchip SRAM.
+ *
+ * input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *    key_handle = 64-bit key handle pointer.
+ *    length = size of data to write in bytes (8<length<=880, length%8=0).
+ *      data =  input data 
+ *
+ * output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ ****************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1WriteEpci(n1_request_type request_type,
+          Uint64 *key_handle, 
+          Uint16 length,
+          Uint8 *data,
+          Uint32 *request_id,Uint32 dev_id)
+#else
+
+Csp1WriteEpci(n1_request_type request_type,
+          Uint64 *key_handle, 
+          Uint16 length,
+          Uint8 *data,
+          Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((length < 8) || (length > 880) || ((length & 0x7) != 0))
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   buffer.opcode = (0x0<<8) | (global_dma_mode<<7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+#ifdef MC2
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = 8 + length;
+   buffer.rlen = 0;
+#else
+   buffer.size = length>>3;
+   buffer.param = 0x8;
+   buffer.dlen = (8 + length)>>3;
+   buffer.rlen = (8)>>3;
+#endif
+   buffer.ctx_ptr = 0;
+   buffer.incnt = 2;      
+   buffer.outcnt = 0;      
+
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *)key_handle);
+   buffer.insize[0] = 8;
+   buffer.inoffset[0] = 8;
+   buffer.inunit[0] = UNIT_64_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(data);
+   buffer.insize[1] = length;
+   buffer.inoffset[1] = length;
+   buffer.inunit[1] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = CAVIUM_SCATTER_GATHER;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+}
+
+
+/*****************************************************************************
+ *
+ * Csp1ReadContext
+ *
+ * Routine to read data from context.
+ *
+ * input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *    context_handle = 64-bit context handle pointer.
+ *    length = size of data to read in bytes (8<length<=1024, length%8=0).
+ *
+ * output
+ *      data = Result data (size variable based on size)
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ ****************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1ReadContext(n1_request_type request_type,
+      Uint64 context_handle, 
+      Uint16 length,
+      Uint8 *data,
+      Uint32 *request_id,Uint32 dev_id)
+#else
+Csp1ReadContext(n1_request_type request_type,
+      Uint64 context_handle, 
+      Uint16 length,
+      Uint8 *data,
+      Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((length < 8) || (length > 1024) || ((length & 0x7) != 0)) 
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+      if ((context_handle & 0xf) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+      if ((context_handle & 0x7) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+   }
+
+   buffer.opcode = (0x4<<8) | (global_dma_mode<<7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+#ifdef MC2
+   buffer.size = length;
+#else
+   buffer.size = length>>3;
+#endif
+   buffer.param = 0;
+   buffer.dlen = 0;
+#ifdef MC2
+   buffer.rlen = length;
+#else
+   buffer.rlen = (length + 8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 0;      
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(data);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+      ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE,(ptrlong) &buffer);
+#else
+      ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE,(ptrlong) &buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+}
+
+ 
+/*+****************************************************************************
+ *
+ * Csp1WriteContext
+ *
+ * Write data to context memory.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit context handle pointer (context_handle%8=0)
+ *      length = size of the data in bytes (8<=length<=1024,length%8=0)
+ *      data = pointer to length bytes of data to be stored
+ *
+ * output
+ *    request_id = Unique ID for this request.
+ *
+ * Return Value
+ *    0  = success 
+ *    >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1WriteContext(n1_request_type request_type,
+       Uint64 context_handle, 
+       Uint16 length,
+       Uint8 *data,
+       Uint32 *request_id,Uint32 dev_id)
+#else
+Csp1WriteContext(n1_request_type request_type,
+       Uint64 context_handle, 
+       Uint16 length,
+       Uint8 *data,
+       Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((length < 8) || (length > 1024) || ((length & 0x7) != 0))
+      return ERR_ILLEGAL_INPUT_LENGTH;
+   
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+      if ((context_handle & 0xf) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+   } else {
+      if ((context_handle & 0x7) != 0)
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+   }
+   
+
+   buffer.opcode = (0x2<<8) | (global_dma_mode<<7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+#ifdef MC2
+   buffer.size = 0;
+#else
+   buffer.size = (length>>3) - 1;
+#endif
+   buffer.param = 0;
+#ifdef MC2
+   buffer.dlen = length;
+   buffer.rlen = 0;
+#else
+   buffer.dlen = (length)>>3;
+   buffer.rlen = (8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 0;      
+
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(data);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = length;
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+      ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE,(ptrlong) &buffer);
+#else
+      ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE,(ptrlong) &buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+}
+
+/*+****************************************************************************
+ *
+ * Csp1WriteIpsecSa
+ *
+ * Write Ipsec SA data to context memory.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *    proto = ESP or AH
+ *    inner_version = Protocol version of inner IP header.
+ *    outer_version = Protocol version of outer IP header.
+ *    mode = SA mode (TUNNEL or TRANSPORT)
+ *    dir = Direction (INBOUND or OUTBOUND)
+ *    cypher = Encryption algorithm 
+ *        (DESCBC, DES3CBC, AES128CBC, AES192CBC, AES256CBC)
+ *    auth = Authentication algorithm
+ *      (MD5HMAC96 or SHA1HMAC96)
+ *    template = Template for Outer IP header
+ *    spi = 32 bit SPI value
+ *    copy_df = 0 (copy the df bit for packet fragments) or 1 (do not copy)
+ *    udp_encap = 0 (no UDP encapsulation) or 1 (UDP encapsulation)
+ *    context_handle = 64-bit context handle pointer (context_handle%8=0)
+ *    next_context_handle = context handle pointer for next SA.
+ *
+ * output
+ *    request_id = Unique ID for this request.
+ *
+ * Return Value
+ *    0  = success 
+ *    >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef IPSEC_TEST
+#ifndef MC2
+Uint32
+Csp1WriteIpsecSa(IpsecProto proto,
+      Version version,
+      IpsecMode mode,
+      Direction dir,
+      EncType cypher,
+      Uint8 *e_key,
+      AuthType auth,
+      Uint8 *a_key,
+#ifndef IPV6_EXT_HEADER_SUPPORT
+      Uint8 template[40],
+#else
+      Uint8 template[384],
+#endif
+      Uint32 spi,
+      Uint8 copy_df,
+      FragType ft,
+      Uint16 inter_frag_padding,
+      Uint8 udp_encap,
+      Uint64 context_handle,
+      Uint64 next_context_handle,
+      int res_order,
+      int req_queue,
+      Uint32 *request_id)
+#else
+Uint32
+Csp1WriteIpsecSa(n1_request_type request_type,
+      IpsecProto proto,
+      Version inner_version,
+      Version outer_version,
+      IpsecMode mode,
+      Direction dir,
+      EncType cypher,
+      Uint8 *e_key,
+      AuthType auth,
+      Uint8 *a_key,
+#ifndef IPV6_EXT_HEADER_SUPPORT
+      Uint8 template[40],
+#else
+      Uint8 template[384],
+#endif
+      Uint32 spi,
+      Uint8 copy_df,
+      FragType ft,
+      Uint16 inter_frag_padding,
+      Uint8 udp_encap,
+      Uint64 context_handle,
+      Uint64 next_context_handle,
+      Selector* selectors,  /* selectors, must match inner_version */
+      int res_order,
+      int req_queue,
+      Uint32 *request_id)
+#endif
+{
+   Uint8 *p;
+   Uint16 *control;
+   Csp1OperationBuffer buffer;
+   Uint32 len;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 in_buffer[512];
+   int queue = req_queue;
+
+   memset(in_buffer,0x00,512);
+
+   p = (Uint8*)&in_buffer;
+   control = (Uint16*)p;
+   *control = 0;
+    /* Populate the control structure as the MC2 microcode requires */
+#ifndef MC2
+   *control = (((dir&0x1) << IPSEC_DIRECTION_SHIFT) | 
+      ((version & 0x1) << IPSEC_VERSION_SHIFT) |
+      ((mode & 0x1) << IPSEC_MODE_SHIFT) |
+      ((proto & 0x1) << IPSEC_PROT_SHIFT) |
+      ((auth & 0x0f) << IPSEC_AUTH_SHIFT) |
+      ((cypher & 0x0f) << IPSEC_CIPHER_SHIFT) |
+      ((copy_df & 0x01) << IPSEC_DF_SHIFT) |
+      ((udp_encap & 0x01) << IPSEC_UDP_SHIFT)); 
+#else
+   *control = (((dir& 0x1) << IPSEC_DIRECTION_SHIFT) |
+      ((VALID_SA & 0x1) << IPSEC_VALID_SHIFT) | 
+      ((outer_version & 0x1) << IPSEC_VERSION_SHIFT) |
+      ((inner_version & 0x1) << (IPSEC_VERSION_SHIFT+1)) |
+      ((mode & 0x1) << IPSEC_MODE_SHIFT) |
+      ((proto & 0x1) << IPSEC_PROT_SHIFT) |
+       ((udp_encap & 0x3) << IPSEC_ENCAP_SHIFT) |  
+      ((cypher & 0x7) << IPSEC_CIPHER_SHIFT) |
+      ((auth & 0x3) << IPSEC_AUTH_SHIFT) |
+      ((dir==INBOUND) ? (0x0 << IPSEC_SELECTOR_SHIFT) : ((copy_df & 0x1) << IPSEC_DF_SHIFT)));
+      if(dir == OUTBOUND)
+        *control = *control | ((ft & 1) << IPSEC_FT_SHIFT);
+      *control = *control | ((next_context_handle ? 1 : 0) << IPSEC_NEXT_SA_SHIFT);
+
+#endif
+   if(dir==INBOUND)
+   {
+     if(selectors) 
+     {
+       *control |= (0x1 << IPSEC_SELECTOR_SHIFT); /*Protocol selector is set by default 0 - proto selector enabled*/
+       inter_frag_padding = 0x0;
+       inter_frag_padding |= ((selectors->protocol & 0xff) << 8);
+     }
+   }
+   *control = htobe16(*control);
+//   cavium_dbgprint("write_ipsec_sa : control 0x%x\n", *control);
+
+   p += 2; 
+   if(dir == OUTBOUND)
+     *(Uint16*)p = htobe16(inter_frag_padding);
+   else //inbound
+     *(Uint16*)p = (selectors)? (htobe16(inter_frag_padding)): 0x0000;//includes Protocol selector(1 byte) + Reserved(1 byte)
+   p += 2;
+   memcpy(p,&spi,4);
+   p += 4;
+
+   memset(p, 0, 32);
+   if(cypher != NO_CYPHER)
+      memcpy(p, e_key, 32);
+   else
+      memset(p, 0, 32);
+
+   p += 32;
+
+   memset(p,0,24);  
+   switch (auth) {
+      case SHA1HMAC96:
+    memcpy(p,a_key,20);
+      break;
+
+      case MD5HMAC96:
+    memcpy(p,a_key,16);
+      break;
+
+      default:
+      case NO_AUTH:
+    memset(p,0,24);
+      break;
+   }
+   p += 24;
+
+#ifndef MC2
+   if (mode == 1 && dir == OUTBOUND)
+#ifndef IPV6_EXT_HEADER_SUPPORT
+      memcpy(p,template,40);
+#else
+      memcpy(p,template,384);
+#endif
+   memset(&buffer, 0, sizeof(buffer));
+
+   buffer.opcode = OP_WRITE_IPSEC_SA; 
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = 13;
+   buffer.rlen = 1;
+   buffer.reserved = 0;
+   buffer.ctx_ptr = context_handle;
+
+#else
+   len = (Uint8*)p - (Uint8*)in_buffer;
+   /* Since bundles is not yet implemented in this API, it returns -1 as error
+    * if the next_context_handle field is not passed as 0 */
+   if(next_context_handle!=0)
+      return -1;
+
+   p += 8;
+   len+=8;
+
+   if (dir == OUTBOUND) {
+   if (mode==TUNNEL) {
+      if (outer_version == IPv4) {
+       if (!udp_encap) {
+          /* Normal IPSec processing */
+      memcpy(p,template,20);
+           p+=20;
+           len+=20;
+          } else {
+            /* UDP Encapsulation */
+         memcpy(p,template,28);
+         p+=28;
+    len+=28;
+          }
+      } else {
+    /* IPv6 */
+        if(!udp_encap) {
+#ifndef IPV6_EXT_HEADER_SUPPORT
+          memcpy(p, template, 40);
+          p+=40;
+          len+=40;
+#else
+          memcpy(p, template, 384);
+          p+= 384;
+          len+= 384;
+#endif
+        }
+        else {
+#ifndef IPV6_EXT_HEADER_SUPPORT
+          memcpy(p, template, 48);
+          p+=48;
+          len+=48;
+#else
+          memcpy(p, template, 384 + 8);
+          p+= 384 + 8;
+          len+= 384 + 8;
+#endif
+        }
+      }
+    }
+       else { //Transport
+        if(udp_encap) {
+       if(outer_version == IPV4) {
+         memset(p,0,20);
+         memcpy(p+20,template,8);
+         p+=28;
+         len+=28;
+       }
+       else{
+         memset(p,0,40);
+         memcpy(p+40,template,8);
+         p+=48;
+         len+=48;
+       }
+     }
+   }
+
+    }
+   else { //inbound
+      memcpy(p,template,8); //for UDP encap
+      p+=8;
+      len+=8;
+      if(selectors)
+      {
+     
+        memcpy(p,SELECTOR(selectors),SELECTOR_SIZE(inner_version));
+        p += (SELECTOR_SIZE(inner_version));
+        len += (SELECTOR_SIZE(inner_version));
+      }
+   }
+
+#ifndef IPV6_EXT_HEADER_SUPPORT
+   memset(p, 0, 256-len);
+#else
+   memset(p, 0, 512-len);
+#endif
+
+   memset(&buffer, 0, sizeof(buffer));
+
+   buffer.opcode = ((dir == INBOUND) ? OP_WRITE_INBOUND_IPSEC_SA : OP_WRITE_OUTBOUND_IPSEC_SA); 
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = len;
+   buffer.rlen = 0;
+   buffer.reserved = 0;
+   buffer.ctx_ptr = context_handle;
+#endif
+
+#ifdef IPSEC_SCATTER_GATHER
+   buffer.dma_mode = CAVIUM_SCATTER_GATHER;
+#else
+   buffer.dma_mode = CAVIUM_DIRECT;
+#endif
+
+   buffer.incnt = 1;
+   /* For DIRECT mode, we need out_buffer for completion code.
+    * For SCATTER_GATHER, we do not need this, because completion
+    * code goes to rptr of command
+    */
+   if(buffer.dma_mode == CAVIUM_DIRECT)
+      buffer.outcnt=1;
+   else
+      buffer.outcnt=0;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(in_buffer);
+#ifndef MC2
+   buffer.insize[0] = buffer.dlen*8;
+#else
+   buffer.insize[0] = len;
+#endif
+   buffer.inoffset[0] = buffer.insize[0];
+   buffer.inunit[0] = UNIT_8_BIT;
+
+if(dir == OUTBOUND) {
+
+   inter_frag_padding = htobe16(inter_frag_padding);
+   buffer.inptr[1] = CAST_TO_X_PTR(&inter_frag_padding);
+   buffer.insize[1] = 2;
+   buffer.inoffset[1] = 2;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.dlen += buffer.insize[1];
+}
+else
+   buffer.incnt = 1;
+
+   buffer.res_order = res_order;
+   buffer.req_queue = queue;
+   buffer.callback = 0;
+   buffer.cb_arg = 0;
+//#ifdef NPLUS
+   buffer.group = CAVIUM_IPSEC_GRP;
+//#endif
+    buffer.req_queue = 0;
+    buffer.req_type = 0; // CAVIUM_BLOCKING
+    buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+    buffer.dma_mode = global_dma_mode;
+    buffer.status = 0;
+
+    cond_code = 
+       ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+    return ret_val;
+}
+/*+****************************************************************************
+ *
+ * Csp1ProcessPacket
+ *
+ * Process outbound packet
+ *
+ * Input
+ *    size = 0 (for MC2) or size of input data in bytes (for MC1).
+ *    param = 0 (for MC2) or Offset of IP header from 8-byte alignment (for MC1) *    dlen = length of input (packet)
+ *    inv = poniter to input data (packet to be processed)
+ *    rlen = length of output buffer (processed packet)
+ *    context_handle = 64-bit context handle pointer (context_handle%8=0)
+ *    response_order = 
+ *    req_queue = 
+ *    
+ * Output
+ *   outv = pointer to output buffer
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *    0  = success 
+ *    >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ProcessPacket(Uint16 size, 
+          Uint16 param,
+          Direction dir,
+          Uint16 dlen,
+          n1_scatter_buffer *inv,
+          n1_scatter_buffer *outv, 
+          int rlen,
+          Uint64 context_handle, 
+          int response_order, 
+          int req_queue,
+          Uint32 *request_id)
+{
+   Csp1OperationBuffer buffer;
+   Uint32 ret_val;
+   Uint32 cond_code;
+   int i;
+//   Uint32 req_id;
+
+   memset(&buffer, 0, sizeof(buffer));
+
+   buffer.opcode = (dir == OUTBOUND) ? OP_IPSEC_PACKET_OUTBOUND: OP_IPSEC_PACKET_INBOUND;
+   buffer.size = size;
+   buffer.param = param;
+   buffer.dlen = dlen;
+   buffer.rlen = rlen;
+   buffer.reserved = 0;
+   buffer.ctx_ptr = context_handle;
+   buffer.incnt = inv->bufcnt;
+   buffer.outcnt = outv->bufcnt;
+   
+   for ( i = 0; i < inv->bufcnt; i++) {
+      buffer.inptr[i] = CAST_TO_X_PTR(inv->bufptr[i]);
+      buffer.insize[i] = inv->bufsize[i];
+      buffer.inoffset[i] = buffer.insize[i];
+      buffer.inunit[i] = UNIT_8_BIT;
+   }
+   
+   for ( i = 0; i < outv->bufcnt; i++) 
+   {
+      buffer.outptr[i] = CAST_TO_X_PTR(outv->bufptr[i]);
+      buffer.outsize[i] = outv->bufsize[i];
+      buffer.outoffset[i] = buffer.outsize[i];
+      buffer.outunit[i] = UNIT_8_BIT;
+   }
+
+#ifdef IPSEC_SCATTER_GATHER
+   buffer.dma_mode = CAVIUM_SCATTER_GATHER;
+#else
+   buffer.dma_mode = CAVIUM_DIRECT;
+#endif
+
+//#ifdef NPLUS
+   buffer.group = CAVIUM_IPSEC_GRP;
+//#endif
+   buffer.req_queue = req_queue;
+   buffer.req_type = 0;
+   buffer.res_order = response_order;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+   cond_code = 
+       ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+}
+#endif /* IPSEC_TEST */
+
+/*+****************************************************************************
+ *
+ * Csp1Random
+ *
+ * Get random data from random pool maintained by the driver.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *          This api will only block if driver will have to refill
+ *          its random number pool. THis argument is ignored by the 
+ *          driver.
+ *   length = size of random data in bytes 
+ *
+ * Output
+ *   random = pointer to length bytes of random data
+ *      request_id = Unique ID for this request. This argument is ignored by the 
+ *                   driver.
+ *
+ * Return Value
+ * 0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+#ifdef CAVIUM_MULTICARD_API
+Csp1Random(n1_request_type request_type,
+      Uint16 length, 
+      Uint8 *random,
+      Uint32 *request_id,Uint32 dev_id)
+#else
+Csp1Random(n1_request_type request_type,
+      Uint16 length, 
+      Uint8 *random,
+      Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   buffer.opcode = (0x1<<8) | (global_dma_mode<<7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+   buffer.size = length;
+   buffer.rlen = length;
+   buffer.param = 0;
+   buffer.dlen = 0;
+
+   buffer.incnt = 0;      
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_GP_GRP;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(random);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+   buffer.ctx_ptr = 0;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+
+#ifdef CAVIUM_MULTICARD_API
+   cond_code = ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_GET_RANDOM_CODE, (ptrlong)&buffer);
+#else
+   cond_code = ioctl(CSP1_driver_handle, IOCTL_N1_GET_RANDOM_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   ret_val=cond_code;
+
+   return ret_val;
+}
+
+/*+****************************************************************************
+ *
+ * Csp1Hash
+ *
+ * Compute the HASH of a complete message. Does not use context.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   hash_type = MD5_TYPE or SHA1_TYPE 
+ *   message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *   message = pointer to length bytes of input to be HMACed
+ *
+ * Output
+ *   hash = pointer to the hash_size HASH result 
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *    0  = success 
+ *    >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+#ifdef CAVIUM_MULTICARD_API
+Uint32 
+Csp1Hash(n1_request_type request_type,
+    HashType hash_type, 
+    Uint16 message_length, 
+    Uint8 *message, 
+    Uint8 *hash,
+    Uint32 *request_id,Uint32 dev_id)
+#else
+Uint32 
+Csp1Hash(n1_request_type request_type,
+    HashType hash_type, 
+    Uint16 message_length, 
+    Uint8 *message, 
+    Uint8 *hash,
+    Uint32 *request_id)
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 hash_size=0;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+   buffer.opcode = (0x3<<9) | (global_dma_mode<<7) | MAJOR_OP_HASH;
+   buffer.size = 0;
+   if (hash_type == MD5_TYPE) {
+      buffer.param = 0x01;
+      hash_size = 16;
+   }
+   else if (hash_type == SHA1_TYPE) {
+      buffer.param = 0x02;
+      hash_size = 20;
+   }
+   else if (hash_type == SHA256_TYPE) {
+      buffer.param = 0x03;
+      hash_size = SHA256_HASH_LEN;	//32bytes
+   }
+   else if (hash_type == SHA384_TYPE) {
+      buffer.param = 0x04;
+      hash_size = SHA384_HASH_LEN;	//48bytes
+   }
+   else if (hash_type == SHA512_TYPE) {
+      buffer.param = 0x05;
+      hash_size = SHA512_HASH_LEN;	//64bytes
+   }
+   buffer.dlen = message_length;
+   buffer.rlen = (Uint16) hash_size;
+   if(hash_size > SHA256_HASH_LEN) 
+      buffer.incnt = 2;      
+   else 
+      buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   if(hash_size > SHA256_HASH_LEN) { /*for sha384 and sha512*/
+   buffer.inptr[0] = CAST_TO_X_PTR(message);
+   buffer.insize[0] = SHA2_HASH_IV_LEN;/*iv(64B) in case of sha384 and sha512*/
+   buffer.inoffset[0] = ROUNDUP8(SHA2_HASH_IV_LEN);
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.inptr[1] = CAST_TO_X_PTR(message+SHA2_HASH_IV_LEN);
+   buffer.insize[1] = message_length-SHA2_HASH_IV_LEN;/*len-64B*/
+   buffer.inoffset[1] = ROUNDUP8(message_length-SHA2_HASH_IV_LEN);
+   buffer.inunit[1] = UNIT_8_BIT;
+   } else 
+   if(hash_size <= SHA256_HASH_LEN) { /*for md5, sha1 and sha256*/
+   buffer.inptr[0] = CAST_TO_X_PTR(message);
+   buffer.insize[0] = message_length;
+   buffer.inoffset[0] = ROUNDUP8(message_length);
+   buffer.inunit[0] = UNIT_8_BIT;
+   }
+
+   buffer.outptr[0] = CAST_TO_X_PTR(hash);
+   buffer.outsize[0] = hash_size;
+   buffer.outoffset[0] = 24;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+      ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+      ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+#endif
+
+
+/*+****************************************************************************
+ *
+ * Csp1Hmac
+ *
+ * Compute the HMAC of a complete message. Does not use context.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   hash_type = MD5_TYPE or SHA1_TYPE 
+ *   key_length = size of the key in bytes (key_length%8=0, 8<=key_length<=64)
+ *   key = pointer to key_length-byte key
+ *   message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *   message = pointer to length bytes of input to be HMACed
+ *
+ * Output
+ *   hmac = pointer to the hash_size HMAC result 
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *    0  = success 
+ *    >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Hmac(n1_request_type request_type,
+    HashType hash_type, 
+    Uint8 *iv,
+    Uint16 key_length, 
+    Uint8 *key, 
+    Uint16 message_length, 
+    Uint8 *message, 
+    Uint8 *hmac,
+#ifdef CAVIUM_MULTICARD_API
+    Uint32 *request_id,Uint32 dev_id
+#else
+    Uint32 *request_id
+#endif
+    )
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 hash_size=0;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+if((hash_type == MD5_TYPE) || (hash_type == SHA1_TYPE)) {
+   if ((key_length < 8) || (key_length > 64))/*|| ((key_length & 0x7) != 0))*/
+      return ERR_ILLEGAL_KEY_LENGTH;
+} else { /*for SHA256, SHA384 and SHA512*/
+   if ((key_length < 8) || (key_length > 900))/*|| ((key_length & 0x7) != 0))*/
+      return ERR_ILLEGAL_KEY_LENGTH;
+}
+
+#ifdef MC2
+   buffer.opcode = (0x3<<9) | (global_dma_mode<<7) | MAJOR_OP_HMAC;
+#else
+   buffer.opcode = (0x3<<9) | (hash_type<<8) | (global_dma_mode<<7) | MAJOR_OP_HMAC;
+#endif
+
+#ifdef MC2
+   buffer.size = key_length;
+   if (hash_type == SHA1_TYPE) {
+      buffer.param = 0x02;
+      hash_size = 20;
+   } else if (hash_type == MD5_TYPE) {
+      buffer.param = 0x01;
+      hash_size = 16;
+   } else if (hash_type == SHA256_TYPE) {
+      buffer.param = 0x03;
+      hash_size = 32;
+   } else if (hash_type == SHA384_TYPE) {
+      buffer.param = 0x04;
+      hash_size = 48;
+   } else if (hash_type == SHA512_TYPE) {
+      buffer.param = 0x05;
+      hash_size = 64;
+   } else
+      buffer.param = 0;
+   if((hash_type == SHA384_TYPE) || (hash_type == SHA512_TYPE)) 
+   buffer.dlen = key_length + message_length + 64;
+   else
+   buffer.dlen = key_length + message_length;
+   buffer.rlen = (Uint16) hash_size;
+#else
+   buffer.size = message_length;
+   buffer.param = (key_length>>3) - 1;
+   buffer.dlen = (key_length + ROUNDUP8(message_length))>>3;
+   buffer.rlen = (24 + 8)>>3;
+#endif
+
+#ifdef MC2
+   if((hash_type == SHA384_TYPE) || (hash_type == SHA512_TYPE)) 
+   buffer.incnt = 3;      
+   else
+#endif
+   buffer.incnt = 2;      
+
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+#ifdef MC2
+   if((hash_type == SHA384_TYPE) || (hash_type == SHA512_TYPE)) {
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 64;
+   buffer.inoffset[0] = 64;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(message);
+   buffer.insize[2] = message_length;
+   buffer.inoffset[2] = ROUNDUP8(message_length);
+   buffer.inunit[2] = UNIT_8_BIT;
+   }
+else 
+#endif
+   {
+   buffer.inptr[0] = CAST_TO_X_PTR(key);
+   buffer.insize[0] = key_length;
+   buffer.inoffset[0] = key_length;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(message);
+   buffer.insize[1] = message_length;
+   buffer.inoffset[1] = ROUNDUP8(message_length);
+   buffer.inunit[1] = UNIT_8_BIT;
+   }
+
+   buffer.outptr[0] = CAST_TO_X_PTR(hmac);
+   buffer.outsize[0] = hash_size;
+   buffer.outoffset[0] = 24;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1HmacStart
+ *
+ *   Compute the first stage in a multi-step HMAC.
+ *   
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   context_handle = 64-bit pointer to context (context_handle%8=0)
+ *   hash_type = MD5_TYPE or SHA1_TYPE 
+ *   key_length = size of the key in bytes (key_length%8=0, 8<=key_length<=64)
+ *   key = pointer to key_length-byte key
+ *   message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *   message = pointer to length bytes of input to be HMACed
+ *
+ * Output
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ *   >0 = failure or pending
+ *   see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HmacStart(n1_request_type request_type,
+           Uint64 context_handle, 
+           HashType hash_type, 
+           Uint16 key_length, 
+           Uint8 *key, 
+           Uint16 message_length, 
+           Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+           Uint32 *request_id,Uint32 dev_id
+#else
+           Uint32 *request_id
+#endif 
+           ) 
+{
+#ifdef MC2
+   return    ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 hash_size;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   if ((key_length < 8) || (key_length > 64) || ((key_length & 0x7) != 0))
+
+      return ERR_ILLEGAL_KEY_LENGTH;
+#endif
+
+   buffer.opcode = (0x1<<9) | (hash_type<<8) | (global_dma_mode<<7) | MAJOR_OP_HMAC;
+//   hash_size = 20 - (hash_type<<2);
+   hash_size = (hash_type==MD5_TYPE)? 16:20;
+
+   buffer.size = message_length;
+   buffer.param = (key_length>>3) - 1;
+   buffer.dlen = (key_length + ROUNDUP8(message_length))>>3;
+   buffer.rlen = (8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 2;      
+   buffer.outcnt = 0;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(key);
+   buffer.insize[0] = key_length;
+   buffer.inoffset[0] = key_length;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(message);
+   buffer.insize[1] = message_length;
+   buffer.inoffset[1] = ROUNDUP8(message_length);
+   buffer.inunit[1] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = CAVIUM_SCATTER_GATHER;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+#endif /*MC2*/
+}
+
+ 
+/*+****************************************************************************
+ *
+ * Csp1HmacUpdate
+ *
+ *   Compute an intermediate step in a multi-step HMAC.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   context_handle = 64-bit pointer to context (context_handle%8=0)
+ *   hash_type = MD5_TYPE or SHA1_TYPE 
+ *   message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *   message = pointer to length bytes of input to be HMACed
+ *
+ * Output
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ *   >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HmacUpdate(n1_request_type request_type,
+            Uint64 context_handle, 
+            HashType hash_type, 
+            Uint16 message_length, 
+            Uint8 *message,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+{
+#ifdef MC2
+   return ERR_OPERATION_NOT_SUPPORTED;
+#else
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 hash_size;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+#endif
+
+   buffer.opcode = (0x0<<9) | (hash_type<<8) | (global_dma_mode<<7) | MAJOR_OP_HMAC;
+//   hash_size = 20 - (hash_type<<2);
+   hash_size = (hash_type==MD5_TYPE)? 16:20;
+
+   buffer.size = message_length;
+   buffer.param = 0;
+   buffer.dlen = (ROUNDUP8(message_length))>>3;
+   buffer.rlen = (8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 0;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(message);
+   buffer.insize[0] = message_length;
+   buffer.inoffset[0] = ROUNDUP8(message_length);
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+
+#endif /*MC2*/
+}
+
+          
+/*+****************************************************************************
+ *
+ * Csp1HmacFinish
+ *
+ *   Compute the final step in a multi-step HMAC.
+ *
+ * Input
+ *    request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   context_handle = 64-bit pointer to context (context_handle%8=0)
+ *   hash_type = MD5_TYPE or SHA1_TYPE 
+ *   message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *   message = pointer to length bytes of input to be HMACed
+ *
+ * Output
+ *   final_hmac = pointer to the hash_size-word HMAC result 
+ *   request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ *   >0 = failure or pending
+ *    see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1HmacFinish(n1_request_type request_type,
+      Uint64 context_handle, 
+      HashType hash_type, 
+      Uint16 message_length, 
+      Uint8 *message, 
+      Uint8 *final_hmac,
+#ifdef CAVIUM_MULTICARD_API
+      Uint32 *request_id,Uint32 dev_id
+#else
+      Uint32 *request_id
+#endif
+     )
+
+{
+#ifdef MC2
+   return ERR_OPERATION_NOT_SUPPORTED;
+#else
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 hash_size;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+#endif
+
+   buffer.opcode = (0x2<<9) | (hash_type<<8) | (global_dma_mode<<7) | MAJOR_OP_HMAC;
+//   hash_size = 20 - (hash_type<<2);
+   hash_size = (hash_type==MD5_TYPE)? 16:20;
+
+   buffer.size = message_length;
+   buffer.param = 0;
+   buffer.dlen = (ROUNDUP8(message_length))>>3;
+   buffer.rlen = (24 + 8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(message);
+   buffer.insize[0] = message_length;
+   buffer.inoffset[0] = ROUNDUP8(message_length);
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(final_hmac);
+   buffer.outsize[0] = hash_size;
+   buffer.outoffset[0] = 24;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+#endif /*MC2*/
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Me
+ *
+ * Modular exponentiation.
+ *
+ * p = x^e mod m
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   #ifdef MC2
+ *      modlength = size of modulus in bytes (16<=modlength<=512)
+ *      explength = size of exponent in bytes 
+ *      datalength = size of data in bytes
+ *      modulus = pointer to modlength-byte modulus
+ *      exponent = pointer to explength-byte exponent
+ *      data = pointer to datalength-byte data
+ *   #else
+ *      result_location = CONTEXT_PTR or RESULT_PTR 
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      modlength = size of modulus in bytes (modlength%8=0, 24<modlength<=256)
+ *      data = pointer to modlength-byte value to be exponentiated
+ *      modulus = pointer to modlength-byte modulus
+ *      exponent = pointer to modlength-byte exponent
+ *   #endif
+ *
+ * Output
+ *   #ifdef MC2
+ *      result = pointer to modlength-byte output
+ *   #else
+ *      result = if (result_location == RESULT_PTR) pointer to modlength-byte 
+ *             output in byte format
+ *   #endif
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Me(n1_request_type request_type,
+      Uint16 modlength,
+      Uint16 explength,
+      Uint16 datalength,
+      Uint8 *modulus,
+      Uint8 *exponent,
+      Uint8 *data, 
+      Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+      Uint32 *request_id,Uint32 dev_id
+#else
+      Uint32 *request_id
+#endif
+      )
+
+#else
+Uint32 
+Csp1Me(n1_request_type request_type,
+      ResultLocation result_location,
+      Uint64 context_handle, 
+      Uint16 modlength, 
+      Uint8 *data, 
+      Uint8 *modulus, 
+      Uint8 *exponent,
+      Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+      Uint32 *request_id,Uint32 dev_id
+#else
+      Uint32 *request_id
+#endif
+      )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint16 length = 0;
+#endif
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if (result_location == CONTEXT_PTR) {
+
+      if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+         if ((context_handle & 0xf) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      } else {
+
+         if ((context_handle & 0x7) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      }
+   }
+
+   if ((modlength & 0x7) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+#ifdef MC2
+   if ((modlength >= 17) && (modlength <= 128)) {
+#else
+   if ((modlength >= 24) && (modlength <= 128)) {
+#endif
+
+#ifdef MC2
+      buffer.opcode = (MAJOR_OP_ME_PKCS) | (global_dma_mode<<7) ;
+   } else if ((modlength > 128) && (modlength <= 512)) {
+#else
+      buffer.opcode = (result_location<<9) | (0x0<<8) | (global_dma_mode<<7) 
+         | MAJOR_OP_ME_PKCS;
+      length = (modlength>>3) - 1;
+   } else if ((modlength > 128) && (modlength <= 256)) {
+#endif
+
+
+#ifdef MC2
+      buffer.opcode = (MAJOR_OP_ME_PKCS_LARGE) | (global_dma_mode<<7);
+#else
+      buffer.opcode = (result_location<<9) | (0x0<<8) | (global_dma_mode<<7) 
+         | MAJOR_OP_ME_PKCS_LARGE;
+      length = (modlength>>3) - 17;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+   } else {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+   }
+
+#ifdef MC2
+   buffer.ctx_ptr=0;
+   buffer.dlen = modlength + explength + datalength;
+   buffer.param = explength;
+   buffer.size = modlength;
+   buffer.rlen = modlength;
+#else
+   buffer.size = length;
+   buffer.param = 0;
+   buffer.dlen = (3 * modlength)>>3;
+   buffer.rlen = (8)>>3;
+   buffer.ctx_ptr = context_handle;
+#endif
+
+#ifdef MC2 
+   buffer.incnt = 3;
+   buffer.inptr[0] = CAST_TO_X_PTR(modulus);
+   buffer.insize[0] = modlength;
+   buffer.inoffset[0] = modlength;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(exponent);
+   buffer.insize[1] = explength;
+   buffer.inoffset[1] = explength;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(data);
+   buffer.insize[2] = datalength;
+   buffer.inoffset[2] = datalength;
+   buffer.inunit[2] = UNIT_8_BIT;
+
+        buffer.outcnt = 1;
+
+        buffer.outptr[0] = CAST_TO_X_PTR(result);
+        buffer.outsize[0] = modlength;
+        buffer.outoffset[0] = modlength;
+        buffer.outunit[0] = UNIT_8_BIT;
+
+#else 
+   buffer.incnt = 3;
+   buffer.inptr[0] = CAST_TO_X_PTR(data);
+   buffer.insize[0] = modlength;
+   buffer.inoffset[0] = modlength;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(modulus);
+   buffer.insize[1] = modlength;
+   buffer.inoffset[1] = modlength;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(exponent);
+   buffer.insize[2] = modlength;
+   buffer.inoffset[2] = modlength;
+   buffer.inunit[2] = UNIT_8_BIT;
+#endif
+
+   buffer.group = CAVIUM_GP_GRP;
+
+    buffer.req_queue = 0;
+    buffer.req_type = request_type;
+    buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+    buffer.dma_mode = global_dma_mode;
+
+#ifndef MC2
+   if (result_location == RESULT_PTR) {
+
+      buffer.rlen += (modlength>>3);
+
+      buffer.outcnt = 1;   
+      
+      buffer.outptr[0] = CAST_TO_X_PTR(result);
+      buffer.outsize[0] = modlength;
+      buffer.outoffset[0] = modlength;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+   } else if (result_location == CONTEXT_PTR)
+
+      buffer.outcnt = 0;
+#endif
+   buffer.status = 0;
+
+       cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+      *request_id = buffer.request_id;
+
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+      return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Pkcs1v15Enc
+ *
+ * Creates PKCS#1v1.5 container.
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   #ifdef MC2
+ *      block_type = type of PKCS#1v1.5 padding (BT1 or BT2)
+ *      modlength = size of modulus in bytes 
+ *      explength = size of exponent in bytes 
+ *      datalength = size of data in bytes
+ *      modulus = pointer to modlength-byte modulus
+ *      exponent = pointer to explength-byte exponent
+ *      data = pointer to datalength-byte data
+ *   #else
+ *      result_location = CONTEXT_PTR or RESULT_PTR 
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      key_material_input = KEY_HANDLE or INPUT_DATA
+ *      key_handle = 64-bit handle for key memory 
+ *      block_type = type of PKCS#1v1.5 padding (BT1 or BT2)
+ *      modlength = size of modulus in bytes (modlength%8=0, 24<modlength<=256)
+ *      modulus = (key_material_input == INPUT_DATA) ? pointer to RSA modulus : don't care
+ *      exponent = (key_material_input == INPUT_DATA) ? pointer to RSA exponent : don't care
+ *      length = size of the input value 
+ *      data = pointer to length-byte value to be exponentiated
+ *   #endif
+ *
+ * Output
+ *   #ifdef MC2
+ *      result = pointer to modlength bytes of output
+ *   #else
+ *      result = (result_location == RESULT_PTR) ? (pointer to modlength bytes of output: don't care)
+ *   #endif
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Pkcs1v15Enc(n1_request_type request_type,
+            RsaBlockType block_type,
+            Uint16 modlength, 
+            Uint16 explength,
+            Uint16 datalength, 
+            Uint8 *modulus, 
+            Uint8 *exponent, 
+            Uint8 *data,
+            Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Pkcs1v15Enc(n1_request_type request_type,
+            ResultLocation result_location, 
+            Uint64 context_handle,
+            KeyMaterialInput key_material_input,
+            Uint64 key_handle, 
+            RsaBlockType block_type,
+            Uint16 modlength, 
+            Uint8 *modulus, 
+            Uint8 *exponent, 
+            Uint16 length, 
+            Uint8 *data,
+            Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint16 size = 0;
+   Uint8 *p_modulus = NULL, *p_exponent = NULL;
+   Uint8 pkey[512];
+   Uint64 tmp_key;
+   Uint32 dummy=0;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+   if (result_location == CONTEXT_PTR) {
+
+      if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+         if ((context_handle & 0xf) != 0)
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      } else {
+
+         if ((context_handle & 0x7) != 0)
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+      }
+   }
+
+   if ((modlength & 0x7) != 0)
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   if (key_handle & (((Uint64)0x10000) << 32))
+      return ERR_ILLEGAL_MOD_EX_TYPE;
+#endif
+
+#ifdef MC2 
+
+        memset(&buffer,0,sizeof(Csp1OperationBuffer));
+        buffer.ctx_ptr=0;
+        buffer.dlen = modlength + explength + datalength;
+        buffer.size = modlength;
+        buffer.param = (block_type) | (explength<<1);
+        buffer.rlen = modlength;
+
+#else
+   if (key_material_input == KEY_HANDLE) {
+
+         if (key_handle & (((Uint64)0x20000) << 32)) {
+         
+         tmp_key = key_handle & UINT64_C(0x0000ffffffffffff);
+         
+#ifdef CAVIUM_MULTICARD_API
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (2*modlength), pkey,&dummy,dev_id))
+#else
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (2*modlength), pkey,&dummy))
+#endif
+         
+            return ERR_ILLEGAL_KEY_HANDLE;
+
+         p_modulus = &(pkey[0]);
+         p_exponent = &(pkey[modlength]);
+         buffer.param = (Uint16)0x4000;
+
+      }
+
+      else if (key_handle & 0x8000) {
+
+         buffer.param = (Uint16)key_handle & 0xffff; 
+
+      } else {
+
+         buffer.param = ((Uint16)key_handle & 0x1ff8) >> 3;
+
+      }
+   
+   } else if (key_material_input == INPUT_DATA) {
+
+      buffer.param = (Uint16)0x4000;
+      p_modulus = modulus;
+      p_exponent = exponent;
+
+   }
+#endif
+#ifdef MC2
+   if ((modlength >= 17) && (modlength <= 128)) {
+#else
+   if ((modlength >= 24) && (modlength <= 128)) {
+#endif
+
+#ifdef MC2
+      buffer.opcode = (global_dma_mode<<7) | (0x3<<8) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 512)) {
+#else
+      size = (length<<8) + (NORMAL_MOD_EX << 7) + ((modlength>>3) - 1);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x3<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 256)) {
+#endif
+
+#ifdef MC2
+      buffer.opcode = (global_dma_mode<<7) | (0x3<<8) | MAJOR_OP_ME_PKCS_LARGE;
+#else
+      size = (length<<8) + (NORMAL_MOD_EX << 7) + ((modlength>>3) - 17);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x3<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+   } else {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+   }
+
+#ifdef MC2
+   buffer.incnt = 3;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(modulus);
+   buffer.insize[0] = modlength;
+   buffer.inoffset[0] = modlength;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(exponent);
+   buffer.insize[1] = explength;
+   buffer.inoffset[1] = explength;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(data);
+   buffer.insize[2] = datalength;
+   buffer.inoffset[2] = datalength;
+   buffer.inunit[2] = UNIT_8_BIT;
+
+   buffer.outcnt = 1;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(result);
+   buffer.outsize[0] = modlength;
+   buffer.outoffset[0] = modlength;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+#else 
+   buffer.size = size;
+   buffer.dlen = (modlength>>3);
+   buffer.rlen = (8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   if ((key_material_input == INPUT_DATA)
+       ||
+       (key_handle & (((Uint64)0x20000) << 32))) {
+
+      buffer.dlen += ((2*modlength)>>3);
+
+      buffer.incnt = 3;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR(p_modulus);
+      buffer.insize[1] = modlength;
+      buffer.inoffset[1] = modlength;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR(p_exponent);
+      buffer.insize[2] = modlength;
+      buffer.inoffset[2] = modlength;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR(data);
+      buffer.insize[3] = modlength;
+      buffer.inoffset[3] = modlength;
+      buffer.inunit[3] = UNIT_8_BIT;
+
+   } else {
+
+      buffer.incnt = 1;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+
+   }
+
+   if (result_location == RESULT_PTR) {
+
+      buffer.rlen += (modlength>>3);
+
+      buffer.outcnt = 1;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR(result);
+      buffer.outsize[0] = modlength;
+      buffer.outoffset[0] = modlength;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+   } else if (result_location == CONTEXT_PTR) {
+
+      buffer.outcnt = 0;      
+
+   }
+#endif
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Pkcs1v15CrtEnc
+ *
+ * Creates PKCS#1v1.5 container using the Chinese Remainder Theorem.
+ * The combination of block type BT2 and CRT may produce unpredictable results.
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   #ifdef MC2
+ *      block_type = type of PKCS#1v1.5 padding (BT1 only)
+ *      modlength = size of modulus in bytes
+ *      datalength = size of input data in bytes.
+ *      Q = prime factor of RSA modulus
+ *      Eq = exponent mod(Q-1)
+ *      P = prime factor of RSA modulus
+ *      Ep = exponent mod(P-1)
+ *      iqmp = (Q^-1) mod P
+ *   #else
+ *      result_location = CONTEXT_PTR or RESULT_PTR 
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      key_material_input = KEY_HANDLE or INPUT_DATA
+ *      key_handle = 64-bit handle for key memory 
+ *      block_type = type of PKCS#1v1.5 padding (BT1 only)
+ *      modlength = size of modulus in bytes (modlength%8=0, 24<modlength<=256)
+ *      Q = (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ *      Eq = (key_material_input == INPUT_DATA) ? exponent mod(Q-1) : don't care
+ *      P = (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ *      Ep = (key_material_input == INPUT_DATA) ? exponent mod(P-1) : don't care
+ *      iqmp = (key_material_input == INPUT_DATA) ? (Q^-1) mod P : don't care
+ *      length = size of the input value 
+ *   #endif
+ *      data = pointer to length-byte value to be exponentiated
+ *
+ * Output
+ *   #ifdef MC2
+ *      result = pointer to modlength bytes of output
+ *   #else
+ *      result = (result_location == RESULT_PTR) ? (pointer to modlength bytes of output : don't care
+ *   #endif
+ *      request_id = Unique ID for this request.
+ * 
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Pkcs1v15CrtEnc(n1_request_type request_type,
+               RsaBlockType block_type,
+               Uint16 modlength, 
+               Uint16 datalength, 
+               Uint8 *Q, 
+               Uint8 *Eq, 
+               Uint8 *P, 
+               Uint8 *Ep, 
+               Uint8 *iqmp, 
+               Uint8 *data,
+               Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Pkcs1v15CrtEnc(n1_request_type request_type,
+               ResultLocation result_location, 
+               Uint64 context_handle, 
+               KeyMaterialInput key_material_input,
+               Uint64 key_handle, 
+               RsaBlockType block_type,
+               Uint16 modlength, 
+               Uint8 *Q, 
+               Uint8 *Eq, 
+               Uint8 *P, 
+               Uint8 *Ep, 
+               Uint8 *iqmp, 
+               Uint16 length, 
+               Uint8 *data,
+               Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint16 size = 0;
+   Uint8 *p_Q = NULL, *p_Eq = NULL, *p_P = NULL, *p_Ep = NULL, *p_iqmp = NULL;
+   Uint8 pkey[640];
+   Uint64 tmp_key;
+   Uint32 dummy=0;
+#endif
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if (result_location == CONTEXT_PTR) {
+
+      if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+         if ((context_handle & 0xf) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      } else {
+
+         if ((context_handle & 0x7) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      }
+   }
+
+   
+   if (block_type == BT2) 
+
+      return ERR_ILLEGAL_BLOCK_TYPE;
+
+   if ((modlength & 0x7) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   if (!(key_handle & (((Uint64)0x10000) << 32)))
+
+      return ERR_ILLEGAL_MOD_EX_TYPE;
+#endif
+
+#ifdef MC2
+   buffer.ctx_ptr=0;
+   buffer.dlen = (Uint16) (2.5 * modlength + datalength);
+   buffer.size = modlength;
+   buffer.param = (block_type);
+   buffer.rlen = modlength;
+#else
+   if (key_material_input == KEY_HANDLE) {
+
+      if (key_handle & (((Uint64)0x20000) << 32)) {
+
+         tmp_key = key_handle & UINT64_C(0x0000ffffffffffff);
+         
+#ifdef CAVIUM_MULTICARD_API
+         if(Csp1ReadContext(CAVIUM_BLOCKING,tmp_key, (5*modlength/2), pkey, &dummy,dev_id))
+#else
+         if(Csp1ReadContext(CAVIUM_BLOCKING,tmp_key, (5*modlength/2), pkey, &dummy))
+#endif
+         
+            return ERR_ILLEGAL_KEY_HANDLE;
+
+         p_Q = &(pkey[0]);
+         p_Eq = &(pkey[modlength/2]); 
+         p_P = &(pkey[2*(modlength/2)]);
+         p_Ep = &(pkey[3*(modlength/2)]); 
+         p_iqmp = &(pkey[4*(modlength/2)]);
+
+         buffer.param = (Uint16)0x4000;
+
+      }
+
+      else if (key_handle & 0x8000) {
+
+         buffer.param = (Uint16)key_handle & 0xffff; 
+
+      } else {
+
+         buffer.param = ((Uint16)key_handle & 0x1ff8) >> 3;
+
+      }
+   
+   } else if (key_material_input == INPUT_DATA) {
+
+      buffer.param = (Uint16)0x4000;
+      p_Q = Q;
+      p_Eq = Eq; 
+      p_P = P;
+      p_Ep = Ep; 
+      p_iqmp = iqmp; 
+
+   }
+#endif
+
+#ifdef MC2
+   if ((modlength >= 34) && (modlength <= 128) && ((modlength & 0x1) == 0)) {
+#else
+   if ((modlength >= 48) && (modlength <= 128) && ((modlength & 0x1) == 0)) {
+#endif
+
+#ifdef MC2
+         buffer.opcode = (global_dma_mode<<7) | (0x4<<8) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 512) && ((modlength & 0x1) == 0)) {
+#else
+      size = (length<<8) + (CRT_MOD_EX << 7) + ((modlength>>3) - 1);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x3<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 256) && ((modlength & 0x1) == 0)) {
+#endif
+
+
+#ifdef MC2
+      buffer.opcode = (global_dma_mode<<7) | (0x4<<8) | MAJOR_OP_ME_PKCS_LARGE;
+#else
+      size = (length<<8) + (CRT_MOD_EX << 7) + ((modlength>>3) - 17);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x3<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+   } else {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+   }
+
+#ifdef MC2
+   buffer.incnt = 6;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(Q);
+   buffer.insize[0] = modlength/2;
+   buffer.inoffset[0] = modlength/2;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(Eq);
+   buffer.insize[1] = modlength/2;
+   buffer.inoffset[1] = modlength/2;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(P);
+   buffer.insize[2] = modlength/2;
+   buffer.inoffset[2] = modlength/2;
+   buffer.inunit[2] = UNIT_8_BIT;
+   buffer.inptr[3] = CAST_TO_X_PTR(Ep);
+   buffer.insize[3] = modlength/2;
+   buffer.inoffset[3] = modlength/2;
+   buffer.inunit[3] = UNIT_8_BIT;
+   buffer.inptr[4] = CAST_TO_X_PTR(iqmp);
+   buffer.insize[4] = modlength/2;
+   buffer.inoffset[4] = modlength/2;
+   buffer.inunit[4] = UNIT_8_BIT;
+   buffer.inptr[5] = CAST_TO_X_PTR(data);
+   buffer.insize[5] = datalength;
+   buffer.inoffset[5] = datalength;
+   buffer.inunit[5] = UNIT_8_BIT;
+
+   buffer.outcnt = 1;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(result);
+   buffer.outsize[0] = modlength;
+   buffer.outoffset[0] = modlength;
+   buffer.outunit[0] = UNIT_8_BIT;
+#else 
+   buffer.size = size;
+   buffer.dlen = (ROUNDUP8(modlength))>>3;
+   buffer.rlen = (8)>>3;
+   buffer.ctx_ptr = context_handle;
+   if ((key_material_input == INPUT_DATA)
+      ||
+      (key_handle & (((Uint64)0x20000) << 32))) {
+
+      buffer.dlen += ((5*modlength/2)>>3);
+
+      buffer.incnt = 6;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR(p_Q);
+      buffer.insize[1] = modlength/2;
+      buffer.inoffset[1] = modlength/2;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR(p_Eq);
+      buffer.insize[2] = modlength/2;
+      buffer.inoffset[2] = modlength/2;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR(p_P);
+      buffer.insize[3] = modlength/2;
+      buffer.inoffset[3] = modlength/2;
+      buffer.inunit[3] = UNIT_8_BIT;
+      buffer.inptr[4] = CAST_TO_X_PTR(p_Ep);
+      buffer.insize[4] = modlength/2;
+      buffer.inoffset[4] = modlength/2;
+      buffer.inunit[4] = UNIT_8_BIT;
+      buffer.inptr[5] = CAST_TO_X_PTR(p_iqmp);
+      buffer.insize[5] = modlength/2;
+      buffer.inoffset[5] = modlength/2;
+      buffer.inunit[5] = UNIT_8_BIT;
+
+   } else {
+
+      buffer.incnt = 1;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR( data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+
+   }
+
+   if (result_location == RESULT_PTR) {
+
+      buffer.rlen += (modlength>>3);
+
+      buffer.outcnt = 1;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR(result);
+      buffer.outsize[0] = modlength;
+      buffer.outoffset[0] = modlength;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+   } else if (result_location == CONTEXT_PTR) {
+
+      buffer.outcnt = 0;      
+
+   }
+#endif
+ 
+   buffer.group = CAVIUM_SSL_GRP;
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Pkcs1v15Dec
+ *
+ * Decrypts PKCS#1v1.5 container.
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   #ifdef MC2
+ *      block_type = type of PKCS#1v1.5 padding (BT1 only)
+ *      modlength = size of modulus in bytes
+ *      explength = size of exponent in bytes
+ *      modulus = pointer to modlength-byte modulus
+ *      exponent = pointer to explength-byte exponent
+ *      data = pointer to modlength-11 bytes input
+ *   #else
+ *      result_location = CONTEXT_PTR or RESULT_PTR 
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      key_material_input = KEY_HANDLE or INPUT_DATA
+ *      key_handle = 64-bit handle for key memory 
+ *      block_type = type of PKCS#1v1.5 padding (BT1 or BT2)
+ *      modlength = size of modulus in bytes (modlength%8=0, 24<modlength<=256)
+ *      modulus = (key_material_input == INPUT_DATA) ? pointer to RSA modulus : don't care
+ *      exponent = (key_material_input == INPUT_DATA) ? pointer to RSA exponent : don't care
+ *      data = pointer to modlength-byte value to be exponentiated
+ *   #endif
+ *
+ * Output
+ *   #ifdef MC2
+ *      out_length = size of decrypted data in Network Byte order.
+ *      result = out_length byte size result
+ *   #else
+ *      result = (result_location == RESULT_PTR) ? (pointer to modlength bytes of output, 
+ *            *out_length bytes used) : don't care
+ *      out_length = pointer to output length in bytes
+ *   #endif
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Pkcs1v15Dec(n1_request_type request_type,
+            RsaBlockType block_type,
+            Uint16 modlength, 
+            Uint16 explength,
+            Uint8 *modulus, 
+            Uint8 *exponent, 
+            Uint8 *data,
+            Uint16 *out_length,
+            Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Pkcs1v15Dec(n1_request_type request_type,
+            ResultLocation result_location, 
+            Uint64 context_handle, 
+            KeyMaterialInput key_material_input,
+            Uint64 key_handle, 
+            RsaBlockType block_type,
+            Uint16 modlength, 
+            Uint8 *modulus, 
+            Uint8 *exponent, 
+            Uint8 *data,
+            Uint8 *result,
+            Uint64 *out_length,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint16 size = 0;
+   Uint8 *p_modulus = NULL, *p_exponent = NULL;
+   Uint8 pkey[512];
+   Uint64 tmp_key;
+   Uint32 dummy=0;
+#endif          
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+#if defined(CSP1_API_DEBUG)
+   if (result_location == CONTEXT_PTR) {
+
+      if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+         if ((context_handle & 0xf) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      } else {
+
+         if ((context_handle & 0x7) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      }
+   }
+
+
+   if ((modlength & 0x7) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   if (key_handle & (((Uint64)0x10000) << 32))
+
+      return ERR_ILLEGAL_MOD_EX_TYPE;
+#endif
+
+#ifdef MC2
+   buffer.ctx_ptr=0;
+   buffer.dlen = (2*modlength) + explength;
+   buffer.size = modlength;
+   buffer.param = (block_type) | (explength<<1);
+   buffer.rlen = 2 + modlength; /* outlength + modlength bytes result */
+#else 
+   if (key_material_input == KEY_HANDLE) {
+
+      if (key_handle & (((Uint64)0x20000) << 32)) {
+
+         tmp_key = key_handle & UINT64_C(0x0000ffffffffffff);
+         
+#ifdef CAVIUM_MULTICARD_API
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (2*modlength), pkey, &dummy,dev_id))
+#else
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (2*modlength), pkey, &dummy))
+#endif
+         
+            return ERR_ILLEGAL_KEY_HANDLE;
+
+         p_modulus = &(pkey[0]);
+         p_exponent = &(pkey[modlength]);
+
+         buffer.param = (Uint16)0x4000;
+
+      }
+
+      else if (key_handle & 0x8000) {
+
+         buffer.param = (Uint16)key_handle & 0xffff; 
+
+      } else {
+
+         buffer.param = ((Uint16)key_handle & 0x1ff8) >> 3;
+
+      }
+   
+   } else if (key_material_input == INPUT_DATA) {
+
+      buffer.param = (Uint16)0x4000;
+      p_modulus = modulus;
+      p_exponent = exponent;
+
+   }
+#endif
+
+#ifdef MC2
+   if ((modlength >= 17) && (modlength <= 128)) {
+#else
+   if ((modlength >= 24) && (modlength <= 128)) {
+#endif
+#ifdef MC2
+      buffer.opcode = (global_dma_mode<<7) | (0x1<<8) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 512)) {
+#else
+      size = (modlength>>3) - 1;
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x1<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 256)) {
+#endif
+
+#ifdef MC2
+      buffer.opcode = (global_dma_mode<<7) | (0x1<<8) | MAJOR_OP_ME_PKCS_LARGE;
+#else
+      size = (modlength>>3) - 17;
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x1<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+   } else {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+   }
+
+#ifdef MC2
+   buffer.incnt = 3;
+
+   buffer.inptr[0] = CAST_TO_X_PTR(modulus);
+   buffer.insize[0] = modlength;
+   buffer.inoffset[0] = modlength;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(exponent);
+   buffer.insize[1] = explength;
+   buffer.inoffset[1] = explength;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(data);
+   buffer.insize[2] = modlength;
+   buffer.inoffset[2] = modlength;
+   buffer.inunit[2] = UNIT_8_BIT;
+
+   buffer.outcnt = 2;
+
+   buffer.outptr[0] = CAST_TO_X_PTR((Uint8 *)out_length);
+   buffer.outsize[0] = 2;
+   buffer.outoffset[0] = 2;
+   buffer.outunit[0] = UNIT_16_BIT;
+   buffer.outptr[1] = CAST_TO_X_PTR(result);
+   buffer.outsize[1] = modlength;
+   buffer.outoffset[1] = modlength;
+   buffer.outunit[1] = UNIT_8_BIT;
+
+#else 
+   buffer.size = size;
+   buffer.dlen = (modlength)>>3;
+   buffer.rlen = (8 + 8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   if ((key_material_input == INPUT_DATA)
+      ||
+      (key_handle & (((Uint64)0x20000) << 32))) {
+
+      buffer.dlen += ((2*modlength)>>3);
+
+      buffer.incnt = 3;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR(p_modulus);
+      buffer.insize[1] = modlength;
+      buffer.inoffset[1] = modlength;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR(p_exponent);
+      buffer.insize[2] = modlength;
+      buffer.inoffset[2] = modlength;
+      buffer.inunit[2] = UNIT_8_BIT;
+
+   } else {
+
+      buffer.incnt = 1;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+
+   }
+
+   if (result_location == RESULT_PTR) {
+
+      buffer.rlen += (modlength>>3);
+
+      buffer.outcnt = 2;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR(result);
+      buffer.outsize[0] = modlength;
+      buffer.outoffset[0] = modlength;
+      buffer.outunit[0] = UNIT_8_BIT;
+      buffer.outptr[1] = CAST_TO_X_PTR((Uint8 *)out_length);
+      buffer.outsize[1] = 8;
+      buffer.outoffset[1] = 8;
+      buffer.outunit[1] = UNIT_64_BIT;
+
+   } else if (result_location == CONTEXT_PTR) {
+
+      buffer.outcnt = 1;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR((Uint8 *)out_length);
+      buffer.outsize[0] = 8;
+      buffer.outoffset[0] = 8;
+      buffer.outunit[0] = UNIT_64_BIT;
+   }
+#endif
+
+   buffer.group = CAVIUM_SSL_GRP;
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+    
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Pkcs1v15CrtDec
+ *
+ * Decrypts PKCS#1v1.5 container using the Chinese Remainder Theorem.
+ * The combination of block type 01 and CRT may produce unpredictable results.
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *   #ifdef MC2
+ *      block_type = type of PKCS#1v1.5 padding (BT2 only)
+ *      modlength = size of modulus in bytes
+ *      Q = prime factor of RSA modulus
+ *      Eq = exponent mod(Q-1)
+ *      P = prime factor of RSA modulus
+ *      Ep = exponent mod(P-1)
+ *      iqmp = (Q^-1) mod P
+ *      data = pointer to modlength-byte value to be exponentiated
+ *   #else
+ *      result_location = CONTEXT_PTR or RESULT_PTR 
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      key_material_input = KEY_HANDLE or INPUT_DATA
+ *      key_handle = 64-bit handle for key memory 
+ *      block_type = type of PKCS#1v1.5 padding (BT2 only)
+ *      modlength = size of modulus in bytes (modlength%8=0, 24<modlength<=256)
+ *      Q = (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ *      Eq = (key_material_input == INPUT_DATA) ? exponent mod(Q-1) : don't care
+ *      P = (key_material_input == INPUT_DATA) ? prime factor of RSA modulus : don't care
+ *      Ep = (key_material_input == INPUT_DATA) ? exponent mod(P-1) : don't care
+ *      iqmp = (key_material_input == INPUT_DATA) ? (Q^-1) mod P : don't care
+ *      data = pointer to modlength-byte value to be exponentiated
+ *   #endif
+ *
+ * Output
+ *   #ifdef MC2
+ *      out_length = pointer to output length in bytes (Network Byte order)
+ *      result = (pointer to modlength bytes of output,   *out_length bytes used)
+ *   #else
+ *      result = (result_location == RESULT_PTR) ? (pointer to modlength bytes of output, 
+ *                     *out_length bytes used) : don't care
+ *      out_length = pointer to output length in bytes
+ *   #endif
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Pkcs1v15CrtDec(n1_request_type request_type,
+               RsaBlockType block_type,
+               Uint16 modlength, 
+               Uint8 *Q, 
+               Uint8 *Eq, 
+               Uint8 *P, 
+               Uint8 *Ep, 
+               Uint8 *iqmp, 
+               Uint8 *data,
+               Uint16 *out_length,
+               Uint8 *result,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Pkcs1v15CrtDec(n1_request_type request_type,
+               ResultLocation result_location, 
+               Uint64 context_handle, 
+               KeyMaterialInput key_material_input,
+               Uint64 key_handle, 
+               RsaBlockType block_type,
+               Uint16 modlength, 
+               Uint8 *Q, 
+               Uint8 *Eq, 
+               Uint8 *P, 
+               Uint8 *Ep, 
+               Uint8 *iqmp, 
+               Uint8 *data,
+               Uint8 *result,
+               Uint64 *out_length,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint16 size = 0;
+   Uint8 *p_Q = NULL, *p_Eq = NULL, *p_P = NULL, *p_Ep = NULL, *p_iqmp = NULL;
+   Uint8 pkey[640];
+   Uint64 tmp_key;
+   Uint32 dummy=0;
+#endif
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+   buffer.group = CAVIUM_SSL_GRP;
+#if defined(CSP1_API_DEBUG)
+   if (result_location == CONTEXT_PTR) {
+
+      if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+         if ((context_handle & 0xf) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      } else {
+
+         if ((context_handle & 0x7) != 0)
+
+            return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+      }
+   }
+
+
+   if (block_type == BT1) 
+
+      return ERR_ILLEGAL_BLOCK_TYPE;
+
+   if ((modlength & 0x7) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   if (!(key_handle & (((Uint64)0x10000) << 32)))
+
+      return ERR_ILLEGAL_MOD_EX_TYPE;
+#endif
+
+#ifdef MC2
+   buffer.ctx_ptr=0;
+   buffer.dlen = (Uint16) ((2.5*modlength) + modlength);
+   buffer.size = modlength;
+   buffer.param = (block_type);
+   buffer.rlen = 2 + modlength;
+
+#else
+   if (key_material_input == KEY_HANDLE) {
+
+      if (key_handle & (((Uint64)0x20000) << 32)) {
+
+         tmp_key = key_handle & UINT64_C(0x0000ffffffffffff);
+         
+#ifdef CAVIUM_MULTICARD_API
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (5*modlength/2), pkey, &dummy,dev_id))
+#else
+         if(Csp1ReadContext(CAVIUM_BLOCKING, tmp_key, (5*modlength/2), pkey, &dummy))
+#endif
+         
+            return ERR_ILLEGAL_KEY_HANDLE;
+
+         p_Q = &(pkey[0]);
+         p_Eq = &(pkey[modlength/2]); 
+         p_P = &(pkey[2*(modlength/2)]);
+         p_Ep = &(pkey[3*(modlength/2)]); 
+         p_iqmp = &(pkey[4*(modlength/2)]);
+
+         buffer.param = (Uint16)0x4000;
+
+      }
+
+      else if (key_handle & 0x8000) {
+
+         buffer.param = (Uint16)key_handle & 0xffff; 
+
+      } else {
+
+         buffer.param = ((Uint16)key_handle & 0x1ff8) >> 3;
+
+      }
+   
+   } else if (key_material_input == INPUT_DATA) {
+
+      buffer.param = (Uint16)0x4000;
+      p_Q = Q;
+      p_Eq = Eq; 
+      p_P = P;
+      p_Ep = Ep; 
+      p_iqmp = iqmp;
+
+   }
+#endif
+#ifdef MC2
+   if ((modlength >= 34) && (modlength <= 128) && ((modlength & 0x1) == 0)) {
+#else
+   if ((modlength >= 48) && (modlength <= 128) && ((modlength & 0x1) == 0)) {
+#endif
+#ifdef MC2
+      buffer.opcode = (0x2<<8) | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 512) && ((modlength & 0x1) == 0)) {
+#else
+      size = (CRT_MOD_EX << 7) + ((modlength>>3) - 1);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x1<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS;
+   } else if ((modlength > 128) && (modlength <= 256) && ((modlength & 0x1) == 0)) {
+#endif
+
+#ifdef MC2
+      buffer.opcode = (0x2<<8) | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS_LARGE;
+#else
+      size = (CRT_MOD_EX << 7) + ((modlength>>3) - 17);
+      buffer.opcode = (result_location<<12) | (block_type<<10) | (0x1<<8) 
+         | (global_dma_mode<<7) | MAJOR_OP_ME_PKCS_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+   } else {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+   }
+
+#ifdef MC2
+
+   buffer.incnt = 6;
+   buffer.inptr[0] = CAST_TO_X_PTR(Q);
+   buffer.insize[0] = modlength/2;
+   buffer.inoffset[0] = modlength/2;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(Eq);
+   buffer.insize[1] = modlength/2;
+   buffer.inoffset[1] = modlength/2;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(P);
+   buffer.insize[2] = modlength/2;
+   buffer.inoffset[2] = modlength/2;
+   buffer.inunit[2] = UNIT_8_BIT;
+   buffer.inptr[3] = CAST_TO_X_PTR(Ep);
+   buffer.insize[3] = modlength/2;
+   buffer.inoffset[3] = modlength/2;
+   buffer.inunit[3] = UNIT_8_BIT;
+   buffer.inptr[4] =CAST_TO_X_PTR( iqmp);
+   buffer.insize[4] = modlength/2;
+   buffer.inoffset[4] = modlength/2;
+   buffer.inunit[4] = UNIT_8_BIT;
+   buffer.inptr[5] = CAST_TO_X_PTR(data);
+   buffer.insize[5] = modlength;
+   buffer.inoffset[5] = modlength;
+   buffer.inunit[5] = UNIT_8_BIT;
+
+   buffer.outcnt = 2;
+   buffer.outptr[0] = CAST_TO_X_PTR((Uint8 *)out_length);
+   buffer.outsize[0] = 2;
+   buffer.outoffset[0] = 2;
+   buffer.outunit[0] = UNIT_16_BIT;
+
+   buffer.outptr[1] = CAST_TO_X_PTR(result);
+   buffer.outsize[1] = modlength;
+   buffer.outoffset[1] = modlength;
+   buffer.outunit[1] = UNIT_8_BIT;
+
+#else
+   buffer.size = size;
+   buffer.dlen = (modlength)>>3;
+   buffer.rlen = (8 + 8)>>3;
+   buffer.ctx_ptr = context_handle;
+
+   if ((key_material_input == INPUT_DATA)
+      ||
+      (key_handle & (((Uint64)0x20000) << 32))) {
+
+      buffer.dlen += ((5*modlength/2)>>3);
+
+      buffer.incnt = 6;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR(p_Q);
+      buffer.insize[1] = modlength/2;
+      buffer.inoffset[1] = modlength/2;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR(p_Eq);
+      buffer.insize[2] = modlength/2;
+      buffer.inoffset[2] = modlength/2;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] =CAST_TO_X_PTR( p_P);
+      buffer.insize[3] = modlength/2;
+      buffer.inoffset[3] = modlength/2;
+      buffer.inunit[3] = UNIT_8_BIT;
+      buffer.inptr[4] = CAST_TO_X_PTR(p_Ep);
+      buffer.insize[4] = modlength/2;
+      buffer.inoffset[4] = modlength/2;
+      buffer.inunit[4] = UNIT_8_BIT;
+      buffer.inptr[5] = CAST_TO_X_PTR(p_iqmp);
+      buffer.insize[5] = modlength/2;
+      buffer.inoffset[5] = modlength/2;
+      buffer.inunit[5] = UNIT_8_BIT;
+
+   } else {
+
+      buffer.incnt = 1;      
+
+      buffer.inptr[0] = CAST_TO_X_PTR(data);
+      buffer.insize[0] = modlength;
+      buffer.inoffset[0] = modlength;
+      buffer.inunit[0] = UNIT_8_BIT;
+
+   }
+
+   if (result_location == RESULT_PTR) {
+
+      buffer.rlen += (modlength>>3);
+
+      buffer.outcnt = 2;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR(result);
+      buffer.outsize[0] = modlength;
+      buffer.outoffset[0] = modlength;
+      buffer.outunit[0] = UNIT_8_BIT;
+      buffer.outptr[1] = CAST_TO_X_PTR((Uint8 *)out_length);
+      buffer.outsize[1] = 8;
+      buffer.outoffset[1] = 8;
+      buffer.outunit[1] = UNIT_64_BIT;
+
+   } else if (result_location == CONTEXT_PTR) {
+
+      buffer.outcnt = 1;      
+
+      buffer.outptr[0] = CAST_TO_X_PTR((Uint8 *)out_length);
+      buffer.outsize[0] = 8;
+      buffer.outoffset[0] = 8;
+      buffer.outunit[0] = UNIT_64_BIT;
+   }
+#endif
+
+
+    buffer.req_queue = 0;
+    buffer.req_type = request_type;
+    buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+    buffer.dma_mode = global_dma_mode;
+    buffer.status = 0;
+    
+    cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+    *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+    return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1InitializeRc4
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      key_length = size of key in bytes (1<=length<=256)
+ *      key = pointer to length-byte key 
+ *
+ * Output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1InitializeRc4(n1_request_type request_type,
+              Uint64 context_handle, 
+              Uint16 key_length, 
+              Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   if ((key_length < 1) || (key_length > 256))
+      return ERR_ILLEGAL_KEY_LENGTH;
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+#ifdef MC2
+   buffer.opcode = (0x9<<8) | (global_dma_mode << 7) | MAJOR_OP_RANDOM_WRITE_CONTEXT;
+   buffer.size = 0;
+   buffer.dlen = key_length;
+   buffer.rlen = 0;
+#else
+   buffer.opcode = (0x0<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   buffer.size = key_length - 1;
+   buffer.dlen = (ROUNDUP8(key_length))>>3;
+   buffer.rlen = (8)>>3;
+#endif
+   buffer.param = 0;
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 0;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(key);
+   buffer.insize[0] = key_length;
+   buffer.inoffset[0] = ROUNDUP8(key_length);
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRc4
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      length = size of input in bytes (0<=length<=2^16-1)
+ *      input = pointer to length-byte input
+ *
+ * Output
+ *      output = pointer to length-byte output 
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1EncryptRc4(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+
+#ifdef MC2
+   buffer.opcode = (context_update<<13) | (global_dma_mode<<7) 
+      | MAJOR_OP_ENCRYPT_DECRYPT;
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = length;
+   buffer.rlen = length;
+#else
+   buffer.opcode = (context_update<<13) | (0x2<<8) | (global_dma_mode<<7) 
+      | MAJOR_OP_ENCRYPT_DECRYPT;
+   buffer.size = length;
+   buffer.param = 0;
+   buffer.dlen = (ROUNDUP8(length))>>3;
+   buffer.rlen = (ROUNDUP8(length) + 8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(input);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = ROUNDUP8(length);
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = (global_dma_mode == global_dma_mode) ? ROUNDUP8(length) : length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Initialize3DES
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      iv = pointer to 8-byte initialization vector
+ *      key = pointer to 24-byte key 
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1Initialize3DES(n1_request_type request_type,
+               Uint64 context_handle, 
+               Uint8 *iv, 
+               Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+#ifdef MC2
+   return ERR_OPERATION_NOT_SUPPORTED;
+#else
+   Uint8 temp[32];
+   Uint32 ret_val;
+   Uint32 dummy=0;
+
+   if(request_type == CAVIUM_NON_BLOCKING)
+      return ERR_OPERATION_NOT_SUPPORTED;
+   memcpy(temp, iv, 8);
+   memcpy(temp + 8, key, 24);
+
+#ifdef CAVIUM_MULTICARD_API
+   ret_val = Csp1WriteContext(CAVIUM_BLOCKING, context_handle, 32, temp,&dummy,dev_id);
+#else
+   ret_val = Csp1WriteContext(CAVIUM_BLOCKING, context_handle, 32, temp,&dummy);
+#endif
+
+   return ret_val;
+#endif /*MC2*/
+}
+             
+             
+             
+/*+****************************************************************************
+ *
+ * Csp1Encrypt3Des
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      input = pointer to length-byte input
+ *   #ifdef MC2
+ *      iv = pointer to 8-byte IV
+ *      key = pointer to 24-byte key
+ *      length = size of input in bytes (0<=length<2^16-32, length%8=0)
+ *   #else
+ *      length = size of input in bytes (0<=length<=2^16-8, length%8=0)
+ *   #endif
+ *
+ * Output
+ *      output = pointer to ROUNDUP8(length)-byte output, 
+ *      request_id = Unique ID for this request.
+ *      
+ *
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Encrypt3Des(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Encrypt3Des(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifndef MC2
+   Uint8 temp[8];
+   Uint32 pad_len=0;
+#endif
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+
+#ifndef MC2 
+   if ((length & 0x7) != 0){
+      memset(temp,0x0,8);
+      pad_len=8-(length & 0x7);
+/*         return ERR_ILLEGAL_INPUT_LENGTH; */
+   }
+#else /* MC2 */
+   if ((length >= 0xffe0) != 0) 
+         return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+
+#ifdef MC2
+   buffer.opcode = (context_update<<13) | (0x4<<8) | (global_dma_mode<<7) 
+      | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = length + 32;
+   buffer.rlen = ROUNDUP8(length);
+#else
+   buffer.opcode = (context_update<<13) | (0x4<<8) | (global_dma_mode<<7) 
+      | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   buffer.size = (length+pad_len)>>3;
+   buffer.param = 0;
+   buffer.dlen = (length+pad_len)>>3;
+   buffer.rlen = (length + pad_len+8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+   buffer.group = CAVIUM_SSL_GRP;
+
+#ifdef MC2
+   buffer.incnt = 3;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 8;
+   buffer.inoffset[0] = 8;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = 24;
+   buffer.inoffset[1] = 24;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(input);
+   buffer.insize[2] = length;
+   buffer.inoffset[2] = length;
+   buffer.inunit[2] = UNIT_8_BIT;
+#else
+   buffer.incnt = 2;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(input);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = length;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(temp);
+   buffer.insize[1] = pad_len;
+   buffer.inoffset[1] = pad_len;
+   buffer.inunit[1] = UNIT_8_BIT;
+#endif
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+#ifdef MC2
+   buffer.outsize[0] = ROUNDUP8(length);
+   buffer.outoffset[0] = ROUNDUP8(length);
+#else
+   buffer.outsize[0]   = ROUNDUP8(length);
+   buffer.outoffset[0] = ROUNDUP8(length);
+#endif
+   buffer.outunit[0] = UNIT_8_BIT;
+   
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+   return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Decrypt3Des
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      length = size of input in bytes (length%8=0, 0<=length<=2^16-1)
+ *      input = pointer to length-byte input
+ *   #ifdef MC2
+ *      iv = pointer to 8-byte IV
+ *      key = pointer to 24-byte key
+ *   #endif
+ *
+ * Output
+ *      output = pointer to length-byte output, 
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1Decrypt3Des(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1Decrypt3Des(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   if ((length & 0x7) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+#ifdef MC2
+   buffer.opcode =  (0x5<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   buffer.size = 0;
+   buffer.param = 0;
+   buffer.dlen = length + 32;
+   buffer.rlen = length;
+#else
+   buffer.opcode = (context_update<<13) | (0x5<<8) | (global_dma_mode<<7) 
+      | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   buffer.size = length>>3;
+   buffer.param = 0;
+   buffer.dlen = length>>3;
+   buffer.rlen = (length + 8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+
+#ifdef MC2
+   buffer.incnt = 3;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 8;
+   buffer.inoffset[0] = 8;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = 24;
+   buffer.inoffset[1] = 24;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(input);
+   buffer.insize[2] = length;
+   buffer.inoffset[2] = length;
+   buffer.inunit[2] = UNIT_8_BIT;
+#else
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(input);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = length;
+   buffer.inunit[0] = UNIT_8_BIT;
+#endif
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+    return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1InitializeAES
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      aes_type = AES_128, AES_192, or AES_256
+ *      iv = pointer to 16-byte initialization vector
+ *      key = pointer to key, whose length depends on aes_type 
+ *
+ * Output
+ *      request_id = Unique ID for this request. (ignored)
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1InitializeAES(n1_request_type request_type,
+              Uint64 context_handle, 
+              AesType aes_type, 
+              Uint8 *iv, 
+              Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+#ifdef MC2
+   return ERR_OPERATION_NOT_SUPPORTED;
+#else
+   Uint8 temp[48];
+   Uint32 ret_val;
+   Uint32 dummy=0;
+
+   if(request_type == CAVIUM_NON_BLOCKING)
+      return ERR_OPERATION_NOT_SUPPORTED;
+
+   memcpy(temp, iv, 16);
+
+   memcpy(temp + 16, key, 16 + 8 * aes_type);
+
+#ifdef CAVIUM_MULTICARD_API
+   ret_val = Csp1WriteContext(CAVIUM_BLOCKING,context_handle, (Uint16)(32 + 8 * aes_type), temp,&dummy,dev_id);
+#else
+   ret_val = Csp1WriteContext(CAVIUM_BLOCKING,context_handle, (Uint16)(32 + 8 * aes_type), temp,&dummy);
+#endif
+
+   return ret_val;
+#endif /*MC2*/
+}
+             
+             
+/*+****************************************************************************
+ *
+ * Csp1EncryptAes
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type = AES_128, AES_192, or AES_256
+ *      length = size of input in bytes (0<=length<=2^16-1)
+ *      input = pointer to length-byte input
+ *   #ifdef MC2
+ *      iv = pointer to 16- byte IV
+ *      key = pointer to key depending upon aes type
+ *   #endif
+ *
+ * Output
+ *      output = pointer to ROUNDUP16(length)-byte output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+#ifdef MC2
+Uint32 
+Csp1EncryptAes(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1EncryptAes(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifdef MC2
+   Uint32 key_length;
+#endif
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+
+#ifndef MC2
+   if ((length & 0xf) != 0) 
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+#ifdef MC2
+   buffer.opcode = (0x6<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   if (aes_type == AES_128) {
+      buffer.size = 0x0005;
+      key_length = 16;
+   } else if (aes_type == AES_192) {
+      buffer.size = 0x0006;
+      key_length = 24;
+   } else if (aes_type == AES_256) {
+      buffer.size = 0x0007;
+      key_length = 32;
+   } else {
+      buffer.size = 0x0000;
+      key_length = 0;
+   }
+   buffer.param = 0;
+   buffer.dlen = length + 16 + key_length;
+   buffer.rlen = ROUNDUP16(length);
+#else
+   buffer.opcode = (context_update<<13) | ((aes_type + 1 )<<11) | (0x6<<8) 
+      | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   buffer.size = length>>4;
+   buffer.param = 0;
+   buffer.dlen = length>>3;
+   buffer.rlen = (length + 8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+   buffer.group = CAVIUM_SSL_GRP;
+
+#ifdef MC2
+   buffer.incnt = 3;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 16;
+   buffer.inoffset[0] = 16;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(input);
+   buffer.insize[2] = length;
+   buffer.inoffset[2] = length;
+   buffer.inunit[2] = UNIT_8_BIT;
+#else
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(input);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = length;
+   buffer.inunit[0] = UNIT_8_BIT;
+#endif
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+#ifdef MC2
+/*+****************************************************************************
+ *
+ * Csp1EncryptAesGcmGmac
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type     = AES_128, AES_192, or AES_256
+ *      length       = size of input in bytes (0<=length<=2^16-1)
+ *      input        = pointer to length-byte input
+ *      aad          = pointer to key depending upon the AAD Length
+ *   #ifdef MC2
+ *      iv           = pointer to 16- byte IV
+ *      key          = pointer to key depending upon aes type
+ *   #endif
+ *
+ * Output
+ *      output       = pointer to length+tag_length(16B) output
+ *      request_id   = Unique ID for this request.
+ *
+ * Return Value
+ *      0            = success 
+ *      >0           = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1EncryptAesGcmGmac(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *aad,
+            Uint8 eseqnumber,
+            Uint8 *output,
+            Uint8 gcm_gmac_bit,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code=0;
+   Uint32 ret_val=0;
+   Uint16 param2 = 0;
+   Uint16 aad_len=0; 
+   Uint32 key_length=0;
+   Uint32 iv_length=0;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.opcode = (0x8<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   if (gcm_gmac_bit) 
+      param2 |= 1; //gmac bit
+   else 
+      param2 |= 0;
+   iv_length = 12;
+   buffer.param |= (param2<<15);    //GCM/GMAC bit
+   param2 = 0;
+   if (aes_type == AES_128) {
+      param2 = (1<<1);
+      key_length = 16;
+   } else if (aes_type == AES_192) {
+      param2 = (2<<1);
+      key_length = 24;
+   } else if (aes_type == AES_256) {
+      param2 = (3<<1);
+      key_length = 32;
+   } else {
+      buffer.size = 0x0000;
+      key_length = 0;
+   }
+   buffer.param |= param2;
+   param2 = 0;
+   if(eseqnumber) {
+     param2 = 1;
+     aad_len = 12;
+   }
+   else { 
+     param2 = 0;
+     aad_len = 8; 
+   }
+   buffer.param |= param2;
+   buffer.size = length;
+   if(!gcm_gmac_bit) {
+   buffer.dlen = buffer.size + key_length + 16/*nonce*/ + ROUNDUP8(aad_len);
+   buffer.rlen = length + 16;	/*length+tag_length(always tag length is 16B)*/
+   }
+   else {
+   buffer.dlen = buffer.size + key_length +16 /*nonce*/;
+   buffer.rlen = 16; /*tag_length*/
+   }
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 4;       
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 16;
+   buffer.inoffset[0] = 16;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(aad);
+   if(!gcm_gmac_bit) {
+   buffer.insize[2] = ROUNDUP8(aad_len);
+   buffer.inoffset[2] = ROUNDUP8(aad_len);
+   } else {
+   buffer.insize[2] = length;
+   buffer.inoffset[2] = length;
+   }   
+   buffer.inunit[2] = UNIT_8_BIT;
+   buffer.inptr[3] = CAST_TO_X_PTR(input);
+   if(!gcm_gmac_bit) {
+   buffer.insize[3] = length;
+   buffer.inoffset[3] = length;
+   } else {
+   buffer.insize[3] = 0;
+   buffer.inoffset[3] = 0;
+   }
+   buffer.inunit[3] = UNIT_8_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   if(!gcm_gmac_bit) {
+   buffer.outsize[0] = length + 16;
+   buffer.outoffset[0] = length + 16;
+   } else {
+   buffer.outsize[0] = 16;
+   buffer.outoffset[0] = 16;
+   }
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+#endif
+
+
+             
+#ifdef MC2
+             
+             
+/*+****************************************************************************
+ *
+ * Csp1SrtpAesCtr
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type = AES_128  (is it only for AES_128) 
+ *      length = size of input in bytes (0<=length<=2^16-1)
+ *      input = pointer to length-byte input
+ *   #ifdef MC2
+ *      iv = pointer to 16- byte IV
+ *      key = pointer to key depending upon aes type
+ *   #endif
+ *
+ * Output
+ *      output = pointer to ROUNDUP16(length)-byte output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1SrtpAesCtr(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint32 key_length;
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   if (aes_type == AES_128) {
+      key_length = 16;
+   } 
+   else if (aes_type == AES_192) {
+      key_length = 24;
+   } 
+   else if (aes_type == AES_256) {
+      key_length = 32;
+   } 
+   else {
+      key_length = 0;
+   }
+     buffer.size = length;
+        buffer.opcode = 0x0018 | (global_dma_mode<<7);
+    	buffer.param = ((key_length - 16)/8);
+   	buffer.dlen = length +  key_length  + 16; //length + key_length + iv_length;
+   	buffer.rlen = length; 
+   buffer.ctx_ptr = context_handle;
+
+#ifdef MC2
+   	buffer.incnt = 3;      
+   	buffer.outcnt = 1;      
+
+   	buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   	buffer.insize[0] = 16;
+   	buffer.inoffset[0] = 16;
+   	buffer.inunit[0] = UNIT_8_BIT;
+
+   	buffer.inptr[1] = CAST_TO_X_PTR(key);
+   	buffer.insize[1] = key_length;
+   	buffer.inoffset[1] = key_length;
+   	buffer.inunit[1] = UNIT_8_BIT;
+
+   	buffer.inptr[2] = CAST_TO_X_PTR(input);
+   	buffer.insize[2] = length;
+   	buffer.inoffset[2] = length;
+   	buffer.inunit[2] = UNIT_8_BIT;
+
+#endif
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+#endif
+
+#ifdef MC2
+/*+****************************************************************************
+ * Csp1ProcessSrtp
+ * input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      encrypt      = 0 - encrypt, 1 -decrypt
+ *      keytype      = AES_128, AES_192, or AES_256
+ *      authtype     = NULL or SHA1 
+ *      proto        = 0 - SRTP, 1 - SRTCP
+ *      length       = size of input in bytes (0<=length<=2^16-1)
+ *      hdr_ln       = size of the hdr in bytes (0 <= hdr_ln <= 72)
+ *      index_ln     = size of the Tag len[7:4] and Index len [3:0] in bytes (0 <= index_ln <= 4)
+ *      iv           = pointer to 16- byte IV
+ *      key          = pointer to key depending upon aes type
+ *      auth_key     = pointer to auth_key depending upon auth type
+ *      index        = pointer to index depending upon index_ln
+ *      auth_tag     = pointer to auth_tag depending upon auth type & encrypt
+ *      input        = pointer to ROUNDUP8(length) + ROUNDUP8(hdr_ln) bytes input
+ *
+ * Output
+ *      output       = pointer to length + ((proto) ? Index_ln : 0) + auth_tag[(auth_type&!encrypt)? Tag len : 0] output
+ *      request_id   = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ *   >0 = failure or pending
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ProcessSrtp(n1_request_type request_type,
+                Uint8 encrypt,
+                Uint8 keytype,
+                Uint8 authtype,
+                Uint8 proto, 
+                Uint16 length,
+                Uint8 hdr_ln,
+                Uint8 index_ln,
+                Uint8 *iv,
+                Uint8 *key,
+                Uint8 *auth_key,
+                Uint8 *index,
+                Uint8 *auth_tag,
+                Uint8 *input,
+                Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+                Uint32 *request_id,Uint32 dev_id
+#else
+                Uint32 *request_id
+#endif
+                )
+{
+
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+   Uint8 minor_op;
+   Uint8 key_length;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   minor_op = encrypt;
+   minor_op |= ((keytype&0x3) << 1);
+   minor_op |= ((authtype&0x7) << 3);
+   minor_op |= ((proto&0x1) << 6);
+   key_length = ((keytype + 2) << 3);
+
+   buffer.opcode = 0x0018 | (global_dma_mode<<7);
+   buffer.opcode |= ((minor_op&0xff) << 8);
+   buffer.size = length;
+   buffer.param =  hdr_ln;
+   buffer.param |=  (index_ln << 8);
+   buffer.dlen = 16/*iv*/ + key_length + ((authtype) ? 24 : 0)/*authkey*/ + ROUNDUP8(hdr_ln) + ROUNDUP8(length) 
+                 + ROUNDUP8(index_ln & 0xF);
+
+   if ((encrypt) && (authtype == 1))
+      buffer.dlen += ((index_ln >> 4) & 0xF); /* auth tag length */
+
+#if 0
+   buffer.rlen = ROUNDUP8(hdr_ln) + length + ((proto) ? (index_ln & 0xF): 0);
+#else
+   buffer.rlen =  length + ((proto) ? (index_ln & 0xF): 0);
+#endif
+
+   if ((!encrypt) && (authtype == 1))
+      buffer.rlen += ((index_ln >> 4) & 0xF); /* auth tag length */
+
+   buffer.incnt = 6;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 16;
+   buffer.inoffset[0] = 16;
+   buffer.inunit[0] = UNIT_8_BIT;
+
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+
+   buffer.inptr[2] = CAST_TO_X_PTR(auth_key);
+   buffer.insize[2] = (authtype) ? 24 :0;
+   buffer.inoffset[2] = (authtype) ? 24 :0;
+   buffer.inunit[2] = UNIT_8_BIT;
+
+   buffer.inptr[3] = CAST_TO_X_PTR(index);
+   buffer.insize[3] = ROUNDUP8(index_ln & 0xF);
+   buffer.inoffset[3] = ROUNDUP8(index_ln & 0xF);
+   buffer.inunit[3] = UNIT_8_BIT;
+
+   buffer.inptr[4] = CAST_TO_X_PTR(input);
+   buffer.insize[4] = ROUNDUP8(length) + ROUNDUP8(hdr_ln);
+   buffer.inoffset[4] = ROUNDUP8(length) + ROUNDUP8(hdr_ln);
+   buffer.inunit[4] = UNIT_8_BIT;
+
+   buffer.inptr[5] = CAST_TO_X_PTR(auth_tag);
+   buffer.insize[5] = (authtype & encrypt) ? ((index_ln >> 4) & 0xF) :0;
+   buffer.inoffset[5] = (authtype & encrypt) ? ((index_ln >> 4) & 0xF) :0;
+   buffer.inunit[5] = UNIT_8_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = buffer.rlen;
+   buffer.outoffset[0] = buffer.rlen;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+#endif
+
+#ifdef MC2
+/*+****************************************************************************
+ *
+ * Csp1AesXcbcPrf128 
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	key = pointer to key
+ * 	key_length = size of the key ( 1 <= key_length <= 912)
+ *	data = pointer to input data
+ * 	data_length = size of input data
+ *
+ * Output
+ *      output = pointer to (AESXCBC_BLOCK_SIZE)-byte output
+ *      request_id = Unique ID for this request.
+ *
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1AesXcbcPrf128(n1_request_type request_type,
+	Uint8 *key,
+	Uint16 key_length, 
+	Uint8 *data, 
+	Uint16 data_length,
+	Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+	Uint32 *request_id,Uint32 dev_id
+#else
+	Uint32 *request_id
+#endif
+)
+
+{
+	Csp1OperationBuffer buffer;
+	Uint32 cond_code;
+	Uint32 ret_val;
+	memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+	buffer.opcode = 0x0807 | (global_dma_mode<<7);
+	buffer.param = 0;
+	buffer.size = key_length;
+	buffer.dlen = ROUNDUP16(key_length) + data_length;
+	buffer.rlen = AESXCBC_BLOCK_SIZE;
+
+   	buffer.incnt = 2;      
+   	buffer.outcnt = 1;      
+
+    buffer.group = CAVIUM_SSL_GRP;
+
+   	buffer.inptr[0] = CAST_TO_X_PTR(key);
+   	buffer.insize[0] = ROUNDUP16(key_length);
+   	buffer.inoffset[0] = ROUNDUP16(key_length);
+   	buffer.inunit[0] = UNIT_8_BIT;
+
+   	buffer.inptr[1] = CAST_TO_X_PTR(data);
+   	buffer.insize[1] = data_length;
+   	buffer.inoffset[1] = data_length;
+   	buffer.inunit[1] = UNIT_8_BIT;
+
+
+	buffer.outptr[0] = CAST_TO_X_PTR(output);
+	buffer.outsize[0] = AESXCBC_BLOCK_SIZE;
+	buffer.outoffset[0] = AESXCBC_BLOCK_SIZE;
+	buffer.outunit[0] = UNIT_8_BIT;
+
+	buffer.req_queue = 0;
+	buffer.req_type = request_type;
+	buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+	buffer.dma_mode = global_dma_mode;
+	buffer.status = 0;
+	cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+	 ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+	 ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+	*request_id = buffer.request_id;
+	if(cond_code)
+	 ret_val = cond_code; /*return error val*/
+	else
+	 ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+	return ret_val;
+}
+#endif
+
+#ifdef MC2
+/*+****************************************************************************
+ *
+ * Csp1AesCfbRfc3826
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	key = pointer to key
+ *      aes_type = AES_128, AES_192, AES_256
+ * 	iv = pointer to iv
+ *	data = pointer to input data
+ * 	data_length = size of input data
+ * 	encrypt =  0:1 (decrypt:encrypt) 
+ *
+ * Output
+ *      output = pointer to (AESXCBC_BLOCK_SIZE)-byte output
+ *      request_id = Unique ID for this request.
+ *
+ *
+ * Return Value
+ *      0  = success 
+ *      >0 = failure or pending
+ *      see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32 
+Csp1AesCfbRfc3826(n1_request_type request_type,
+	Uint8 *key,
+        AesType aes_type, 
+	Uint8 *iv,
+	Uint8 *data, 
+	Uint16 data_length,
+	Uint8 *output,
+	Uint8 encrypt, /* 0:1 (decrypt:encrypt) */
+#ifdef CAVIUM_MULTICARD_API
+	Uint32 *request_id,Uint32 dev_id
+#else
+	Uint32 *request_id
+#endif
+)
+
+{
+	Csp1OperationBuffer buffer;
+	Uint32 cond_code;
+	Uint32 ret_val;
+   	Uint32 key_length;
+	memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+	if(encrypt)
+         buffer.opcode = (0x6<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+	else
+         buffer.opcode = (0x7<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   	if (aes_type == AES_128) {
+         buffer.size = 0x0005;
+         key_length = 16;
+   	} else if (aes_type == AES_192) {
+         buffer.size = 0x0006;
+         key_length = 24;
+   	} else if (aes_type == AES_256) {
+         buffer.size = 0x0007;
+         key_length = 32;
+   	} else {
+         buffer.size = 0x0000;
+         key_length = 0;
+   	}
+	buffer.param = (1 << 15); /*15th bit for AES_CFB*/ 
+	buffer.dlen = key_length + 16 /* iv */ + data_length;
+	buffer.rlen = data_length;
+
+   	buffer.incnt = 3;      
+   	buffer.outcnt = 1;      
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   	buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   	buffer.insize[0] = 16;
+   	buffer.inoffset[0] = 16;
+   	buffer.inunit[0] = UNIT_8_BIT;
+
+   	buffer.inptr[1] = CAST_TO_X_PTR(key);
+   	buffer.insize[1] = key_length;
+   	buffer.inoffset[1] = key_length;
+   	buffer.inunit[1] = UNIT_8_BIT;
+
+   	buffer.inptr[2] = CAST_TO_X_PTR(data);
+   	buffer.insize[2] = data_length;
+   	buffer.inoffset[2] = data_length;
+   	buffer.inunit[2] = UNIT_8_BIT;
+
+
+	buffer.outptr[0] = CAST_TO_X_PTR(output);
+	buffer.outsize[0] = data_length;
+	buffer.outoffset[0] = data_length;
+	buffer.outunit[0] = UNIT_8_BIT;
+
+	buffer.req_queue = 0;
+	buffer.req_type = request_type;
+	buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+	buffer.dma_mode = global_dma_mode;
+	buffer.status = 0;
+	cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+	 ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+	 ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+	*request_id = buffer.request_id;
+	if(cond_code)
+	 ret_val = cond_code; /*return error val*/
+	else
+	 ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+	return ret_val;
+}
+#endif
+/*+****************************************************************************
+ *
+ * Csp1DecryptAes
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type = AES_128, AES_192, or AES_256
+ *      length = size of input in bytes (length%16=0, 0<=length<=2^16-1)
+ *      input = pointer to length-byte input
+ *   #ifdef MC2
+ *      iv = pointer to 16- byte IV
+ *      key = pointer to key depending upon aes type
+ *   #endif
+ *
+ * Output
+ *      output = pointer to length-byte output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+#ifdef MC2
+Uint32 
+Csp1DecryptAes(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+            Uint8 *iv,
+            Uint8 *key,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#else
+Uint32 
+Csp1DecryptAes(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 *output,
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+#endif
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code;
+   Uint32 ret_val;
+#ifdef MC2
+   Uint32 key_length;
+#endif
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   if ((length & 0xf) != 0)
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+#ifdef MC2
+   buffer.opcode = (0x7<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   if (aes_type == AES_128) {
+      buffer.size = 0x0005;
+      key_length = 16;
+   } else if (aes_type == AES_192) {
+      buffer.size = 0x0006;
+      key_length = 24;
+   } else if (aes_type == AES_256) {
+      buffer.size = 0x0007;
+      key_length = 32;
+   } else {
+      buffer.size = 0x0000;
+      key_length = 0;
+   }
+   buffer.param = 0;
+   buffer.dlen = length + 16 + key_length;
+   buffer.rlen = length;
+#else
+   buffer.opcode = (context_update<<13) | ((aes_type + 1 )<<11) | (0x7<<8) 
+      | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+
+   buffer.size = length>>4;
+   buffer.param = 0;
+   buffer.dlen = length>>3;
+   buffer.rlen = (length + 8)>>3;
+#endif
+   buffer.ctx_ptr = context_handle;
+
+#ifdef MC2
+   buffer.incnt = 3;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 16;
+   buffer.inoffset[0] = 16;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(input);
+   buffer.insize[2] = length;
+   buffer.inoffset[2] = length;
+   buffer.inunit[2] = UNIT_8_BIT;
+#else
+   buffer.incnt = 1;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(input);
+   buffer.insize[0] = length;
+   buffer.inoffset[0] = length;
+   buffer.inunit[0] = UNIT_8_BIT;
+#endif
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+
+#ifdef MC2
+/*+****************************************************************************
+ *
+ * Csp1DecryptAesGcm
+ *
+ * Input
+ *      request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *      context_handle = 64-bit pointer to context (context_handle%8=0)
+ *      context_update = UPDATE or NO_UPDATE
+ *      aes_type     = AES_128, AES_192, or AES_256
+ *      length       = size of input in bytes (length%16=0, 0<=length<=2^16-1)
+ *      input        = pointer to length-byte input in case of GCM
+ *      eseqnum      = extented sequence number bit
+ *      tag_length   = can be 4, 8. 12 and 16B
+ *      aad          = pointer to AAD data incase of GCM, 
+ *                     pointer to length-byte AAD in GMAC
+ *      output       = pointer to length-byte output in GCM, 
+ *                     pointer to 0B output in case of GMAC. 
+ *      gcm_gmac_bit = set if GMAC, otherwise GCM
+ *      iv = pointer to 16- byte IV
+ *      key = pointer to key depending upon aes type
+ *
+ * Output
+ *      output = pointer to length-byte output
+ *      request_id = Unique ID for this request.
+ *
+ * Return Value
+ *   0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32 
+Csp1DecryptAesGcm(n1_request_type request_type,
+            Uint64 context_handle, 
+            ContextUpdate context_update, 
+            AesType aes_type, 
+            Uint16 length, 
+            Uint8 *input, 
+            Uint8 eseqnumber,           
+            Uint16 tag_length,
+            Uint8 *aad,
+            Uint8 *output,
+            Uint8 gcm_gmac_bit,
+            Uint8 *iv,
+            Uint8 *key,
+                 
+#ifdef CAVIUM_MULTICARD_API
+            Uint32 *request_id,Uint32 dev_id
+#else
+            Uint32 *request_id
+#endif
+           )
+
+{
+   Csp1OperationBuffer buffer;
+   Uint32 cond_code=0;
+   Uint32 ret_val=0;
+   Uint16 param2=0;
+   Uint16 aad_len=0; 
+   Uint32 key_length=0;
+   Uint32 iv_length=0;
+
+   memset(&buffer,0,sizeof(Csp1OperationBuffer));
+   if ((context_handle & UINT64_C(0x8000000000000000)) != 0) {
+
+      if ((context_handle & 0xf) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   } else {
+
+      if ((context_handle & 0x7) != 0)
+
+         return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+   }
+
+   buffer.group = CAVIUM_SSL_GRP;
+
+   buffer.opcode = (0x9<<8) | (global_dma_mode<<7) | MAJOR_OP_ENCRYPT_DECRYPT;
+   iv_length = 12;	
+   if (gcm_gmac_bit) 
+      param2 |= 1; //gmac bit
+   else 
+      param2 |= 0;
+   buffer.param |= (param2<<15);    //GCM/GMAC bit
+   param2 = 0;
+   if(tag_length == 16)  
+      param2 =  (0x3<<3);
+   else if(tag_length == 12) 
+      param2 =  (0x2<<3);
+   else if(tag_length == 8) 
+      param2 =  (0x1<<3);
+   else /*tag_length == 4*/
+      param2 = (0x0<<3);
+   
+   buffer.param = buffer.param | param2;
+   param2 = 0;
+   if (aes_type == AES_128) {
+      param2 = (1<<1);
+      key_length = 16;
+   } else if (aes_type == AES_192) {
+      param2 = (2<<1);
+      key_length = 24;
+   } else if (aes_type == AES_256) {
+      param2 = (3<<1);
+      key_length = 32;
+   } else {
+      param2 = 0;
+      key_length = 0;
+   }
+   buffer.param |= param2;
+   param2 = 0;
+   if(eseqnumber) {
+     param2 = 1;
+     aad_len = 12;
+   }
+   else { 
+     param2 = 0;
+     aad_len = 8; 
+   }
+   buffer.param |= param2;
+   buffer.size = length;
+   if(!gcm_gmac_bit) {
+   buffer.dlen = buffer.size + key_length + 16/*nonce*/ + 
+                 ROUNDUP8(aad_len) + tag_length;
+   buffer.rlen = length;	
+   } else {
+   buffer.dlen = buffer.size + key_length + 16/*nonce*/ + tag_length;
+   buffer.rlen = 0;	
+   }
+   
+   buffer.ctx_ptr = context_handle;
+
+   buffer.incnt = 4;      
+   buffer.outcnt = 1;      
+
+   buffer.inptr[0] = CAST_TO_X_PTR(iv);
+   buffer.insize[0] = 16;
+   buffer.inoffset[0] = 16;
+   buffer.inunit[0] = UNIT_8_BIT;
+   buffer.inptr[1] = CAST_TO_X_PTR(key);
+   buffer.insize[1] = key_length;
+   buffer.inoffset[1] = key_length;
+   buffer.inunit[1] = UNIT_8_BIT;
+   buffer.inptr[2] = CAST_TO_X_PTR(aad);
+   if(!gcm_gmac_bit) {
+   buffer.insize[2] = ROUNDUP8(aad_len);
+   buffer.inoffset[2] = ROUNDUP8(aad_len);
+   } else {
+   buffer.insize[2] = length + 16;
+   buffer.inoffset[2] = length + 16;
+   }
+   buffer.inunit[2] = UNIT_8_BIT;
+   buffer.inptr[3] = CAST_TO_X_PTR(input);
+   if(!gcm_gmac_bit) {
+   buffer.insize[3] = length+16;
+   buffer.inoffset[3] = length+16;
+   } else {
+   buffer.insize[3] = 0;
+   buffer.inoffset[3] = 0;
+   }
+   buffer.inunit[3] = UNIT_8_BIT;
+
+   buffer.outptr[0] = CAST_TO_X_PTR(output);
+   if(!gcm_gmac_bit) {
+   buffer.outsize[0] = length;
+   buffer.outoffset[0] = length;
+   } else {
+   buffer.outsize[0] = 0;
+   buffer.outoffset[0] = 0;
+   }
+   buffer.outunit[0] = UNIT_8_BIT;
+
+   buffer.req_queue = 0;
+   buffer.req_type = request_type;
+   buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+   buffer.dma_mode = global_dma_mode;
+   buffer.status = 0;
+
+   cond_code = 
+#ifdef CAVIUM_MULTICARD_API
+     ioctl(gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#else
+     ioctl(CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+#endif
+
+
+   *request_id = buffer.request_id;
+   if(cond_code)
+     ret_val = cond_code; /*return error val*/
+   else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+   return ret_val;
+}
+#endif
+
+/*****************************************************************************
+ *
+ * Csp1GetAllResults
+ *
+ * Returns the status of all requests sent by the current process
+ *
+ * Input
+ *  req_stat_buf = array of Csp1RequestStatusBuffer structures
+ *  buf_size = size of req_stat_buf in multiple of Csp1RequestStatusBuffer size.
+ *                           (buf_size % sizeof(Csp1RequestStatusBuffer) = 0)
+ *
+ * Output
+ *      res_count = number of elements returned in req_stat_buf.
+ *
+ * Return Value
+ *      completion code = 0 (for success), ERR_BAD_IOCTL
+ *
+ ****************************************************************************/
+Uint32
+Csp1GetAllResults(Csp1RequestStatusBuffer *req_stat_buf,
+                                  Uint32 buf_size,
+                                  Uint32 *res_count
+#ifdef CAVIUM_MULTICARD_API
+                                  ,Uint32 device_id
+#endif
+                                  )
+{
+     Uint32 ret_code = 0;
+     Csp1StatusOperationBuffer buffer;
+
+   memset(&buffer,0,sizeof(Csp1StatusOperationBuffer));
+     if ((buf_size == 0) ||
+                (buf_size%sizeof(Csp1RequestStatusBuffer)))
+                return ERR_ILLEGAL_INPUT_LENGTH;
+
+     /*get the number of requests*/
+     memset (&buffer, 0, sizeof buffer);
+     buffer.cnt = buf_size/sizeof(Csp1RequestStatusBuffer);
+     buffer.req_stat_buf = (Uint64)(ptrlong)req_stat_buf;
+
+#if defined(linux) || defined(_WIN32)
+#ifdef CAVIUM_MULTICARD_API
+   ret_code = ioctl((gpkpdev_hdlr[device_id]), IOCTL_N1_GET_ALL_REQUEST_STATUS, (ptrlong)&buffer);
+#else
+     ret_code = ioctl(CSP1_driver_handle, IOCTL_N1_GET_ALL_REQUEST_STATUS, (ptrlong)&buffer);
+#endif
+#else
+     ret_code = ERR_OPERATION_NOT_SUPPORTED;
+#endif
+
+     if(ret_code == 0)
+        *res_count = buffer.res_count;
+     return ret_code;
+}
+
+/*****************************************************************************
+ *
+ *Csp1GetDevCnt
+ *
+ * Returns the number of Nitrox devices detected.
+ *
+ * Output
+ *      pdev_count = number of devices returned in pdev_count.
+ *
+ * Return Value
+ *      completion code = 0 (for success), ERR_BAD_IOCTL
+ *
+ ****************************************************************************/
+Uint32
+Csp1GetDevCnt(Uint32 *pdev_count,Uint8 *dev_mask)
+{
+     Uint32 ret_code = 0;
+     Csp1DevMask  buf;
+     memset(&buf,0,sizeof buf);
+#ifdef CAVIUM_MULTICARD_API
+     ret_code = ioctl(gpkpdev_hdlr[CAVIUM_DEV_ID],IOCTL_N1_GET_DEV_CNT,(ptrlong)&buf);
+#else
+     ret_code = ioctl(CSP1_driver_handle,IOCTL_N1_GET_DEV_CNT,(ptrlong)&buf);
+#endif
+     if(ret_code!= 0)
+     {
+        printf("CSP1: No devices detected \n");
+     }
+     *pdev_count=buf.dev_cnt;
+     *dev_mask=buf.dev_mask;
+	  
+#ifdef CAVIUM_MULTICARD_API	  
+     int i;
+	  for(i=0;i<buf.dev_cnt;i++)
+	     if(1<<i&buf.dev_mask){
+		     default_device=i;
+			  break;		        
+	     }       
+#endif	  
+		
+	
+     return ret_code;
+
+}
+/*****************************************************************************
+ *
+ *Csp1GetDevType
+ *
+ * Returns the device type: 
+ * Output
+ *      device = NLITE/N1/PX.
+ *
+ * Return Value
+ *      completion code = 0 (for success), ERR_BAD_IOCTL
+ *
+ ****************************************************************************/
+
+Uint32
+Csp1GetDevType(Uint32 *device)
+{
+     Uint32 ret_code = 0;
+#ifdef CAVIUM_MULTICARD_API
+     ret_code = ioctl(gpkpdev_hdlr[CAVIUM_DEV_ID],IOCTL_N1_GET_DEV_TYPE,device);
+#else
+     ret_code = ioctl(CSP1_driver_handle,IOCTL_N1_GET_DEV_TYPE,device);
+#endif
+     if(ret_code!= 0)
+     {
+        printf("CSP1: No devices detected \n");
+     }
+     return ret_code;
+}
+
+
+/*****************************************************************************
+ *
+ * CSP1_multi_open_device_file
+ *
+ * Opens a device with minor number =  dev_id
+ *
+ * Input
+ *  dev_id = minor number of the device to be openend.
+ *
+ * Output
+ *
+ * Return Value
+ *      completion code = 0 (for success), errno
+ *
+ ****************************************************************************/
+int
+CSP1_multi_open_device_file(int dev_id)
+{
+	char   name[32];
+        int cond_code = 0;
+
+	strcpy(name, "/dev/pkp_");
+	
+	strcat(name, "dev");
+
+        if(dev_id)
+           sprintf(name,"%s%d",name,dev_id);
+
+	printf("CSP1_multi_open_device_file: %s\n", name);
+
+        if(CSP1_driver_handle < 0)
+	   CSP1_driver_handle= open(name, O_RDWR);
+
+        if (CSP1_driver_handle < 0) 
+          cond_code = errno;
+        else 
+        {
+           cond_code = 0;
+        }
+        return cond_code;
+}
+
+
+/*****************************************************************************
+ *
+ * SpeedTestResult
+ *
+ * Calculate the result of speedtest
+ *       
+ * Input  
+ *  info = information of speedtest.
+ *      
+ * Output
+ *           
+ * Return Value
+ *      ret = speed values in Mbps 
+              0 (if time_taken = 0 microsecond )
+ *  
+ ****************************************************************************/
+
+
+Uint64 SpeedTestResult(Speed_Test_Info *info)
+{   
+        Uint64 ret = 0;
+        if(info->time_taken != 0)
+                ret = ((info->req_completed * info->dlen * 8) /(info->time_taken ));
+        return (ret);
+}
+
+
+#ifdef _WIN32
+DWORD	sleepInMs = 1;
+static	HANDLE pkpHandle = INVALID_HANDLE_VALUE;
+
+int
+open (const char *path, int flags)
+{
+	if (pkpHandle != INVALID_HANDLE_VALUE) {
+		errno = ERROR_ALREADY_INITIALIZED;
+		return -1;
+	}
+	pkpHandle = CreateFile ("\\\\.\\PKP0", GENERIC_READ | GENERIC_WRITE,
+	    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
+	    FILE_ATTRIBUTE_NORMAL, NULL);
+	if (pkpHandle == INVALID_HANDLE_VALUE) {
+		errno = GetLastError ();
+		return -1;
+	}
+	else
+		return (int) pkpHandle;
+}
+
+int
+close (int fd)
+{
+	if (pkpHandle != INVALID_HANDLE_VALUE) {
+		CloseHandle (pkpHandle);
+		pkpHandle = INVALID_HANDLE_VALUE;
+		return 0;
+	}
+	errno = ERROR_FILE_NOT_FOUND;
+	return -1;
+}
+
+int
+ioctl (int fd, int request, ...)
+{
+	int	cst;
+	va_list	vl;
+	DWORD	retb;
+
+	if (pkpHandle == INVALID_HANDLE_VALUE) {
+		errno = ERROR_INVALID_PARAMETER;
+		return -1;
+	}
+	va_start (vl, request);
+	switch (request) {
+	case IOCTL_N1_OPERATION_CODE:
+	case IOCTL_N1_DO_OPERATION:
+	case IOCTL_N1_DO_SG_OPERATION:
+	case IOCTL_N1_GET_RANDOM_CODE:
+		{
+			Csp1OperationBuffer	*ob;
+
+			ob = va_arg (vl, Csp1OperationBuffer *);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) ob, (DWORD) sizeof (Csp1OperationBuffer),
+			    (LPVOID) ob, (DWORD) sizeof (Csp1OperationBuffer),
+			    &retb, NULL)) {
+				cst = ob->status;
+				if (ob->status == ERR_REQ_PENDING) {
+					ob->status = EAGAIN;
+					cst = 0;
+				}
+			}
+			else {
+				cst = -1;
+				errno = GetLastError ();
+			}
+		}
+		break;
+	case IOCTL_N1_ALLOC_CONTEXT:
+	case IOCTL_N1_FREE_CONTEXT:
+		{
+			n1_context_buf	*cbuf;
+
+			cbuf = va_arg (vl, n1_context_buf *);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) cbuf, (DWORD) sizeof (n1_context_buf),
+			    (LPVOID) cbuf, (DWORD) sizeof (n1_context_buf),
+			    &retb, NULL)) {
+				cst = 0;
+			}
+			else {
+				errno = GetLastError ();
+				cst = -1;
+			}
+		}
+		break;
+	case IOCTL_N1_POLL_CODE:
+	case IOCTL_N1_GET_REQUEST_STATUS:
+		{
+			Csp1RequestStatusBuffer	*rsb;
+
+			rsb = va_arg (vl, Csp1RequestStatusBuffer *);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) rsb, (DWORD)
+			    sizeof (Csp1RequestStatusBuffer), (LPVOID) rsb,
+			    (DWORD) sizeof (Csp1RequestStatusBuffer), &retb,
+			    NULL)) {
+				cst = rsb->status;
+				if (rsb->status == ERR_REQ_PENDING) {
+					rsb->status = EAGAIN;
+					cst = 0;
+				}
+			}
+			else {
+				errno = GetLastError ();
+				cst = -1;
+			}
+		}
+		break;
+	case IOCTL_N1_GET_ALL_REQUEST_STATUS:
+		{
+			Csp1StatusOperationBuffer	*sob;
+
+			sob = va_arg (vl, Csp1StatusOperationBuffer *);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) sob, (DWORD)
+			    sizeof (Csp1StatusOperationBuffer), (LPVOID) sob,
+			    (DWORD) sizeof (Csp1StatusOperationBuffer), &retb,
+			    NULL)) {
+				errno = GetLastError ();
+				cst = -1;
+			}
+		}
+		break;
+	case IOCTL_N1_ALLOC_KEYMEM:
+	case IOCTL_N1_FREE_KEYMEM:
+	case IOCTL_N1_WRITE_KEYMEM:
+		{
+			n1_write_key_buf	*keybuf;
+
+			keybuf = va_arg (vl, n1_write_key_buf *);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) keybuf, (DWORD) sizeof (n1_write_key_buf),
+			    (LPVOID) keybuf, (DWORD) sizeof (n1_write_key_buf),
+			    &retb, NULL))
+				cst = 0;
+			else {
+				errno = GetLastError ();
+				cst = -1;
+			}
+		}
+		break;
+	case IOCTL_N1_FLUSH_ALL_CODE:
+		if (DeviceIoControl (pkpHandle, (DWORD) request, NULL,
+		    0, NULL, 0, &retb, NULL))
+			cst = 0;
+		else {
+			errno = GetLastError ();
+			cst = -1;
+		}
+		break;
+	case IOCTL_N1_FLUSH_CODE:
+		{
+			Uint32	id;
+
+			id = va_arg (vl, Uint32);
+			if (DeviceIoControl (pkpHandle, (DWORD) request,
+			    (LPVOID) &id, (DWORD) sizeof (Uint32), NULL, 0,
+			    &retb, NULL))
+				cst = 0;
+			else {
+				errno = GetLastError ();
+				cst = -1;
+			}
+		}
+		break;
+	case IOCTL_N1_DEBUG_WRITE_CODE:
+	case IOCTL_N1_DEBUG_READ_CODE:
+	case IOCTL_PCI_DEBUG_WRITE_CODE:
+	case IOCTL_PCI_DEBUG_READ_CODE:
+	case IOCTL_N1_INIT_CODE:
+	case IOCTL_N1_SOFT_RESET_CODE:
+	case IOCTL_N1_API_TEST_CODE:
+	default:
+		errno = ERROR_INVALID_PARAMETER;
+		cst = -1;
+		break;
+	}
+	return cst;
+}
+#endif
+
+/*
+ * $Id: cavium_common.c,v 1.44 2009/09/18 06:29:42 aravikumar Exp $
+ * $Log: cavium_common.c,v $
+ * Revision 1.44  2009/09/18 06:29:42  aravikumar
+ * Csp1Random group changed to GP_GRP
+ *
+ * Revision 1.43  2009/09/16 11:42:51  aravikumar
+ * SSL group added for missing APIs
+ *
+ * Revision 1.42  2009/09/14 09:39:33  aravikumar
+ * group changed to GP_GRP for Csp1Me
+ *
+ * Revision 1.41  2009/09/09 14:29:17  aravikumar
+ * NPLUS macro dependency removed and made it dynamic
+ *
+ * Revision 1.40  2009/08/07 07:09:04  rdhana
+ * Removed returning of SRTP header at output.
+ *
+ * Revision 1.39  2009/07/03 07:08:30  rdhana
+ * Updated SRTP_AES_CTR to support variable Tag len and non-returning of ROC incase of SRTP.
+ * API changes:
+ * minor OPcode[6] = 0 - SRTP and 1 - SRTCP
+ * Param2[15:12] =  Tag length in bytes.
+ * Param2[11:8]  =  Index length in bytes
+ *
+ * Revision 1.38  2009/06/23 10:41:42  kramaraju
+ * Added multicard suport for Csp1GetAllResults api
+ *
+ * Revision 1.37  2009/06/23 08:37:05  kmonendra
+ * Changes in SpeedTestResult.
+ *
+ * Revision 1.36  2009/06/22 06:49:49  rsruthi
+ * -- Added AES_CFB Support.
+ *
+ * Revision 1.35  2009/06/18 09:55:39  rdhana
+ * Added IPv6 Extension header and Selector Check support.
+ *
+ * Revision 1.34  2009/06/02 14:47:12  kmonendra
+ * Done type casting in SpeedTestResult function.
+ *
+ * Revision 1.33  2009/05/15 10:31:14  kmonendra
+ * Changes in SpeedTestResult, return speed in Mbps.
+ *
+ * Revision 1.32  2009/05/11 09:56:41  jrana
+ * Defined ioctl switch IOCTL_N1_GET_ALL_REQUEST_STATUS for Csp1GetAllResults routine to work with windows.
+ *
+ * Revision 1.31  2009/05/06 09:40:50  kmonendra
+ * Fixed comments for SpeedTestResult().
+ *
+ * Revision 1.30  2009/04/07 05:34:03  kmonendra
+ * Added SpeedTestResult() for speedtest.
+ *
+ * Revision 1.29  2009/03/10 11:49:07  rdhana
+ * Added Single PASS [AES_xxx + SHA1] SRTP support in SSL and IPSEC.
+ *
+ * Revision 1.28  2009/01/28 09:26:26  kmaheshwar
+ * Removed MC1 define related code in Csp1SrtpAesCtr and Csp1AesXcbcPrf128
+ *
+ * Revision 1.27  2009/01/09 05:53:52  kmaheshwar
+ * Added AesXcbcPrf128 (RFC 3566,3664, and 4434) support and it is disabled in Makefile
+ *
+ * Revision 1.26  2009/01/06 06:46:11  rdhana
+ * Added AES_192, AES_256 Support in Csp1SrtpAesCtr.
+ *
+ * Revision 1.25  2008/10/24 09:35:21  ysandeep
+ * changed "admin" to "nle_admin"
+ *
+ * Revision 1.24  2008/10/18 05:53:58  aramesh
+ * default_device set properly.
+ *
+ * Revision 1.23  2008/10/16 09:30:36  aramesh
+ * default_device  variable is added.
+ *
+ * Revision 1.22  2008/10/15 08:03:38  ysandeep
+ * Multicard support for NPLUS added.
+ *
+ * Revision 1.21  2008/08/08 09:37:17  aramesh
+ * initialized hash_size to 0.
+ *
+ * Revision 1.20  2008/07/10 12:17:29  rsruthi
+ * --Fixed compilation error related to HMAC_SHA384/SHA512 support in MC2.
+ *
+ * Revision 1.19  2008/07/07 12:34:39  aramesh
+ * Csp1GetDev parameters are changed.
+ *
+ * Revision 1.18  2008/07/03 09:59:37  aramesh
+ * Declared Csp1GetDevType API.
+ *
+ * Revision 1.16  2008/06/05 07:01:55  sshekkari
+ * Modified Csp1Me, PkcsEnc, PkcsCrtEnc, PkcsDec and PkcsCrtDec MC2 api's to support modlength upto 4096-bits.
+ *
+ * Revision 1.15  2008/06/03 06:19:40  rsruthi
+ * - Added AesGCM/GMAC Encrypt/Decrypt API Support.
+ * - Added SHA256, SHA384, SHA512 support in Csp1Hash and Csp1Hmac APIs.
+ *
+ * Revision 1.14  2008/05/22 05:48:17  aramesh
+ * Csp1drivehandle is used only for non-multicard support.
+ *
+ * Revision 1.13  2008/04/25 06:06:45  rdhana
+ * Added the FRAG_SUPPORT code in normal flow and  Removed the FRAG_SUPPORT ifdef and else part of the code.
+ *
+ * Revision 1.12  2008/02/12 13:27:08  aramesh
+ * CSP1_driver_handle initilaized for multicard api also.
+ *
+ * Revision 1.11  2008/02/04 07:44:12  kmaheshwar
+ * added Csp1SrtpAesCtr
+ *
+ * Revision 1.10  2007/10/26 13:48:37  kchunduri
+ * --memset 'Csp1OperationBuffer' to zero to overcome issues observed with gcc-4.1.
+ *
+ * Revision 1.9  2007/10/18 09:35:09  lpathy
+ * Added windows support.
+ *
+ * Revision 1.8  2007/09/10 10:15:22  kchunduri
+ * --API changed to accept 'dev_id' as input parameter.
+ *
+ * Revision 1.7  2007/08/14 08:27:01  kchunduri
+ * --define new API to retrieve number of Nitrox Devices detected and
+ *   API to open a device with dev_id as input parameter.
+ *
+ * Revision 1.6  2007/07/04 09:25:49  kchunduri
+ * --multi-card support.
+ *
+ * Revision 1.5  2007/05/04 10:30:38  kchunduri
+ * fix compiler warnings.
+ *
+ * Revision 1.4  2007/05/01 05:45:37  kchunduri
+ * * modified UIT64_C macro.
+ *
+ * Revision 1.3  2007/03/06 01:53:39  panicker
+ * * CSP1_open_device_file - new routine automatically creates device file name
+ *   and opens it for NitroxPX & N1 for NPLUS and normal mode.
+ *
+ * Revision 1.2  2007/02/20 23:30:52  panicker
+ * * N1 and NLE device files are different
+ *
+ * Revision 1.1  2007/01/15 23:17:42  panicker
+ * *** empty log message ***
+ *
+ * Revision 1.37  2006/08/23 05:41:18  pnalla
+ * Added Fragmentation and UDP Encapsulation support
+ *
+ * Revision 1.36  2006/08/21 10:01:12  kchunduri
+ * the status of IOCTL_N1_OPERATION is available in 'status' field. Earlier status is a return parameter. Need to change since earlier implementation was a problemon FreeBSD-4.11 for NB_CRYPTO mode of operation.
+ *
+ * Revision 1.35  2006/08/16 14:21:20  kchunduri
+ * --IOCTL_N1_POLL_CODE takes Csp1RequestStatusBuffer as argument instead of RequestID value
+ *
+ * Revision 1.34  2006/05/16 13:44:52  kchunduri
+ * --fix compilation warning
+ *
+ * Revision 1.33  2006/05/16 10:18:15  kchunduri
+ * --conditional definition of UINT64_C
+ *
+ * Revision 1.32  2006/05/16 09:51:35  kchunduri
+ * --changes to support re-aligned API structures.
+ *
+ * Revision 1.31  2006/05/05 11:02:12  dgandhewar
+ * added UINT64_C(x) define
+ *
+ * Revision 1.30  2006/04/17 03:52:08  kchunduri
+ * --single IOCTL support for Csp1GetAllResults --kiran
+ *
+ * Revision 1.29  2006/03/27 04:55:23  kchunduri
+ * --kchunduri new API Csp1GetAllResults()
+ *
+ * Revision 1.28  2005/12/14 09:34:09  kkiran
+ * - Replaced SSL flag with IPSEC_TEST flag to fix compilation error in TurboSSL
+ *
+ * Revision 1.27  2005/11/24 05:37:23  kanantha
+ * Removed the compilation warning
+ *
+ * Revision 1.26  2005/11/17 13:31:09  kanantha
+ * Updating with the 64 bit modifications, with proper matching of data types
+ *
+ * Revision 1.25  2005/10/20 10:00:35  phegde
+ * - Added two APIs named Csp1WriteIpsecSa() and Csp1ProcessPacket() to support IPSec functionality.
+ *
+ * Revision 1.24  2005/09/29 12:29:52  sgadam
+ * Moved back FreeBSD AMD64 changes to CVS head
+ *
+ * Revision 1.21  2005/09/29 10:06:37  sgadam
+ * - input length for 3Des Enc is aligned multiple of 8 bytes.
+ *
+ * Revision 1.20  2005/09/28 15:39:30  ksadasivuni
+ * - Merging FreeBSD 6.0 ADM64 release with CVS Head
+ * - In ipsec_mc2.c the change is due to passing of physical context pointer
+ * directly to userspace application. So no need for vtophys
+ *
+ * Revision 1.19  2005/09/08 14:27:35  sgadam
+ * - Warning Removed
+ *
+ * Revision 1.18  2005/09/06 10:10:39  ksadasivuni
+ * - Added "ULL" suffix to long constants
+ *
+ * Revision 1.17  2005/08/31 18:12:22  bimran
+ * Fixed several compile warnings.
+ *
+ * Revision 1.16  2005/08/13 06:48:03  sgadam
+ * SSL-FIPS merged code
+ *
+ * Revision 1.15  2005/05/21 05:04:16  rkumar
+ * Merge with India CVS head
+ *
+ * Revision 1.14  2005/02/01 04:04:56  bimran
+ * copyright fix
+ *
+ * Revision 1.13  2004/10/12 00:12:26  danny
+ * bug fix
+ * nehanet #366
+ *
+ * Revision 1.12  2004/08/25 22:31:34  tsingh
+ * new file from India (Ram) fixes hash define
+ *
+ * Revision 1.2  2004/08/20 15:43:14  rkumar
+ * Csp1HMac bug fixed for MC2
+ *
+ * Revision 1.1.1.1  2004/07/28 06:43:14  rkumar
+ * Initial Checkin
+ *
+ * Revision 1.11  2004/06/03 21:10:08  bimran
+ * added context type in deallocationg context.
+ *
+ * Revision 1.10  2004/05/02 19:35:13  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.9  2004/05/01 05:57:44  bimran
+ * Fixed a function descriptions on each function to match with the latest microcode and driver.
+ *
+ * Revision 1.8  2004/04/30 21:19:25  bimran
+ * Fixed comments and enabled random number to be get from driver.
+ *
+ * Revision 1.7  2004/04/28 03:16:02  bimran
+ * Fixed comments.
+ *
+ * Revision 1.6  2004/04/26 18:57:31  bimran
+ * Fixed comment header of Csp1Initialize() to reflect NPLUS changes.
+ *
+ * Revision 1.5  2004/04/23 21:46:32  bimran
+ * Lot of cleanup.
+ * Removed all OS dependencies.
+ * It should all be just ioctl.
+ *
+ * Revision 1.4  2004/04/21 22:23:49  bimran
+ * Fixed key memory allocation deallocation.
+ *
+ * Revision 1.3  2004/04/16 23:55:23  bimran
+ * Removed un-necessary defines. THey should go to cavium_common.h.
+ *
+ * Revision 1.2  2004/04/16 00:04:48  bimran
+ * Fixed compilation issues.
+ * returned ERR_OPERATION_NOT_SUPPORTED instead of '0' when a microcode does not support a particular macro.
+ *
+ * Revision 1.1  2004/04/15 22:38:38  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
+
diff -Naur openssl-0.9.8i/crypto/engine/cavium_ssl.c openssl-0.9.8i-cns3xxx/crypto/engine/cavium_ssl.c
--- openssl-0.9.8i/crypto/engine/cavium_ssl.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8i-cns3xxx/crypto/engine/cavium_ssl.c	2010-05-31 12:11:59.000000000 +0200
@@ -0,0 +1,14879 @@
+/* cavium_ssl.c */
+/*
+ * Copyright (c) 2003-2005, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+
+#ifdef _WIN32
+#include <windows.h>
+#include <winioctl.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <fcntl.h>
+#undef	NO_ERROR
+
+int	open (const char *, int);
+int	close (int);
+int	ioctl (int, int, ...);
+#endif
+#include <cavium_sysdep.h>
+#include <cavium_common.h>
+#include <cavium_ioctl.h>
+#include <cavium_endian.h>
+#include <cavium_ioctl.h>
+#include <cavium_ssl.h>
+#include <stdlib.h>
+#include <string.h>
+
+extern Csp1DmaMode global_dma_mode;
+extern int CSP1_driver_handle;
+
+#ifdef CAVIUM_MULTICARD_API
+extern int gpkpdev_hdlr[];
+#endif
+
+
+#ifndef UINT64_C 
+#define UINT64_C(x)   ((unsigned long long) (x ## ull))
+#endif
+
+#ifndef MC2
+static void pkp_leftfill (unsigned char input[], int length,
+			  unsigned char output[], int finallength);
+static void swap_word_openssl (unsigned char *d, unsigned char *s, int len);
+#endif
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1GetDmaMode
+ * 
+ * Returns the current DMA mode
+ *
+ * Input
+ *  none
+ * 
+ * Ouput
+ *  none
+ *
+ * Return Value
+ *	DmaMode: CAVIUM_DIRECT, CAVIUM_SCATTER_GATHER
+ *
+ *-***************************************************************************/
+DmaMode
+Csp1GetDmaMode (void)
+{
+  return global_dma_mode;
+}
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1GetDriverState
+ * 
+ * Function to check whether the driver handle is initialized or not.
+ *
+ * Input
+ *  none
+ * 
+ * Ouput
+ *  none
+ *
+ * Return Value
+ *	0  = driver handle is ready.
+ *	-1 = driver handle is not initialized
+ *-***************************************************************************/
+int
+#ifdef CAVIUM_MULTICARD_API
+Csp1GetDriverState (Uint32 dev_id)
+#else
+Csp1GetDriverState ()
+#endif
+{
+#ifdef CAVIUM_MULTICARD_API
+  if (gpkpdev_hdlr[dev_id] != -1)
+#else
+  if (CSP1_driver_handle != -1)
+#endif
+    return 0;
+  else
+    return -1;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1SetEncryptedMasterSecretKey
+ *
+ * Sets the key material for encryption of master secrets used by resume 
+ * operations.
+ *
+ * Input
+ *		key = pointer to 48 bytes of key material
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *-***************************************************************************/
+Uint32
+#ifdef CAVIUM_MULTICARD_API
+Csp1SetEncryptedMasterSecretKey (Uint8 * key,Uint32 dev_id)
+#else
+Csp1SetEncryptedMasterSecretKey (Uint8 * key)
+#endif
+{
+  Uint32 ret_val;
+  Uint32 dummy = 0;
+#ifdef CAVIUM_MULTICARD_API
+  Uint64 tmp_keyhdl=0;
+  ret_val = Csp1WriteEpci (CAVIUM_BLOCKING,&tmp_keyhdl, 48, key, &dummy,dev_id);
+#else
+  ret_val = Csp1WriteEpci (CAVIUM_BLOCKING, 0, 48, key, &dummy);
+#endif
+  return ret_val;
+
+}
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1Handshake
+ *
+ * Calculates the hashes needed by the SSL handshake.
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit pointer to context (context_handle%8=0)
+ *		message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *		message = pointer to length bytes of input
+ *
+ * Output
+ *		md5_final_hash = pointer to the 4-halfword handshake final result 
+ *		sha1_final_hash = pointer to the 5-halfword handshake final result 
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Handshake (n1_request_type request_type,
+	       Uint64 context_handle,
+	       Uint16 message_length,
+	       Uint8 * message,
+	       Uint8 * md5_final_hash,
+	       Uint8 * sha1_final_hash, 
+#ifdef CAVIUM_MULTICARD_API
+	       Uint32 * request_id,Uint32 dev_id
+#else
+	       Uint32 * request_id
+#endif
+              )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+
+  Uint32 md5_hash_size = 16;
+  Uint32 sha1_hash_size = 20;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+
+  buffer.opcode = (0x3 << 9) | (global_dma_mode << 7) | MAJOR_OP_HANDSHAKE;
+  buffer.size = message_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (16 + 24 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 2;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[0] =CAST_TO_X_PTR( md5_final_hash);
+  buffer.outsize[0] = md5_hash_size;
+  buffer.outoffset[0] = 16;
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( sha1_final_hash);
+  buffer.outsize[1] = sha1_hash_size;
+  buffer.outoffset[1] = 24;
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeStart
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit pointer to context (context_handle%8=0)
+ *		message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *		message = pointer to length bytes of input
+ *
+ * Output
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1HandshakeStart (n1_request_type request_type,
+		    Uint64 context_handle,
+		    Uint16 message_length,
+		    Uint8 * message, 
+#ifdef CAVIUM_MULTICARD_API
+                    Uint32 * request_id, Uint32 dev_id
+#else
+                    Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+  buffer.opcode = (0x1 << 9) | (global_dma_mode << 7) | MAJOR_OP_HANDSHAKE;
+  buffer.size = message_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 0;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeUpdate
+ *
+ * Calculates the partial hashes needed by the SSL handshake.
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit pointer to context (context_handle%8=0)
+ *		message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *		message = pointer to length bytes of input
+ * Output
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1HandshakeUpdate (n1_request_type request_type,
+		     Uint64 context_handle,
+		     Uint16 message_length,
+		     Uint8 * message, 
+#ifdef CAVIUM_MULTICARD_API
+                     Uint32 * request_id, Uint32 dev_id
+#else
+                     Uint32 * request_id
+#endif
+                    )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+  buffer.opcode = (0x0 << 9) | (global_dma_mode << 7) | MAJOR_OP_HANDSHAKE;
+  buffer.size = message_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 0;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1HandshakeFinish
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit pointer to context (context_handle%8=0)
+ *		message_length = size of input in bytes (0<=message_length<=2^16-1)
+ *		message = pointer to length bytes of input
+ *
+ * Output
+ *		md5_final_hash = pointer to the 4-word handshake final result 
+ *		sha1_final_hash = pointer to the 5-word handshake final result 
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1HandshakeFinish (n1_request_type request_type,
+		     Uint64 context_handle,
+		     Uint16 message_length,
+		     Uint8 *message,
+		     Uint8 *md5_final_hash,
+		     Uint8 *sha1_final_hash, 
+#ifdef CAVIUM_MULTICARD_API
+			 Uint32 *request_id,Uint32 dev_id
+#else
+			 Uint32 *request_id
+#endif
+                    )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+
+  Uint32 md5_hash_size = 16;
+  Uint32 sha1_hash_size = 20;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+  buffer.opcode = (0x2 << 9) | (global_dma_mode << 7) | MAJOR_OP_HANDSHAKE;
+  buffer.size = message_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (16 + 24 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 2;
+
+  buffer.inptr[0] = CAST_TO_X_PTR(message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( md5_final_hash);
+  buffer.outsize[0] = md5_hash_size;
+  buffer.outoffset[0] = 16;
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( sha1_final_hash);
+  buffer.outsize[1] = sha1_hash_size;
+  buffer.outoffset[1] = 24;
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+#endif /* MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullRc4
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the RC4 cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value.
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *									returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFullRc4 (n1_request_type request_type,
+		      Uint64 context_handle,
+		      Uint64 * key_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      Rc4Type rc4_type,
+		      MasterSecretReturn master_secret_ret,
+		      Uint16 modlength,
+		      Uint8 * encrypt_premaster_secret,
+		      Uint8 * client_random,
+		      Uint8 * server_random,
+		      Uint16 handshake_length,
+		      Uint8 * handshake,
+		      Uint8 * client_finished_message,
+		      Uint8 * server_finished_message,
+		      Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+			  Uint32 *request_id,Uint32 dev_id
+#else
+			  Uint32 *request_id
+#endif
+                    )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+#ifndef MC2
+  Uint16 param = 0;
+#endif
+  Uint16 finished_size;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+#ifndef MC2
+  if ((modlength & 0x7) != 0)
+	  return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x3 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x3 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.size = modlength;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (rc4_type << 3) | (1 << 7);
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+  buffer.rlen = 2 * (finished_size + hash_size);
+#else
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *)  key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR(  encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+#ifndef MC2
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#else
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += 48;
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+      buffer.outsize[1] = finished_size + hash_size;
+      buffer.outoffset[1] = finished_size + hash_size;
+      buffer.outunit[1] = UNIT_8_BIT;
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+      buffer.outsize[2] = finished_size + hash_size;
+      buffer.outoffset[2] = finished_size + hash_size;
+      buffer.outunit[2] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+      buffer.outsize[0] = finished_size + hash_size;
+      buffer.outoffset[0] = finished_size + hash_size;
+      buffer.outunit[0] = UNIT_8_BIT;
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+      buffer.outsize[1] = finished_size + hash_size;
+      buffer.outoffset[1] = finished_size + hash_size;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+  *request_id = (buffer.request_id);
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullRc4Finish
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the RC4 cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request (previously hashed plus included 
+ * messsage data) should include all handshake message data after (and 
+ * including) the client hello message up until (but not including) the first 
+ * finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *								returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFullRc4Finish (n1_request_type request_type,
+			    Uint64 context_handle,
+			    Uint64 * key_handle,
+			    HashType hash_type,
+			    SslVersion ssl_version,
+			    Rc4Type rc4_type,
+			    MasterSecretReturn master_secret_ret,
+			    Uint16 modlength,
+			    Uint8 * encrypt_premaster_secret,
+			    Uint8 * client_random,
+			    Uint8 * server_random,
+			    Uint16 handshake_length,
+			    Uint8 * handshake,
+			    Uint8 * client_finished_message,
+			    Uint8 * server_finished_message,
+			    Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			    Uint32 * request_id, Uint32 dev_id
+#else
+			    Uint32 * request_id
+#endif
+                          )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((modlength & 0x7) != 0)
+	  return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x2 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x2 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *)  key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR(  encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyRc4
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message.  
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		verify_data = pointer to 36 bytes of verify data 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *						returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerifyRc4 (n1_request_type request_type,
+			Uint64 context_handle,
+			Uint64 * key_handle,
+			HashType hash_type,
+			SslVersion ssl_version,
+			Rc4Type rc4_type,
+			MasterSecretReturn master_secret_ret,
+			Uint16 modlength,
+			Uint8 * encrypt_premaster_secret,
+			Uint8 * client_random,
+			Uint8 * server_random,
+			Uint16 handshake_length,
+			Uint8 * handshake,
+			Uint8 * verify_data,
+			Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 * request_id,Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                       )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+#ifndef MC2
+  Uint16 param = 0;
+#endif
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+#ifndef MC2
+  if ((modlength & 0x7) != 0)
+	  return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.size = modlength;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (rc4_type << 3) | (1 << 7);
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+#else
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[4] = handshake_length;
+#else
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[4] = UNIT_8_BIT;
+
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen = 48 + 36;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] =CAST_TO_X_PTR(  verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.rlen = 36;
+      buffer.outcnt = 1;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+#else
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] =CAST_TO_X_PTR(  encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyRc4Finish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the RC4 cases.
+ *
+ * Handshake data can be accumulated prior to this request by calls to 
+ * Handshake*, and this request will append the included handshake 
+ * message data to the pre-existing handshake hash state. The handshake message 
+ * data for this request (previously hashed plus included messsage data) should 
+ * include all handshake message data after (and including) the client hello 
+ * message up until (but not including) the client verify message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		verify_data = pointer to 36 bytes of verify data 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerifyRc4Finish (n1_request_type request_type,
+			      Uint64 context_handle,
+			      Uint64 * key_handle,
+			      HashType hash_type,
+			      SslVersion ssl_version,
+			      Rc4Type rc4_type,
+			      MasterSecretReturn master_secret_ret,
+			      Uint16 modlength,
+			      Uint8 * encrypt_premaster_secret,
+			      Uint8 * client_random,
+			      Uint8 * server_random,
+			      Uint16 handshake_length,
+			      Uint8 * handshake,
+			      Uint8 * verify_data,
+			      Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			      Uint32 * request_id, Uint32 dev_id
+#else
+			      Uint32 * request_id
+#endif
+                              )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+  if ((modlength & 0x7) != 0)
+	  return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x0 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x0 << 13) | (rc4_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+    }
+  else
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /*if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFull3Des
+ *
+ * Does a full handshake on the server with RSA <= 1024. This entry point 
+ * handles all the DES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		des_type = DES, DES_EXPORT_40 or DES3_192
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *		srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *		client_pad_length = number of 64-bit words to pad above min
+ *		server_pad_length = number of 64-bit words to pad above min
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value.
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *							returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFull3Des (n1_request_type request_type,
+		       Uint64 context_handle,
+		       Uint64 * key_handle,
+		       HashType hash_type,
+		       SslVersion ssl_version,
+		       DesType des_type,
+		       MasterSecretReturn master_secret_ret,
+		       ClientFinishMessageOutput clnt_fin_msg_out,
+		       ServerFinishMessageOutput srvr_fin_msg_out,
+		       Uint16 client_pad_length,
+		       Uint16 server_pad_length,
+		       Uint16 modlength,
+		       Uint8 * encrypt_premaster_secret,
+		       Uint8 * client_random,
+		       Uint8 * server_random,
+		       Uint16 handshake_length,
+		       Uint8 * handshake,
+		       Uint8 * client_finished_message,
+		       Uint8 * server_finished_message,
+		       Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                       Uint32 * request_id, Uint32 dev_id
+#else
+                       Uint32 * request_id
+#endif
+                      )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+#ifdef MC2
+  if ((modlength & 0x7) != 0)
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x7 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x7 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (des_type << 3) | (1 << 7);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    param |= (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    param |= (1 << 9);
+
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = modlength;
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+  buffer.rlen = 0;
+#else
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  buffer.param = param;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] =CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] =CAST_TO_X_PTR(  client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[4] = handshake_length;
+#else
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[4] = UNIT_8_BIT;
+
+
+#ifdef MC2
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen = 48;
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+	  buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+	  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+
+	}
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[1] = finished_size;
+	  buffer.outoffset[1] = finished_size;
+	}
+
+      buffer.outunit[1] = UNIT_8_BIT;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+	  buffer.outsize[2] = ROUNDUP8 (finished_size + hash_size + 1);
+	  buffer.outoffset[2] = ROUNDUP8 (finished_size + hash_size + 1);
+
+	}
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[2] = finished_size;
+	  buffer.outoffset[2] = finished_size;
+	}
+
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+    {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+	  buffer.outsize[0] = ROUNDUP8 (finished_size + hash_size + 1);
+	  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size + 1);
+
+	}
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[0] = finished_size;
+	  buffer.outoffset[0] = finished_size;
+	}
+
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+	  buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+	  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+
+	}
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[1] = finished_size;
+	  buffer.outoffset[1] = finished_size;
+	}
+
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+#else
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFull3DesFinish
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the DES cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		des_type = DES, DES_EXPORT_40 or DES3_192
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *		srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *		client_pad_length = number of 64-bit words to pad above min
+ *		server_pad_length = number of 64-bit words to pad above min
+ *		modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value.
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *							returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFull3DesFinish (n1_request_type request_type,
+			     Uint64 context_handle,
+			     Uint64 * key_handle,
+			     HashType hash_type,
+			     SslVersion ssl_version,
+			     DesType des_type,
+			     MasterSecretReturn master_secret_ret,
+			     ClientFinishMessageOutput clnt_fin_msg_out,
+			     ServerFinishMessageOutput srvr_fin_msg_out,
+			     Uint16 client_pad_length,
+			     Uint16 server_pad_length,
+			     Uint16 modlength,
+			     Uint8 * encrypt_premaster_secret,
+			     Uint8 * client_random,
+			     Uint8 * server_random,
+			     Uint16 handshake_length,
+			     Uint8 * handshake,
+			     Uint8 * client_finished_message,
+			     Uint8 * server_finished_message,
+			     Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			     Uint32 * request_id, Uint32 dev_id
+#else
+			     Uint32 * request_id
+#endif
+                           )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 finished_size;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+  else
+    {
+      if ((context_handle & 0x7) != 0)
+		  return ERR_ILLEGAL_CONTEXT_HANDLE;
+    }
+
+  if ((modlength & 0x7) != 0)
+	  return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x5 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x5 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerify3Des
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		des_type = DES, DES_EXPORT_40, DES3_192
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		verify_data = pointer to 36 bytes of verify data 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerify3Des (n1_request_type request_type,
+			 Uint64 context_handle,
+			 Uint64 * key_handle,
+			 HashType hash_type,
+			 SslVersion ssl_version,
+			 DesType des_type,
+			 MasterSecretReturn master_secret_ret,
+			 Uint16 modlength,
+			 Uint8 * encrypt_premaster_secret,
+			 Uint8 * client_random,
+			 Uint8 * server_random,
+			 Uint16 handshake_length,
+			 Uint8 * handshake,
+			 Uint8 * verify_data,
+			 Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                         Uint32 * request_id,Uint32 dev_id
+#else
+                         Uint32 * request_id
+#endif
+                        )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+#ifndef MC2
+  Uint16 param = 0;
+#endif
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+#ifndef MC2
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x3 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x3 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.size = modlength;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (des_type << 3) | (1 << 7);
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+#else
+  hash_size = 20 - (hash_type << 2);
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  buffer.incnt = 5;
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[4] = handshake_length;
+#else
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[4] = UNIT_8_BIT;
+
+
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen = 48 + 36;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.rlen = 36;
+      buffer.outcnt = 1;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+#else
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerify3DesFinish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the DES/3DES 
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		des_type = DES, DES_EXPORT_40 or DES3_192
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		verify_data = pointer to 36 bytes of verify data 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerify3DesFinish (n1_request_type request_type,
+			       Uint64 context_handle,
+			       Uint64 * key_handle,
+			       HashType hash_type,
+			       SslVersion ssl_version,
+			       DesType des_type,
+			       MasterSecretReturn master_secret_ret,
+			       Uint16 modlength,
+			       Uint8 * encrypt_premaster_secret,
+			       Uint8 * client_random,
+			       Uint8 * server_random,
+			       Uint16 handshake_length,
+			       Uint8 * handshake,
+			       Uint8 * verify_data,
+			       Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			       Uint32 * request_id, Uint32 dev_id
+#else
+			       Uint32 * request_id
+#endif
+                              )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 12) | (des_type << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullAes
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the AES cases. The handshake message data for this request 
+ * should include all handshake message data after (and including) the client 
+ * hello message up until (but not including) the first finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		aes_type = AES_128 or AES_256
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *		srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *		client_pad_length = number of 128-bit words to pad above min
+ *		server_pad_length = number of 128-bit words to pad above min
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value.
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *						returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFullAes (n1_request_type request_type,
+		      Uint64 context_handle,
+		      Uint64 * key_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      AesType aes_type,
+		      MasterSecretReturn master_secret_ret,
+		      ClientFinishMessageOutput clnt_fin_msg_out,
+		      ServerFinishMessageOutput srvr_fin_msg_out,
+		      Uint16 client_pad_length,
+		      Uint16 server_pad_length,
+		      Uint16 modlength,
+		      Uint8 * encrypt_premaster_secret,
+		      Uint8 * client_random,
+		      Uint8 * server_random,
+		      Uint16 handshake_length,
+		      Uint8 * handshake,
+		      Uint8 * client_finished_message,
+		      Uint8 * server_finished_message,
+		      Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id, Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                    )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 finished_size;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+#ifndef MC2
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0xd << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0xd << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+
+  param = (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    param |= (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    param |= (1 << 9);
+
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = modlength;
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+  buffer.rlen = 0;
+#else
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+#endif
+  buffer.param = param;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[4] = handshake_length;
+#else
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[4] = UNIT_8_BIT;
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen = 48;
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+	  buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+	  buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+
+	}
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[1] = finished_size;
+	  buffer.outoffset[1] = finished_size;
+	}
+
+      buffer.outunit[1] = UNIT_8_BIT;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+	  buffer.outsize[2] = ROUNDUP16 (finished_size + hash_size + 1);
+	  buffer.outoffset[2] = ROUNDUP16 (finished_size + hash_size + 1);
+
+	}
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[2] = finished_size;
+	  buffer.outoffset[2] = finished_size;
+	}
+
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+    {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+	  buffer.outsize[0] = ROUNDUP16 (finished_size + hash_size + 1);
+	  buffer.outoffset[0] = ROUNDUP16 (finished_size + hash_size + 1);
+
+	}
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[0] = finished_size;
+	  buffer.outoffset[0] = finished_size;
+	}
+
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+	{
+	  buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+	  buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+	  buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+
+	}
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+	{
+	  buffer.rlen += finished_size;
+
+	  buffer.outsize[1] = finished_size;
+	  buffer.outoffset[1] = finished_size;
+	}
+
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+#else
+  
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1RsaServerFullAesFinish
+ *
+ * Does a full handshake on the server. This entry point 
+ * handles all the aes cases. The handshake data is accumulated prior to this 
+ * request by calls to Handshake*, and this request appends the 
+ * included handshake message data to the pre-existing handshake hash state.
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until 
+ * (but not including) the first finished message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		aes_type = AES_128 or AES_256
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *		srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *		client_pad_length = number of 128-bit words to pad above min
+ *		server_pad_length = number of 128-bit words to pad above min
+ *		modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		client_finished_message = pointer to encrypted part of client finished message 
+ *		server_finished_message = pointer to encrypted part of server finished message 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerFullAesFinish (n1_request_type request_type,
+			    Uint64 context_handle,
+			    Uint64 * key_handle,
+			    HashType hash_type,
+			    SslVersion ssl_version,
+			    AesType aes_type,
+			    MasterSecretReturn master_secret_ret,
+			    ClientFinishMessageOutput clnt_fin_msg_out,
+			    ServerFinishMessageOutput srvr_fin_msg_out,
+			    Uint16 client_pad_length,
+			    Uint16 server_pad_length,
+			    Uint16 modlength,
+			    Uint8 * encrypt_premaster_secret,
+			    Uint8 * client_random,
+			    Uint8 * server_random,
+			    Uint16 handshake_length,
+			    Uint8 * handshake,
+			    Uint8 * client_finished_message,
+			    Uint8 * server_finished_message,
+			    Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			    Uint32 * request_id, Uint32 dev_id
+#else
+			    Uint32 * request_id
+#endif
+                       )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x9 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x9 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyAes
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *		request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *		context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *		key_handle = pointer to 64-bit key memory handle
+ *		hash_type = MD5_TYPE or SHA1_TYPE
+ *		ssl_version = VER3_0 or VER_TLS
+ *		aes_type = AES_128 or AES_256
+ *		master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *		modlength = size of RSA operation in bytes (64<=modlength<=512, modlength%8=0)
+ *	#ifdef MC2
+ *		encrypt_premaster_secret = pointer to modlength-byte value.
+ *	#else
+ *		encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	#endif
+ *		client_random = pointer to 32 bytes of random data
+ *		server_random = pointer to 32 bytes of random data
+ *		handshake_length = size in bytes of the handshake message data
+ *		handshake = pointer to the handshake message data
+ *
+ * Output
+ *		verify_data = pointer to 36 bytes of verify data 
+ *		encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *				returned encrypted master secret : don't care
+ *		request_id = Unique ID for this request
+ *
+ * Return Value
+ *		0  = success 
+ *		>0 = failure or pending
+ *		see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerifyAes (n1_request_type request_type,
+			Uint64 context_handle,
+			Uint64 * key_handle,
+			HashType hash_type,
+			SslVersion ssl_version,
+			AesType aes_type,
+			MasterSecretReturn master_secret_ret,
+			Uint16 modlength,
+			Uint8 * encrypt_premaster_secret,
+			Uint8 * client_random,
+			Uint8 * server_random,
+			Uint16 handshake_length,
+			Uint8 * handshake,
+			Uint8 * verify_data,
+			Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API 
+                        Uint32 * request_id, Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                       )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+#ifndef MC2
+  Uint16 param = 0;
+#endif
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+#ifndef MC2
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#else
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x5 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+#endif
+
+    }
+  else if ((modlength > 128) && (modlength <= 512))
+    {
+#ifdef MC2
+      buffer.opcode =
+	(master_secret_ret << 14) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#else
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x5 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+#endif
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.size = modlength;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+  buffer.dlen = 8 + modlength + 32 + 32 + handshake_length;
+#else
+  hash_size = 20 - (hash_type << 2);
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[4] = handshake_length;
+#else
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[4] = UNIT_8_BIT;
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen = 48 + 36;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.rlen = 36;
+      buffer.outcnt = 1;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+
+#else
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1RsaServerVerifyAesFinish
+ *
+ * Do much of the full handshake - up to the point of the 
+ * verify - in the case when client authentication is required. This is used in 
+ * a full handshake on the server. This entry point handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)
+ *	encrypt_premaster_secret = pointer to modlength-byte value in integer format
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaServerVerifyAesFinish (n1_request_type request_type,
+			      Uint64 context_handle,
+			      Uint64 * key_handle,
+			      HashType hash_type,
+			      SslVersion ssl_version,
+			      AesType aes_type,
+			      MasterSecretReturn master_secret_ret,
+			      Uint16 modlength,
+			      Uint8 * encrypt_premaster_secret,
+			      Uint8 * client_random,
+			      Uint8 * server_random,
+			      Uint16 handshake_length,
+			      Uint8 * handshake,
+			      Uint8 * verify_data,
+			      Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+			      Uint32 * request_id, Uint32 dev_id
+#else
+			      Uint32 * request_id
+#endif
+                         )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param = 0;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((modlength & 0x7) != 0)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  if ((modlength >= 64) && (modlength <= 128))
+    {
+
+      param = (modlength >> 3) - 1;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER;
+
+
+    }
+  else if ((modlength > 128) && (modlength <= 256))
+    {
+
+      param = (modlength >> 3) - 17;
+      buffer.opcode =
+	(master_secret_ret << 15) | (0x1 << 11) | ((aes_type >> 1) << 10) |
+	(ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+	MAJOR_OP_RSASERVER_LARGE;
+
+#if defined(CSP1_API_DEBUG)
+    }
+  else
+    {
+
+      return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+    }
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (8 + modlength + 32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 5;
+
+  buffer.inptr[0] = CAST_TO_X_PTR((Uint8 *) key_handle);
+  buffer.insize[0] = 8;
+  buffer.inoffset[0] = 8;
+  buffer.inunit[0] = UNIT_64_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( encrypt_premaster_secret);
+  buffer.insize[1] = modlength;
+  buffer.inoffset[1] = modlength;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( client_random);
+  buffer.insize[2] = 32;
+  buffer.inoffset[2] = 32;
+  buffer.inunit[2] = UNIT_8_BIT;
+  buffer.inptr[3] = CAST_TO_X_PTR( server_random);
+  buffer.insize[3] = 32;
+  buffer.inoffset[3] = 32;
+  buffer.inunit[3] = UNIT_8_BIT;
+  buffer.inptr[4] = CAST_TO_X_PTR( handshake);
+  buffer.insize[4] = handshake_length;
+  buffer.inoffset[4] = ROUNDUP8 (handshake_length);
+  buffer.inunit[4] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullRc4
+ *
+ * Do a full handshake without RSA operation. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the RC4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFullRc4 (n1_request_type request_type,
+		  Uint64 context_handle,
+		  HashType hash_type,
+		  SslVersion ssl_version,
+		  Rc4Type rc4_type,
+		  MasterSecretReturn master_secret_ret,
+		  Uint16 pre_master_length,
+		  Uint8 * client_random,
+		  Uint8 * server_random,
+		  Uint16 handshake_length,
+		  Uint8 * handshake,
+		  Uint8 * client_finished_message,
+		  Uint8 * server_finished_message,
+		  Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 * request_id, Uint32 dev_id
+#else
+                  Uint32 * request_id
+#endif
+                 )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (rc4_type << 3) | (1 << 7);
+
+  buffer.opcode = (master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+  buffer.rlen = 2 * (finished_size + hash_size);
+   
+#else
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x3 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+
+  buffer.size = handshake_length;
+
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length))>>3;
+
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+#endif
+
+  buffer.param = param;
+  
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifndef MC2
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#else
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += 48;
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+      buffer.outsize[1] = finished_size + hash_size;
+      buffer.outoffset[1] = finished_size + hash_size;
+      buffer.outunit[1] = UNIT_8_BIT;
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+      buffer.outsize[2] = finished_size + hash_size;
+      buffer.outoffset[2] = finished_size + hash_size;
+      buffer.outunit[2] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+      buffer.outsize[0] = finished_size + hash_size;
+      buffer.outoffset[0] = finished_size + hash_size;
+      buffer.outunit[0] = UNIT_8_BIT;
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+      buffer.outsize[1] = finished_size + hash_size;
+      buffer.outoffset[1] = finished_size + hash_size;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherFullRc4Finish
+ *
+ * Do a full handshake without RSA operation. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the rc4
+ * cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFullRc4Finish (n1_request_type request_type,
+			Uint64 context_handle,
+			HashType hash_type,
+			SslVersion ssl_version,
+			Rc4Type rc4_type,
+			MasterSecretReturn master_secret_ret,
+			Uint16 pre_master_length,
+			Uint8 * client_random,
+			Uint8 * server_random,
+			Uint16 handshake_length,
+			Uint8 * handshake,
+			Uint8 * client_finished_message,
+			Uint8 * server_finished_message,
+			Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 * request_id,Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                       )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+#if defined(CSP1_API_DEBUG)
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x2 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+   buffer.status = 0; 
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyRc4
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerifyRc4 (n1_request_type request_type,
+		    Uint64 context_handle,
+		    HashType hash_type,
+		    SslVersion ssl_version,
+		    Rc4Type rc4_type,
+		    MasterSecretReturn master_secret_ret,
+		    Uint16 pre_master_length,
+		    Uint8 * client_random,
+		    Uint8 * server_random,
+		    Uint16 handshake_length,
+		    Uint8 * handshake,
+		    Uint8 * verify_data,
+		    Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                    Uint32 * request_id,Uint32 dev_id
+#else
+                    Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (rc4_type << 3) | (1 << 7);
+
+  buffer.opcode = (master_secret_ret << 14) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+  buffer.rlen = 36;
+
+#else
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x1 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+  buffer.param = param;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifndef MC2
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+#else
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += 48;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.outcnt = 1;
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+
+#endif
+
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+  
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyRc4Finish
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point
+ * handles all the rc4 cases.
+ *
+ * The handshake message data for this request should include all handshake message
+ * data after (and including) the client hello message up until (but not
+ * including) the client verify message. Handshake data can be accumulated prior 
+ * to this request by calls to Handshake*, and this request will append 
+ * the included handshake message data to the pre-existing handshake hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerifyRc4Finish (n1_request_type request_type,
+			  Uint64 context_handle,
+			  HashType hash_type,
+			  SslVersion ssl_version,
+			  Rc4Type rc4_type,
+			  MasterSecretReturn master_secret_ret,
+			  Uint16 pre_master_length,
+			  Uint8 * client_random,
+			  Uint8 * server_random,
+			  Uint16 handshake_length,
+			  Uint8 * handshake,
+			  Uint8 * verify_data,
+			  Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                          Uint32 * request_id,Uint32 dev_id
+#else
+                          Uint32 * request_id
+#endif
+                        )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  param = (pre_master_length >> 2) - 1;
+
+#ifdef MC2
+  buffer.opcode = (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = 0;
+  buffer.param = (hash_type) | (ssl_version << 2) | (RC4_128 << 3);
+  buffer.dlen = handshake_length;
+  buffer.rlen = 2 * (finished_size + hash_size);
+#else
+
+  buffer.opcode = (master_secret_ret << 15) | (0x0 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = handshake_length;
+#endif
+
+#ifdef MC2
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = finished_size + hash_size;
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = finished_size + hash_size;
+  buffer.outunit[1] = UNIT_8_BIT;
+#else
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+#endif
+
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFull3Des
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFull3Des (n1_request_type request_type,
+		   Uint64 context_handle,
+		   HashType hash_type,
+		   SslVersion ssl_version,
+		   DesType des_type,
+		   MasterSecretReturn master_secret_ret,
+		   ClientFinishMessageOutput clnt_fin_msg_out,
+		   ServerFinishMessageOutput srvr_fin_msg_out,
+		   Uint16 client_pad_length,
+		   Uint16 server_pad_length,
+		   Uint16 pre_master_length,
+		   Uint8 * client_random,
+		   Uint8 * server_random,
+		   Uint16 handshake_length,
+		   Uint8 * handshake,
+		   Uint8 * client_finished_message,
+		   Uint8 * server_finished_message,
+		   Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                   Uint32 * request_id,Uint32 dev_id
+#else
+                   Uint32 * request_id
+#endif
+                  )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (des_type << 3) | (1 << 7);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    param |= (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    param |= (1 << 9);
+
+  buffer.opcode = (master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+
+  buffer.rlen = 0;
+
+#else
+  param = (pre_master_length >> 2) - 1;
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x7 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+  
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  
+  buffer.rlen = 8 >> 3;
+
+  buffer.size = handshake_length;
+#endif
+
+  buffer.param = param;
+  
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+  {
+      buffer.rlen = 48;
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+         buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+         buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+
+      }
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[1] = finished_size;
+         buffer.outoffset[1] = finished_size;
+      }
+
+      buffer.outunit[1] = UNIT_8_BIT;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+         buffer.outsize[2] = ROUNDUP8 (finished_size + hash_size + 1);
+         buffer.outoffset[2] = ROUNDUP8 (finished_size + hash_size + 1);
+      }
+
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[2] = finished_size;
+         buffer.outoffset[2] = finished_size;
+      }
+
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+    {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+         buffer.outsize[0] = ROUNDUP8 (finished_size + hash_size + 1);
+         buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size + 1);
+      }
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[0] = finished_size;
+         buffer.outoffset[0] = finished_size;
+      }
+
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+         buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+         buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+      }
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[1] = finished_size;
+         buffer.outoffset[1] = finished_size;
+      }
+
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+#else
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+#endif /* MC2 */
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherFull3DesFinish
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the DES/
+ * 3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFull3DesFinish (n1_request_type request_type,
+			 Uint64 context_handle,
+			 HashType hash_type,
+			 SslVersion ssl_version,
+			 DesType des_type,
+			 MasterSecretReturn master_secret_ret,
+			 ClientFinishMessageOutput clnt_fin_msg_out,
+			 ServerFinishMessageOutput srvr_fin_msg_out,
+			 Uint16 client_pad_length,
+			 Uint16 server_pad_length,
+			 Uint16 pre_master_length,
+			 Uint8 * client_random,
+			 Uint8 * server_random,
+			 Uint16 handshake_length,
+			 Uint8 * handshake,
+			 Uint8 * client_finished_message,
+			 Uint8 * server_finished_message,
+			 Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                         Uint32 * request_id,Uint32 dev_id
+#else
+                         Uint32 * request_id
+#endif
+                      )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode = (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = 0;
+  buffer.param = (hash_type) | (ssl_version << 2) | (DES << 3);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 9);
+
+  buffer.dlen = handshake_length;
+  buffer.rlen = 0;
+
+#else
+
+  param = (pre_master_length >> 2) - 1;
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x5 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = handshake_length;
+#endif
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+#ifdef MC2
+
+  buffer.outptr[0] =CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+      buffer.rlen = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outsize[0] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size + 1);
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+      buffer.rlen = finished_size;
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+    }
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+      buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+      buffer.rlen += finished_size;
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+    }
+  buffer.outunit[1] = UNIT_8_BIT;
+
+#else
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if ! MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerify3Des
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40, DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerify3Des (n1_request_type request_type,
+		     Uint64 context_handle,
+		     HashType hash_type,
+		     SslVersion ssl_version,
+		     DesType des_type,
+		     MasterSecretReturn master_secret_ret,
+		     Uint16 pre_master_length,
+		     Uint8 * client_random,
+		     Uint8 * server_random,
+		     Uint16 handshake_length,
+		     Uint8 * handshake,
+		     Uint8 * verify_data,
+		     Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API 
+                     Uint32 * request_id,Uint32 dev_id
+#else
+                     Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (des_type << 3) | (1 << 7);
+
+  buffer.opcode = (master_secret_ret << 14) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+
+  buffer.rlen = 36;
+
+#else
+
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x3 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+
+  buffer.param = param;
+
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifndef MC2
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+#else
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += 48;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.outcnt = 1;
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherVerify3DesFinish
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerify3DesFinish (n1_request_type request_type,
+			   Uint64 context_handle,
+			   HashType hash_type,
+			   SslVersion ssl_version,
+			   DesType des_type,
+			   MasterSecretReturn master_secret_ret,
+			   Uint16 pre_master_length,
+			   Uint8 * client_random,
+			   Uint8 * server_random,
+			   Uint16 handshake_length,
+			   Uint8 * handshake,
+			   Uint8 * verify_data,
+			   Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 * request_id,Uint32 dev_id
+#else
+                           Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode = (master_secret_ret << 15) | (0x1 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherFullAes
+ *
+ * Do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFullAes (n1_request_type request_type,
+		  Uint64 context_handle,
+		  HashType hash_type,
+		  SslVersion ssl_version,
+		  AesType aes_type,
+		  MasterSecretReturn master_secret_ret,
+		  ClientFinishMessageOutput clnt_fin_msg_out,
+		  ServerFinishMessageOutput srvr_fin_msg_out,
+		  Uint16 client_pad_length,
+		  Uint16 server_pad_length,
+		  Uint16 pre_master_length,
+		  Uint8 * client_random,
+		  Uint8 * server_random,
+		  Uint16 handshake_length,
+		  Uint8 * handshake,
+		  Uint8 * client_finished_message,
+		  Uint8 * server_finished_message,
+		  Uint8 * encrypt_master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                  Uint32 * request_id,Uint32 dev_id
+#else
+                  Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    param |= (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    param |= (1 << 9);
+
+  buffer.opcode = (master_secret_ret << 14) | (0x1 << 13) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+
+  buffer.rlen = 0;
+
+#else
+  param = (pre_master_length >> 2) - 1;
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  buffer.opcode =
+    (master_secret_ret << 15) | (0xd << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+#endif
+
+  buffer.param = param;
+  
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifdef MC2
+  if (master_secret_ret == RETURN_ENCRYPTED)
+  {
+      buffer.rlen = 48;
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+         buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+         buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+      }
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[1] = finished_size;
+         buffer.outoffset[1] = finished_size;
+      }
+
+      buffer.outunit[1] = UNIT_8_BIT;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+         buffer.outsize[2] = ROUNDUP16 (finished_size + hash_size + 1);
+         buffer.outoffset[2] = ROUNDUP16 (finished_size + hash_size + 1);
+      }
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[2] = finished_size;
+         buffer.outoffset[2] = finished_size;
+      }
+
+      buffer.outunit[2] = UNIT_8_BIT;
+
+  }
+  else if (master_secret_ret == NOT_RETURNED)
+  {
+      buffer.outcnt = 2;
+      buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+      if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+         buffer.outsize[0] = ROUNDUP16 (finished_size + hash_size + 1);
+         buffer.outoffset[0] = ROUNDUP16 (finished_size + hash_size + 1);
+      }
+      else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[0] = finished_size;
+         buffer.outoffset[0] = finished_size;
+      }
+
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+      if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+      {
+         buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+         buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+         buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+      }
+      else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+      {
+         buffer.rlen += finished_size;
+
+         buffer.outsize[1] = finished_size;
+         buffer.outoffset[1] = finished_size;
+      }
+
+      buffer.outunit[1] = UNIT_8_BIT;
+   }
+
+#else
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+#endif /* MC2 */
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherFullAesFinish
+ *
+ * When not (RSA <= 1024), do a full handshake. The pre-master secret is read
+ * from the context and the rest of the handshake is completed. This is used
+ * by both the server and the client. This entry point handles all the
+ * AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the first finished message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherFullAesFinish (n1_request_type request_type,
+			Uint64 context_handle,
+			HashType hash_type,
+			SslVersion ssl_version,
+			AesType aes_type,
+			MasterSecretReturn master_secret_ret,
+			ClientFinishMessageOutput clnt_fin_msg_out,
+			ServerFinishMessageOutput srvr_fin_msg_out,
+			Uint16 client_pad_length,
+			Uint16 server_pad_length,
+			Uint16 pre_master_length,
+			Uint8 * client_random,
+			Uint8 * server_random,
+			Uint16 handshake_length,
+			Uint8 * handshake,
+			Uint8 * client_finished_message,
+			Uint8 * server_finished_message,
+			Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 * request_id,Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  param = (pre_master_length >> 2) - 1;
+
+  param |= (server_pad_length << 11) | (client_pad_length << 6);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    param |= 0x1f << 11;
+
+  buffer.opcode =
+    (master_secret_ret << 15) | (0x9 << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 3;
+
+      buffer.outptr[2] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[2] = 48;
+      buffer.outoffset[2] = 48;
+      buffer.outunit[2] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 2;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyAes
+ *
+ * Do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerifyAes (n1_request_type request_type,
+		    Uint64 context_handle,
+		    HashType hash_type,
+		    SslVersion ssl_version,
+		    AesType aes_type,
+		    MasterSecretReturn master_secret_ret,
+		    Uint16 pre_master_length,
+		    Uint8 * client_random,
+		    Uint8 * server_random,
+		    Uint16 handshake_length,
+		    Uint8 * handshake,
+		    Uint8 * verify_data,
+		    Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                    Uint32 * request_id,Uint32 dev_id
+#else
+                    Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  param = (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+
+  buffer.opcode = (master_secret_ret << 14) | (global_dma_mode << 7) |
+       MAJOR_OP_OTHER;
+
+  buffer.size = pre_master_length;
+
+  hash_size = (hash_type == SHA1_TYPE)? 20:16;
+
+  buffer.dlen = 32 + 32 + handshake_length;
+
+  buffer.rlen = 36;
+
+#else
+
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode =
+    (master_secret_ret << 15) | (0x5 << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+#endif
+
+  buffer.param = param;
+
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[2] = handshake_length;
+#else
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[2] = UNIT_8_BIT;
+
+#ifndef MC2
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+#else
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+      buffer.rlen += 48;
+      buffer.outcnt = 2;
+
+      buffer.outptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[0] = 48;
+      buffer.outoffset[0] = 48;
+      buffer.outunit[0] = UNIT_8_BIT;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[1] = 36;
+      buffer.outoffset[1] = 36;
+      buffer.outunit[1] = UNIT_8_BIT;
+    }
+  else
+    {
+      buffer.outcnt = 1;
+      buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+      buffer.outsize[0] = 36;
+      buffer.outoffset[0] = 36;
+      buffer.outunit[0] = UNIT_8_BIT;
+    }
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1OtherVerifyAesFinish
+ *
+ * do a full handshake - up to the point of the
+ * verify operation. The pre-master secret is read from the context.
+ * This is used by both the server and the client. This entry point handles all 
+ * the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the client hello message up until (but 
+ * not including) the client verify message. Handshake data can be accumulated 
+ * prior to this request by calls to Handshake*, and this request will 
+ * append the included handshake message data to the pre-existing handshake 
+ * hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_ret = NOT_RETURNED or RETURN_ENCRYPTED
+ *	pre_master_length = size of premaster secret in bytes 
+ *		(SSLv3: 4<=modlength<=256, modlength%4=0; 
+ *		 TLS: 16<=modlength<=128, modlength%16=0)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	verify_data = pointer to 36 bytes of verify data 
+ *	encrypt_master_secret = (master_secret_ret == RETURN_ENCRYPTED) ? pointer to
+ *		returned encrypted master secret : don't care
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1OtherVerifyAesFinish (n1_request_type request_type,
+			  Uint64 context_handle,
+			  HashType hash_type,
+			  SslVersion ssl_version,
+			  AesType aes_type,
+			  MasterSecretReturn master_secret_ret,
+			  Uint16 pre_master_length,
+			  Uint8 * client_random,
+			  Uint8 * server_random,
+			  Uint16 handshake_length,
+			  Uint8 * handshake,
+			  Uint8 * verify_data,
+			  Uint8 * encrypt_master_secret, 
+#ifdef CAVIUM_MULTICARD_API
+                          Uint32 * request_id, Uint32 dev_id
+#else
+                          Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 param;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((ssl_version == VER3_0)
+      && (((pre_master_length & 0x3) != 0) || (pre_master_length > 256)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  if ((ssl_version == VER_TLS)
+      && (((pre_master_length & 0xf) != 0) || (pre_master_length > 128)))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+  param = (pre_master_length >> 2) - 1;
+
+  buffer.opcode =
+    (master_secret_ret << 15) | (0x1 << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_OTHER;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = param;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (40 + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 3;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+  buffer.insize[1] = 32;
+  buffer.inoffset[1] = 32;
+  buffer.inunit[1] = UNIT_8_BIT;
+  buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+  buffer.insize[2] = handshake_length;
+  buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+  buffer.inunit[2] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( verify_data);
+  buffer.outsize[0] = 36;
+  buffer.outoffset[0] = 40;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  if (master_secret_ret == RETURN_ENCRYPTED)
+    {
+
+      buffer.rlen += (48 >> 3);
+
+      buffer.outcnt = 2;
+
+      buffer.outptr[1] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.outsize[1] = 48;
+      buffer.outoffset[1] = 48;
+      buffer.outunit[1] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_ret == NOT_RETURNED)
+
+    buffer.outcnt = 1;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status = 0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1FinishedRc4Finish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the RC4 cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyRc4* or 
+ * OtherVerifyRc4*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1FinishedRc4Finish (n1_request_type request_type,
+		       Uint64 context_handle,
+		       HashType hash_type,
+		       SslVersion ssl_version,
+		       Uint16 handshake_length,
+		       Uint8 * handshake,
+		       Uint8 * client_finished_message,
+		       Uint8 * server_finished_message, 
+#ifdef CAVIUM_MULTICARD_API
+                       Uint32 * request_id,Uint32 dev_id
+#else
+                       Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+#ifdef MC2
+  buffer.opcode = (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = 0;
+  buffer.param = (hash_type) | (ssl_version << 2) | (RC4_128 << 3);
+  buffer.dlen = handshake_length;
+  buffer.rlen = 2 * (finished_size + hash_size);
+#else
+  buffer.opcode = (0x0 << 10) | (ssl_version << 9) | (hash_type << 8)
+    | (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 2;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( handshake);
+  buffer.insize[0] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[0] = handshake_length;
+#else
+  buffer.inoffset[0] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = finished_size + hash_size;
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = finished_size + hash_size;
+  buffer.outunit[1] = UNIT_8_BIT;
+#else
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Finished3DesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all DES/3DES 
+ * cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerify3Des* or 
+ * OtherVerify3Des*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Finished3DesFinish (n1_request_type request_type,
+			Uint64 context_handle,
+			HashType hash_type,
+			SslVersion ssl_version,
+			ClientFinishMessageOutput clnt_fin_msg_out,
+			ServerFinishMessageOutput srvr_fin_msg_out,
+			Uint16 client_pad_length,
+			Uint16 server_pad_length,
+			Uint16 handshake_length,
+			Uint8 * handshake,
+			Uint8 * client_finished_message,
+			Uint8 * server_finished_message, 
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 * request_id,Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+#ifdef MC2
+  buffer.opcode = (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = 0;
+  buffer.param = (hash_type) | (ssl_version << 2) | (DES << 3);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 9);
+
+  buffer.dlen = handshake_length;
+  buffer.rlen = 0;
+
+#else
+  buffer.opcode = (0x1 << 10) | (ssl_version << 9) | (hash_type << 8)
+    | (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = (server_pad_length << 11) | (client_pad_length << 6);
+  buffer.dlen = (ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+#endif
+
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  buffer.incnt = 1;
+  buffer.outcnt = 2;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( handshake);
+  buffer.insize[0] = handshake_length;
+#ifdef MC2
+  buffer.inoffset[0] = handshake_length;
+#else
+  buffer.inoffset[0] = ROUNDUP8 (handshake_length);
+#endif
+  buffer.inunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+
+#ifdef MC2
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+      buffer.rlen = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outsize[0] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size + 1);
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+      buffer.rlen = finished_size;
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+    }
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+      buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+      buffer.rlen += finished_size;
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+    }
+  buffer.outunit[1] = UNIT_8_BIT;
+
+#else
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+
+  buffer.status=0;
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1FinishedAesFinish
+ *
+ * Finish off the handshake hash and generate the finished messages for a full 
+ * handshake. This is used in a full handshake with client authentication on 
+ * either the client or the server. This follows RsaserverVerify or 
+ * OtherVerify in that case. This entry point handles all the AES cases.
+ *
+ * The handshake hash context should include handshake messages from the
+ * client hello message up until (but not including) the client verify message. 
+ * This state should have been set up by a prior RsaserverVerifyAes* or 
+ * OtherVerifyAes*. The handshake message data for this request should include 
+ * the certificate verify message.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1FinishedAesFinish (n1_request_type request_type,
+		       Uint64 context_handle,
+		       HashType hash_type,
+		       SslVersion ssl_version,
+		       AesType aes_type,
+		       ClientFinishMessageOutput clnt_fin_msg_out,
+		       ServerFinishMessageOutput srvr_fin_msg_out,
+		       Uint16 client_pad_length,
+		       Uint16 server_pad_length,
+		       Uint16 handshake_length,
+		       Uint8 * handshake,
+		       Uint8 * client_finished_message,
+		       Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                        Uint32 * request_id,Uint32 dev_id
+#else
+                        Uint32 * request_id
+#endif
+                   )
+{
+
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+#ifdef MC2
+  buffer.opcode = (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = 0;
+  buffer.param = (hash_type) | (ssl_version << 2) | (aes_type << 3);
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 8);
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 9);
+
+  buffer.dlen = handshake_length;
+  buffer.rlen = 0;
+
+#else
+  buffer.opcode = (0x1 << 11) | ((aes_type >> 1) << 10) | (ssl_version << 9)
+    | (hash_type << 8) | (global_dma_mode << 7) | MAJOR_OP_FINISHED;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = (server_pad_length << 11) | (client_pad_length << 6);
+  buffer.dlen = (ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  buffer.incnt = 1;
+  buffer.outcnt = 2;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( handshake);
+  buffer.insize[0] = handshake_length;
+  buffer.inoffset[0] = ROUNDUP8 (handshake_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = handshake_length;
+#endif
+
+#ifdef MC2
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+      buffer.rlen = ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outsize[0] = ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outoffset[0] = ROUNDUP16 (finished_size + hash_size + 1);
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+      buffer.rlen = finished_size;
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+    }
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+      buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+      buffer.rlen += finished_size;
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+    }
+  buffer.outunit[1] = UNIT_8_BIT;
+
+#else
+  buffer.outptr[0] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+#endif
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeRc4
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ResumeRc4 (n1_request_type request_type,
+	       Uint64 context_handle,
+	       HashType hash_type,
+	       SslVersion ssl_version,
+	       Rc4Type rc4_type,
+	       MasterSecretInput master_secret_inp,
+	       Uint8 * client_random,
+	       Uint8 * server_random,
+	       Uint8 * encrypt_master_secret,
+	       Uint16 handshake_length,
+	       Uint8 * handshake,
+	       Uint8 * client_finished_message,
+	       Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+               Uint32 * request_id,Uint32 dev_id
+#else
+               Uint32 * request_id
+#endif
+               )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.opcode = (master_secret_inp << 14) | MAJOR_OP_RESUME;
+  buffer.size = 0;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (rc4_type << 3) | (1 << 7);
+  buffer.dlen = 32 + 32 + handshake_length;
+  buffer.rlen = 2 * (finished_size + hash_size);
+#else
+
+  buffer.opcode = (master_secret_inp << 15) | (0x1 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = 0;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.dlen += 48;
+#else
+      buffer.dlen += (48 >> 3);
+#endif
+
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR( handshake);
+      buffer.insize[3] = handshake_length;
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+      buffer.inunit[3] = UNIT_8_BIT;
+
+#ifdef MC2
+      buffer.inoffset[3] = handshake_length;
+#endif
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+      buffer.inunit[2] = UNIT_8_BIT;
+
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+#ifdef MC2
+  buffer.outoffset[1] = finished_size + hash_size;
+#else
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+#endif
+  buffer.outunit[1] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.outoffset[0] = finished_size + hash_size;
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1ResumeRc4Finish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the RC4 cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	rc4_type = RC4_128, RC4_EXPORT_40, or RC4_EXPORT_56
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ResumeRc4Finish (n1_request_type request_type,
+		     Uint64 context_handle,
+		     HashType hash_type,
+		     SslVersion ssl_version,
+		     Rc4Type rc4_type,
+		     MasterSecretInput master_secret_inp,
+		     Uint8 * client_random,
+		     Uint8 * server_random,
+		     Uint8 * encrypt_master_secret,
+		     Uint16 handshake_length,
+		     Uint8 * handshake,
+		     Uint8 * client_finished_message,
+		     Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                     Uint32 * request_id,Uint32 dev_id
+#else
+                     Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  buffer.opcode = (master_secret_inp << 15) | (0x0 << 13) | (rc4_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = 0;
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (finished_size + hash_size)
+		 + ROUNDUP8 (finished_size + hash_size) + 8) >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+      buffer.dlen += (48 >> 3);
+
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR( handshake);
+      buffer.insize[3] = handshake_length;
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+      buffer.inunit[3] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] =CAST_TO_X_PTR(  server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+      buffer.inunit[2] = UNIT_8_BIT;
+
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+  buffer.outsize[0] = finished_size + hash_size;
+  buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[0] = UNIT_8_BIT;
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+  buffer.outsize[1] = finished_size + hash_size;
+  buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size);
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+/*+****************************************************************************
+ *
+ * Csp1Resume3Des
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min(not applicable to MC2)
+ *	server_pad_length = number of 64-bit words to pad above min(not applicable to MC2)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Resume3Des (n1_request_type request_type,
+		Uint64 context_handle,
+		HashType hash_type,
+		SslVersion ssl_version,
+		DesType des_type,
+		MasterSecretInput master_secret_inp,
+		ClientFinishMessageOutput clnt_fin_msg_out,
+		ServerFinishMessageOutput srvr_fin_msg_out,
+		Uint16 client_pad_length,
+		Uint16 server_pad_length,
+		Uint8 * client_random,
+		Uint8 * server_random,
+		Uint8 * encrypt_master_secret,
+		Uint16 handshake_length,
+		Uint8 * handshake,
+		Uint8 * client_finished_message,
+		Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                Uint32 * request_id,Uint32 dev_id
+#else
+                Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.opcode = (master_secret_inp << 14) | MAJOR_OP_RESUME;
+  buffer.size = 0;
+
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (des_type << 3) | (1 << 7);
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 8);
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 9);
+
+  buffer.dlen = 32 + 32 + handshake_length;
+  buffer.rlen = 0;
+#else
+  buffer.opcode = (master_secret_inp << 15) | (0x3 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = (client_pad_length << 11) | (server_pad_length << 6);
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.dlen += 48;
+#else
+      buffer.dlen += (48 >> 3);
+#endif
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] =CAST_TO_X_PTR(  handshake);
+      buffer.insize[3] = handshake_length;
+#ifdef MC2
+      buffer.inoffset[3] = handshake_length;
+#else
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+#endif
+      buffer.inunit[3] = UNIT_8_BIT;
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+#ifdef MC2
+      buffer.inoffset[2] = handshake_length;
+#else
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+#endif
+      buffer.inunit[2] = UNIT_8_BIT;
+
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+  {
+
+#ifdef MC2
+      buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+      buffer.outsize[0] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[0] = ROUNDUP8 (finished_size + hash_size + 1);
+#else
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+#endif
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.rlen += finished_size;
+#else
+      buffer.rlen += (finished_size >> 3);
+#endif
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+#ifdef MC2
+      buffer.rlen += ROUNDUP8 (finished_size + hash_size + 1);
+
+      buffer.outsize[1] = ROUNDUP8 (finished_size + hash_size + 1);
+      buffer.outoffset[1] = ROUNDUP8 (finished_size + hash_size + 1);
+#else
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+#endif
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.rlen += finished_size;
+#else
+      buffer.rlen += (finished_size >> 3);
+#endif
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1Resume3DesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the DES/3DES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	des_type = DES, DES_EXPORT_40 or DES3_192
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 64-bit words to pad above min
+ *	server_pad_length = number of 64-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Resume3DesFinish (n1_request_type request_type,
+		      Uint64 context_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      DesType des_type,
+		      MasterSecretInput master_secret_inp,
+		      ClientFinishMessageOutput clnt_fin_msg_out,
+		      ServerFinishMessageOutput srvr_fin_msg_out,
+		      Uint16 client_pad_length,
+		      Uint16 server_pad_length,
+		      Uint8 * client_random,
+		      Uint8 * server_random,
+		      Uint8 * encrypt_master_secret,
+		      Uint16 handshake_length,
+		      Uint8 * handshake,
+		      Uint8 * client_finished_message,
+		      Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id,Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  buffer.opcode = (master_secret_inp << 15) | (0x1 << 12) | (des_type << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = (client_pad_length << 11) | (server_pad_length << 6);
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+      buffer.dlen += (48 >> 3);
+
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR( handshake);
+      buffer.insize[3] = handshake_length;
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+      buffer.inunit[3] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+      buffer.inunit[2] = UNIT_8_BIT;
+
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * client_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP8 (finished_size + hash_size + 1) +
+	  8 * server_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP8 (finished_size + hash_size + 1) + 8 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1ResumeAes
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. 
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min(not applicable to MC2)
+ *	server_pad_length = number of 128-bit words to pad above min(not applicable to MC2)
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ResumeAes (n1_request_type request_type,
+	       Uint64 context_handle,
+	       HashType hash_type,
+	       SslVersion ssl_version,
+	       AesType aes_type,
+	       MasterSecretInput master_secret_inp,
+	       ClientFinishMessageOutput clnt_fin_msg_out,
+	       ServerFinishMessageOutput srvr_fin_msg_out,
+	       Uint16 client_pad_length,
+	       Uint16 server_pad_length,
+	       Uint8 * client_random,
+	       Uint8 * server_random,
+	       Uint8 * encrypt_master_secret,
+	       Uint16 handshake_length,
+	       Uint8 * handshake,
+	       Uint8 * client_finished_message,
+	       Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+               Uint32 * request_id,Uint32 dev_id
+#else
+               Uint32 * request_id
+#endif
+              )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  finished_size = 16 + 24 * ssl_version;
+
+#ifdef MC2
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.opcode = (master_secret_inp << 14) | MAJOR_OP_RESUME;
+  buffer.size = 0;
+
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 8);
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    buffer.param |= (Uint16) (1 << 9);
+
+  buffer.dlen = 32 + 32 + handshake_length;
+  buffer.rlen = 0;
+
+#else
+  buffer.opcode =
+    (master_secret_inp << 15) | (0x5 << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = handshake_length;
+  buffer.param = (client_pad_length << 11) | (server_pad_length << 6);
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+#endif
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.dlen += 48;
+#else
+      buffer.dlen += (48 >> 3);
+#endif
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR( handshake);
+      buffer.insize[3] = handshake_length;
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+      buffer.inunit[3] = UNIT_8_BIT;
+#ifdef MC2
+      buffer.inoffset[3] = handshake_length;
+#endif
+
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+      buffer.inunit[2] = UNIT_8_BIT;
+#ifdef MC2
+      buffer.inoffset[2] = handshake_length;
+#endif
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+#ifdef MC2
+      buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+      buffer.outsize[0] = ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outoffset[0] = ROUNDUP16 (finished_size + hash_size + 1);
+#else
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+#endif
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.rlen += finished_size;
+#else
+      buffer.rlen += (finished_size >> 3);
+#endif
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.rlen += ROUNDUP16 (finished_size + hash_size + 1);
+
+      buffer.outsize[1] = ROUNDUP16 (finished_size + hash_size + 1);
+      buffer.outoffset[1] = ROUNDUP16 (finished_size + hash_size + 1);
+#else
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+#endif
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+#ifdef MC2
+      buffer.rlen += finished_size;
+#else
+      buffer.rlen += (finished_size >> 3);
+#endif
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+  buffer.group = CAVIUM_SSL_GRP;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1ResumeAesFinish
+ *
+ * Completes a resume on either the client or the server. This entry point 
+ * handles all the AES cases.
+ *
+ * The handshake message data for this request should include all handshake 
+ * message data after (and including) the most-recent client hello message up 
+ * until (but not including) the first finished message. Handshake data can be 
+ * accumulated prior to this request by calls to Handshake*, and this 
+ * request will append the included handshake message data to the pre-existing
+ * handshake hash state.
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	master_secret_inp = READ_FROM_CONTEXT or INPUT_ENCRYPTED
+ *	clnt_fin_msg_out = RETURN_CFM_ENCRYPTED or RETURN_CFM_UNENCRYPTED
+ *	srvr_fin_msg_out = RETURN_SFM_ENCRYPTED or RETURN_SFM_UNENCRYPTED
+ *	client_pad_length = number of 128-bit words to pad above min
+ *	server_pad_length = number of 128-bit words to pad above min
+ *	client_random = pointer to 32 bytes of random data
+ *	server_random = pointer to 32 bytes of random data
+ *	encrypt_master_secret = pointer to 48-byte secret
+ *	handshake_length = size in bytes of the handshake message data
+ *	handshake = pointer to the handshake message data
+ *
+ * Output
+ *	client_finished_message = pointer to encrypted part of client finished message 
+ *	server_finished_message = pointer to encrypted part of server finished message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1ResumeAesFinish (n1_request_type request_type,
+		     Uint64 context_handle,
+		     HashType hash_type,
+		     SslVersion ssl_version,
+		     AesType aes_type,
+		     MasterSecretInput master_secret_inp,
+		     ClientFinishMessageOutput clnt_fin_msg_out,
+		     ServerFinishMessageOutput srvr_fin_msg_out,
+		     Uint16 client_pad_length,
+		     Uint16 server_pad_length,
+		     Uint8 * client_random,
+		     Uint8 * server_random,
+		     Uint8 * encrypt_master_secret,
+		     Uint16 handshake_length,
+		     Uint8 * handshake,
+		     Uint8 * client_finished_message,
+		     Uint8 * server_finished_message,
+#ifdef CAVIUM_MULTICARD_API
+                     Uint32 * request_id,Uint32 dev_id
+#else
+                     Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 finished_size;
+  Uint16 hash_size;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+
+  buffer.opcode =
+    (master_secret_inp << 15) | (0x1 << 11) | ((aes_type >> 1) << 10) |
+    (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_RESUME;
+  hash_size = 20 - (hash_type << 2);
+  finished_size = 16 + 24 * ssl_version;
+
+  buffer.size = handshake_length;
+  buffer.param = (client_pad_length << 11) | (server_pad_length << 6);
+  buffer.dlen = (32 + 32 + ROUNDUP8 (handshake_length)) >> 3;
+  buffer.rlen = 8 >> 3;
+  buffer.ctx_ptr = context_handle;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 6;
+
+  if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+
+    buffer.param |= 0x1f << 11;
+
+  if (master_secret_inp == INPUT_ENCRYPTED)
+    {
+
+      buffer.dlen += (48 >> 3);
+
+      buffer.incnt = 4;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( encrypt_master_secret);
+      buffer.insize[0] = 48;
+      buffer.inoffset[0] = 48;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( client_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( server_random);
+      buffer.insize[2] = 32;
+      buffer.inoffset[2] = 32;
+      buffer.inunit[2] = UNIT_8_BIT;
+      buffer.inptr[3] = CAST_TO_X_PTR( handshake);
+      buffer.insize[3] = handshake_length;
+      buffer.inoffset[3] = ROUNDUP8 (handshake_length);
+      buffer.inunit[3] = UNIT_8_BIT;
+
+    }
+  else if (master_secret_inp == READ_FROM_CONTEXT)
+    {
+
+      buffer.incnt = 3;
+
+      buffer.inptr[0] = CAST_TO_X_PTR( client_random);
+      buffer.insize[0] = 32;
+      buffer.inoffset[0] = 32;
+      buffer.inunit[0] = UNIT_8_BIT;
+      buffer.inptr[1] = CAST_TO_X_PTR( server_random);
+      buffer.insize[1] = 32;
+      buffer.inoffset[1] = 32;
+      buffer.inunit[1] = UNIT_8_BIT;
+      buffer.inptr[2] = CAST_TO_X_PTR( handshake);
+      buffer.insize[2] = handshake_length;
+      buffer.inoffset[2] = ROUNDUP8 (handshake_length);
+      buffer.inunit[2] = UNIT_8_BIT;
+
+    }
+
+  buffer.outcnt = 2;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( client_finished_message);
+
+  if (clnt_fin_msg_out == RETURN_CFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * client_pad_length) >> 3);
+
+      buffer.outsize[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+      buffer.outoffset[0] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * client_pad_length;
+
+    }
+  else if (clnt_fin_msg_out == RETURN_CFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[0] = finished_size;
+      buffer.outoffset[0] = finished_size;
+
+    }
+
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.outptr[1] = CAST_TO_X_PTR( server_finished_message);
+
+  if (srvr_fin_msg_out == RETURN_SFM_ENCRYPTED)
+    {
+
+      buffer.rlen +=
+	((ROUNDUP16 (finished_size + hash_size + 1) +
+	  16 * server_pad_length) >> 3);
+
+      buffer.outsize[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+      buffer.outoffset[1] =
+	ROUNDUP16 (finished_size + hash_size + 1) + 16 * server_pad_length;
+
+    }
+  else if (srvr_fin_msg_out == RETURN_SFM_UNENCRYPTED)
+    {
+
+      buffer.rlen += (finished_size >> 3);
+
+      buffer.outsize[1] = finished_size;
+      buffer.outoffset[1] = finished_size;
+
+    }
+
+  buffer.outunit[1] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+#endif /* if !MC2 */
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecordRc4
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	message_length = size of message in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to (length + hash_size) bytes of encrypted record 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1EncryptRecordRc4 (n1_request_type request_type,
+		      Uint64 context_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      SslPartyType ssl_party,
+		      MessageType message_type,
+		      Uint16 message_length,
+		      Uint8 * message, Uint8 * record,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id,Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 62;
+  else
+    context_offset = 8 * 22;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if (message_length > 0x4400)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode =
+    (0x1 << 14) | (message_type << 12) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.param = (hash_type) | (ssl_version << 2) | (RC4_128 << 3);
+  buffer.dlen = message_length;
+  buffer.rlen = message_length + hash_size;
+#else
+
+  buffer.opcode = (0x0 << 15) | (message_type << 12) | (0x0 << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7)
+    | MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = message_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (message_length + hash_size) + 8) >> 3;
+#endif
+
+  buffer.size = message_length;
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+#ifdef MC2
+  buffer.inoffset[0] = message_length;
+#endif
+
+  buffer.outptr[0] = CAST_TO_X_PTR( record);
+  buffer.outsize[0] = message_length + hash_size;
+
+#ifdef MC2
+  buffer.outoffset[0] = message_length + hash_size;
+#else
+  buffer.outoffset[0] =
+    (global_dma_mode ==
+     CAVIUM_DIRECT) ? ROUNDUP8 (message_length +
+				hash_size) : (message_length + hash_size);
+#endif
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordRc4
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of record in bytes (0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to (record length - hash size) bytes 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1DecryptRecordRc4 (n1_request_type request_type,
+		      Uint64 context_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      SslPartyType ssl_party,
+		      MessageType message_type,
+		      Uint16 record_length,
+		      Uint8 * record, Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id,Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 22;
+  else
+    context_offset = 8 * 62;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if (record_length > 0x4400)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode =
+    ((0xb << 12) & (message_type << 12)) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+  buffer.param = (hash_type) | (ssl_version << 2) | (RC4_128 << 3) | (1 << 7);
+  buffer.dlen = record_length;
+  buffer.rlen = record_length;
+  buffer.size = record_length;
+#else
+  buffer.opcode = (0x1 << 15) | (message_type << 12) | (0x0 << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7)
+    | MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = record_length;
+  buffer.param = 0;
+  buffer.dlen = (ROUNDUP8 (record_length)) >> 3;
+  buffer.rlen = (ROUNDUP8 (record_length) + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( record);
+  buffer.insize[0] = record_length;
+  buffer.inoffset[0] = ROUNDUP8 (record_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = record_length;
+#endif
+  buffer.outptr[0] = CAST_TO_X_PTR( message);
+  buffer.outsize[0] = record_length;
+#ifdef MC2
+  buffer.outoffset[0] = record_length;
+#else
+  buffer.outoffset[0] =
+    (global_dma_mode ==
+     CAVIUM_DIRECT) ? ROUNDUP8 (record_length) : record_length;
+#endif
+  buffer.outunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.outoffset[0] = record_length;
+#endif
+
+  buffer.req_type = request_type;
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecord3Des
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	pad_length = size of extra padding in 8-byte blocks
+ *	message_length = size of input in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte input message
+ *
+ * Output
+ *	record_length = pointer to length of the encrypted part of the record in bytes
+ *	record = pointer to *record_length-byte output 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1EncryptRecord3Des (n1_request_type request_type,
+		       Uint64 context_handle,
+		       HashType hash_type,
+		       SslVersion ssl_version,
+		       SslPartyType ssl_party,
+		       MessageType message_type,
+		       Uint16 pad_length,
+		       Uint16 message_length,
+		       Uint8 * message,
+		       Uint16 * record_length,
+		       Uint8 * record,
+#ifdef CAVIUM_MULTICARD_API
+                       Uint32 * request_id,Uint32 dev_id
+#else
+                       Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 34;
+  else
+    context_offset = 8 * 22;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if (message_length > 0x4400)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode =
+    (0x1 << 14) | (message_type << 12) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  *record_length = ROUNDUP8 (message_length + hash_size + 1);
+  buffer.size = message_length;
+  buffer.param = (hash_type) | (ssl_version << 2) | (DES << 3);
+  buffer.dlen = message_length;
+  buffer.rlen = *record_length;
+#else
+
+  buffer.opcode = (0x0 << 14) | (message_type << 12) | (0x1 << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7)
+    | MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  *record_length = ROUNDUP8 (message_length + hash_size + 1) + 8 * pad_length;
+
+  buffer.size = message_length;
+  buffer.param = pad_length;
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (*record_length + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = message_length;
+#endif
+  buffer.outptr[0] = CAST_TO_X_PTR( record);
+  buffer.outsize[0] = *record_length;
+  buffer.outoffset[0] = *record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+  
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecord3Des
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of the encrypted part of the input record in bytes 
+ *		(length%8=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of the input record
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1DecryptRecord3Des (n1_request_type request_type,
+		       Uint64 context_handle,
+		       HashType hash_type,
+		       SslVersion ssl_version,
+		       SslPartyType ssl_party,
+		       MessageType message_type,
+		       Uint16 record_length,
+		       Uint8 * record,
+		       Uint16 * message_length,
+		       Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                       Uint32 * request_id,Uint32 dev_id
+#else
+                       Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 22;
+  else
+    context_offset = 8 * 34;
+#if defined(CSP1_API_DEBUG)
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((record_length > 0x4400) || ((record_length & 0x7) != 0))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+#endif
+
+#ifdef MC2
+  buffer.opcode =
+    ((0xb << 12) & (message_type << 12)) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = record_length;
+  buffer.param = (hash_type) | (ssl_version << 2) | (DES << 3) | (1 << 7);
+  buffer.dlen = 16 + record_length;
+  buffer.rlen = record_length;
+
+#else
+  buffer.opcode = (0x2 << 14) | (message_type << 12) | (0x1 << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7)
+    | MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = record_length;
+  buffer.param = 0;
+  buffer.dlen = (16 + record_length) >> 3;
+  buffer.rlen = (record_length + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 2;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR(record + record_length - 16);
+  buffer.insize[0] = 16;
+  buffer.inoffset[0] = 16;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( record);
+  buffer.insize[1] = record_length;
+  buffer.inoffset[1] = record_length;
+  buffer.inunit[1] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( message);
+  buffer.outsize[0] = record_length;
+  buffer.outoffset[0] = record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  *message_length = record_length - hash_size
+    - *(Uint8 *) (message + record_length - 1) - 1;
+
+  return ret_val;
+}
+
+
+#ifndef MC2
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecord3DesRecover
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of the encrypted part of the input record in bytes 
+ *		(length%8=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte encrypted part of the input record
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output, 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1DecryptRecord3DesRecover (n1_request_type request_type,
+			      Uint64 context_handle,
+			      HashType hash_type,
+			      SslVersion ssl_version,
+			      SslPartyType ssl_party,
+			      MessageType message_type,
+			      Uint16 record_length,
+			      Uint8 * record,
+			      Uint16 * message_length,
+			      Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                              Uint32 * request_id,Uint32 dev_id
+#else
+                              Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 22;
+  else
+    context_offset = 8 * 34;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((record_length > 0x4400) || ((record_length & 0x7) != 0))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  buffer.opcode = (0x3 << 14) | (message_type << 12) | (0x1 << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7)
+    | MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = record_length;
+  buffer.param = 0;
+  buffer.dlen = (16 + record_length) >> 3;
+  buffer.rlen = (record_length + 8) >> 3;
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 2;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR(record + record_length - 16);
+  buffer.insize[0] = 16;
+  buffer.inoffset[0] = 16;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( record);
+  buffer.insize[1] = record_length;
+  buffer.inoffset[1] = record_length;
+  buffer.inunit[1] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( message);
+  buffer.outsize[0] = record_length;
+  buffer.outoffset[0] = record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+  
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  *message_length = record_length - hash_size
+    - *(Uint8 *) (message + record_length - 1) - 1;
+
+  return ret_val;
+}
+#endif
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1EncryptRecordAes
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	pad_length = size of extra padding in 8-byte blocks
+ *	message_length = size of input in bytes (0<=length<=2^14+1024)
+ *	message = pointer to length-byte input
+ *
+ * Output
+ *	record_length = pointer to length of the encrypted part of the record in bytes
+ *	record = pointer to *record_length-byte output, 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1EncryptRecordAes (n1_request_type request_type,
+		      Uint64 context_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      SslPartyType ssl_party,
+		      AesType aes_type,
+		      MessageType message_type,
+		      Uint16 pad_length,
+		      Uint16 message_length,
+		      Uint8 * message,
+		      Uint16 * record_length,
+		      Uint8 * record,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id,Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 38;
+  else
+    context_offset = 8 * 22;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if (message_length > 0x4400)
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode =
+    (0x1 << 14) | (message_type << 12) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  *record_length = ROUNDUP16 (message_length + hash_size + 1);
+  buffer.size = message_length;
+  buffer.param = (hash_type) | (ssl_version << 2) | (aes_type << 3);
+  buffer.dlen = message_length;
+  buffer.rlen = *record_length;
+#else
+  buffer.opcode =
+    (0x0 << 14) | (message_type << 12) | (0x1 << 11) | ((aes_type >> 1) << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  *record_length =
+    ROUNDUP16 (message_length + hash_size + 1) + 16 * pad_length;
+
+  buffer.size = message_length;
+  buffer.param = (Uint16) (pad_length);
+  buffer.dlen = (ROUNDUP8 (message_length)) >> 3;
+  buffer.rlen = (*record_length + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 1;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR( message);
+  buffer.insize[0] = message_length;
+  buffer.inoffset[0] = ROUNDUP8 (message_length);
+  buffer.inunit[0] = UNIT_8_BIT;
+
+#ifdef MC2
+  buffer.inoffset[0] = message_length;
+#endif
+  buffer.outptr[0] = CAST_TO_X_PTR( record);
+  buffer.outsize[0] = *record_length;
+  buffer.outoffset[0] = *record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  return ret_val;
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordAes
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE 
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of input in bytes (length%16=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte input
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1DecryptRecordAes (n1_request_type request_type,
+		      Uint64 context_handle,
+		      HashType hash_type,
+		      SslVersion ssl_version,
+		      SslPartyType ssl_party,
+		      AesType aes_type,
+		      MessageType message_type,
+		      Uint16 record_length,
+		      Uint8 * record,
+		      Uint16 * message_length,
+		      Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                      Uint32 * request_id,Uint32 dev_id
+#else
+                      Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 22;
+  else
+    context_offset = 8 * 38;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((record_length > 0x4400) || ((record_length & 0xf) != 0))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+#ifdef MC2
+  buffer.opcode =
+    ((0xb << 12) & (message_type << 12)) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = (hash_type == SHA1_TYPE) ? 20 : 16;
+
+  buffer.size = record_length;
+  buffer.param =
+    (hash_type) | (ssl_version << 2) | (aes_type << 3) | (1 << 7);
+  buffer.dlen = 32 + record_length;
+  buffer.rlen = record_length;
+#else
+  buffer.opcode =
+    (0x2 << 14) | (message_type << 12) | (0x1 << 11) | ((aes_type >> 1) << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = record_length;
+  buffer.param = 0;
+  buffer.dlen = (32 + record_length) >> 3;
+  buffer.rlen = (record_length + 8) >> 3;
+#endif
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 2;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR(record + record_length - 32);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR( record);
+  buffer.insize[1] = record_length;
+  buffer.inoffset[1] = record_length;
+  buffer.inunit[1] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR( message);
+  buffer.outsize[0] = record_length;
+  buffer.outoffset[0] = record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  *message_length = record_length - hash_size
+    - *(Uint8 *) (message + record_length - 1) - 1;
+
+  return ret_val;
+}
+
+#ifndef MC2
+
+/*+****************************************************************************
+ *
+ * Csp1DecryptRecordAesRecover
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	hash_type = MD5_TYPE or SHA1_TYPE (MD5 hash_size = 16, SHA1 hash_size = 20)
+ *	ssl_version = VER3_0 or VER_TLS
+ *	aes_type = AES_128 or AES_256
+ *	message_type = CHANGE_CIPHER_SPEC, ALERT, HANDSHAKE, or APP_DATA
+ *	record_length = size of input in bytes (length%16=0, 0<=length<=2^14+1024)
+ *	record = pointer to length-byte input
+ *
+ * Output
+ *	message_length = pointer to length in bytes of the decrypted message
+ *	message = pointer to *message_length-byte output
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+Uint32
+Csp1DecryptRecordAesRecover (n1_request_type request_type,
+			     Uint64 context_handle,
+			     HashType hash_type,
+			     SslVersion ssl_version,
+			     SslPartyType ssl_party,
+			     AesType aes_type,
+			     MessageType message_type,
+			     Uint16 record_length,
+			     Uint8 * record,
+			     Uint16 * message_length,
+			     Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                             Uint32 * request_id,Uint32 dev_id
+#else
+                             Uint32 * request_id
+#endif
+                   )
+{
+  Csp1OperationBuffer buffer;
+  Uint32 cond_code;
+  Uint32 ret_val;
+  Uint16 hash_size;
+  Uint64 context_offset;
+
+  memset(&buffer,0,sizeof(Csp1OperationBuffer));
+  if (ssl_party == SSL_SERVER)
+    context_offset = 8 * 22;
+  else
+    context_offset = 8 * 38;
+
+  if ((context_handle & UINT64_C(0x8000000000000000)) != 0)
+    {
+
+      if ((context_handle & 0xf) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+  else
+    {
+
+      if ((context_handle & 0x7) != 0)
+
+	return ERR_ILLEGAL_CONTEXT_HANDLE;
+
+    }
+
+  if ((record_length > 0x4400) || ((record_length & 0xf) != 0))
+
+    return ERR_ILLEGAL_INPUT_LENGTH;
+
+
+  buffer.opcode =
+    (0x3 << 14) | (message_type << 12) | (0x1 << 11) | ((aes_type >> 1) << 10)
+    | (ssl_version << 9) | (hash_type << 8) | (global_dma_mode << 7) |
+    MAJOR_OP_ENCRYPT_DECRYPT_RECORD;
+  hash_size = 20 - (hash_type << 2);
+
+  buffer.size = record_length;
+  buffer.param = 0;
+  buffer.dlen = (32 + record_length) >> 3;
+  buffer.rlen = (record_length + 8) >> 3;
+  buffer.ctx_ptr = context_handle + context_offset;
+  buffer.group = CAVIUM_SSL_GRP;
+
+  buffer.incnt = 2;
+  buffer.outcnt = 1;
+
+  buffer.inptr[0] = CAST_TO_X_PTR (record + record_length - 32);
+  buffer.insize[0] = 32;
+  buffer.inoffset[0] = 32;
+  buffer.inunit[0] = UNIT_8_BIT;
+  buffer.inptr[1] = CAST_TO_X_PTR(record);
+  buffer.insize[1] = record_length;
+  buffer.inoffset[1] = record_length;
+  buffer.inunit[1] = UNIT_8_BIT;
+
+  buffer.outptr[0] = CAST_TO_X_PTR(message);
+  buffer.outsize[0] = record_length;
+  buffer.outoffset[0] = record_length;
+  buffer.outunit[0] = UNIT_8_BIT;
+
+  buffer.req_type = request_type;
+
+  buffer.req_queue = SSL_QUEUE;
+  buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+  buffer.dma_mode = global_dma_mode;
+  buffer.status=0;
+
+
+  cond_code =
+#ifdef CAVIUM_MULTICARD_API
+    ioctl (gpkpdev_hdlr[dev_id], IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#else
+    ioctl (CSP1_driver_handle, IOCTL_N1_OPERATION_CODE, (ptrlong) & buffer);
+#endif
+
+
+  *request_id = buffer.request_id;
+  
+  if(cond_code)
+     ret_val = cond_code; /*return error val*/
+  else
+     ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+  *message_length = record_length - hash_size
+    - *(Uint8 *) (message + record_length - 1) - 1;
+
+  return ret_val;
+}
+
+#endif
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerFullRc4
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerFullRc4 (n1_request_type request_type,
+			   Uint64 context_handle,
+			   Uint64 * key_handle,
+			   Rc4Type rc4_type,
+			   Uint8 * client_master_secret,
+			   Uint16 clear_master_secret_length,
+			   Uint16 encrypted_master_secret_length,
+			   Uint16 modlength,
+			   Uint8 * challenge,
+			   Uint16 challenge_length,
+			   Uint8 * connection_id,
+			   Uint8 * session_id,
+			   Uint8 * client_finished,
+			   Uint8 * server_finished,
+			   Uint8 * server_verify,
+			   Uint8 * master_secret,
+			   Uint16 * master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 * request_id,Uint32 dev_id
+#else
+                           Uint32 * request_id
+#endif
+                   )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+  int ek, key_size, finished_size, ret = 1, i = 0, is_export = 0;
+  Uint64 ctx_ptr, out_length = 0;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *enc_ms = NULL, *temp = NULL, *ms, *p, md5_1[16],
+    md5_2[16], temp_hash[24], mac[16], local_client_finished[40];
+
+  enc_ms = alloca (modlength);
+  if (enc_ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+  memset (enc_ms, 0, modlength);
+
+  temp = alloca (modlength);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+
+  ms = alloca (modlength);
+  if (ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+
+  if (encrypted_master_secret_length < modlength)
+    {
+      p = &client_master_secret[clear_master_secret_length];
+      pkp_leftfill (p, encrypted_master_secret_length, temp, modlength);
+      memcpy (enc_ms, temp, modlength);
+      memset (temp, 0, modlength);
+    }
+  else				/* encrypted master secret length should be equal to modlength or we are deep in trouble. */
+    memcpy (enc_ms, &client_master_secret[clear_master_secret_length],
+	    encrypted_master_secret_length);
+
+  swap_word_openssl (temp, enc_ms, modlength);
+
+  if (*key_handle & 0x1000000000000ULL)
+    {
+      /* key is in crt form */
+      ret = Csp1Pkcs1v15CrtDec (CAVIUM_BLOCKING,
+				RESULT_PTR,
+				0,
+				KEY_HANDLE,
+				*key_handle,
+				BT2,
+				modlength,
+				NULL,
+				NULL,
+				NULL,
+				NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API 
+                                &dummy,dev_id
+#else
+                                &dummy
+#endif
+                   );
+
+    }
+  else
+    {
+      ret = Csp1Pkcs1v15Dec (CAVIUM_BLOCKING,
+			     RESULT_PTR,
+			     0,
+			     KEY_HANDLE,
+			     *key_handle,
+			     BT2,
+			     modlength,
+			     NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                             &dummy,dev_id
+#else
+                             &dummy
+#endif
+                   );
+    }
+
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* check for bad decrypt */
+  if (rc4_type == RC4_EXPORT_40)
+    {
+      is_export = 1;
+      key_size = 16;		/* bytes */
+      ek = 5;
+    }
+  else if (rc4_type == RC4_128)
+    {
+      is_export = 0;
+      ek = 16;
+      key_size = 16;
+    }
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_full;
+    }
+
+
+  if ((!is_export && (out_length != key_size)) ||
+      (is_export
+       && ((out_length != ek)
+	   || (clear_master_secret_length + out_length != key_size))))
+    {
+      ret = ERR_BAD_PKCS_PAD_OR_LENGTH;
+      goto err_full;
+    }
+
+  memset (temp, 0, modlength);
+
+  /*  ms will now have complete master secret */
+  memcpy (temp, ms, (Uint32) out_length);
+  memcpy (ms, client_master_secret, clear_master_secret_length);
+  memcpy (&ms[clear_master_secret_length], temp, (Uint32) out_length);
+
+  /* now store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr,
+			  (Uint16) (clear_master_secret_length +
+				    (Uint32) out_length), ms,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                   );
+
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* generate key material */
+  i = clear_master_secret_length + (Uint32) out_length;
+  p = temp;
+
+  memcpy (temp, ms, i);
+  temp += i;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_1, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                    &dummy,dev_id
+#else
+                    &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  temp[i] = '\x31';
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_2, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+		   &dummy,dev_id
+#else
+		   &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* generate rc4 state and store key */
+  /* To client */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* To server */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* client finish decryption and validation */
+  finished_size = 16 + 16 + 1;	/* 16 = connection id, 16 = md5 mac, 1=message type */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* mac */
+  read_seq = 2;			/* client hello, client_master_secret */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, md5_2, 16);
+  temp += 16;
+
+  memcpy (temp, &local_client_finished[16], 17);
+  temp += 17;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 17 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_full;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_full;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + challenge_length + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+
+
+  finished_size = 16 + 1 + challenge_length;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate server finish message */
+  /* mac */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 6;			/* finished message type */
+  temp++;
+
+  memcpy (temp, session_id, 16);
+  temp += 16;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + 16 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  memcpy (server_finished, mac, 16);
+  server_finished[16] = 6;	/* message type */
+  memcpy (&server_finished[17], session_id, 16);
+
+
+  finished_size = 16 + 1 + 16;	/* 16 = session_id, 1 = message type 16 = md5 mac */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			server_finished, server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else                
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* return master secret */
+  memcpy (master_secret, ms,
+	  clear_master_secret_length + (Uint32) out_length);
+  *master_secret_length = clear_master_secret_length + (Uint32) out_length;
+  ret = 0;
+
+err_full:
+  return ret;
+#endif
+}				/* Csp1RsaSsl20ServerFullRc4 */
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerClientAuthRc4
+ *
+ * Generates key material, and certificate req, verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuthRc4 (n1_request_type request_type,
+				 Uint64 context_handle,
+				 Uint64 * key_handle,
+				 Rc4Type rc4_type,
+				 Uint8 * client_master_secret,
+				 Uint16 clear_master_secret_length,
+				 Uint16 encrypted_master_secret_length,
+				 Uint16 modlength,
+				 Uint8 * challenge,
+				 Uint16 challenge_length,
+				 Uint8 * connection_id,
+				 Uint8 * session_id,
+				 Uint8 * client_finished,
+				 Uint8 auth_type,
+				 Uint8 * cert_challenge,
+				 Uint8 * cert_request,
+				 Uint8 * server_verify,
+				 Uint8 * master_secret,
+				 Uint16 * master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                 Uint32 * request_id,Uint32 dev_id
+#else
+                                 Uint32 * request_id
+#endif
+                   )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ek, key_size, finished_size, ret = 1, i = 0, is_export = 0;
+  Uint64 ctx_ptr, out_length = 0;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *enc_ms = NULL, *temp = NULL, *ms, *p, md5_1[16],
+    md5_2[16], temp_hash[24], mac[16], local_client_finished[40];
+
+  enc_ms = alloca (modlength);
+  if (enc_ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+  memset (enc_ms, 0, modlength);
+
+  temp = alloca (modlength);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+
+  ms = alloca (modlength);
+  if (ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+
+  if (encrypted_master_secret_length < modlength)
+    {
+      p = &client_master_secret[clear_master_secret_length];
+      pkp_leftfill (p, encrypted_master_secret_length, temp, modlength);
+      memcpy (enc_ms, temp, modlength);
+      memset (temp, 0, modlength);
+    }
+  else				/* encrypted master secret length should be equal to modlength or we are deep in trouble. */
+    memcpy (enc_ms, &client_master_secret[clear_master_secret_length],
+	    encrypted_master_secret_length);
+
+  swap_word_openssl (temp, enc_ms, modlength);
+
+  if (*key_handle & 0x1000000000000ULL)
+    {
+      /* key is in crt form */
+      ret = Csp1Pkcs1v15CrtDec (CAVIUM_BLOCKING,
+				RESULT_PTR,
+				0,
+				KEY_HANDLE,
+				*key_handle,
+				BT2,
+				modlength,
+				NULL,
+				NULL,
+				NULL,
+				NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                   );
+
+    }
+  else
+    {
+      ret = Csp1Pkcs1v15Dec (CAVIUM_BLOCKING,
+			     RESULT_PTR,
+			     0,
+			     KEY_HANDLE,
+			     *key_handle,
+			     BT2,
+			     modlength,
+			     NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                             &dummy,dev_id
+#else
+                             &dummy
+#endif
+                   );
+    }
+
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* check for bad decrypt */
+  if (rc4_type == RC4_EXPORT_40)
+    {
+      is_export = 1;
+      key_size = 16;		/* bytes */
+      ek = 5;
+    }
+  else if (rc4_type == RC4_128)
+    {
+      is_export = 0;
+      ek = 16;
+      key_size = 16;
+    }
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_full_client_auth;
+    }
+
+
+  if ((!is_export && (out_length != key_size)) ||
+      (is_export
+       && ((out_length != ek)
+	   || (clear_master_secret_length + out_length != key_size))))
+    {
+      ret = ERR_BAD_PKCS_PAD_OR_LENGTH;
+      goto err_full_client_auth;
+    }
+
+  memset (temp, 0, modlength);
+
+  /*  ms will now have complete master secret */
+  memcpy (temp, ms, (Uint32) out_length);
+  memcpy (ms, client_master_secret, clear_master_secret_length);
+  memcpy (&ms[clear_master_secret_length], temp, (Uint32) out_length);
+
+  /* now store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr,
+			  (Uint16) (clear_master_secret_length +
+				    (Uint32) out_length), ms,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                   );
+
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* generate key material */
+  i = clear_master_secret_length + (Uint32) out_length;
+  p = temp;
+
+  memcpy (temp, ms, i);
+  temp += i;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_1, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                    &dummy,dev_id
+#else
+                    &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  temp[i] = '\x31';
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_2, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                    &dummy,dev_id
+#else
+                    &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* generate rc4 state and store key */
+  /* To client */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* To server */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* client finish decryption and validation */
+  finished_size = 16 + 16 + 1;	/* 16 = connection id, 16 = md5 mac, 1=message type */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* mac */
+  read_seq = 2;			/* client hello, client_master_secret */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, md5_2, 16);
+  temp += 16;
+
+  memcpy (temp, &local_client_finished[16], 17);
+  temp += 17;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 17 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_full_client_auth;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_full_client_auth;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + challenge_length + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+
+
+  finished_size = 16 + 1 + challenge_length;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate cert req message */
+  /* mac */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 7;			/* cert req message type */
+  temp++;
+
+  temp[0] = auth_type;
+  temp++;
+
+  memcpy (temp, cert_challenge, 16);
+  temp += 16;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + 1 + 16 + 4;	/* mac, message type, auth_type, cert_challenge, seq */
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  memcpy (cert_request, mac, 16);
+  cert_request[16] = 7;		/* message type */
+  cert_request[17] = auth_type;
+  memcpy (&cert_request[18], cert_challenge, 16);
+
+
+  finished_size = 16 + 1 + 1 + 16;	/* mac, 1 = message type, 1=auth type,  16 = cert challenge */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, cert_request, cert_request,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* return master secret */
+  memcpy (master_secret, ms,
+	  clear_master_secret_length + (Uint32) out_length);
+  *master_secret_length = clear_master_secret_length + (Uint32) out_length;
+  ret = 0;
+
+err_full_client_auth:
+  return ret;
+#endif
+}				/*Csp1RsaSsl20ServerClientAuthRc4 */
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeRc4
+ *
+ * Resumes a previously negotiated session.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	master_secret = master secret from previous session.
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeRc4 (n1_request_type request_type,
+		    Uint64 context_handle,
+		    Uint64 * key_handle,
+		    Rc4Type rc4_type,
+		    Uint8 * master_secret,
+		    Uint16 master_secret_length,
+		    Uint8 * challenge,
+		    Uint16 challenge_length,
+		    Uint8 * connection_id,
+		    Uint8 * session_id,
+		    Uint8 * client_finished,
+		    Uint8 * server_finished,
+		    Uint8 * server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                    Uint32 * request_id,Uint32 dev_id
+
+#else
+                    Uint32 * request_id
+
+#endif
+                   )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+  int key_size, finished_size, ret = 1, i = 0;
+  Uint64 ctx_ptr;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *temp = NULL, *p, md5_1[16], md5_2[16], temp_hash[24], mac[16],
+    local_client_finished[40];
+  temp = alloca (256);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_resume;
+    }
+
+  /* Set key sizes */
+  if (rc4_type == RC4_EXPORT_40)
+    key_size = 16;		/* bytes */
+  else if (rc4_type == RC4_128)
+    key_size = 16;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_resume;
+    }
+
+  /* store master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, master_secret_length,
+		      master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* generate key material */
+  i = master_secret_length;
+  p = temp;
+
+  memcpy (temp, master_secret, i);
+  temp += i;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_1, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                    &dummy,dev_id
+#else
+                    &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  temp[i] = '\x31';
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_2, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                   &dummy,dev_id
+#else
+                   &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* generate rc4 state and store key */
+  /* To client */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* To server */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* client finish decryption and validation */
+  finished_size = 16 + 16 + 1;	/* 16 = connection id, 16 = md5 mac, 1=message type */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* mac */
+  read_seq = 1;			/* client hello */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, md5_2, 16);
+  temp += 16;
+
+  memcpy (temp, &local_client_finished[16], 17);
+  temp += 17;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 17 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_resume;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_resume;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + challenge_length + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+
+
+  finished_size = 16 + 1 + challenge_length;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate server finish message */
+  /* mac */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 6;			/* finished message type */
+  temp++;
+
+  memcpy (temp, session_id, 16);
+  temp += 16;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + 16 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  memcpy (server_finished, mac, 16);
+  server_finished[16] = 6;	/* message type */
+  memcpy (&server_finished[17], session_id, 16);
+
+
+  finished_size = 16 + 1 + 16;	/* 16 = session_id, 1 = message type 16 = md5 mac */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			server_finished, server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  ret = 0;
+
+err_resume:
+  return ret;
+#endif
+}				/* Csp1Ssl20Resumec4 */
+
+
+
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeClientAuthRc4
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_RC4_128_WITH_MD5
+ *	SSL_CK_RC4_128_EXPORT40_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	rc4_type = RC4_128 or RC4_EXPORT_40
+ *	master_secret = master secret from previous session.
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	auth_type = client auth type
+ *	cert_challenge = cert challenge
+ *
+ * Output
+ *	cert_request = pointer to encrypted part of cert request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24-15	Rc4 Key
+ *	26-59	Rc4 State
+ *	To client
+ *	60		Sequence number
+ *	61		Unused
+ *	62-63	Rc4 Key
+ *	64-97	Rc4 State
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20ResumeClientAuthRc4 (n1_request_type request_type,
+			      Uint64 context_handle,
+			      Uint64 * key_handle,
+			      Rc4Type rc4_type,
+			      Uint8 * master_secret,
+			      Uint16 master_secret_length,
+			      Uint8 * challenge,
+			      Uint16 challenge_length,
+			      Uint8 * connection_id,
+			      Uint8 * session_id,
+			      Uint8 * client_finished,
+			      Uint8 auth_type,
+			      Uint8 * cert_challenge,
+			      Uint8 * cert_request,
+			      Uint8 * server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                              Uint32 * request_id,Uint32 dev_id
+#else
+                              Uint32 * request_id
+#endif
+                   )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+  int key_size, finished_size, ret = 1, i = 0;
+  Uint64 ctx_ptr;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *temp = NULL, *p, md5_1[16], md5_2[16], temp_hash[24], mac[16],
+    local_client_finished[40];
+  temp = alloca (256);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_resume_client_auth;
+    }
+
+  /* Set key sizes */
+  if (rc4_type == RC4_EXPORT_40)
+    key_size = 16;		/* bytes */
+  else if (rc4_type == RC4_128)
+    key_size = 16;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_resume_client_auth;
+    }
+
+  /* store master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, master_secret_length,
+		      master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* generate key material */
+  i = master_secret_length;
+  p = temp;
+
+  memcpy (temp, master_secret, i);
+  temp += i;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_1, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                   &dummy,dev_id
+#else
+                   &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  temp[i] = '\x31';
+  ret =
+    Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+		   (i + 1 + challenge_length + 16), temp, md5_2, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                    &dummy,dev_id
+#else
+                    &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* generate rc4 state and store key */
+  /* To client */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_1, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* To server */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy,dev_id);
+#else
+  ret = Csp1InitializeRc4 (CAVIUM_BLOCKING, ctx_ptr, 16, md5_2, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* client finish decryption and validation */
+  finished_size = 16 + 16 + 1;	/* 16 = connection id, 16 = md5 mac, 1=message type */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size,
+			client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* mac */
+  read_seq = 1;			/* client hello */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, md5_2, 16);
+  temp += 16;
+
+  memcpy (temp, &local_client_finished[16], 17);
+  temp += 17;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 17 + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_resume_client_auth;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_resume_client_auth;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + challenge_length + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+
+
+  finished_size = 16 + 1 + challenge_length;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate cert req message */
+  /* mac */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, md5_1, 16);
+  temp += 16;
+
+  temp[0] = 7;			/* cert req message type */
+  temp++;
+
+  temp[0] = auth_type;
+  temp++;
+
+  memcpy (temp, cert_challenge, 16);
+  temp += 16;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = 16 + 1 + 1 + 16 + 4;	/* mac, message type, auth_type, cert_challenge, seq */
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  memcpy (cert_request, mac, 16);
+  cert_request[16] = 7;		/* message type */
+  cert_request[17] = auth_type;
+  memcpy (&cert_request[18], cert_challenge, 16);
+
+
+  finished_size = 16 + 1 + 1 + 16;	/* mac, 1 = message type, 1=auth type,  16 = cert challenge */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			finished_size, cert_request, cert_request,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                   );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  ret = 0;
+
+err_resume_client_auth:
+  return ret;
+#endif
+}				/* Csp1Ssl20ResumeClientAuthRc4 */
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerFull3Des
+ *
+ * Does a full SSL2.0 handshake on the server with RSA <= 2048 bits. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1RsaSsl20ServerFull3Des (n1_request_type request_type,
+			    Uint64 context_handle,
+			    Uint64 * key_handle,
+			    DesType des_type,
+			    Uint8 * client_master_secret,
+			    Uint16 clear_master_secret_length,
+			    Uint16 encrypted_master_secret_length,
+			    Uint16 modlength,
+			    Uint8 * challenge,
+			    Uint16 challenge_length,
+			    Uint8 * connection_id,
+			    Uint8 * session_id,
+			    Uint8 * iv,
+			    Uint8 * client_finished,
+			    Uint8 * server_finished,
+			    Uint8 * server_verify,
+			    Uint8 * master_secret,
+			    Uint16 * master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                            Uint32 * request_id,Uint32 dev_id
+#else
+                            Uint32 * request_id
+#endif
+                   )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+  int ms_size, ek, key_size, finished_size, pad, ret = 1, i = 0, is_export =
+    0;
+  Uint64 ctx_ptr, out_length = 0;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *enc_ms = NULL, *temp = NULL, *ms, *p, km[48],
+    server_write_key[24], server_read_key[24],
+    temp_hash[24], mac[16], local_client_finished[64], padb[8];
+
+  memset (padb, 0, 8);
+  enc_ms = alloca (modlength);
+  if (enc_ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+  memset (enc_ms, 0, modlength);
+
+  temp = alloca (modlength);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+
+  ms = alloca (modlength);
+  if (ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full;
+    }
+
+  if (encrypted_master_secret_length < modlength)
+    {
+      p = &client_master_secret[clear_master_secret_length];
+      pkp_leftfill (p, encrypted_master_secret_length, temp, modlength);
+      memcpy (enc_ms, temp, modlength);
+      memset (temp, 0, modlength);
+    }
+  else				/* encrypted master secret length should be equal to modlength or we are deep in trouble. */
+    memcpy (enc_ms, &client_master_secret[clear_master_secret_length],
+	    encrypted_master_secret_length);
+
+  swap_word_openssl (temp, enc_ms, modlength);
+
+  if (*key_handle & 0x1000000000000ULL)
+    {
+      /* key is in crt form */
+      ret = Csp1Pkcs1v15CrtDec (CAVIUM_BLOCKING,
+				RESULT_PTR,
+				0,
+				KEY_HANDLE,
+				*key_handle,
+				BT2,
+				modlength,
+				NULL,
+				NULL,
+				NULL,
+				NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                   );
+
+    }
+  else
+    {
+      ret = Csp1Pkcs1v15Dec (CAVIUM_BLOCKING,
+			     RESULT_PTR,
+			     0,
+			     KEY_HANDLE,
+			     *key_handle,
+			     BT2,
+			     modlength,
+			     NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                   );
+    }
+
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* check for bad decrypt */
+  if (des_type == DES)
+    {
+      is_export = 0;
+      key_size = 8;		/* bytes */
+      ek = 8;
+    }
+  else if (des_type == DES3_192)
+    {
+      is_export = 0;
+      ek = 24;
+      key_size = 24;
+    }
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_full;
+    }
+
+
+  if ((!is_export && (out_length != key_size)) ||
+      (is_export
+       && ((out_length != ek)
+	   || (clear_master_secret_length + out_length != key_size))))
+    {
+      ret = ERR_BAD_PKCS_PAD_OR_LENGTH;
+      goto err_full;
+    }
+
+
+  memset (temp, 0, modlength);
+
+  /*  ms will now have complete master secret */
+  memcpy (temp, ms, (Uint32) out_length);
+  memcpy (ms, client_master_secret, clear_master_secret_length);
+  memcpy (&ms[clear_master_secret_length], temp, (Uint32) out_length);
+
+  /* now store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr,
+			  (Uint16) (clear_master_secret_length +
+				    (Uint32) out_length), ms,
+#ifdef CAVIUM_MULTICARD_API
+                          &dummy,dev_id
+#else
+                          &dummy
+#endif
+                   );
+
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* generate key material */
+  ms_size = clear_master_secret_length + (Uint32) out_length;
+  p = temp;
+
+  memcpy (temp, ms, ms_size);
+  temp += ms_size;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  for (i = 0; i < (key_size * 2); i += 16)
+    {
+      ret = Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+			   (ms_size + 1 + challenge_length + 16),
+			   temp, &km[i], temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                   );
+      if (ret)
+	{
+	  goto err_full;
+	}
+
+      temp[ms_size]++;
+    }
+
+
+  /* store keys and IV to context memory */
+
+  memcpy (temp, iv, 8);
+
+  /* To client */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], km, 8);
+      memcpy (&temp[24], km, 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[16], 8);
+    }
+
+  memcpy (server_write_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* To server */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], &km[8], 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[8], 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], &km[24], 8);
+      memcpy (&temp[16], &km[32], 8);
+      memcpy (&temp[24], &km[40], 8);
+    }
+
+  memcpy (server_read_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* client finished decryption and validation. */
+  finished_size = 16 + 16 + 1;	/* 16 = mc, 16 = conn_id_len, 1=message type */
+  pad = 8 - (finished_size % 8);
+
+  /* finished size after padding */
+  finished_size += pad;
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret = Csp1Decrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                         );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* mac */
+  read_seq = 2;			/* client hello, client_master_secret */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, server_read_key, key_size);
+  temp += key_size;
+
+  memcpy (temp, &local_client_finished[16], finished_size - 16);
+  temp += (finished_size - 16);
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + (finished_size - 16) + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_full;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_full;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+  pad = 8 - ((16 + 1 + challenge_length) % 8);
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + challenge_length + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+  memcpy (&server_verify[17 + challenge_length], padb, pad);
+
+
+  finished_size = 16 + 1 + challenge_length + pad;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate server finish message */
+  /* mac */
+  pad = 8 - ((16 + 1 + 16) % 8);
+
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 6;			/* finished message type */
+  temp++;
+
+  memcpy (temp, session_id, 16);
+  temp += 16;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + 16 + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  memcpy (server_finished, mac, 16);
+  server_finished[16] = 6;	/* message type */
+  memcpy (&server_finished[17], session_id, 16);
+  memcpy (&server_finished[17 + 16], padb, pad);
+
+
+  finished_size = 16 + 1 + 16 + pad;	/* 16 = session_id, 1 = message type 16 = md5 mac */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 server_finished, server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full;
+    }
+
+
+  /* return master secret */
+  memcpy (master_secret, ms,
+	  clear_master_secret_length + (Uint32) out_length);
+  *master_secret_length = clear_master_secret_length + (Uint32) out_length;
+  ret = 0;
+
+err_full:
+  return ret;
+#endif
+}				/* Csp1RsaSsl20ServerFull3Des */
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1RsaSsl20ServerClientAuth3Des
+ *
+ * Generates key material, verifies cllient finished msg, creates server verify
+ * and cert request messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	client_master_secret = master key received in client-master-key handshake message.
+ *	clear_master_secret_length = length (in bytes) of clear portion of client_master_secret
+ *	encrypted_master_secret_length = length (in bytes) of encrypted portion of client_master_secret
+ *	modlength = size of RSA operation in bytes (64<=modlength<=256, modlength%8=0)	
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *	auth_type =  client auth type
+ *	cert_challenge =  certficate challenge.
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	cert_request = pointer to encrypted part of certificate request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	master_secret = master secret to used in session caching for reuse.
+ *	master_secret_length = size in bytes of master secret.
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1RsaSsl20ServerClientAuth3Des (n1_request_type request_type,
+				  Uint64 context_handle,
+				  Uint64 * key_handle,
+				  DesType des_type,
+				  Uint8 * client_master_secret,
+				  Uint16 clear_master_secret_length,
+				  Uint16 encrypted_master_secret_length,
+				  Uint16 modlength,
+				  Uint8 * challenge,
+				  Uint16 challenge_length,
+				  Uint8 * connection_id,
+				  Uint8 * session_id,
+				  Uint8 * iv,
+				  Uint8 * client_finished,
+				  Uint8 auth_type,
+				  Uint8 * cert_challenge,
+				  Uint8 * cert_request,
+				  Uint8 * server_verify,
+				  Uint8 * master_secret,
+				  Uint16 * master_secret_length,
+#ifdef CAVIUM_MULTICARD_API
+                                  Uint32 * request_id,Uint32 dev_id
+#else
+                                  Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ms_size, ek, key_size, finished_size, pad, ret = 1, i = 0, is_export =
+    0;
+  Uint64 ctx_ptr, out_length = 0;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *enc_ms = NULL, *temp = NULL, *ms, *p, km[48],
+    server_write_key[24], server_read_key[24],
+    temp_hash[24], mac[16], local_client_finished[64], padb[8];
+
+  memset (padb, 0, 8);
+  enc_ms = alloca (modlength);
+  if (enc_ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+  memset (enc_ms, 0, modlength);
+
+  temp = alloca (modlength);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+
+  ms = alloca (modlength);
+  if (ms == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_full_client_auth;
+    }
+
+  if (encrypted_master_secret_length < modlength)
+    {
+      p = &client_master_secret[clear_master_secret_length];
+      pkp_leftfill (p, encrypted_master_secret_length, temp, modlength);
+      memcpy (enc_ms, temp, modlength);
+      memset (temp, 0, modlength);
+    }
+  else				/* encrypted master secret length should be equal to modlength or we are deep in trouble. */
+    memcpy (enc_ms, &client_master_secret[clear_master_secret_length],
+	    encrypted_master_secret_length);
+
+  swap_word_openssl (temp, enc_ms, modlength);
+
+  if (*key_handle & 0x1000000000000ULL)
+    {
+      /* key is in crt form */
+      ret = Csp1Pkcs1v15CrtDec (CAVIUM_BLOCKING,
+				RESULT_PTR,
+				0,
+				KEY_HANDLE,
+				*key_handle,
+				BT2,
+				modlength,
+				NULL,
+				NULL,
+				NULL,
+				NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+
+    }
+  else
+    {
+      ret = Csp1Pkcs1v15Dec (CAVIUM_BLOCKING,
+			     RESULT_PTR,
+			     0,
+			     KEY_HANDLE,
+			     *key_handle,
+			     BT2,
+			     modlength,
+			     NULL, NULL, temp, ms, &out_length,
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+    }
+
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* check for bad decrypt */
+  if (des_type == DES)
+    {
+      is_export = 0;
+      key_size = 8;		/* bytes */
+      ek = 8;
+    }
+  else if (des_type == DES3_192)
+    {
+      is_export = 0;
+      ek = 24;
+      key_size = 24;
+    }
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_full_client_auth;
+    }
+
+
+  if ((!is_export && (out_length != key_size)) ||
+      (is_export
+       && ((out_length != ek)
+	   || (clear_master_secret_length + out_length != key_size))))
+    {
+      ret = ERR_BAD_PKCS_PAD_OR_LENGTH;
+      goto err_full_client_auth;
+    }
+
+
+  memset (temp, 0, modlength);
+
+  /*  ms will now have complete master secret */
+  memcpy (temp, ms, (Uint32) out_length);
+  memcpy (ms, client_master_secret, clear_master_secret_length);
+  memcpy (&ms[clear_master_secret_length], temp, (Uint32) out_length);
+
+  /* now store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr,
+			  (Uint16) (clear_master_secret_length +
+				    (Uint32) out_length), ms,
+#ifdef CAVIUM_MULTICARD_API
+                           &dummy,dev_id
+#else
+                           &dummy
+#endif
+                 );
+
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* generate key material */
+  ms_size = clear_master_secret_length + (Uint32) out_length;
+  p = temp;
+
+  memcpy (temp, ms, ms_size);
+  temp += ms_size;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  for (i = 0; i < (key_size * 2); i += 16)
+    {
+      ret = Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+			   (ms_size + 1 + challenge_length + 16),
+			   temp, &km[i], temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                           &dummy,dev_id
+#else
+                           &dummy
+#endif
+                 );
+      if (ret)
+	{
+	  goto err_full_client_auth;
+	}
+
+      temp[ms_size]++;
+    }
+
+
+  /* store keys and IV to context memory */
+
+  memcpy (temp, iv, 8);
+
+  /* To client */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], km, 8);
+      memcpy (&temp[24], km, 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[16], 8);
+    }
+
+  memcpy (server_write_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* To server */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], &km[8], 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[8], 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], &km[24], 8);
+      memcpy (&temp[16], &km[32], 8);
+      memcpy (&temp[24], &km[40], 8);
+    }
+
+  memcpy (server_read_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* client finished decryption and validation. */
+  finished_size = 16 + 16 + 1;	/* 16 = mc, 16 = conn_id_len, 1=message type */
+  pad = 8 - (finished_size % 8);
+
+  /* finished size after padding */
+  finished_size += pad;
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret = Csp1Decrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* mac */
+  read_seq = 2;			/* client hello, client_master_secret */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, server_read_key, key_size);
+  temp += key_size;
+
+  memcpy (temp, &local_client_finished[16], finished_size - 16);
+  temp += (finished_size - 16);
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + (finished_size - 16) + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_full_client_auth;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_full_client_auth;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+  pad = 8 - ((16 + 1 + challenge_length) % 8);
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + challenge_length + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+  memcpy (&server_verify[17 + challenge_length], padb, pad);
+
+
+  finished_size = 16 + 1 + challenge_length + pad;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate cert request message */
+  /* mac */
+  pad = 8 - ((16 + 1 + 1 + 16) % 8);
+
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 7;			/* cert req message type */
+  temp++;
+
+  temp[0] = auth_type;
+  temp++;
+
+  memcpy (temp, cert_challenge, 16);
+  temp += 16;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + 1 + 16 + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  memcpy (cert_request, mac, 16);
+  cert_request[16] = 7;		/* message type */
+  cert_request[17] = auth_type;
+  memcpy (&cert_request[18], cert_challenge, 16);
+  memcpy (&cert_request[18 + 16], padb, pad);
+
+
+  finished_size = 16 + 1 + 1 + 16 + pad;	/* 16 = mac, 1 = message type, 1= auth_type 16 = cert_challenge */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, cert_request, cert_request,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_full_client_auth;
+    }
+
+
+  /* return master secret */
+  memcpy (master_secret, ms,
+	  clear_master_secret_length + (Uint32) out_length);
+  *master_secret_length = clear_master_secret_length + (Uint32) out_length;
+  ret = 0;
+
+err_full_client_auth:
+  return ret;
+
+#endif
+}				/*Csp1RsaSsl20ServerClientAuth3Des */
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20Resume3Des
+ *
+ * Resumes a previouly negotiated handshake. 
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+ *	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	master_secret = master key generated in previous handshake
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *
+ *
+ * Output
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	server_finished = pointer to encrypted part of server finished message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20Resume3Des (n1_request_type request_type,
+		     Uint64 context_handle,
+		     Uint64 * key_handle,
+		     DesType des_type,
+		     Uint8 * master_secret,
+		     Uint16 master_secret_length,
+		     Uint8 * challenge,
+		     Uint16 challenge_length,
+		     Uint8 * connection_id,
+		     Uint8 * session_id,
+		     Uint8 * iv,
+		     Uint8 * client_finished,
+		     Uint8 * server_finished,
+		     Uint8 * server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                     Uint32 * request_id,Uint32 dev_id
+#else
+                     Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ms_size, key_size, finished_size, pad, ret = 1, i = 0;
+  Uint64 ctx_ptr;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *temp = NULL, *p, km[48],
+    server_write_key[24], server_read_key[24],
+    temp_hash[24], mac[16], local_client_finished[64], padb[8];
+
+  memset (padb, 0, 8);
+  temp = alloca (256);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_resume;
+    }
+
+
+  /* check for bad decrypt */
+  if (des_type == DES)
+    key_size = 8;		/* bytes */
+  else if (des_type == DES3_192)
+    key_size = 24;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_resume;
+    }
+
+
+  /* store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, master_secret_length,
+		      master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* generate key material */
+  ms_size = master_secret_length;
+  p = temp;
+
+  memcpy (temp, master_secret, ms_size);
+  temp += ms_size;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  for (i = 0; i < (key_size * 2); i += 16)
+    {
+      ret = Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+			   (ms_size + 1 + challenge_length + 16),
+			   temp, &km[i], temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                 );
+      if (ret)
+	{
+	  goto err_resume;
+	}
+
+      temp[ms_size]++;
+    }
+
+
+  /* store keys and IV to context memory */
+
+  memcpy (temp, iv, 8);
+
+  /* To client */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], km, 8);
+      memcpy (&temp[24], km, 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[16], 8);
+    }
+
+  memcpy (server_write_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+
+  /* To server */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], &km[8], 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[8], 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], &km[24], 8);
+      memcpy (&temp[16], &km[32], 8);
+      memcpy (&temp[24], &km[40], 8);
+    }
+
+  memcpy (server_read_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+
+  /* client finished decryption and validation. */
+  finished_size = 16 + 16 + 1;	/* 16 = mc, 16 = conn_id_len, 1=message type */
+  pad = 8 - (finished_size % 8);
+
+  /* finished size after padding */
+  finished_size += pad;
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret = Csp1Decrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* mac */
+  read_seq = 1;			/* client hello */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, server_read_key, key_size);
+  temp += key_size;
+
+  memcpy (temp, &local_client_finished[16], finished_size - 16);
+  temp += (finished_size - 16);
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + (finished_size - 16) + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                        &dummy,dev_id
+#else
+                        &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_resume;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_resume;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+  pad = 8 - ((16 + 1 + challenge_length) % 8);
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + challenge_length + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+  memcpy (&server_verify[17 + challenge_length], padb, pad);
+
+
+  finished_size = 16 + 1 + challenge_length + pad;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate server finish message */
+  /* mac */
+  pad = 8 - ((16 + 1 + 16) % 8);
+
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 6;			/* finished message type */
+  temp++;
+
+  memcpy (temp, session_id, 16);
+  temp += 16;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + 16 + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  memcpy (server_finished, mac, 16);
+  server_finished[16] = 6;	/* message type */
+  memcpy (&server_finished[17], session_id, 16);
+  memcpy (&server_finished[17 + 16], padb, pad);
+
+
+  finished_size = 16 + 1 + 16 + pad;	/* 16 = session_id, 1 = message type 16 = md5 mac */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 server_finished, server_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume;
+    }
+
+
+  ret = 0;
+
+err_resume:
+  return ret;
+#endif
+}				/* Csp1Ssl20Resume3Des */
+
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20ResumeClientAuth3Des
+ *
+ * Uses master key from a previous session, generates key material, cert req,
+ * and verify messages.
+ *
+ *
+ * Supported ciphers
+ *	SSL_CK_DES_64_CBC_WITH_MD5
+	SSL_CK_DES_192_EDE3_CBC_WITH_MD5
+ *
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit byte-pointer to context (context_handle%8=0)
+ *	key_handle = pointer to 64-bit key memory handle
+ *	des_type = DES or DES3_192
+ *	master_secret = master key generated in previous handshake
+ *	master_secret_length = size in bytes of master secret.
+ *	challenge = pointer to challenge data.
+ *	challenge_length = length (in bytes) of challenge data.
+ *	connection_id = pointer to 16 bytes of connection ID.
+ *	session_id = pointer to 16 bytes of Session ID.
+ *	iv = initialization vectore sent by client
+ *	client_finished = pointer to encrypted part of client finished message 
+ *	auth_type =  client authentication type
+ *	cert_challenge = cert request challenge
+ *	cert_request = certificate request
+ *
+ *
+ * Output
+ *
+ *	cert_request = pointer to encrypted part of cert request message 
+ *	server_verify =  pointer to encrypted part of server verify message 
+ *  request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *
+ * Context format:
+ *	Context is left in a state where it can be used for record processing:
+ *	Word	
+ *	0-15	reserved for hashing
+ *	16-21	master secret
+ *	To server
+ *	22		Sequence number
+ *	23		Unused
+ *	24		IV
+ *	25-27	3Des Keys
+ *	To client
+ *	28		Sequence number
+ *	29		Unused
+ *	30		IV
+ *	31-33	3Des Keys
+ *
+ *
+ *-***************************************************************************/
+Uint32
+Csp1Ssl20ResumeClientAuth3Des (n1_request_type request_type,
+			       Uint64 context_handle,
+			       Uint64 * key_handle,
+			       DesType des_type,
+			       Uint8 * master_secret,
+			       Uint16 master_secret_length,
+			       Uint8 * challenge,
+			       Uint16 challenge_length,
+			       Uint8 * connection_id,
+			       Uint8 * session_id,
+			       Uint8 * iv,
+			       Uint8 * client_finished,
+			       Uint8 auth_type,
+			       Uint8 * cert_challenge,
+			       Uint8 * cert_request,
+			       Uint8 * server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                               Uint32 * request_id,Uint32 dev_id
+#else
+                               Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ms_size, key_size, finished_size, pad, ret = 1, i = 0;
+  Uint64 ctx_ptr;
+  Uint64 read_seq = 0, write_seq = 0;
+  Uint32 seq = 0, dummy = 0;
+  Uint8 *temp = NULL, *p, km[48],
+    server_write_key[24], server_read_key[24],
+    temp_hash[24], mac[16], local_client_finished[64], padb[8];
+
+  memset (padb, 0, 8);
+  temp = alloca (256);
+  if (temp == NULL)
+    {
+      ret = ERR_MEMORY_ALLOC_FAILURE;
+      goto err_resume_client_auth;
+    }
+
+
+  /* check for bad decrypt */
+  if (des_type == DES)
+    key_size = 8;		/* bytes */
+  else if (des_type == DES3_192)
+    key_size = 24;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err_resume_client_auth;
+    }
+
+
+  /* store complete master secret to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_MASTER_SECRET);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, master_secret_length,
+		      master_secret,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* generate key material */
+  ms_size = master_secret_length;
+  p = temp;
+
+  memcpy (temp, master_secret, ms_size);
+  temp += ms_size;
+
+  memcpy (temp, "\x30", 1);
+  temp += 1;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, connection_id, 16);
+  temp = p;
+
+  for (i = 0; i < (key_size * 2); i += 16)
+    {
+      ret = Csp1Handshake (CAVIUM_BLOCKING, context_handle,
+			   (ms_size + 1 + challenge_length + 16),
+			   temp, &km[i], temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                 );
+      if (ret)
+	{
+	  goto err_resume_client_auth;
+	}
+
+      temp[ms_size]++;
+    }
+
+
+  /* store keys and IV to context memory */
+
+  memcpy (temp, iv, 8);
+
+  /* To client */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], km, 8);
+      memcpy (&temp[24], km, 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], km, 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[16], 8);
+    }
+
+  memcpy (server_write_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+
+  /* To server */
+  if (key_size == 8)
+    {
+      memcpy (&temp[8], &km[8], 8);
+      memcpy (&temp[16], &km[8], 8);
+      memcpy (&temp[24], &km[8], 8);
+    }
+
+  if (key_size == 24)
+    {
+      memcpy (&temp[8], &km[24], 8);
+      memcpy (&temp[16], &km[32], 8);
+      memcpy (&temp[24], &km[40], 8);
+    }
+
+  memcpy (server_read_key, &temp[8], 24);
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+#ifdef CAVIUM_MULTICARD_API
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy,dev_id);
+#else
+  ret = Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 32, temp, &dummy);
+#endif
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+
+  /* client finished decryption and validation. */
+  finished_size = 16 + 16 + 1;	/* 16 = mc, 16 = conn_id_len, 1=message type */
+  pad = 8 - (finished_size % 8);
+
+  /* finished size after padding */
+  finished_size += pad;
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret = Csp1Decrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size,
+			 client_finished, local_client_finished,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* mac */
+  read_seq = 1;			/* client hello */
+  seq = htobe32 ((Uint32) read_seq);
+
+  p = temp;
+  memcpy (temp, server_read_key, key_size);
+  temp += key_size;
+
+  memcpy (temp, &local_client_finished[16], finished_size - 16);
+  temp += (finished_size - 16);
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + (finished_size - 16) + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  /* compare mac */
+  if (memcmp (local_client_finished, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err_resume_client_auth;
+    }
+
+  INC32 (read_seq);
+
+  /* compare client finished with connection id */
+  if (memcmp (&local_client_finished[16 + 1], connection_id, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;	/*??? */
+      goto err_resume_client_auth;
+    }
+
+
+  /* generate server verify message */
+  /* mac */
+  pad = 8 - ((16 + 1 + challenge_length) % 8);
+
+  write_seq = 1;		/* server hello */
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 5;
+  temp++;
+
+  memcpy (temp, challenge, challenge_length);
+  temp += challenge_length;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + challenge_length + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  memcpy (server_verify, mac, 16);
+  server_verify[16] = 5;	/* message type */
+  memcpy (&server_verify[17], challenge, challenge_length);
+  memcpy (&server_verify[17 + challenge_length], padb, pad);
+
+
+  finished_size = 16 + 1 + challenge_length + pad;	/* 16 = md5 mac, 1 = message type, */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, server_verify, server_verify,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  INC32 (write_seq);
+
+
+  /* generate cert request message */
+  /* mac */
+  pad = 8 - ((16 + 1 + 1 + 16) % 8);
+
+  seq = htobe32 ((Uint32) write_seq);
+  p = temp;
+
+  memcpy (temp, server_write_key, key_size);
+  temp += key_size;
+
+  temp[0] = 7;			/* cert req message type */
+  temp++;
+
+  temp[0] = auth_type;
+  temp++;
+
+  memcpy (temp, cert_challenge, 16);
+  temp += 16;
+
+  memcpy (temp, padb, pad);
+  temp += pad;
+
+  memcpy (temp, (Uint8 *) & seq, 4);
+
+  temp = p;
+  i = key_size + 1 + 1 + 16 + pad + 4;
+
+  ret = Csp1Handshake (CAVIUM_BLOCKING,
+		       context_handle, i, temp, mac, temp_hash,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  memcpy (cert_request, mac, 16);
+  cert_request[16] = 7;		/* message type */
+  cert_request[17] = auth_type;
+  memcpy (&cert_request[18], cert_challenge, 16);
+  memcpy (&cert_request[18 + 16], padb, pad);
+
+
+  finished_size = 16 + 1 + 1 + 16 + pad;	/* 16 = mac, 1 = message type, 1= auth_type 16 = cert_challenge */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 finished_size, cert_request, cert_request,
+#ifdef CAVIUM_MULTICARD_API
+                          &dummy,dev_id
+#else
+                          &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  INC32 (write_seq);
+
+  /* copy write sequence and read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err_resume_client_auth;
+    }
+
+
+  ret = 0;
+
+err_resume_client_auth:
+  return ret;
+#endif
+}				/* Csp1Ssl20ResumeClientAuth3Des */
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20DecryptRecordRc4
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	record_length = size of record in bytes (0<=length<=2^16-1)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to decrypted message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20DecryptRecordRc4 (n1_request_type request_type,
+			   Uint64 context_handle,
+			   Uint16 record_length,
+			   Uint8 * record,
+			   Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 * request_id,Uint32 dev_id
+#else
+                           Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ret, seq, mac_size, key_size, act_size;
+  Uint8 mac[36], read_key[24];
+  Uint64 ctx_ptr, read_seq;
+  Uint32 dummy = 0;
+
+  mac_size = 16;
+  key_size = 16;
+  act_size = record_length - mac_size;
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_STATE);
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr,
+			CAVIUM_UPDATE,
+			record_length, record, message,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* mac */
+  /* read sequence */
+
+  read_seq = 0;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+
+  ret =
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                     &dummy,dev_id
+#else
+                     &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+  seq = htobe32 ((Uint32) read_seq);
+
+  /* read key */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_KM);
+
+  ret =
+#ifdef CAVIUM_MULTICARD_API
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size, read_key, &dummy,dev_id);
+#else
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size, read_key, &dummy);
+#endif
+  if (ret)
+    {
+      goto err;
+    }
+
+
+  ret = Csp1HandshakeStart (CAVIUM_BLOCKING,
+			    context_handle, key_size, read_key,
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeUpdate (CAVIUM_BLOCKING,
+			     context_handle, act_size, &message[16],
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeFinish (CAVIUM_BLOCKING,
+			     context_handle,
+			     4, (Uint8 *) & seq, mac, &mac[16],
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* compare mac */
+  if (memcmp (message, mac, mac_size))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err;
+    }
+
+  /* expect the next number */
+  INC32 (read_seq);
+
+  /* copy read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+
+      goto err;
+    }
+
+  ret = 0;
+err:
+  return ret;
+#endif
+}
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20EncryptRecordRc4
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	message_length = size of message in bytes (0<=length<=2^16-1)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to encrypted record 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20EncryptRecordRc4 (n1_request_type request_type,
+			   Uint64 context_handle,
+			   Uint16 message_length,
+			   Uint8 * message,
+			   Uint8 * record,
+#ifdef CAVIUM_MULTICARD_API
+                           Uint32 * request_id,Uint32 dev_id
+#else
+                           Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ret, seq, mac_size, key_size, act_size, l;
+  Uint8 mac[36], write_key[24];
+  Uint64 ctx_ptr, write_seq;
+  Uint32 dummy = 0;
+
+  key_size = 16;
+  mac_size = 16;
+  act_size = message_length;
+
+  /* mac */
+  /* read write seq */
+  write_seq = 0;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+
+  ret =
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                     &dummy,dev_id
+#else
+                     &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+  seq = htobe32 ((Uint32) write_seq);
+
+  /* read key */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_KM);
+
+  ret =
+#ifdef CAVIUM_MULTICARD_API
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size, write_key, &dummy,dev_id);
+#else
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size, write_key, &dummy);
+#endif
+  if (ret)
+    {
+      goto err;
+    }
+
+
+  ret = Csp1HandshakeStart (CAVIUM_BLOCKING,
+			    context_handle, key_size, write_key,
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeUpdate (CAVIUM_BLOCKING,
+			     context_handle, message_length, message,
+#ifdef CAVIUM_MULTICARD_API
+                             &dummy,dev_id
+#else
+                             &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeFinish (CAVIUM_BLOCKING,
+			     context_handle,
+			     4, (Uint8 *) & seq, mac, &mac[16],
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+
+  memcpy (record, mac, mac_size);
+  memcpy (&record[mac_size], message, message_length);
+
+  l = mac_size + act_size;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_STATE);
+
+  ret = Csp1EncryptRc4 (CAVIUM_BLOCKING,
+			ctx_ptr, CAVIUM_UPDATE, l, record, record,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* expect the next number */
+  INC32 (write_seq);
+
+  /* copy write sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_RC4_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                           &dummy,dev_id
+#else
+                           &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = 0;
+err:
+  return ret;
+#endif
+}
+
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20DecryptRecord3Des
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	des_type = DES or DES3_192
+ *	record_length = size of record in bytes (0<=length<=2^16-1)
+ *	record = pointer to length-byte encrypted part of record 
+ *
+ * Output
+ *	message = pointer to decrypted message 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20DecryptRecord3Des (n1_request_type request_type,
+			    Uint64 context_handle,
+			    DesType des_type,
+			    Uint16 record_length,
+			    Uint8 * record,
+			    Uint8 * message,
+#ifdef CAVIUM_MULTICARD_API
+                            Uint32 * request_id,Uint32 dev_id
+#else
+                            Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+  int ret, seq, mac_size, key_size;
+  Uint8 mac[36], read_key[32];	/*read IV also. */
+  Uint64 ctx_ptr, read_seq;
+  Uint32 dummy = 0;
+  mac_size = 16;
+  if (des_type == DES)
+    key_size = 8;
+  else if (des_type == DES3_192)
+    key_size = 24;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err;
+    }
+
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret = Csp1Decrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr,
+			 CAVIUM_UPDATE,
+			 record_length, record, message,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* mac */
+
+  /* read sequence number */
+  read_seq = 0;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+
+  ret =
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+  seq = htobe32 ((Uint32) read_seq);
+
+  /* read key */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_KM);
+
+  ret =
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size + 8, read_key,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeStart (CAVIUM_BLOCKING, context_handle, key_size, &read_key[8],
+#ifdef CAVIUM_MULTICARD_API
+              &dummy,dev_id
+#else
+              &dummy
+#endif
+              );
+
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeUpdate (CAVIUM_BLOCKING,
+			     context_handle,
+			     record_length - 16, &message[16],
+#ifdef CAVIUM_MULTICARD_API
+                             &dummy,dev_id
+#else
+                             &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeFinish (CAVIUM_BLOCKING,
+			     context_handle,
+			     4, (Uint8 *) & seq, mac, &mac[16],
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* compare mac */
+  if (memcmp (message, mac, 16))
+    {
+      ret = ERR_BAD_CIPHER_OR_MAC;
+      goto err;
+    }
+
+  INC32 (read_seq);
+
+
+  /* copy read sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_READ_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & read_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = 0;
+err:
+  return ret;
+#endif
+}
+
+
+
+/*+****************************************************************************
+ *
+ * Csp1Ssl20EncryptRecord3Des
+ *
+ * Input
+ *	request_type = CAVIUM_BLOCKING or CAVIUM_NON_BLOCKING
+ *	context_handle = 64-bit pointer to context (context_handle%8=0)
+ *	des_type = DES or DES3_192
+ *	message_length = size of message in bytes (0<=length<=2^16-1)
+ *	message = pointer to length-byte message 
+ *
+ * Output
+ *	record = pointer to encrypted record 
+ *	request_id = Unique ID for this request
+ *
+ * Return Value
+ *	0  = success 
+ * >0 = failure or pending
+ * see error_codes.txt
+ *
+ *-***************************************************************************/
+
+Uint32
+Csp1Ssl20EncryptRecord3Des (n1_request_type request_type,
+			    Uint64 context_handle,
+			    DesType des_type,
+			    Uint16 message_length,
+			    Uint8 * message,
+			    Uint16 * record_length,
+			    Uint8 * record,
+#ifdef CAVIUM_MULTICARD_API
+                            Uint32 * request_id,Uint32 dev_id
+#else
+                            Uint32 * request_id
+#endif
+                 )
+{
+#ifdef MC2
+  return ERR_OPERATION_NOT_SUPPORTED;
+#else
+
+  int ret, seq, mac_size, key_size, act_size, l, pad;
+  Uint8 mac[36], write_key[32], padb[8];
+  Uint64 ctx_ptr, write_seq;
+  Uint32 dummy = 0;
+  if (des_type == DES)
+    key_size = 8;
+  else if (des_type == DES3_192)
+    key_size = 24;
+  else
+    {
+      ret = ERR_OPERATION_NOT_SUPPORTED;
+      goto err;
+    }
+
+  memset (padb, 0, 8);
+  mac_size = 16;
+  pad = 8 - ((mac_size + message_length) % 8);
+  act_size = message_length + pad;
+
+
+  /* append pad bytes to the message */
+  memcpy (&message[message_length], padb, pad);
+
+  /* mac */
+  /* read write seq */
+
+  write_seq = 0;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+
+  ret =
+    Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                      &dummy,dev_id
+#else
+                      &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+  seq = htobe32 ((Uint32) write_seq);
+
+  /* read key */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1ReadContext (CAVIUM_BLOCKING, ctx_ptr, key_size + 8, write_key,
+#ifdef CAVIUM_MULTICARD_API
+                          &dummy,dev_id
+#else
+                          &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+
+  ret = Csp1HandshakeStart (CAVIUM_BLOCKING,
+			    context_handle, key_size, &write_key[8],
+#ifdef CAVIUM_MULTICARD_API
+                            &dummy,dev_id
+#else
+                            &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeUpdate (CAVIUM_BLOCKING,
+			     context_handle, act_size, message,
+#ifdef CAVIUM_MULTICARD_API
+                             &dummy,dev_id
+#else
+                             &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  ret = Csp1HandshakeFinish (CAVIUM_BLOCKING,
+			     context_handle,
+			     4, (Uint8 *) & seq, mac, &mac[16],
+#ifdef CAVIUM_MULTICARD_API
+                               &dummy,dev_id
+#else
+                               &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+
+  memcpy (record, mac, mac_size);
+  memcpy (&record[mac_size], message, act_size);
+
+  l = mac_size + act_size;
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_KM);
+
+  ret = Csp1Encrypt3Des (CAVIUM_BLOCKING,
+			 ctx_ptr, CAVIUM_UPDATE, l, record, record,
+#ifdef CAVIUM_MULTICARD_API
+                         &dummy,dev_id
+#else
+                         &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  /* expect the next number */
+  INC32 (write_seq);
+
+  /* copy write sequence to context memory */
+  ctx_ptr = context_handle + (8 * OFFSET_SSL2_3DES_SERVER_WRITE_SEQ);
+  ret =
+    Csp1WriteContext (CAVIUM_BLOCKING, ctx_ptr, 8, (Uint8 *) & write_seq,
+#ifdef CAVIUM_MULTICARD_API
+                       &dummy,dev_id
+#else
+                       &dummy
+#endif
+                 );
+  if (ret)
+    {
+      goto err;
+    }
+
+  *record_length = l;
+  ret = 0;
+err:
+  return ret;
+#endif
+}
+
+
+
+#ifndef MC2
+/* some utility functions */
+
+static void
+pkp_leftfill (unsigned char input[], int length, unsigned char output[],
+	      int finallength)
+{
+  int i;
+  int j;
+  memset (output, 0, finallength);
+  j = finallength - 1;
+  for (i = length - 1; i >= 0; i--)
+    {
+      output[j] = input[i];
+      j = j - 1;
+    }
+}
+
+
+
+static void
+swap_word_openssl (unsigned char *d, unsigned char *s, int len)
+{
+  int i, j;
+  Uint64 *ps;
+  Uint64 *pd;
+
+  j = 0;
+
+  ps = (Uint64 *) s;
+  pd = (Uint64 *) d;
+
+  for (i = (len >> 3) - 1; i >= 0; i--)
+    {
+      pd[j] = ps[i];
+      j++;
+    }
+
+}
+#endif /* MC2 */
+
+/*
+ * $Id: cavium_ssl.c,v 1.13 2009/10/19 09:05:36 aravikumar Exp $
+ * $Log: cavium_ssl.c,v $
+ * Revision 1.13  2009/10/19 09:05:36  aravikumar
+ * CAIUM_SSL_GRP state added for AesResume
+ *
+ * Revision 1.12  2009/09/11 06:50:40  aravikumar
+ * Added buffer.group=CAVIUM_SSL_GRP statement to all APIs
+ *
+ * Revision 1.11  2009/06/25 05:21:09  aravikumar
+ * fifteenth bit of opcode set to 1 for encryption and 0 for decryption to
+ * identitify
+ *
+ * Revision 1.10  2008/08/12 10:48:46  aramesh
+ * deleted gpkpdev_keyhandle
+ *
+ * Revision 1.9  2008/06/05 06:44:56  sshekkari
+ * Modified Rsa Handshake operations to support modlength upto 4096-bits.
+ *
+ * Revision 1.8  2007/10/26 13:48:37  kchunduri
+ * --memset 'Csp1OperationBuffer' to zero to overcome issues observed with gcc-4.1.
+ *
+ * Revision 1.7  2007/10/24 05:21:21  aramesh
+ * unused variable tmp_keyhd1 warning fixed
+ *
+ * Revision 1.6  2007/10/18 09:35:09  lpathy
+ * Added windows support.
+ *
+ * Revision 1.5  2007/09/17 09:18:06  kchunduri
+ * --Cannot send NULL Key handler Pointer.
+ *
+ * Revision 1.4  2007/09/10 10:15:22  kchunduri
+ * --API changed to accept 'dev_id' as input parameter.
+ *
+ * Revision 1.3  2007/06/18 06:26:14  tghoriparti
+ * header files for memset, alloca, memcpy added
+ *
+ * Revision 1.2  2007/05/01 05:45:37  kchunduri
+ * * modified UIT64_C macro.
+ *
+ * Revision 1.1  2007/01/15 23:17:42  panicker
+ * *** empty log message ***
+ *
+ * Revision 1.24  2006/08/16 14:38:06  kchunduri
+ * --the status of IOCTL_N1_OPERATION is available in 'status' field. Earlier the status is a return parameter.
+ *
+ * Revision 1.23  2006/08/11 10:51:51  kchunduri
+ * --fix compilation problem on freebsd-4.11
+ *
+ * Revision 1.22  2006/05/16 13:46:36  kchunduri
+ * --fix compilation warning
+ *
+ * Revision 1.21  2006/05/16 09:56:04  kchunduri
+ * --changes to support re-aligned API structures
+ *
+ * Revision 1.20  2006/01/27 06:19:34  ksadasivuni
+ * - rolled back ssl queue changes
+ *
+ * Revision 1.19  2006/01/24 12:58:50  ksadasivuni
+ * -  All SSL requests now use queue 1(data plane) instead of
+ *    queue 0( control plane).
+ *
+ * Revision 1.18  2005/11/17 13:31:09  kanantha
+ * Updating with the 64 bit modifications, with proper matching of data types
+ *
+ * Revision 1.17  2005/09/29 12:22:18  sgadam
+ * Moving the FreeBSD AMD64 changes back to the head
+ *
+ * Revision 1.15  2005/09/28 15:39:30  ksadasivuni
+ * - Merging FreeBSD 6.0 ADM64 release with CVS Head
+ * - In ipsec_mc2.c the change is due to passing of physical context pointer
+ * directly to userspace application. So no need for vtophys
+ *
+ * Revision 1.14  2005/09/27 07:47:36  sgadam
+ * Fixed Warnings on FC4
+ *
+ * Revision 1.13  2005/09/02 11:13:59  ksadasivuni
+ * - Added ULL suffix to long constants.
+ *   Latest versions of gcc gives warning without it.
+ *
+ * Revision 1.12  2005/02/01 04:04:56  bimran
+ * copyright fix
+ *
+ * Revision 1.11  2004/05/02 19:35:13  bimran
+ * Added Copyright notice.
+ *
+ * Revision 1.10  2004/05/01 05:57:44  bimran
+ * Fixed a function descriptions on each function to match with the latest microcode and driver.
+ *
+ * Revision 1.9  2004/04/30 21:20:20  bimran
+ * Recover functiosn are only applicable to MC1.
+ *
+ * Revision 1.8  2004/04/29 03:39:49  bimran
+ * Added MC2 support to OtherVerify* functions so that client auth would work with export ciphers.
+ *
+ * Revision 1.7  2004/04/28 22:05:32  bimran
+ * Fixed OtherFullRc4 for MC1.
+ *
+ * Revision 1.6  2004/04/28 03:16:03  bimran
+ * Fixed comments.
+ *
+ * Revision 1.5  2004/04/28 01:24:08  bimran
+ * Added MC2 support to all OtherFull* functions.
+ *
+ * Revision 1.4  2004/04/26 22:32:02  tsingh
+ * Fixed RsaServerFullAes.
+ *
+ * Revision 1.3  2004/04/23 21:47:15  bimran
+ * Lot of cleanup.
+ * Removed all OS dependencies.
+ * It should all be just ioctl.
+ *
+ * Revision 1.2  2004/04/16 23:56:46  bimran
+ * Fixed include directives. It is our API headfer file, it should not have any reference to openssl.
+ * Fixed indentation.
+ *
+ * Revision 1.1  2004/04/15 22:38:38  bimran
+ * Checkin of the code from India with some cleanups.
+ *
+ */
diff -Naur openssl-0.9.8i/crypto/engine/eng_all.c openssl-0.9.8i-cns3xxx/crypto/engine/eng_all.c
--- openssl-0.9.8i/crypto/engine/eng_all.c	2010-05-31 12:02:25.000000000 +0200
+++ openssl-0.9.8i-cns3xxx/crypto/engine/eng_all.c	2010-05-31 12:11:51.000000000 +0200
@@ -68,6 +68,7 @@
 #if 0
 	ENGINE_load_openssl();
 #endif
+	ENGINE_load_cavium();
 #if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_PADLOCK)
 	ENGINE_load_padlock();
 #endif
diff -Naur openssl-0.9.8i/crypto/engine/hw_cavium.c openssl-0.9.8i-cns3xxx/crypto/engine/hw_cavium.c
--- openssl-0.9.8i/crypto/engine/hw_cavium.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-0.9.8i-cns3xxx/crypto/engine/hw_cavium.c	2011-01-06 09:23:28.000000000 +0100
@@ -0,0 +1,1407 @@
+
+/* hw_cavium.c */
+/*
+ * Copyright (c) 2003-2006, Cavium Networks. All rights reserved.
+ *
+ * This Software is the property of Cavium Networks. The Software and all 
+ * accompanying documentation are copyrighted. The Software made available here 
+ * constitutes the proprietary information of Cavium Networks. You agree to take * 
+ * reasonable steps to prevent the disclosure, unauthorized use or unauthorized 
+ * distribution of the Software. You shall use this Software solely with Cavium 
+ * hardware. 
+ *
+ * Except as expressly permitted in a separate Software License Agreement 
+ * between You and Cavium Networks, You shall not modify, decompile, 
+ * disassemble, extract, or otherwise reverse engineer this Software. You shall
+ * not make any copy of the Software or its accompanying documentation, except 
+ * for copying incident to the ordinary and intended use of the Software and 
+ * the Underlying Program and except for the making of a single archival copy.
+ *
+ * This Software, including technical data, may be subject to U.S. export 
+ * control laws, including the U.S. Export Administration Act and its 
+ * associated regulations, and may be subject to export or import regulations 
+ * in other countries. You warrant that You will comply strictly in all 
+ * respects with all such regulations and acknowledge that you have the 
+ * responsibility to obtain licenses to export, re-export or import the 
+ * Software.
+ *
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" AND 
+ * WITH ALL FAULTS AND CAVIUM MAKES NO PROMISES, REPRESENTATIONS OR WARRANTIES, 
+ * EITHER EXPRESS,IMPLIED, STATUTORY,OR OTHERWISE, WITH RESPECT TO THE SOFTWARE,
+ * INCLUDING ITS CONDITION,ITS CONFORMITY TO ANY REPRESENTATION OR DESCRIPTION, 
+ * OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM SPECIFICALLY 
+ * DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE, MERCHANTABILITY, 
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE,LACK OF VIRUSES,ACCURACY OR
+ * COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO 
+ * DESCRIPTION. THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE 
+ * SOFTWARE LIES WITH YOU.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <openssl/crypto.h>
+#include <openssl/engine.h>
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <openssl/evp.h>
+
+#ifdef CAVIUM_ENGINE
+#include "cav_crypto_engine.h"
+#include <cavium_common.h>
+#include <cavium_ssl.h>
+#define ENGINE_SIG_LENGTH	36
+#define MAX_SUPPORTED_CIPHERS	12
+#define MAX_SUPPORTED_DIGESTS    5
+#define SHA_DIGEST_LENGTH       20   
+#define MD5_DIGEST_LENGTH       16   
+#define MD5_CBLOCK	        64   
+
+#define CAVIUM_CMD_SO_PATH		ENGINE_CMD_BASE
+static const ENGINE_CMD_DEFN cavium_cmd_defns[] = {
+	{CAVIUM_CMD_SO_PATH,
+		"SO_PATH",
+		"Specifies the path to the 'nuronssl' shared library",
+		ENGINE_CMD_FLAG_STRING},
+	{0, NULL, NULL, 0}
+};
+RSA_METHOD *default_rsa; 
+/*engine static variables */
+static const char *cavium_engine_id   = "cavium";
+static const char *cavium_engine_name = "Cavium hardware engine support";
+
+/* ENGINE routines */
+
+static int cavium_init(ENGINE *e);
+static int cavium_shutdown(ENGINE *e);
+
+static const char *CAVIUM_LIBNAME = NULL;
+static const char *get_CAVIUM_LIBNAME(void)
+	{
+	if(CAVIUM_LIBNAME)
+		return CAVIUM_LIBNAME;
+	return NULL;
+	}
+
+static void free_CAVIUM_LIBNAME(void)
+	{
+	if(CAVIUM_LIBNAME)
+		OPENSSL_free((void*)CAVIUM_LIBNAME);
+	CAVIUM_LIBNAME = NULL;
+	}
+static long set_CAVIUM_LIBNAME(const char *name)
+	{
+	free_CAVIUM_LIBNAME();
+	return (((CAVIUM_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);
+	}
+
+static int cavium_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())
+	{
+	switch(cmd)
+		{
+	case CAVIUM_CMD_SO_PATH:
+		if(p == NULL)
+			{
+			return 0;
+			}
+		return set_CAVIUM_LIBNAME((const char *)p);
+	default:
+		break;
+		}
+	return 0;
+}
+
+/* RSA functions */
+
+#ifndef OPENSSL_NO_RSA
+static int cav_rsa_pub_enc(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding);
+static int cav_rsa_pub_dec(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding);
+static int cav_rsa_priv_dec(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding);
+static int cav_rsa_priv_enc(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding);
+int cav_bn_mod_exp(BIGNUM *r, const BIGNUM *a,const BIGNUM *p,const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx);
+int cav_rsa_sign(int type, const unsigned char *m, unsigned int m_len,unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
+int cav_rsa_verify(int dtype, const unsigned char *m, unsigned int m_len,unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);
+#endif
+
+#ifndef OPENSSL_NO_DSA
+int cav_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx); 
+#endif
+#ifndef OPENSSL_NO_DH
+int cav_dh_bn_mod_exp(const DH *dh, BIGNUM *r, const BIGNUM *a,const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx); 
+#endif
+
+/* random functions */
+
+int cavium_rand_bytes(unsigned char *buf, int num);
+/* Digest structures and functions */
+#ifdef CAVIUM_DIGEST
+struct digest_st{
+	int len;
+	int size;
+	unsigned char *data;
+};
+static struct {
+	int	id;
+	int	nid;
+} digests[] = {
+	{ 1,		NID_sha1,  },
+	{ 2,		NID_md5,  },
+	{ 0,		NID_undef, },
+};
+
+int get_cavium_digests(const int **nids);
+int cavium_digest_init(EVP_MD_CTX *);
+int cavium_digest_update(EVP_MD_CTX *,const void *, size_t );
+int cavium_digest_final(EVP_MD_CTX *, unsigned char *);
+int cavium_digest_copy(EVP_MD_CTX *, const EVP_MD_CTX *);
+int cavium_digest_cleanup(EVP_MD_CTX *ctx);
+#endif
+
+/* Cipher related structures and functions */
+
+#ifdef CAVIUM_CIPHERS
+
+struct cipher_data{
+	unsigned char *e_key;
+	unsigned char *d_key;
+	Uint64  e_ctx;
+	Uint64  d_ctx;
+};
+struct cipher_ctx{
+	Uint64 e_ctx;
+	Uint64 d_ctx;
+};
+
+static struct {
+	int 	id;
+	int	nid;
+	int	ivmax;
+	int	keylen;
+} ciphers[] = {
+	{1,		NID_des_ede3_cbc,	8,	 24, },
+	{2,		NID_des_cbc,		8,	  8, },
+	{3,		NID_aes_128_cbc,	16,	 16, },
+	{4,		NID_aes_256_cbc,	16,	 32, },
+#ifdef ENABLE_RC4
+	{5,		NID_rc4,		0,	  0,  },
+#endif
+	{0,		NID_undef,		0,	  0, },
+};
+
+int cipher_nid_to_id(int);
+int cavium_get_cipher_max_iv(int);
+int cavium_is_cipher_key_length_valid(int ,int);
+int get_cavium_ciphers(const int **cnids);
+
+int cavium_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc){
+	Uint32 req_id;
+	int cipher_id;
+	int ret;
+	struct cipher_ctx *c_ctx=NULL;
+	struct cipher_data *c_data=NULL;
+	AesType aes_type;
+	unsigned char *temp_key=(unsigned char *)OPENSSL_malloc(100);
+	unsigned char *e_key, *d_key;
+	if(temp_key ==NULL)
+		return 0;
+	cipher_id = cipher_nid_to_id(ctx->cipher->nid);
+	if(cipher_id == 0)
+		return 0;
+	if(!cavium_is_cipher_key_length_valid(cipher_id,ctx->key_len))
+		return 0;
+	if(ctx->cipher->block_size > 1){
+		if(ctx->cipher->iv_len > cavium_get_cipher_max_iv(cipher_id))
+			return 0;
+		c_data= (struct cipher_data *)(ctx->cipher_data);
+		if(ctx->encrypt){
+#ifdef MC2
+			e_key=(unsigned char *)OPENSSL_malloc(100);
+			if(e_key == NULL)
+				return 0;
+			memcpy(e_key,key,ctx->key_len);
+			c_data->e_key = e_key;
+			c_data->e_ctx=(Uint64)0;
+#else
+			c_data->e_key=NULL;
+			memcpy(temp_key,key,ctx->key_len);
+			if(Csp1AllocContext(CONTEXT_SSL,&c_data->e_ctx)){
+				OPENSSL_free(temp_key);
+				return 0;
+			}
+#endif	
+			
+		} else {
+#ifdef MC2
+			d_key=(unsigned char *)OPENSSL_malloc(100);
+			if(d_key == NULL )
+				return 0;
+			c_data->d_key = d_key;
+			memcpy(c_data->d_key,key,ctx->key_len);
+			c_data->d_ctx=(Uint64)0;
+#else
+			c_data->d_key=NULL;
+			memcpy(temp_key,key,ctx->key_len);
+			if(Csp1AllocContext(CONTEXT_SSL,&c_data->d_ctx)){
+				OPENSSL_free(temp_key);
+				return 0;
+			}
+#endif	
+		}
+	}else{
+		c_ctx= (struct cipher_ctx *)(ctx->cipher_data);
+		if(ctx->encrypt){
+			if(Csp1AllocContext(CONTEXT_SSL, &c_ctx->e_ctx))
+				return 0;
+		} else{
+			if(Csp1AllocContext(CONTEXT_SSL, &c_ctx->d_ctx))
+				return 0;
+		}
+	}
+	switch(ctx->cipher->nid){
+
+		case NID_des_cbc	:
+#ifdef MC2
+				if(ctx->encrypt){
+					memcpy(&e_key[8],&e_key[0],8);
+					memcpy(&e_key[16],&e_key[0],8);
+				}else {
+					memcpy(&d_key[8],&d_key[0],8);
+					memcpy(&d_key[16],&d_key[0],8);
+				}
+				return 1;
+#else
+				memcpy(&temp_key[8],&temp_key[0],8);	
+				memcpy(&temp_key[16],&temp_key[0],8);	
+					
+#endif
+		case NID_des_ede3_cbc 	:
+#ifdef MC2
+				OPENSSL_free(temp_key);
+				return 1;
+#else
+				if(ctx->encrypt){
+				ret = Csp1Initialize3DES( CAVIUM_BLOCKING,
+							  c_data->e_ctx,
+							  (unsigned char *)iv,
+							  (unsigned char *)temp_key,
+							  &req_id );
+				}else {
+				ret = Csp1Initialize3DES( CAVIUM_BLOCKING,
+							  c_data->d_ctx,
+							  (unsigned char *)iv,
+							  (unsigned char *)temp_key,
+							  &req_id );
+				}
+				OPENSSL_free(temp_key);
+				if(ret == 0)
+					return 1;
+				else	
+					return 0;
+#endif
+				break;
+		case NID_aes_128_cbc	:
+		case NID_aes_256_cbc	:
+#ifdef MC2
+				OPENSSL_free(temp_key);
+				return 1;
+#else
+				OPENSSL_free(temp_key);
+				if(ctx->cipher->nid == NID_aes_128_cbc )
+					aes_type = AES_128;
+				else {					
+				if(ctx->cipher->nid == NID_aes_256_cbc )
+					aes_type = AES_256;
+				else
+					return 0;
+				}
+				if(ctx->encrypt){
+				ret = Csp1InitializeAES( CAVIUM_BLOCKING,
+							  c_data->e_ctx,
+							  aes_type,
+							  (unsigned char *)iv,
+							  (unsigned char *)key,
+							  &req_id );
+				} else {
+				ret = Csp1InitializeAES( CAVIUM_BLOCKING,
+							  c_data->d_ctx,
+							  aes_type,
+							  (unsigned char *)iv,
+							  (unsigned char *)key,
+							  &req_id );
+				}
+				if(ret == 0)
+					return 1;
+				else	
+					return 0;
+#endif			
+				break;
+		case NID_rc4	:
+				if(ctx->encrypt)
+				{		
+					ret = Csp1InitializeRc4( CAVIUM_BLOCKING,
+								 c_ctx->e_ctx,
+								 ctx->key_len,
+								 (Uint8 *)key,
+								 &req_id );
+				} else {
+					ret = Csp1InitializeRc4( CAVIUM_BLOCKING,
+								 c_ctx->d_ctx,
+								 ctx->key_len,
+								 (Uint8 *)key,
+								 &req_id );
+				}
+#ifndef MC2
+				OPENSSL_free(temp_key);
+#endif			
+				if(ret == 0)
+					return 1;
+				else
+					return 0;							 
+		default 	:
+				break;
+				
+	}
+	return 0;	
+}
+
+int cavium_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,const unsigned char *in,unsigned int inln){
+	Uint32 req_id;
+	struct cipher_data *ciph_data=NULL;
+	struct cipher_ctx *ciph_ctx=NULL;
+	int ret = 0;
+	AesType aes_type;
+#ifdef MC2
+	unsigned char *iiv;
+	unsigned char saved_iv[25];
+#endif
+	if(!inln)
+		return 0;
+	if(ctx->cipher->block_size >1)
+		ciph_data=(struct cipher_data *)ctx->cipher_data;
+	else 	
+		ciph_ctx=(struct cipher_ctx *)ctx->cipher_data;
+	switch(ctx->cipher->nid){
+		case NID_des_ede3_cbc	: 
+		case NID_des_cbc	: 
+				if((inln%ctx->cipher->block_size) != 0)
+					return 0;
+#ifdef MC2
+				if(!ctx->encrypt){
+					iiv=(void *)in+inln - ctx->cipher->iv_len;
+					memcpy(saved_iv,iiv,ctx->cipher->iv_len);
+				}
+#endif
+				if(ctx->encrypt){
+					ret = Csp1Encrypt3Des( CAVIUM_BLOCKING,
+								ciph_data->e_ctx,
+#ifdef MC2
+								CAVIUM_NO_UPDATE,
+#else
+								CAVIUM_UPDATE,
+#endif
+								inln,
+								(Uint8 *)in,
+								(Uint8 *)out,
+#ifdef MC2
+								(Uint8 *)ctx->iv,
+								(Uint8 *)ciph_data->e_key,
+#endif
+								&req_id );
+				} else {
+					ret = Csp1Decrypt3Des( 	CAVIUM_BLOCKING,
+							      	ciph_data->d_ctx,
+#ifdef MC2
+								CAVIUM_NO_UPDATE,
+#else
+								CAVIUM_UPDATE,
+#endif
+								inln,
+								(Uint8 *)in,
+								(Uint8 *)out,
+#ifdef MC2 
+								(Uint8 *)ctx->iv,
+								(Uint8 *)ciph_data->d_key,
+#endif
+								&req_id );
+				}
+				if(ret)
+					return 0;
+#ifdef MC2
+				if(ctx->encrypt)
+					iiv = (void *)out+ inln -ctx->cipher->iv_len;
+				else
+					iiv = saved_iv;
+					memcpy(ctx->iv,iiv,ctx->cipher->iv_len);
+#endif
+				return 1;
+		case NID_aes_128_cbc	: 
+		case NID_aes_256_cbc	: 
+				if((inln%ctx->cipher->block_size) != 0)
+					return 0;
+				 if(ctx->cipher->nid == NID_aes_128_cbc)
+					aes_type = AES_128;
+				else{
+				if(ctx->cipher->nid == NID_aes_256_cbc)
+					aes_type = AES_256;
+				else
+					return 0;
+				}
+#ifdef MC2
+				if(!ctx->encrypt){
+					iiv=(void *)in+inln - ctx->cipher->iv_len;
+					memcpy(saved_iv,iiv,ctx->cipher->iv_len);
+				}
+#endif
+				if(ctx->encrypt){
+					ret = Csp1EncryptAes( CAVIUM_BLOCKING,
+								ciph_data->e_ctx,
+#ifdef MC2
+								CAVIUM_NO_UPDATE,
+#else
+								CAVIUM_UPDATE,
+#endif
+								aes_type,
+								inln,
+								(Uint8 *)in,
+								(Uint8 *)out,
+#ifdef MC2
+								(Uint8 *)ctx->iv,
+								(Uint8 *)ciph_data->e_key,
+#endif
+								&req_id );
+				} else {
+					ret = Csp1DecryptAes( 	CAVIUM_BLOCKING,
+							      	ciph_data->d_ctx,
+#ifdef MC2
+								CAVIUM_NO_UPDATE,
+#else
+								CAVIUM_UPDATE,
+#endif
+								aes_type,
+								inln,
+								(Uint8 *)in,
+								(Uint8 *)out,
+#ifdef MC2 
+								(Uint8 *)ctx->iv,
+								(Uint8 *)ciph_data->d_key,
+#endif
+								&req_id );
+				}
+				if(ret)
+					return 0;
+#ifdef MC2
+				if(ctx->encrypt)
+					iiv = (void *)out+ inln -ctx->cipher->iv_len;
+				else
+					iiv = saved_iv;
+					memcpy(ctx->iv,iiv,ctx->cipher->iv_len);
+#endif
+				return 1;
+		case NID_rc4 :
+				if(ctx->encrypt){
+					ret = Csp1EncryptRc4(
+						CAVIUM_BLOCKING,
+						(Uint64)ciph_ctx->e_ctx,
+						CAVIUM_UPDATE,
+						inln,
+						(Uint8 *)in,
+						(Uint8 *)out,
+						&req_id );
+				} else {
+					ret = Csp1EncryptRc4(
+						CAVIUM_BLOCKING,
+						(Uint64)ciph_ctx->d_ctx,
+						CAVIUM_UPDATE,
+						inln,
+						(Uint8 *)in,
+						(Uint8 *)out,
+						&req_id );
+				}
+				if(ret)
+					return 0;
+				else 
+					return 1;
+				break;
+		default		: 
+				break;	
+	}
+	return 0;
+						
+}
+int cavium_cleanup(EVP_CIPHER_CTX *ctx){
+	struct cipher_data *ciph_data;
+	struct cipher_ctx *ciph_ctx;
+	if(ctx->cipher->block_size >1){
+		ciph_data =(struct cipher_data *)ctx->cipher_data;
+		if(ctx->encrypt){
+			if(ciph_data->e_key){
+				OPENSSL_free(ciph_data->e_key);		
+				ciph_data->e_key=NULL;
+			}
+			if(ciph_data->e_ctx){
+				Csp1FreeContext(CONTEXT_SSL, ciph_data->e_ctx);
+				ciph_data->e_ctx=(Uint64)0;
+			}
+				
+		}else{
+			if(ciph_data->d_key){
+				OPENSSL_free(ciph_data->d_key);	
+				ciph_data->d_key = NULL;
+			}
+			if(ciph_data->d_ctx){
+				Csp1FreeContext(CONTEXT_SSL, ciph_data->d_ctx);
+				ciph_data->d_ctx=(Uint64)0;
+			}
+		}	
+	}else{
+		ciph_ctx =(struct cipher_ctx *)ctx->cipher_data;
+		if(ctx->encrypt && ciph_ctx->e_ctx) {
+			Csp1FreeContext(CONTEXT_SSL, ciph_ctx->e_ctx);
+			ciph_ctx->e_ctx =(Uint64)0;
+		}
+		if(!ctx->encrypt && ciph_ctx->d_ctx) {
+			Csp1FreeContext(CONTEXT_SSL, ciph_ctx->d_ctx);
+			ciph_ctx->d_ctx = (Uint64)0;
+		}
+	}
+	return 1;
+}
+int cipher_nid_to_id(int nid){
+	int i;
+	for(i=0;ciphers[i].id;i++){
+		if(ciphers[i].nid == nid)
+			return ciphers[i].id;
+	} 
+	return 0;
+}
+
+int cavium_get_cipher_max_iv(int id){
+	int i;
+	for(i=0;ciphers[i].id;i++){
+		if(ciphers[i].id == id)
+			return (ciphers[i].ivmax);
+	}
+	return 0;
+}
+
+int cavium_is_cipher_key_length_valid(int id,int len){
+	int i;
+	for(i=0;ciphers[i].id;i++){
+		if(ciphers[i].id == id)
+		{	
+			if(ciphers[i].keylen == len || ciphers[i].keylen ==0 )
+				return 1;
+			else
+				return 0;
+		}
+	}
+	return 0;
+}
+const EVP_CIPHER cavium_3des_cbc = {
+	NID_des_ede3_cbc,
+	8, 24, 8,
+	EVP_CIPH_CBC_MODE,
+	cavium_init_key,
+	cavium_do_cipher,
+	cavium_cleanup,
+	sizeof(struct cipher_data),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,
+	NULL
+};
+const EVP_CIPHER cavium_des_cbc = {
+	NID_des_cbc,
+	8, 8, 8,
+	EVP_CIPH_CBC_MODE,
+	cavium_init_key,
+	cavium_do_cipher,
+	cavium_cleanup,
+	sizeof(struct cipher_data),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,
+	NULL
+};
+
+const EVP_CIPHER cavium_rc4= {
+	NID_rc4,
+	1, 16, 0,
+	EVP_CIPH_VARIABLE_LENGTH,
+	cavium_init_key,
+	cavium_do_cipher,
+	cavium_cleanup,
+	sizeof(struct cipher_ctx),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,
+	NULL
+};
+
+const EVP_CIPHER cavium_aes_128 = {
+	NID_aes_128_cbc,
+	16, 16, 16,
+	EVP_CIPH_CBC_MODE,
+	cavium_init_key,
+	cavium_do_cipher,
+	cavium_cleanup,
+	sizeof(struct cipher_data),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,
+	NULL
+};
+
+const EVP_CIPHER cavium_aes_256 = {
+	NID_aes_256_cbc,
+	16, 32, 16,
+	EVP_CIPH_CBC_MODE,
+	cavium_init_key,
+	cavium_do_cipher,
+	cavium_cleanup,
+	sizeof(struct cipher_data),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,
+	NULL
+};
+
+static int cavium_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid)
+{
+	if (!cipher)
+		return (get_cavium_ciphers(nids));
+
+	switch (nid) {
+	case NID_des_ede3_cbc	:
+			*cipher = &cavium_3des_cbc;
+			break;
+	case NID_des_cbc	:
+			*cipher = &cavium_des_cbc;
+			break;
+	case NID_aes_128_cbc	:
+			*cipher = &cavium_aes_128;
+			break;
+	case NID_aes_256_cbc	:
+			*cipher = &cavium_aes_256;
+			break;
+	case NID_rc4		:
+			*cipher = &cavium_rc4;
+			break;
+	default:
+			*cipher = NULL;
+			break;
+	}
+	if(*cipher == NULL)
+		return 0;
+	return 1;
+}
+		
+int get_cavium_ciphers(const int **cnids)
+{
+	static int nids[MAX_SUPPORTED_CIPHERS];
+	int i, count = 0;
+
+	for (i = 0; ciphers[i].id && count < MAX_SUPPORTED_CIPHERS; i++) {
+		if (ciphers[i].nid == NID_undef)
+			continue;
+		nids[count++] = ciphers[i].nid;
+	}
+	if (count > 0)
+		*cnids = nids;
+	else
+		*cnids = NULL;
+	return (count);
+}
+
+#endif
+
+
+#ifdef CAVIUM_DIGEST
+
+static const EVP_MD cavium_sha_md=
+	{
+	NID_sha1,
+	NID_sha1WithRSAEncryption,
+	SHA_DIGEST_LENGTH,
+	0,
+	cavium_digest_init,
+	cavium_digest_update,
+	cavium_digest_final,
+	cavium_digest_copy,
+	cavium_digest_cleanup,
+	EVP_PKEY_RSA_method,
+	SHA_CBLOCK,
+	sizeof(EVP_MD)+sizeof(struct digest_st),
+	};
+static const EVP_MD cavium_md5_md=
+	{
+	NID_md5,
+	NID_md5WithRSAEncryption,
+	MD5_DIGEST_LENGTH,
+	0,
+	cavium_digest_init,
+	cavium_digest_update,
+	cavium_digest_final,
+	cavium_digest_copy,
+	cavium_digest_cleanup,
+	EVP_PKEY_RSA_method,
+	MD5_CBLOCK,
+	sizeof(EVP_MD)+sizeof(struct digest_st),
+	};
+
+static int
+cavium_engine_digests(ENGINE *e, const EVP_MD **digest, const int **nids, int nid)
+{
+	if (!digest)
+		return (get_cavium_digests(nids));
+	switch (nid) {
+	case NID_sha1 :
+		*digest = &cavium_sha_md; 
+		break;
+	case NID_md5 :
+		*digest = &cavium_md5_md; 
+		break;
+	default:
+		*digest = NULL;
+		break;
+	}
+	return (*digest != NULL);
+}
+
+int get_cavium_digests(const int **cnids)
+{
+	static int nids[MAX_SUPPORTED_DIGESTS];
+	int i, count = 0;
+	for (i = 0; digests[i].id && count < MAX_SUPPORTED_DIGESTS; i++) {
+		if (digests[i].nid == NID_undef)
+			continue;
+		nids[count++] = digests[i].nid;
+	}
+	if (count > 0)
+		*cnids = nids;
+	else
+		*cnids = NULL;
+	return (count);
+}
+
+
+int cavium_digest_init(EVP_MD_CTX *ctx){
+	struct digest_st *digest_buf=(struct digest_st *)ctx->md_data;
+	digest_buf->data=(unsigned char *)OPENSSL_malloc(4000);
+	memset(digest_buf->data,0,4000);
+	digest_buf->len = 0;
+	digest_buf->size=4000;
+	return 1;
+}
+
+int cavium_digest_update(EVP_MD_CTX *ctx,const void *data, size_t count){
+	struct digest_st *digest_buf=(struct digest_st *)ctx->md_data;
+	if(digest_buf->data==NULL)
+	{
+		printf("\n There is no data buffer \n");
+		return 0;
+	}
+	switch(ctx->digest->type){
+		case NID_sha1	:
+		case NID_md5	:
+				while((digest_buf->len+count) > digest_buf->size){
+					digest_buf->data=(unsigned char *)OPENSSL_realloc(digest_buf->data,(digest_buf->size+1000));
+					if(digest_buf->data == NULL)
+						return 0;
+					digest_buf->size+=1000;
+				}	
+				memcpy(&digest_buf->data[digest_buf->len],data,count);
+				digest_buf->len+=count;
+				return 1;
+		default 	: break;
+				
+	}	
+	return 0;
+}
+
+int cavium_digest_final(EVP_MD_CTX *ctx, unsigned char *md){
+	int ret=0;
+	Uint32 req_id;
+#ifndef MC2
+	unsigned char md5[100];
+	unsigned char sha[100];
+	Uint64 temp_ctx;
+#endif
+	struct digest_st *digest_buf=(struct digest_st *)ctx->md_data;
+	switch(ctx->digest->type){
+#ifdef MC2
+		case NID_sha1	:
+				if(digest_buf->len >32768)
+				{
+					printf("\n Can't Handle this much data ");
+					return 0;
+				}
+				 ret = Csp1Hash( CAVIUM_BLOCKING,
+						  SHA1_TYPE,
+						  digest_buf->len,
+						  digest_buf->data,
+						  md,
+						  &req_id);
+				if(ret)
+					return 0;
+				else			
+					return 1;
+		case NID_md5	:
+				if(digest_buf->len >32768)
+				{
+					printf("\n Can't Handle this much data ");
+					return 0;
+				}
+				  ret = Csp1Hash( CAVIUM_BLOCKING,
+						  MD5_TYPE,
+						  digest_buf->len,
+						  digest_buf->data,
+						  md,
+						  &req_id);
+				if(ret)
+					return 0;
+				else			
+					return 1;
+	
+#else
+		case NID_sha1	:
+		case NID_md5	:
+				if(Csp1AllocContext(CONTEXT_SSL,&temp_ctx))
+					return 0;
+				ret = Csp1HandshakeStart( CAVIUM_BLOCKING,
+						    temp_ctx,
+						    0,
+						    NULL,
+						    &req_id);
+				if(ret)
+				return 0;
+				ret = Csp1HandshakeUpdate( CAVIUM_BLOCKING,
+						     temp_ctx,
+						    digest_buf->len,
+						    digest_buf->data,
+						    &req_id);	
+				if(ret)
+				return 0;
+				ret = Csp1HandshakeFinish( CAVIUM_BLOCKING,
+						    temp_ctx,
+						    0,
+						    NULL,
+						    md5,
+						    sha,
+						   &req_id);
+						    
+				Csp1FreeContext(CONTEXT_SSL,temp_ctx);
+				if(!ret){
+					if(ctx->digest->type == NID_sha1){
+						memcpy(md,sha,20);
+					}
+					else{
+						memcpy(md,md5,16);
+					}
+					return 1;
+				}
+				else 	return 0;
+#endif
+		default :
+				return 0;
+	}
+	return 0;
+}
+int cavium_digest_cleanup(EVP_MD_CTX *ctx)
+{
+	struct digest_st *digest_buf=(struct digest_st *)ctx->md_data;
+	if(digest_buf->data)
+	{
+		OPENSSL_free(digest_buf->data);
+		digest_buf->size=0;
+		digest_buf->len = 0;
+	}
+	return 1;
+}
+
+int cavium_digest_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)
+{
+	struct digest_st *in_buf=(struct digest_st *)in->md_data;
+	struct digest_st *out_buf=(struct digest_st *)out->md_data;
+	if(in_buf->data)
+	{
+		out_buf->data=(unsigned char *)OPENSSL_malloc(in_buf->size);
+		if(out_buf->data == NULL)
+			return 0;
+		memcpy(out_buf->data,in_buf->data,in_buf->len);
+		out_buf->len=in_buf->len;		
+		out_buf->size=in_buf->size;		
+	}
+	return 1;
+}
+#endif
+
+
+static int cavium_init(ENGINE *e)
+{
+#ifdef NPLUS
+	if(Csp1Initialize(CAVIUM_DIRECT,SSL_SPM_IDX))
+#else
+	if(Csp1Initialize(CAVIUM_DIRECT))
+#endif
+	{
+		return 0;	
+	}
+	default_rsa=(RSA_METHOD *)RSA_PKCS1_SSLeay();
+	if(default_rsa == NULL)
+		return 0;
+	return 1;
+}
+
+
+
+static int cavium_shutdown(ENGINE *e)
+{
+	Csp1Shutdown();
+	return 1;
+}
+
+#ifndef OPENSSL_NO_RSA
+
+int cav_rsa_sign(int type, const unsigned char *m, unsigned int m_len,unsigned char *sigret, unsigned int *siglen, const RSA *rsa)
+        {
+        X509_SIG sig;
+        ASN1_TYPE parameter;
+        int i,j,ret=1;
+        unsigned char *p, *tmps = NULL;
+        const unsigned char *s = NULL;
+        X509_ALGOR algor;
+        ASN1_OCTET_STRING digest;
+	RSA *temp = NULL;
+
+        if((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_sign)
+                {
+                return rsa->meth->rsa_sign(type, m, m_len,
+                        sigret, siglen, rsa);
+                }
+        /* Special case: SSL signature, just check the length */
+        if(type == NID_md5_sha1) {
+                if(m_len != ENGINE_SIG_LENGTH) {
+                        RSAerr(RSA_F_RSA_SIGN,RSA_R_INVALID_MESSAGE_LENGTH);
+                        return(0);
+                }
+                i = ENGINE_SIG_LENGTH;
+                s = m;
+        } else {
+                sig.algor= &algor;
+                sig.algor->algorithm=OBJ_nid2obj(type);
+                if (sig.algor->algorithm == NULL)
+                        {
+                        RSAerr(RSA_F_RSA_SIGN,RSA_R_UNKNOWN_ALGORITHM_TYPE);
+                        return(0);
+                        }
+                if (sig.algor->algorithm->length == 0)
+                     {
+                        RSAerr(RSA_F_RSA_SIGN,RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
+                        return(0);
+                     }
+                parameter.type=V_ASN1_NULL;
+                parameter.value.ptr=NULL;
+                sig.algor->parameter= &parameter;
+     
+	        sig.digest= &digest;
+                sig.digest->data=(unsigned char *)m; /* TMP UGLY CAST */
+                sig.digest->length=m_len;
+                                                                                                                             
+                i=i2d_X509_SIG(&sig,NULL);
+        }
+        j=RSA_size(rsa);
+        if (i > (j-RSA_PKCS1_PADDING_SIZE))
+                {
+                RSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
+                return(0);
+                }
+        if(type != NID_md5_sha1) {
+                tmps=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+                if (tmps == NULL)
+                        {
+                        RSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);
+                        return(0);
+                        }
+                p=tmps;
+                i2d_X509_SIG(&sig,&p);
+                s=tmps;
+        }
+	temp = (RSA *)rsa;
+        i=cav_rsa_priv_enc(i,s,sigret,temp,RSA_PKCS1_PADDING);
+        if (i <= 0)
+                ret=0;
+        else
+              *siglen=i;
+                                                                                                                             
+        if(type != NID_md5_sha1) {
+                OPENSSL_cleanse(tmps,(unsigned int)j+1);
+                OPENSSL_free(tmps);
+        }
+        return(ret);
+}
+
+
+int cav_rsa_verify(int dtype, const unsigned char *m, unsigned int m_len,unsigned char *sigbuf, unsigned int siglen, const RSA *rsa)
+        {
+        int i,ret=0,sigtype;
+        unsigned char *s;
+        const unsigned char *p;
+        X509_SIG *sig=NULL;
+	RSA *temp = NULL;
+                                                                                                                             
+        if (siglen != (unsigned int)RSA_size(rsa))
+                {
+                RSAerr(RSA_F_RSA_VERIFY,RSA_R_WRONG_SIGNATURE_LENGTH);
+                return(0);
+                }
+                                                                                                                             
+        if((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify)
+                {
+                return rsa->meth->rsa_verify(dtype, m, m_len,
+                        sigbuf, siglen, rsa);
+                }
+                                                                                                                             
+        s=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);
+        if (s == NULL)
+                {
+                RSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);
+                goto err;
+                }
+        if((dtype == NID_md5_sha1) && (m_len != ENGINE_SIG_LENGTH) ) {
+                        RSAerr(RSA_F_RSA_VERIFY,RSA_R_INVALID_MESSAGE_LENGTH);
+                        return(0);
+        }
+	temp = (RSA *)rsa;
+        i=cav_rsa_pub_dec((int)siglen,sigbuf,s,temp,RSA_PKCS1_PADDING);
+
+        if (i <= 0) goto err;
+
+        /* Special case: SSL signature */
+        if(dtype == NID_md5_sha1) {
+                if((i != ENGINE_SIG_LENGTH) || memcmp(s, m, ENGINE_SIG_LENGTH))
+                                RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+                else ret = 1;
+        } else {
+                p=s;
+                sig=d2i_X509_SIG(NULL,&p,(long)i);
+                                                                                                                             
+                if (sig == NULL) goto err;
+                sigtype=OBJ_obj2nid(sig->algor->algorithm);
+        
+#ifdef RSA_DEBUG
+                /* put a backward compatibility flag in EAY */
+                fprintf(stderr,"in(%s) expect(%s)\n",OBJ_nid2ln(sigtype),
+                        OBJ_nid2ln(dtype));
+#endif
+                if (sigtype != dtype)
+                        {
+                        if (((dtype == NID_md5) &&
+                                (sigtype == NID_md5WithRSAEncryption)) ||
+                                ((dtype == NID_md2) &&
+                                (sigtype == NID_md2WithRSAEncryption)))
+                                {
+                                /* ok, we will let it through */
+#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)
+                                fprintf(stderr,"signature has problems, re-make with post SSLeay045\n");
+#endif
+                                }
+                        else
+                                {
+                                RSAerr(RSA_F_RSA_VERIFY,
+                                                RSA_R_ALGORITHM_MISMATCH);
+                                goto err;
+                                }
+                        }
+                if (    ((unsigned int)sig->digest->length != m_len) ||
+                        (memcmp(m,sig->digest->data,m_len) != 0))
+                        {
+                        RSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
+                        }
+                else
+                        ret=1;
+        }
+err:
+        if (sig != NULL) X509_SIG_free(sig);
+        OPENSSL_cleanse(s,(unsigned int)siglen);
+        OPENSSL_free(s);
+        return(ret);
+        }
+
+static int cav_rsa_pub_enc(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding)
+{
+	int ret=0;
+	#if 0
+	if(padding == RSA_PKCS1_PADDING)
+	{
+		ret=pkp_rsa_public_encrypt(flen,(unsigned char *)from,to,rsa);
+		if(!ret)
+			ret=default_rsa->rsa_pub_enc(flen,from,to,rsa,padding);
+	}
+	else
+	#endif
+	{
+		ret=default_rsa->rsa_pub_enc(flen,from,to,rsa,padding);
+	}
+	return ret;
+}
+static int cav_rsa_pub_dec(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding)
+{
+	int ret=0;
+	if(padding == RSA_PKCS1_PADDING)
+	{
+		ret=pkp_rsa_public_decrypt(flen,(unsigned char *)from,to,rsa);
+		if(!ret)
+		ret=default_rsa->rsa_pub_dec(flen,from,to,rsa,padding);
+	}
+	else
+	{
+		ret=default_rsa->rsa_pub_dec(flen,from,to,rsa,padding);
+	}
+	return ret;
+}
+static int cav_rsa_priv_enc(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding)
+{
+	int ret=0;
+	if(padding == RSA_PKCS1_PADDING)
+	{
+		ret=pkp_rsa_private_encrypt(flen,(unsigned char *)from,to,rsa);
+		if(!ret)
+		ret=default_rsa->rsa_priv_enc(flen,from,to,rsa,padding);
+	}
+	else
+	{
+		ret=default_rsa->rsa_priv_enc(flen,from,to,rsa,padding);
+	}
+	return ret;
+}
+static int cav_rsa_priv_dec(int flen,const unsigned char *from, unsigned char *to,RSA *rsa,int padding)
+{
+	int ret=0;
+	if(padding == RSA_PKCS1_PADDING)
+	{
+		ret=pkp_rsa_private_decrypt(flen,(unsigned char *)from,to,rsa);
+		if(!ret)
+		ret=default_rsa->rsa_priv_dec(flen,from,to,rsa,padding);
+	}
+	else
+	{
+		ret=default_rsa->rsa_priv_dec(flen,from,to,rsa,padding);
+	}
+	return ret;
+}
+
+int cav_bn_mod_exp(BIGNUM *r, const BIGNUM *a,const BIGNUM *p,const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx)
+{
+	if(cav_mod_exp(r,(BIGNUM *)a, (BIGNUM *)p,(BIGNUM *)m))
+		return 1;
+	return 0;
+	
+}
+static RSA_METHOD cavium_rsa={
+	"Cavium RSA method",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	0,
+	NULL,
+	NULL,
+	NULL
+	};
+#endif
+
+#ifndef OPENSSL_NO_DSA
+static DSA_METHOD cavium_dsa={
+	"Cavium DSA method ",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	0,
+	NULL
+};
+int cav_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx) 
+{
+	if(cav_mod_exp(r,(BIGNUM *)a, (BIGNUM *)p,(BIGNUM *)m))
+		return 1;
+	return 0;
+}
+#endif
+#ifndef OPENSSL_NO_DH
+static DH_METHOD cavium_dh={
+	"Cavium DH Method",
+	NULL,	
+	NULL,	
+	NULL,	
+	NULL,	
+	NULL,	
+	0,
+	NULL
+};
+int cav_dh_bn_mod_exp(const DH *dh, BIGNUM *r, const BIGNUM *a,const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,BN_MONT_CTX *m_ctx) 
+{
+	if(cav_mod_exp(r,(BIGNUM *)a, (BIGNUM *)p,(BIGNUM *)m))
+		return 1;
+	return 0;
+}
+#endif
+
+static RAND_METHOD cavium_rand =
+	{
+	NULL, /* seed */
+	NULL, /* get random bytes from the card */
+	NULL, /* cleanup */
+	NULL, /* add */
+	NULL, /* pseudo rand */
+	NULL, /* status */
+	};
+
+int cavium_rand_bytes(unsigned char *buf, int num){
+	Uint32  req_id;
+	if(Csp1Random(0, num, buf, &req_id)){
+		return 0;
+	}
+	return 1;
+}
+
+int cavium_bind_helper(ENGINE *e)
+{
+	const RAND_METHOD *meth2;
+	const RSA_METHOD *meth1;
+	const DSA_METHOD  *meth3;
+	const DH_METHOD   *meth4;
+	if(!ENGINE_set_id(e,cavium_engine_id) ||
+		!ENGINE_set_name(e,cavium_engine_name) ||
+#ifndef OPENSSL_NO_RSA
+		!ENGINE_set_RSA(e,&cavium_rsa) ||
+#endif
+#ifndef OPENSSL_NO_DSA
+		!ENGINE_set_DSA(e,&cavium_dsa) ||
+#endif
+#ifndef OPENSSL_NO_DH
+		!ENGINE_set_DH(e,&cavium_dh) ||
+#endif
+		!ENGINE_set_RAND(e,&cavium_rand) ||
+		!ENGINE_set_init_function(e,cavium_init) ||
+		!ENGINE_set_ctrl_function(e, cavium_ctrl) ||
+#ifdef CAVIUM_CIPHERS
+		!ENGINE_set_ciphers(e,cavium_engine_ciphers) ||
+#endif
+#ifdef CAVIUM_DIGEST
+ 		!ENGINE_set_digests(e, cavium_engine_digests)	||
+#endif
+		!ENGINE_set_finish_function(e,cavium_shutdown))
+	{
+		return 0;
+	}
+#ifndef OPENSSL_NO_RSA
+	meth1 = RSA_PKCS1_SSLeay();
+	cavium_rsa.bn_mod_exp	= 	cav_bn_mod_exp;
+	cavium_rsa.rsa_mod_exp 	=	meth1->rsa_mod_exp;
+	cavium_rsa.rsa_pub_enc	=	cav_rsa_pub_enc;
+	cavium_rsa.rsa_pub_dec	=	cav_rsa_pub_dec;
+	cavium_rsa.rsa_priv_enc	=	cav_rsa_priv_enc;
+	cavium_rsa.rsa_priv_dec	=	cav_rsa_priv_dec;
+	cavium_rsa.rsa_sign	=	cav_rsa_sign;
+	cavium_rsa.rsa_verify	=	cav_rsa_verify;
+#endif
+#ifndef OPENSSL_NO_DSA
+	meth3 = DSA_get_default_method();
+	cavium_dsa.dsa_do_sign 		= meth3->dsa_do_sign;
+	cavium_dsa.dsa_sign_setup 	= meth3->dsa_sign_setup;
+	cavium_dsa.dsa_do_verify 	= meth3->dsa_do_verify;
+	cavium_dsa.dsa_mod_exp 		= meth3->dsa_mod_exp;
+	cavium_dsa.bn_mod_exp 		= cav_dsa_bn_mod_exp;
+	cavium_dsa.init			= meth3->init;
+	cavium_dsa.finish		= meth3->finish;
+	cavium_dsa.flags		= meth3->flags;
+	cavium_dsa.app_data		= meth3->app_data;
+	
+#endif
+#ifndef OPENSSL_NO_DH
+	meth4 = DH_get_default_method();
+	cavium_dh.generate_key 	= meth4->generate_key;
+	cavium_dh.compute_key	= meth4->compute_key;
+        cavium_dh.bn_mod_exp   	= cav_dh_bn_mod_exp;	
+	cavium_dh.init		= meth4->init;
+	cavium_dh.finish	= meth4->finish;
+    	cavium_dh.flags		= meth4->flags;
+	cavium_dh.app_data	= meth4->app_data;	
+#endif
+	meth2=RAND_SSLeay();
+	cavium_rand.seed	=	meth2->seed;
+	//cavium_rand.bytes	=	cavium_rand_bytes;
+	cavium_rand.bytes	=	meth2->bytes;
+	cavium_rand.cleanup	=	meth2->cleanup;
+	cavium_rand.add		=	meth2->add;
+	//cavium_rand.pseudorand	=	cavium_rand_bytes;
+	cavium_rand.pseudorand	=	meth2->pseudorand;
+	cavium_rand.status	=	meth2->status;
+
+	return 1;
+}
+
+
+ENGINE *engine_cavium(void)
+{
+	ENGINE *ret = ENGINE_new();
+	if(!ret)
+		return NULL;
+	if(!cavium_bind_helper(ret)){
+		ENGINE_free(ret);
+		return NULL;
+	}	
+	return ret;
+}
+void ENGINE_load_cavium()
+{
+	ENGINE *to_add = engine_cavium();
+	if(!to_add)
+		return;
+	ENGINE_add(to_add);
+	ENGINE_free(to_add);
+	ERR_clear_error();
+}
+
+#ifdef ENGINE_DYNAMIC_SUPPORT
+static int bind_fn(ENGINE *e,const char *id)
+{
+	if(id && strcmp(id,cavium_engine_id)!=0){
+		return 0;
+	}
+	if(!cavium_bind_helper(e)){
+		return 0;
+	}
+	return 1;
+}
+IMPLEMENT_DYNAMIC_CHECK_FN()
+/*IMPLEMENT_DYNAMIC_BIND_FN(bind_fn)*/
+int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { 
+	if (ERR_get_implementation() != fns->err_fns) 
+	{ 
+	if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, 
+				fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) 				return 0; 
+	CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); 
+	CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); 
+	CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); 
+	CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); 
+	CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); 
+	if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) 
+		return 0; 
+	} 
+	if(!bind_fn(e,id)) return 0; 
+	return 1; 
+}
+#endif
+
+#endif
diff -Naur openssl-0.9.8i/crypto/engine/Makefile openssl-0.9.8i-cns3xxx/crypto/engine/Makefile
--- openssl-0.9.8i/crypto/engine/Makefile	2010-05-31 12:02:25.000000000 +0200
+++ openssl-0.9.8i-cns3xxx/crypto/engine/Makefile	2010-05-31 12:11:51.000000000 +0200
@@ -21,12 +21,20 @@
 	eng_table.c eng_pkey.c eng_fat.c eng_all.c \
 	tb_rsa.c tb_dsa.c tb_ecdsa.c tb_dh.c tb_ecdh.c tb_rand.c tb_store.c \
 	tb_cipher.c tb_digest.c \
-	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c eng_padlock.c
+	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c eng_padlock.c \
+	cav_crypto_engine.c \
+	cavium_common.c \
+	cavium_ssl.c\
+	hw_cavium.c
 LIBOBJ= eng_err.o eng_lib.o eng_list.o eng_init.o eng_ctrl.o \
 	eng_table.o eng_pkey.o eng_fat.o eng_all.o \
 	tb_rsa.o tb_dsa.o tb_ecdsa.o tb_dh.o tb_ecdh.o tb_rand.o tb_store.o \
 	tb_cipher.o tb_digest.o \
-	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o eng_padlock.o
+	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o eng_padlock.o \
+	cav_crypto_engine.o \
+	cavium_common.o \
+	cavium_ssl.o\
+	hw_cavium.o
 
 SRC= $(LIBSRC)
 

diff -Naur openssl-0.9.8r-orig/crypto/engine/engine.h openssl-0.9.8r/crypto/engine/engine.h
--- openssl-0.9.8r-orig/crypto/engine/engine.h	2010-02-09 15:18:15.000000000 +0100
+++ openssl-0.9.8r/crypto/engine/engine.h	2013-08-02 13:38:15.944696279 +0200
@@ -345,6 +345,10 @@
 #endif
 #endif
 
+
+void ENGINE_load_cavium(void);
+
+
 /* Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation
  * "registry" handling. */
 unsigned int ENGINE_get_table_flags(void);
